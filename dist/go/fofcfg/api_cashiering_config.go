/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CashieringConfigAPIService CashieringConfigAPI service
type CashieringConfigAPIService service

type CashieringConfigAPICalculatePostingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	transactionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postingAmount *float32
	taxType *string
	guestBalance *float32
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICalculatePostingRequest) Authorization(authorization string) CashieringConfigAPICalculatePostingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICalculatePostingRequest) XAppKey(xAppKey string) CashieringConfigAPICalculatePostingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICalculatePostingRequest) XHotelid(xHotelid string) CashieringConfigAPICalculatePostingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Base amount to test for posting.
func (r CashieringConfigAPICalculatePostingRequest) PostingAmount(postingAmount float32) CashieringConfigAPICalculatePostingRequest {
	r.postingAmount = &postingAmount
	return r
}

// Specify this criteria if calculation is based on the tax type.
func (r CashieringConfigAPICalculatePostingRequest) TaxType(taxType string) CashieringConfigAPICalculatePostingRequest {
	r.taxType = &taxType
	return r
}

// Specify this criteria if calculation is based on the guest balance.
func (r CashieringConfigAPICalculatePostingRequest) GuestBalance(guestBalance float32) CashieringConfigAPICalculatePostingRequest {
	r.guestBalance = &guestBalance
	return r
}

// Specify this criteria if calculation is based on room type.
func (r CashieringConfigAPICalculatePostingRequest) RoomType(roomType string) CashieringConfigAPICalculatePostingRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r CashieringConfigAPICalculatePostingRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICalculatePostingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICalculatePostingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICalculatePostingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICalculatePostingRequest) Execute() (*CalculatedPosting, *http.Response, error) {
	return r.ApiService.CalculatePostingExecute(r)
}

/*
CalculatePosting Operation to CalculatePosting.

Operation to test posting amount. <p><strong>OperationId:</strong>calculatePosting</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionCode Transaction Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPICalculatePostingRequest
*/
func (a *CashieringConfigAPIService) CalculatePosting(ctx context.Context, transactionCode string, hotelId string) CashieringConfigAPICalculatePostingRequest {
	return CashieringConfigAPICalculatePostingRequest{
		ApiService: a,
		ctx: ctx,
		transactionCode: transactionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CalculatedPosting
func (a *CashieringConfigAPIService) CalculatePostingExecute(r CashieringConfigAPICalculatePostingRequest) (*CalculatedPosting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalculatedPosting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CalculatePosting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes/{transactionCode}/chargeSimulations"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionCode"+"}", url.PathEscape(parameterValueToString(r.transactionCode, "transactionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionCode must have at least 1 elements")
	}
	if strlen(r.transactionCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.postingAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmount", r.postingAmount, "")
  }
	if r.taxType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxType", r.taxType, "")
  }
	if r.guestBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestBalance", r.guestBalance, "")
  }
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIChangeCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesToBeChanged *CompTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIChangeCompTypesRequest) Authorization(authorization string) CashieringConfigAPIChangeCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIChangeCompTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIChangeCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIChangeCompTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIChangeCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Comp Types.
func (r CashieringConfigAPIChangeCompTypesRequest) CompTypesToBeChanged(compTypesToBeChanged CompTypesToBeChanged) CashieringConfigAPIChangeCompTypesRequest {
	r.compTypesToBeChanged = &compTypesToBeChanged
	return r
}

// External system code.
func (r CashieringConfigAPIChangeCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIChangeCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIChangeCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIChangeCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIChangeCompTypesRequest) Execute() (*CompTypesStatus, *http.Response, error) {
	return r.ApiService.ChangeCompTypesExecute(r)
}

/*
ChangeCompTypes Operation to Change Comp Types.

Operation to Change Comp Types. <p><strong>OperationId:</strong>changeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIChangeCompTypesRequest
*/
func (a *CashieringConfigAPIService) ChangeCompTypes(ctx context.Context) CashieringConfigAPIChangeCompTypesRequest {
	return CashieringConfigAPIChangeCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompTypesStatus
func (a *CashieringConfigAPIService) ChangeCompTypesExecute(r CashieringConfigAPIChangeCompTypesRequest) (*CompTypesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.ChangeCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIChangeFiscalCommandsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeFiscalCommands *ChangeFiscalCommands
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIChangeFiscalCommandsRequest) Authorization(authorization string) CashieringConfigAPIChangeFiscalCommandsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIChangeFiscalCommandsRequest) XAppKey(xAppKey string) CashieringConfigAPIChangeFiscalCommandsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIChangeFiscalCommandsRequest) XHotelid(xHotelid string) CashieringConfigAPIChangeFiscalCommandsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update existing Fiscal Command.
func (r CashieringConfigAPIChangeFiscalCommandsRequest) ChangeFiscalCommands(changeFiscalCommands ChangeFiscalCommands) CashieringConfigAPIChangeFiscalCommandsRequest {
	r.changeFiscalCommands = &changeFiscalCommands
	return r
}

// External system code.
func (r CashieringConfigAPIChangeFiscalCommandsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIChangeFiscalCommandsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIChangeFiscalCommandsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIChangeFiscalCommandsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIChangeFiscalCommandsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFiscalCommandsExecute(r)
}

/*
ChangeFiscalCommands Change configuration fiscal commands

Use this API to update configuration fiscal commands. <p><strong>OperationId:</strong>changeFiscalCommands</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return CashieringConfigAPIChangeFiscalCommandsRequest
*/
func (a *CashieringConfigAPIService) ChangeFiscalCommands(ctx context.Context, hotelId string) CashieringConfigAPIChangeFiscalCommandsRequest {
	return CashieringConfigAPIChangeFiscalCommandsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) ChangeFiscalCommandsExecute(r CashieringConfigAPIChangeFiscalCommandsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.ChangeFiscalCommands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalCommands"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeFiscalCommands
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIChangeFiscalPartnersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	changeFiscalPartners *ChangeFiscalPartners
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIChangeFiscalPartnersRequest) Authorization(authorization string) CashieringConfigAPIChangeFiscalPartnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIChangeFiscalPartnersRequest) XAppKey(xAppKey string) CashieringConfigAPIChangeFiscalPartnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIChangeFiscalPartnersRequest) XHotelid(xHotelid string) CashieringConfigAPIChangeFiscalPartnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change Fiscal Partners.
func (r CashieringConfigAPIChangeFiscalPartnersRequest) ChangeFiscalPartners(changeFiscalPartners ChangeFiscalPartners) CashieringConfigAPIChangeFiscalPartnersRequest {
	r.changeFiscalPartners = &changeFiscalPartners
	return r
}

// External system code.
func (r CashieringConfigAPIChangeFiscalPartnersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIChangeFiscalPartnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIChangeFiscalPartnersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIChangeFiscalPartnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIChangeFiscalPartnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFiscalPartnersExecute(r)
}

/*
ChangeFiscalPartners Change configuration fiscal partners

Use this API to update configuration fiscal partners. <p><strong>OperationId:</strong>changeFiscalPartners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return CashieringConfigAPIChangeFiscalPartnersRequest
*/
func (a *CashieringConfigAPIService) ChangeFiscalPartners(ctx context.Context, hotelId string) CashieringConfigAPIChangeFiscalPartnersRequest {
	return CashieringConfigAPIChangeFiscalPartnersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) ChangeFiscalPartnersExecute(r CashieringConfigAPIChangeFiscalPartnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.ChangeFiscalPartners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalPartners"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.changeFiscalPartners
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigToBeChanged *FolioTypeLegendMappingConfigToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit folio type legend mapping information.
func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigToBeChanged(folioTypeLegendMappingConfigToBeChanged FolioTypeLegendMappingConfigToBeChanged) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigToBeChanged = &folioTypeLegendMappingConfigToBeChanged
	return r
}

// External system code.
func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) Execute() (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	return r.ApiService.ChangeFolioTypeLegendMappingConfigExecute(r)
}

/*
ChangeFolioTypeLegendMappingConfig Operation to change folio type legend mappings config.

Operation to change folio type legend mappings config. <p><strong>OperationId:</strong>changeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigAPIService) ChangeFolioTypeLegendMappingConfig(ctx context.Context) CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest {
	return CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingConfigStatus
func (a *CashieringConfigAPIService) ChangeFolioTypeLegendMappingConfigExecute(r CashieringConfigAPIChangeFolioTypeLegendMappingConfigRequest) (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingConfigStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.ChangeFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodesCopy *AdjustmentCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigAPICopyAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the Adjustment Codes to be copied.
func (r CashieringConfigAPICopyAdjustmentCodesRequest) AdjustmentCodesCopy(adjustmentCodesCopy AdjustmentCodesCopy) CashieringConfigAPICopyAdjustmentCodesRequest {
	r.adjustmentCodesCopy = &adjustmentCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyAdjustmentCodesExecute(r)
}

/*
CopyAdjustmentCodes Operation to copy AdjustmentCodes.

Operation to copy Adjustment Codes. <p><strong>OperationId:</strong>copyAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyAdjustmentCodesRequest
*/
func (a *CashieringConfigAPIService) CopyAdjustmentCodes(ctx context.Context) CashieringConfigAPICopyAdjustmentCodesRequest {
	return CashieringConfigAPICopyAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyAdjustmentCodesExecute(r CashieringConfigAPICopyAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyCustomChargeExemptionsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customChargeExemptionsConfigCopy *CustomChargeExemptionsConfigCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) Authorization(authorization string) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) XAppKey(xAppKey string) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) XHotelid(xHotelid string) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the Custom Charge Exemptions to be copied.
func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) CustomChargeExemptionsConfigCopy(customChargeExemptionsConfigCopy CustomChargeExemptionsConfigCopy) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	r.customChargeExemptionsConfigCopy = &customChargeExemptionsConfigCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyCustomChargeExemptionsConfigExecute(r)
}

/*
CopyCustomChargeExemptionsConfig Operation to copy Custom Charge Exemptions Config.

Operation to copy Custom Charge Exemptions Config. <p><strong>OperationId:</strong>copyCustomChargeExemptionsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPICopyCustomChargeExemptionsConfigRequest
*/
func (a *CashieringConfigAPIService) CopyCustomChargeExemptionsConfig(ctx context.Context, sourceHotelId string) CashieringConfigAPICopyCustomChargeExemptionsConfigRequest {
	return CashieringConfigAPICopyCustomChargeExemptionsConfigRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyCustomChargeExemptionsConfigExecute(r CashieringConfigAPICopyCustomChargeExemptionsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyCustomChargeExemptionsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/customCharges/exemptions/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customChargeExemptionsConfigCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodesCopy *ExpenseArrangementCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the expense arrangement codes to be copied.
func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) ExpenseArrangementCodesCopy(expenseArrangementCodesCopy ExpenseArrangementCodesCopy) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	r.expenseArrangementCodesCopy = &expenseArrangementCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyExpenseArrangementCodesExecute(r)
}

/*
CopyExpenseArrangementCodes Operation to copy ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>copyExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyExpenseArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) CopyExpenseArrangementCodes(ctx context.Context) CashieringConfigAPICopyExpenseArrangementCodesRequest {
	return CashieringConfigAPICopyExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyExpenseArrangementCodesExecute(r CashieringConfigAPICopyExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioParametersCopy *FiscalFolioParametersCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigAPICopyFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigAPICopyFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigAPICopyFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Fiscal Folio Parameters to other hotel code(s).
func (r CashieringConfigAPICopyFiscalFolioParametersRequest) FiscalFolioParametersCopy(fiscalFolioParametersCopy FiscalFolioParametersCopy) CashieringConfigAPICopyFiscalFolioParametersRequest {
	r.fiscalFolioParametersCopy = &fiscalFolioParametersCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyFiscalFolioParametersExecute(r)
}

/*
CopyFiscalFolioParameters Operation to copy FiscalFolioParameters.

Operation to copy Fiscal Folio Parameters. <p><strong>OperationId:</strong>copyFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigAPICopyFiscalFolioParametersRequest
*/
func (a *CashieringConfigAPIService) CopyFiscalFolioParameters(ctx context.Context, sourceHotelId string) CashieringConfigAPICopyFiscalFolioParametersRequest {
	return CashieringConfigAPICopyFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyFiscalFolioParametersExecute(r CashieringConfigAPICopyFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/fiscalFolioParameters/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioParametersCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyFolioArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioArrangementCodesCopy *FolioArrangementCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyFolioArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPICopyFolioArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyFolioArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyFolioArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyFolioArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyFolioArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of folio arrangement codes to be copied.
func (r CashieringConfigAPICopyFolioArrangementCodesRequest) FolioArrangementCodesCopy(folioArrangementCodesCopy FolioArrangementCodesCopy) CashieringConfigAPICopyFolioArrangementCodesRequest {
	r.folioArrangementCodesCopy = &folioArrangementCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyFolioArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyFolioArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyFolioArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyFolioArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyFolioArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyFolioArrangementCodesExecute(r)
}

/*
CopyFolioArrangementCodes Operation to copy FolioArrangementCodes.

 <p><strong>OperationId:</strong>copyFolioArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyFolioArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) CopyFolioArrangementCodes(ctx context.Context) CashieringConfigAPICopyFolioArrangementCodesRequest {
	return CashieringConfigAPICopyFolioArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyFolioArrangementCodesExecute(r CashieringConfigAPICopyFolioArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyFolioArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioArrangementCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioArrangementCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyGroupArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	groupArrangementCodesCopy *GroupArrangementCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyGroupArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPICopyGroupArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyGroupArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyGroupArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyGroupArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyGroupArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the group arrangement codes to be copied.
func (r CashieringConfigAPICopyGroupArrangementCodesRequest) GroupArrangementCodesCopy(groupArrangementCodesCopy GroupArrangementCodesCopy) CashieringConfigAPICopyGroupArrangementCodesRequest {
	r.groupArrangementCodesCopy = &groupArrangementCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyGroupArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyGroupArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyGroupArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyGroupArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyGroupArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyGroupArrangementCodesExecute(r)
}

/*
CopyGroupArrangementCodes Operation to copy GroupArrangementCodes.

 <p><strong>OperationId:</strong>copyGroupArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyGroupArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) CopyGroupArrangementCodes(ctx context.Context) CashieringConfigAPICopyGroupArrangementCodesRequest {
	return CashieringConfigAPICopyGroupArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyGroupArrangementCodesExecute(r CashieringConfigAPICopyGroupArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyGroupArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groupArrangementCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.groupArrangementCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyPackageArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	packageArrangementCodesCopy *PackageArrangementCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyPackageArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPICopyPackageArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyPackageArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyPackageArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyPackageArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyPackageArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the package arrangement codes to be copied.
func (r CashieringConfigAPICopyPackageArrangementCodesRequest) PackageArrangementCodesCopy(packageArrangementCodesCopy PackageArrangementCodesCopy) CashieringConfigAPICopyPackageArrangementCodesRequest {
	r.packageArrangementCodesCopy = &packageArrangementCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyPackageArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyPackageArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyPackageArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyPackageArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyPackageArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyPackageArrangementCodesExecute(r)
}

/*
CopyPackageArrangementCodes Operation to copy PackageArrangementCodes.

 <p><strong>OperationId:</strong>copyPackageArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyPackageArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) CopyPackageArrangementCodes(ctx context.Context) CashieringConfigAPICopyPackageArrangementCodesRequest {
	return CashieringConfigAPICopyPackageArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyPackageArrangementCodesExecute(r CashieringConfigAPICopyPackageArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyPackageArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageArrangementCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageArrangementCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	paymentMethodsCopy *PaymentMethodsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyPaymentMethodsRequest) Authorization(authorization string) CashieringConfigAPICopyPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyPaymentMethodsRequest) XAppKey(xAppKey string) CashieringConfigAPICopyPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyPaymentMethodsRequest) XHotelid(xHotelid string) CashieringConfigAPICopyPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of payment methods to be copied.
func (r CashieringConfigAPICopyPaymentMethodsRequest) PaymentMethodsCopy(paymentMethodsCopy PaymentMethodsCopy) CashieringConfigAPICopyPaymentMethodsRequest {
	r.paymentMethodsCopy = &paymentMethodsCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyPaymentMethodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyPaymentMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyPaymentMethodsExecute(r)
}

/*
CopyPaymentMethods Operation to copy PaymentMethods.

Operation to copy payment methods. <p><strong>OperationId:</strong>copyPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyPaymentMethodsRequest
*/
func (a *CashieringConfigAPIService) CopyPaymentMethods(ctx context.Context) CashieringConfigAPICopyPaymentMethodsRequest {
	return CashieringConfigAPICopyPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyPaymentMethodsExecute(r CashieringConfigAPICopyPaymentMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelPaymentMethods/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.paymentMethodsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyRevenueBucketCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketCodesCopy *RevenueBucketCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyRevenueBucketCodesRequest) Authorization(authorization string) CashieringConfigAPICopyRevenueBucketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyRevenueBucketCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyRevenueBucketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyRevenueBucketCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyRevenueBucketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying one or more Revenue Bucket Codes configurations from one source property to one or more target properties.
func (r CashieringConfigAPICopyRevenueBucketCodesRequest) RevenueBucketCodesCopy(revenueBucketCodesCopy RevenueBucketCodesCopy) CashieringConfigAPICopyRevenueBucketCodesRequest {
	r.revenueBucketCodesCopy = &revenueBucketCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyRevenueBucketCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyRevenueBucketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyRevenueBucketCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyRevenueBucketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyRevenueBucketCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyRevenueBucketCodesExecute(r)
}

/*
CopyRevenueBucketCodes Operation to copy RevenueBucketCodes.

Operation to copy Revenue Bucket Codes. <p><strong>OperationId:</strong>copyRevenueBucketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyRevenueBucketCodesRequest
*/
func (a *CashieringConfigAPIService) CopyRevenueBucketCodes(ctx context.Context) CashieringConfigAPICopyRevenueBucketCodesRequest {
	return CashieringConfigAPICopyRevenueBucketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyRevenueBucketCodesExecute(r CashieringConfigAPICopyRevenueBucketCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyRevenueBucketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueBucketCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyRevenueBucketTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketTypesCopy *RevenueBucketTypesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyRevenueBucketTypesRequest) Authorization(authorization string) CashieringConfigAPICopyRevenueBucketTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyRevenueBucketTypesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyRevenueBucketTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyRevenueBucketTypesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyRevenueBucketTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the Revenue Bucket Types to be copied.
func (r CashieringConfigAPICopyRevenueBucketTypesRequest) RevenueBucketTypesCopy(revenueBucketTypesCopy RevenueBucketTypesCopy) CashieringConfigAPICopyRevenueBucketTypesRequest {
	r.revenueBucketTypesCopy = &revenueBucketTypesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyRevenueBucketTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyRevenueBucketTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyRevenueBucketTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyRevenueBucketTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyRevenueBucketTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyRevenueBucketTypesExecute(r)
}

/*
CopyRevenueBucketTypes Operation to copy RevenueBucketTypes.

Operation to copy Revenue Bucket Types. <p><strong>OperationId:</strong>copyRevenueBucketTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyRevenueBucketTypesRequest
*/
func (a *CashieringConfigAPIService) CopyRevenueBucketTypes(ctx context.Context) CashieringConfigAPICopyRevenueBucketTypesRequest {
	return CashieringConfigAPICopyRevenueBucketTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyRevenueBucketTypesExecute(r CashieringConfigAPICopyRevenueBucketTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyRevenueBucketTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketTypes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueBucketTypesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyRevenueTypeMappingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueTypeMappingCopy *RevenueTypeMappingCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyRevenueTypeMappingRequest) Authorization(authorization string) CashieringConfigAPICopyRevenueTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyRevenueTypeMappingRequest) XAppKey(xAppKey string) CashieringConfigAPICopyRevenueTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyRevenueTypeMappingRequest) XHotelid(xHotelid string) CashieringConfigAPICopyRevenueTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying Revenue Type Mapping.
func (r CashieringConfigAPICopyRevenueTypeMappingRequest) RevenueTypeMappingCopy(revenueTypeMappingCopy RevenueTypeMappingCopy) CashieringConfigAPICopyRevenueTypeMappingRequest {
	r.revenueTypeMappingCopy = &revenueTypeMappingCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyRevenueTypeMappingRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyRevenueTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyRevenueTypeMappingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyRevenueTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyRevenueTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyRevenueTypeMappingExecute(r)
}

/*
CopyRevenueTypeMapping Operation to copy RevenueTypeMapping.

 <p><strong>OperationId:</strong>copyRevenueTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyRevenueTypeMappingRequest
*/
func (a *CashieringConfigAPIService) CopyRevenueTypeMapping(ctx context.Context) CashieringConfigAPICopyRevenueTypeMappingRequest {
	return CashieringConfigAPICopyRevenueTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyRevenueTypeMappingExecute(r CashieringConfigAPICopyRevenueTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyRevenueTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypeMapping/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueTypeMappingCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructionsCopy *RoutingInstructionsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyRoutingInstructionsRequest) Authorization(authorization string) CashieringConfigAPICopyRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringConfigAPICopyRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringConfigAPICopyRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the routing instructions to be copied to hotel code(s).
func (r CashieringConfigAPICopyRoutingInstructionsRequest) RoutingInstructionsCopy(routingInstructionsCopy RoutingInstructionsCopy) CashieringConfigAPICopyRoutingInstructionsRequest {
	r.routingInstructionsCopy = &routingInstructionsCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyRoutingInstructionsExecute(r)
}

/*
CopyRoutingInstructions Operation to copy RoutingInstructions.

Operation to copy routing instructions. <p><strong>OperationId:</strong>copyRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyRoutingInstructionsRequest
*/
func (a *CashieringConfigAPIService) CopyRoutingInstructions(ctx context.Context) CashieringConfigAPICopyRoutingInstructionsRequest {
	return CashieringConfigAPICopyRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyRoutingInstructionsExecute(r CashieringConfigAPICopyRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routingInstructions/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructionsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyTaxBracketsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxBracketsCopy *TaxBracketsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyTaxBracketsRequest) Authorization(authorization string) CashieringConfigAPICopyTaxBracketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyTaxBracketsRequest) XAppKey(xAppKey string) CashieringConfigAPICopyTaxBracketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyTaxBracketsRequest) XHotelid(xHotelid string) CashieringConfigAPICopyTaxBracketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying tax brackets.
func (r CashieringConfigAPICopyTaxBracketsRequest) TaxBracketsCopy(taxBracketsCopy TaxBracketsCopy) CashieringConfigAPICopyTaxBracketsRequest {
	r.taxBracketsCopy = &taxBracketsCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyTaxBracketsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyTaxBracketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyTaxBracketsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyTaxBracketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyTaxBracketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTaxBracketsExecute(r)
}

/*
CopyTaxBrackets Operation to copy TaxBrackets.

Operation to copy Tax Brackets. This function only be available when the parameter "Tax Bracket Calculation" is on. <p><strong>OperationId:</strong>copyTaxBrackets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyTaxBracketsRequest
*/
func (a *CashieringConfigAPIService) CopyTaxBrackets(ctx context.Context) CashieringConfigAPICopyTaxBracketsRequest {
	return CashieringConfigAPICopyTaxBracketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyTaxBracketsExecute(r CashieringConfigAPICopyTaxBracketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyTaxBrackets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxBrackets/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxBracketsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypesCopy *TaxTypesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyTaxTypesRequest) Authorization(authorization string) CashieringConfigAPICopyTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the Tax Types to be copied.
func (r CashieringConfigAPICopyTaxTypesRequest) TaxTypesCopy(taxTypesCopy TaxTypesCopy) CashieringConfigAPICopyTaxTypesRequest {
	r.taxTypesCopy = &taxTypesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTaxTypesExecute(r)
}

/*
CopyTaxTypes Operation to copy TaxTypes.

Operation to copy Tax Types. <p><strong>OperationId:</strong>copyTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyTaxTypesRequest
*/
func (a *CashieringConfigAPIService) CopyTaxTypes(ctx context.Context) CashieringConfigAPICopyTaxTypesRequest {
	return CashieringConfigAPICopyTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyTaxTypesExecute(r CashieringConfigAPICopyTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxTypesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodesCopy *TransactionCodesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPICopyTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPICopyTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPICopyTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying transaction codes in the configuration.
func (r CashieringConfigAPICopyTransactionCodesRequest) TransactionCodesCopy(transactionCodesCopy TransactionCodesCopy) CashieringConfigAPICopyTransactionCodesRequest {
	r.transactionCodesCopy = &transactionCodesCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTransactionCodesExecute(r)
}

/*
CopyTransactionCodes Operation to copy TransactionCodes.

Operation to copy transaction codes. <p><strong>OperationId:</strong>copyTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) CopyTransactionCodes(ctx context.Context) CashieringConfigAPICopyTransactionCodesRequest {
	return CashieringConfigAPICopyTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyTransactionCodesExecute(r CashieringConfigAPICopyTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupsCopy *TransactionGroupsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPICopyTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPICopyTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPICopyTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the transaction groups to be copied.
func (r CashieringConfigAPICopyTransactionGroupsRequest) TransactionGroupsCopy(transactionGroupsCopy TransactionGroupsCopy) CashieringConfigAPICopyTransactionGroupsRequest {
	r.transactionGroupsCopy = &transactionGroupsCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTransactionGroupsExecute(r)
}

/*
CopyTransactionGroups Operation to copy TransactionGroups.

Operation to copy transaction groups. <p><strong>OperationId:</strong>copyTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) CopyTransactionGroups(ctx context.Context) CashieringConfigAPICopyTransactionGroupsRequest {
	return CashieringConfigAPICopyTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyTransactionGroupsExecute(r CashieringConfigAPICopyTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionGroupsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPICopyTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionSubgroupsCopy *TransactionSubgroupsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPICopyTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPICopyTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPICopyTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPICopyTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPICopyTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPICopyTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy transaction subgroups to the properties specified.
func (r CashieringConfigAPICopyTransactionSubgroupsRequest) TransactionSubgroupsCopy(transactionSubgroupsCopy TransactionSubgroupsCopy) CashieringConfigAPICopyTransactionSubgroupsRequest {
	r.transactionSubgroupsCopy = &transactionSubgroupsCopy
	return r
}

// External system code.
func (r CashieringConfigAPICopyTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPICopyTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPICopyTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPICopyTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPICopyTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTransactionSubgroupsExecute(r)
}

/*
CopyTransactionSubgroups Operation to copy TransactionSubgroups.

Operation to copy transaction subgroups <p><strong>OperationId:</strong>copyTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPICopyTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) CopyTransactionSubgroups(ctx context.Context) CashieringConfigAPICopyTransactionSubgroupsRequest {
	return CashieringConfigAPICopyTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) CopyTransactionSubgroupsExecute(r CashieringConfigAPICopyTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.CopyTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionSubGroups/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionSubgroupsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCode *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) AdjustmentCode(adjustmentCode string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.adjustmentCode = &adjustmentCode
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) HotelId(hotelId string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdjustmentCodesExecute(r)
}

/*
DeleteAdjustmentCodes Operation to delete AdjustmentCodes.

Operation to remove Adjustment Codes. <p><strong>OperationId:</strong>deleteAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteAdjustmentCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteAdjustmentCodes(ctx context.Context) CashieringConfigAPIDeleteAdjustmentCodesRequest {
	return CashieringConfigAPIDeleteAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteAdjustmentCodesExecute(r CashieringConfigAPIDeleteAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adjustmentCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCode", r.adjustmentCode, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	articleCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	articleHotelId *[]string
	inactive *[]bool
	orderSequence *[]float32
	description *[]string
	transactionCode *[]string
	amount *float32
	currencyCode *string
	availableForPostIt *bool
	color *string
	universalProductCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIDeleteArticlesRequest) HotelId(hotelId string) CashieringConfigAPIDeleteArticlesRequest {
	r.hotelId = &hotelId
	return r
}

// Unique code of the article.
func (r CashieringConfigAPIDeleteArticlesRequest) ArticleCodes(articleCodes []string) CashieringConfigAPIDeleteArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteArticlesRequest) Authorization(authorization string) CashieringConfigAPIDeleteArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteArticlesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteArticlesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code to which the article belongs.
func (r CashieringConfigAPIDeleteArticlesRequest) ArticleHotelId(articleHotelId []string) CashieringConfigAPIDeleteArticlesRequest {
	r.articleHotelId = &articleHotelId
	return r
}

// Indicates whether the article is inactive or not.
func (r CashieringConfigAPIDeleteArticlesRequest) Inactive(inactive []bool) CashieringConfigAPIDeleteArticlesRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r CashieringConfigAPIDeleteArticlesRequest) OrderSequence(orderSequence []float32) CashieringConfigAPIDeleteArticlesRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r CashieringConfigAPIDeleteArticlesRequest) Description(description []string) CashieringConfigAPIDeleteArticlesRequest {
	r.description = &description
	return r
}

// Transaction code to which the article belongs.
func (r CashieringConfigAPIDeleteArticlesRequest) TransactionCode(transactionCode []string) CashieringConfigAPIDeleteArticlesRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r CashieringConfigAPIDeleteArticlesRequest) Amount(amount float32) CashieringConfigAPIDeleteArticlesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringConfigAPIDeleteArticlesRequest) CurrencyCode(currencyCode string) CashieringConfigAPIDeleteArticlesRequest {
	r.currencyCode = &currencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r CashieringConfigAPIDeleteArticlesRequest) AvailableForPostIt(availableForPostIt bool) CashieringConfigAPIDeleteArticlesRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r CashieringConfigAPIDeleteArticlesRequest) Color(color string) CashieringConfigAPIDeleteArticlesRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r CashieringConfigAPIDeleteArticlesRequest) UniversalProductCode(universalProductCode []string) CashieringConfigAPIDeleteArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteArticlesExecute(r)
}

/*
DeleteArticles Operation to delete Articles.

Operation to remove articles. <p><strong>OperationId:</strong>deleteArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteArticlesRequest
*/
func (a *CashieringConfigAPIService) DeleteArticles(ctx context.Context) CashieringConfigAPIDeleteArticlesRequest {
	return CashieringConfigAPIDeleteArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteArticlesExecute(r CashieringConfigAPIDeleteArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	{
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.articleHotelId != nil {
		t := *r.articleHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
  }
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
  }
	if r.universalProductCode != nil {
		t := *r.universalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *[]string
	roomClassHotelId *string
	roomClassCode *string
	sourceCodeHotelId *string
	sourceCode *string
	rateCategory *string
	rateCode *[]string
	guaranteeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with authorization rule
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Authorization rule Room type.
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) RoomType(roomType []string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.roomType = &roomType
	return r
}

func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) RoomClassHotelId(roomClassHotelId string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) RoomClassCode(roomClassCode string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) SourceCodeHotelId(sourceCodeHotelId string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.sourceCodeHotelId = &sourceCodeHotelId
	return r
}

func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) SourceCode(sourceCode string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.sourceCode = &sourceCode
	return r
}

// Rate category Code.
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) RateCategory(rateCategory string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.rateCategory = &rateCategory
	return r
}

// Rate code associated to this rule.
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) RateCode(rateCode []string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.rateCode = &rateCode
	return r
}

// Guarantee code associated to this rule.
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) GuaranteeCode(guaranteeCode []string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationConfigRuleExecute(r)
}

/*
DeleteAuthorizationConfigRule Operation to delete AuthorizationConfigRule.

 <p><strong>OperationId:</strong>deleteAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigAPIService) DeleteAuthorizationConfigRule(ctx context.Context) CashieringConfigAPIDeleteAuthorizationConfigRuleRequest {
	return CashieringConfigAPIDeleteAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteAuthorizationConfigRuleExecute(r CashieringConfigAPIDeleteAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
  }
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
  }
	if r.sourceCodeHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodeHotelId", r.sourceCodeHotelId, "")
  }
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
  }
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
  }
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
  }
	if r.guaranteeCode != nil {
		t := *r.guaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroup *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) AuthorizerGroup(authorizerGroup string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.authorizerGroup = &authorizerGroup
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) HotelId(hotelId string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizerGroupsExecute(r)
}

/*
DeleteAuthorizerGroups Operation to delete AuthorizerGroups.

Operation to remove Authorizer Groups. <p><strong>OperationId:</strong>deleteAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteAuthorizerGroupsRequest
*/
func (a *CashieringConfigAPIService) DeleteAuthorizerGroups(ctx context.Context) CashieringConfigAPIDeleteAuthorizerGroupsRequest {
	return CashieringConfigAPIDeleteAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteAuthorizerGroupsExecute(r CashieringConfigAPIDeleteAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authorizerGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroup", r.authorizerGroup, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteBudgetForecastRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	budgetForecastToDelete *BudgetForecastToDelete
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteBudgetForecastRequest) Authorization(authorization string) CashieringConfigAPIDeleteBudgetForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteBudgetForecastRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteBudgetForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteBudgetForecastRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteBudgetForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to load the Budget or Forecast information.
func (r CashieringConfigAPIDeleteBudgetForecastRequest) BudgetForecastToDelete(budgetForecastToDelete BudgetForecastToDelete) CashieringConfigAPIDeleteBudgetForecastRequest {
	r.budgetForecastToDelete = &budgetForecastToDelete
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteBudgetForecastRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteBudgetForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteBudgetForecastRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteBudgetForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteBudgetForecastRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBudgetForecastExecute(r)
}

/*
DeleteBudgetForecast Operation to delete BudgetForecast.

Operation to Delete Budget Forecast information. <p><strong>OperationId:</strong>deleteBudgetForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteBudgetForecastRequest
*/
func (a *CashieringConfigAPIService) DeleteBudgetForecast(ctx context.Context) CashieringConfigAPIDeleteBudgetForecastRequest {
	return CashieringConfigAPIDeleteBudgetForecastRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteBudgetForecastExecute(r CashieringConfigAPIDeleteBudgetForecastRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteBudgetForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/budgetForecast"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.budgetForecastToDelete
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteCollectingAgentTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxCode *[]int32
	taxTypeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// It represents Hotel code
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) Authorization(authorization string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Primary Key Sequence.
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) TaxCode(taxCode []int32) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.taxCode = &taxCode
	return r
}

func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) TaxTypeCodes(taxTypeCodes []string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.taxTypeCodes = &taxTypeCodes
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCollectingAgentTaxesExecute(r)
}

/*
DeleteCollectingAgentTaxes Operation to delete CollectingAgentTaxes.

Operation to remove Collecting Agent Taxes. <p><strong>OperationId:</strong>deleteCollectingAgentTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteCollectingAgentTaxesRequest
*/
func (a *CashieringConfigAPIService) DeleteCollectingAgentTaxes(ctx context.Context) CashieringConfigAPIDeleteCollectingAgentTaxesRequest {
	return CashieringConfigAPIDeleteCollectingAgentTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteCollectingAgentTaxesExecute(r CashieringConfigAPIDeleteCollectingAgentTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteCollectingAgentTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/collectingAgentTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.taxCode != nil {
		t := *r.taxCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxCode", t, "multi")
		}
  }
	if r.taxTypeCodes != nil {
		t := *r.taxTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	redemptionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) Authorization(authorization string) CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCompBucketRedemptionConfigExecute(r)
}

/*
DeleteCompBucketRedemptionConfig Operation to remove Comp Bucket Redemption Codes.

Operation to remove Comp Bucket Redemption Codes. <p><strong>OperationId:</strong>deleteCompBucketRedemptionConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param redemptionCode Bucket Redemption Code
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest
*/
func (a *CashieringConfigAPIService) DeleteCompBucketRedemptionConfig(ctx context.Context, redemptionCode string, hotelId string) CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest {
	return CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest{
		ApiService: a,
		ctx: ctx,
		redemptionCode: redemptionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteCompBucketRedemptionConfigExecute(r CashieringConfigAPIDeleteCompBucketRedemptionConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteCompBucketRedemptionConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compBucket/redemption/{redemptionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"redemptionCode"+"}", url.PathEscape(parameterValueToString(r.redemptionCode, "redemptionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.redemptionCode) < 1 {
		return localVarReturnValue, nil, reportError("redemptionCode must have at least 1 elements")
	}
	if strlen(r.redemptionCode) > 2000 {
		return localVarReturnValue, nil, reportError("redemptionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with currency exchange service tax
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency exchange service tax code
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxCode(currencyExchangeServiceTaxCode []string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxCode = &currencyExchangeServiceTaxCode
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCurrencyExchangeServiceTaxesExecute(r)
}

/*
DeleteCurrencyExchangeServiceTaxes Operation to delete CurrencyExchangeServiceTaxes.

Operation to remove currency exchange service taxes. <p><strong>OperationId:</strong>deleteCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigAPIService) DeleteCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteCurrencyExchangeServiceTaxesExecute(r CashieringConfigAPIDeleteCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.currencyExchangeServiceTaxCode != nil {
		t := *r.currencyExchangeServiceTaxCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) Authorization(authorization string) CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCustomChargeExemptionsConfigExecute(r)
}

/*
DeleteCustomChargeExemptionsConfig Operation to remove Custom Charge Exemptions Config.

Operation to remove Custom Charge Exemptions Config. <p><strong>OperationId:</strong>deleteCustomChargeExemptionsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest
*/
func (a *CashieringConfigAPIService) DeleteCustomChargeExemptionsConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest {
	return CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteCustomChargeExemptionsConfigExecute(r CashieringConfigAPIDeleteCustomChargeExemptionsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteCustomChargeExemptionsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/exemptions/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteCustomChargesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteCustomChargesConfigRequest) Authorization(authorization string) CashieringConfigAPIDeleteCustomChargesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteCustomChargesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteCustomChargesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteCustomChargesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteCustomChargesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteCustomChargesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteCustomChargesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteCustomChargesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteCustomChargesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteCustomChargesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCustomChargesConfigExecute(r)
}

/*
DeleteCustomChargesConfig Operation to remove Custom Charge Codes.

Operation to remove Custom Charge Codes. <p><strong>OperationId:</strong>deleteCustomChargesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIDeleteCustomChargesConfigRequest
*/
func (a *CashieringConfigAPIService) DeleteCustomChargesConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIDeleteCustomChargesConfigRequest {
	return CashieringConfigAPIDeleteCustomChargesConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteCustomChargesConfigExecute(r CashieringConfigAPIDeleteCustomChargesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteCustomChargesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIDeleteCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteCustomNumberConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCustomNumberConfigExecute(r)
}

/*
DeleteCustomNumberConfig Operation to remove custom number config.

 <p><strong>OperationId:</strong>deleteCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIDeleteCustomNumberConfigRequest
*/
func (a *CashieringConfigAPIService) DeleteCustomNumberConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIDeleteCustomNumberConfigRequest {
	return CashieringConfigAPIDeleteCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteCustomNumberConfigExecute(r CashieringConfigAPIDeleteCustomNumberConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customNumbers/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	exchangeRates *ExchangeRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteExchangeRatesRequest) Authorization(authorization string) CashieringConfigAPIDeleteExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteExchangeRatesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Exchange Rates to be Set.
func (r CashieringConfigAPIDeleteExchangeRatesRequest) ExchangeRates(exchangeRates ExchangeRates) CashieringConfigAPIDeleteExchangeRatesRequest {
	r.exchangeRates = &exchangeRates
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteExchangeRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExchangeRatesExecute(r)
}

/*
DeleteExchangeRates Operation to delete ExchangeRates.

Operation to Delete Exchange Rates. <p><strong>OperationId:</strong>deleteExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteExchangeRatesRequest
*/
func (a *CashieringConfigAPIService) DeleteExchangeRates(ctx context.Context) CashieringConfigAPIDeleteExchangeRatesRequest {
	return CashieringConfigAPIDeleteExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteExchangeRatesExecute(r CashieringConfigAPIDeleteExchangeRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exchangeRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exchangeRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) Code(code []string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExpenseArrangementCodesExecute(r)
}

/*
DeleteExpenseArrangementCodes Operation to delete ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>deleteExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteExpenseArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteExpenseArrangementCodes(ctx context.Context) CashieringConfigAPIDeleteExpenseArrangementCodesRequest {
	return CashieringConfigAPIDeleteExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteExpenseArrangementCodesExecute(r CashieringConfigAPIDeleteExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	partner *[]string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code of the Hotel.
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.hotelId = &hotelId
	return r
}

// Fiscal folio parameter associated with Partner.
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) Partner(partner []string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.partner = &partner
	return r
}

// Code of the Fiscal Folio Parameter.
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) Code(code []string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFiscalFolioParametersExecute(r)
}

/*
DeleteFiscalFolioParameters Operation to delete FiscalFolioParameters.

Operation to remove Fiscal Folio Parameters. <p><strong>OperationId:</strong>deleteFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteFiscalFolioParametersRequest
*/
func (a *CashieringConfigAPIService) DeleteFiscalFolioParameters(ctx context.Context) CashieringConfigAPIDeleteFiscalFolioParametersRequest {
	return CashieringConfigAPIDeleteFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteFiscalFolioParametersExecute(r CashieringConfigAPIDeleteFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.partner != nil {
		t := *r.partner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partner", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partner", t, "multi")
		}
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteFiscalPeriodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	yearId *[]float32
	startDate *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Resort for which the Period is defined.
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) Authorization(authorization string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Id of the Year.
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) YearId(yearId []float32) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.yearId = &yearId
	return r
}

// Start Date of the Period
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) StartDate(startDate []string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.startDate = &startDate
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteFiscalPeriodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFiscalPeriodsExecute(r)
}

/*
DeleteFiscalPeriods Operation to delete FiscalPeriods.

Operation to remove Fiscal Periods. <p><strong>OperationId:</strong>deleteFiscalPeriods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteFiscalPeriodsRequest
*/
func (a *CashieringConfigAPIService) DeleteFiscalPeriods(ctx context.Context) CashieringConfigAPIDeleteFiscalPeriodsRequest {
	return CashieringConfigAPIDeleteFiscalPeriodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteFiscalPeriodsExecute(r CashieringConfigAPIDeleteFiscalPeriodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteFiscalPeriods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalPeriods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.yearId != nil {
		t := *r.yearId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "yearId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "yearId", t, "multi")
		}
  }
	if r.startDate != nil {
		t := *r.startDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteFiscalYearsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	yearId *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Resort for which the Year is defined.
func (r CashieringConfigAPIDeleteFiscalYearsRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteFiscalYearsRequest) Authorization(authorization string) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteFiscalYearsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteFiscalYearsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Unique id of the Year.
func (r CashieringConfigAPIDeleteFiscalYearsRequest) YearId(yearId []float32) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.yearId = &yearId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteFiscalYearsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteFiscalYearsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteFiscalYearsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteFiscalYearsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFiscalYearsExecute(r)
}

/*
DeleteFiscalYears Operation to delete FiscalYears.

Operation to remove Fiscal Years. <p><strong>OperationId:</strong>deleteFiscalYears</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteFiscalYearsRequest
*/
func (a *CashieringConfigAPIService) DeleteFiscalYears(ctx context.Context) CashieringConfigAPIDeleteFiscalYearsRequest {
	return CashieringConfigAPIDeleteFiscalYearsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteFiscalYearsExecute(r CashieringConfigAPIDeleteFiscalYearsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteFiscalYears")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalYears"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.yearId != nil {
		t := *r.yearId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "yearId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "yearId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteFolioArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) Code(code []string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteFolioArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFolioArrangementCodesExecute(r)
}

/*
DeleteFolioArrangementCodes Operation to delete FolioArrangementCodes.

 <p><strong>OperationId:</strong>deleteFolioArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteFolioArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteFolioArrangementCodes(ctx context.Context) CashieringConfigAPIDeleteFolioArrangementCodesRequest {
	return CashieringConfigAPIDeleteFolioArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteFolioArrangementCodesExecute(r CashieringConfigAPIDeleteFolioArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteFolioArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteFolioPrintQueuesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	queueName *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with folio print queue
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) Authorization(authorization string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio print queue name
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) QueueName(queueName []string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.queueName = &queueName
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteFolioPrintQueuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFolioPrintQueuesExecute(r)
}

/*
DeleteFolioPrintQueues Operation to delete FolioPrintQueues.

Operation to remove folio print queues. <p><strong>OperationId:</strong>deleteFolioPrintQueues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteFolioPrintQueuesRequest
*/
func (a *CashieringConfigAPIService) DeleteFolioPrintQueues(ctx context.Context) CashieringConfigAPIDeleteFolioPrintQueuesRequest {
	return CashieringConfigAPIDeleteFolioPrintQueuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteFolioPrintQueuesExecute(r CashieringConfigAPIDeleteFolioPrintQueuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteFolioPrintQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioPrintQueues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.queueName != nil {
		t := *r.queueName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteFolioTypesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) Authorization(authorization string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) Code(code []string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteFolioTypesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFolioTypesConfigExecute(r)
}

/*
DeleteFolioTypesConfig Operation to delete FolioTypesConfig.

Operation to remove Folio Type Names. <p><strong>OperationId:</strong>deleteFolioTypesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteFolioTypesConfigRequest
*/
func (a *CashieringConfigAPIService) DeleteFolioTypesConfig(ctx context.Context) CashieringConfigAPIDeleteFolioTypesConfigRequest {
	return CashieringConfigAPIDeleteFolioTypesConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteFolioTypesConfigExecute(r CashieringConfigAPIDeleteFolioTypesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteFolioTypesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypesConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteForeignCurrenciesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) Authorization(authorization string) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) CurrencyCodes(currencyCodes []string) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	r.currencyCodes = &currencyCodes
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteForeignCurrenciesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteForeignCurrenciesExecute(r)
}

/*
DeleteForeignCurrencies Operation to delete ForeignCurrencies.

Operation to remove Foreign Currencies. <p><strong>OperationId:</strong>deleteForeignCurrencies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteForeignCurrenciesRequest
*/
func (a *CashieringConfigAPIService) DeleteForeignCurrencies(ctx context.Context) CashieringConfigAPIDeleteForeignCurrenciesRequest {
	return CashieringConfigAPIDeleteForeignCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteForeignCurrenciesExecute(r CashieringConfigAPIDeleteForeignCurrenciesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteForeignCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.currencyCodes != nil {
		t := *r.currencyCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteGlobalExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	exchangeRates *ExchangeRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) Authorization(authorization string) CashieringConfigAPIDeleteGlobalExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteGlobalExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Global Exchange Rates to be Set.
func (r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) ExchangeRates(exchangeRates ExchangeRates) CashieringConfigAPIDeleteGlobalExchangeRatesRequest {
	r.exchangeRates = &exchangeRates
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteGlobalExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteGlobalExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGlobalExchangeRatesExecute(r)
}

/*
DeleteGlobalExchangeRates Operation to delete GlobalExchangeRates.

Operation to Delete Global Exchange Rates. <p><strong>OperationId:</strong>deleteGlobalExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteGlobalExchangeRatesRequest
*/
func (a *CashieringConfigAPIService) DeleteGlobalExchangeRates(ctx context.Context) CashieringConfigAPIDeleteGlobalExchangeRatesRequest {
	return CashieringConfigAPIDeleteGlobalExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteGlobalExchangeRatesExecute(r CashieringConfigAPIDeleteGlobalExchangeRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteGlobalExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/globalExchangeRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exchangeRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteGroupArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	hotelId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) Code(code []string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.code = &code
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteGroupArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGroupArrangementCodesExecute(r)
}

/*
DeleteGroupArrangementCodes Operation to delete GroupArrangementCodes.

 <p><strong>OperationId:</strong>deleteGroupArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteGroupArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteGroupArrangementCodes(ctx context.Context) CashieringConfigAPIDeleteGroupArrangementCodesRequest {
	return CashieringConfigAPIDeleteGroupArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteGroupArrangementCodesExecute(r CashieringConfigAPIDeleteGroupArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteGroupArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groupArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteNoShowPostingRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationType *[]string
	sourceCode *[]string
	postingRule *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Indicates for which hotel this posting rule apply to.
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) Authorization(authorization string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Type of the reservation.
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) ReservationType(reservationType []string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.reservationType = &reservationType
	return r
}

// Source code of the reservation.
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) SourceCode(sourceCode []string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.sourceCode = &sourceCode
	return r
}

// Simple Type for Posting Rule Types.
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) PostingRule(postingRule []string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.postingRule = &postingRule
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteNoShowPostingRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteNoShowPostingRulesExecute(r)
}

/*
DeleteNoShowPostingRules Operation to delete NoShowPostingRules.

Operation to remove No Show Posting Rules. <p><strong>OperationId:</strong>deleteNoShowPostingRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteNoShowPostingRulesRequest
*/
func (a *CashieringConfigAPIService) DeleteNoShowPostingRules(ctx context.Context) CashieringConfigAPIDeleteNoShowPostingRulesRequest {
	return CashieringConfigAPIDeleteNoShowPostingRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteNoShowPostingRulesExecute(r CashieringConfigAPIDeleteNoShowPostingRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteNoShowPostingRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noShowPostingRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.reservationType != nil {
		t := *r.reservationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", t, "multi")
		}
  }
	if r.sourceCode != nil {
		t := *r.sourceCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", t, "multi")
		}
  }
	if r.postingRule != nil {
		t := *r.postingRule
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRule", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRule", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeletePackageArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) HotelId(hotelId []string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) Code(code []string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeletePackageArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePackageArrangementCodesExecute(r)
}

/*
DeletePackageArrangementCodes Operation to delete PackageArrangementCodes.

 <p><strong>OperationId:</strong>deletePackageArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeletePackageArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) DeletePackageArrangementCodes(ctx context.Context) CashieringConfigAPIDeletePackageArrangementCodesRequest {
	return CashieringConfigAPIDeletePackageArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeletePackageArrangementCodesExecute(r CashieringConfigAPIDeletePackageArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeletePackageArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteRevenueBucketCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	revenueBucketType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) Code(code []string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.code = &code
	return r
}

// Revenue Export Bucket Type
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) RevenueBucketType(revenueBucketType []string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.revenueBucketType = &revenueBucketType
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteRevenueBucketCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRevenueBucketCodesExecute(r)
}

/*
DeleteRevenueBucketCodes Operation to delete RevenueBucketCodes.

Operation to remove Revenue Bucket Codes. <p><strong>OperationId:</strong>deleteRevenueBucketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteRevenueBucketCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteRevenueBucketCodes(ctx context.Context) CashieringConfigAPIDeleteRevenueBucketCodesRequest {
	return CashieringConfigAPIDeleteRevenueBucketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteRevenueBucketCodesExecute(r CashieringConfigAPIDeleteRevenueBucketCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteRevenueBucketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.revenueBucketType != nil {
		t := *r.revenueBucketType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteRevenueBucketTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) Authorization(authorization string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) Code(code []string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteRevenueBucketTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRevenueBucketTypesExecute(r)
}

/*
DeleteRevenueBucketTypes Operation to delete RevenueBucketTypes.

Operation to remove Revenue Bucket Types. <p><strong>OperationId:</strong>deleteRevenueBucketTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteRevenueBucketTypesRequest
*/
func (a *CashieringConfigAPIService) DeleteRevenueBucketTypes(ctx context.Context) CashieringConfigAPIDeleteRevenueBucketTypesRequest {
	return CashieringConfigAPIDeleteRevenueBucketTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteRevenueBucketTypesExecute(r CashieringConfigAPIDeleteRevenueBucketTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteRevenueBucketTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteRevenueTypeMappingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueTypeMappingID *string
	idExtension *int32
	idContext *string
	type_ *string
	revenueType *string
	eventType *string
	space *string
	transactionCode *string
	cateringOnly *string
	serviceCharge *float32
	serviceChargeTrxCode *string
	serviceChargeCalulationMethod *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel Code to which the Revenue Type Mapping belongs to.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) HotelId(hotelId string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) Authorization(authorization string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) RevenueTypeMappingID(revenueTypeMappingID string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.revenueTypeMappingID = &revenueTypeMappingID
	return r
}

// Additional identifying value assigned by the creating system.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) IdExtension(idExtension int32) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) IdContext(idContext string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) Type_(type_ string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.type_ = &type_
	return r
}

// Provides information about the Revenue Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) RevenueType(revenueType string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.revenueType = &revenueType
	return r
}

// Provides information about the Event Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) EventType(eventType string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.eventType = &eventType
	return r
}

// Provides information about the Space/Location for the Revenue Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) Space(space string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.space = &space
	return r
}

// Transaction code for the Revenue Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) TransactionCode(transactionCode string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.transactionCode = &transactionCode
	return r
}

// For Catering and Event.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) CateringOnly(cateringOnly string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.cateringOnly = &cateringOnly
	return r
}

// Service Charge for the Revenue Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) ServiceCharge(serviceCharge float32) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.serviceCharge = &serviceCharge
	return r
}

// Service Charge for the Revenue Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) ServiceChargeTrxCode(serviceChargeTrxCode string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.serviceChargeTrxCode = &serviceChargeTrxCode
	return r
}

// Service Charge for the Revenue Type.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) ServiceChargeCalulationMethod(serviceChargeCalulationMethod string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.serviceChargeCalulationMethod = &serviceChargeCalulationMethod
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteRevenueTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRevenueTypeMappingExecute(r)
}

/*
DeleteRevenueTypeMapping Operation to delete RevenueTypeMapping.

 <p><strong>OperationId:</strong>deleteRevenueTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteRevenueTypeMappingRequest
*/
func (a *CashieringConfigAPIService) DeleteRevenueTypeMapping(ctx context.Context) CashieringConfigAPIDeleteRevenueTypeMappingRequest {
	return CashieringConfigAPIDeleteRevenueTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteRevenueTypeMappingExecute(r CashieringConfigAPIDeleteRevenueTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteRevenueTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypeMapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.revenueTypeMappingID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeMappingID", r.revenueTypeMappingID, "")
  }
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.revenueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueType", r.revenueType, "")
  }
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "")
  }
	if r.space != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space", r.space, "")
  }
	if r.transactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", r.transactionCode, "")
  }
	if r.cateringOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringOnly", r.cateringOnly, "")
  }
	if r.serviceCharge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceCharge", r.serviceCharge, "")
  }
	if r.serviceChargeTrxCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceChargeTrxCode", r.serviceChargeTrxCode, "")
  }
	if r.serviceChargeCalulationMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceChargeCalulationMethod", r.serviceChargeCalulationMethod, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) HotelId(hotelId string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) Authorization(authorization string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) Code(code string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoutingInstructionsExecute(r)
}

/*
DeleteRoutingInstructions Operation to delete RoutingInstructions.

Operation to remove routing instructions. <p><strong>OperationId:</strong>deleteRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteRoutingInstructionsRequest
*/
func (a *CashieringConfigAPIService) DeleteRoutingInstructions(ctx context.Context) CashieringConfigAPIDeleteRoutingInstructionsRequest {
	return CashieringConfigAPIDeleteRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteRoutingInstructionsExecute(r CashieringConfigAPIDeleteRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTaxBracketsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxPercentage *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel Code where tax bracket belongs to.
func (r CashieringConfigAPIDeleteTaxBracketsRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTaxBracketsRequest) Authorization(authorization string) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTaxBracketsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTaxBracketsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Tax Percentage for which this Tax Bracket applies.
func (r CashieringConfigAPIDeleteTaxBracketsRequest) TaxPercentage(taxPercentage []float32) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.taxPercentage = &taxPercentage
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTaxBracketsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTaxBracketsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTaxBracketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTaxBracketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTaxBracketsExecute(r)
}

/*
DeleteTaxBrackets Operation to delete TaxBrackets.

Operation to remove Tax Brackets. This function only be available when the parameter "Tax Bracket Calculation" is on. <p><strong>OperationId:</strong>deleteTaxBrackets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTaxBracketsRequest
*/
func (a *CashieringConfigAPIService) DeleteTaxBrackets(ctx context.Context) CashieringConfigAPIDeleteTaxBracketsRequest {
	return CashieringConfigAPIDeleteTaxBracketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTaxBracketsExecute(r CashieringConfigAPIDeleteTaxBracketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTaxBrackets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxBrackets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.taxPercentage != nil {
		t := *r.taxPercentage
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxPercentage", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxPercentage", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	taxTypeCode *[]string
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Configuration code.
func (r CashieringConfigAPIDeleteTaxTypesRequest) TaxTypeCode(taxTypeCode []string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.taxTypeCode = &taxTypeCode
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteTaxTypesRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTaxTypesRequest) Authorization(authorization string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTaxTypesExecute(r)
}

/*
DeleteTaxTypes Operation to delete TaxTypes.

Operation to remove Tax Types. <p><strong>OperationId:</strong>deleteTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTaxTypesRequest
*/
func (a *CashieringConfigAPIService) DeleteTaxTypes(ctx context.Context) CashieringConfigAPIDeleteTaxTypesRequest {
	return CashieringConfigAPIDeleteTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTaxTypesExecute(r CashieringConfigAPIDeleteTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.taxTypeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCode", t, "multi")
		}
	}
	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTemplateCustomNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	configurationId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) Authorization(authorization string) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) ConfigurationId(configurationId string) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	r.configurationId = &configurationId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTemplateCustomNumberRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateCustomNumberExecute(r)
}

/*
DeleteTemplateCustomNumber Operation to remove template custom number configuration.

You can use this API to remove template custom number configuration. <p><strong>OperationId:</strong>deleteTemplateCustomNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTemplateCustomNumberRequest
*/
func (a *CashieringConfigAPIService) DeleteTemplateCustomNumber(ctx context.Context) CashieringConfigAPIDeleteTemplateCustomNumberRequest {
	return CashieringConfigAPIDeleteTemplateCustomNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTemplateCustomNumberExecute(r CashieringConfigAPIDeleteTemplateCustomNumberRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTemplateCustomNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/customNumbers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configurationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", r.configurationId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateCustomNumberConfigExecute(r)
}

/*
DeleteTemplateCustomNumberConfig Operation to remove template custom number configuration.

You can use this API to remove template custom number configuration.<br><p><strong><mark>This API is deprecated. Please use deleteTemplateCustomNumber instead</mark></strong></p> <p><strong>OperationId:</strong>deleteTemplateCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) DeleteTemplateCustomNumberConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest {
	return CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringConfigAPIService) DeleteTemplateCustomNumberConfigExecute(r CashieringConfigAPIDeleteTemplateCustomNumberConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTemplateCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/template/customNumbers/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	transactionCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateTransactionCodesExecute(r)
}

/*
DeleteTemplateTransactionCodes Operation to delete TemplateTransactionCodes.

Operation to remove template transaction codes. <p><strong>OperationId:</strong>deleteTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTemplateTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteTemplateTransactionCodes(ctx context.Context) CashieringConfigAPIDeleteTemplateTransactionCodesRequest {
	return CashieringConfigAPIDeleteTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTemplateTransactionCodesExecute(r CashieringConfigAPIDeleteTemplateTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTemplateTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	templateTransactionCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) TemplateTransactionCodes(templateTransactionCodes []string) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	r.templateTransactionCodes = &templateTransactionCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateTransactionGroupsExecute(r)
}

/*
DeleteTemplateTransactionGroups Operation to delete TemplateTransactionGroups.

Operation to remove existing template transaction group. <p><strong>OperationId:</strong>deleteTemplateTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTemplateTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) DeleteTemplateTransactionGroups(ctx context.Context) CashieringConfigAPIDeleteTemplateTransactionGroupsRequest {
	return CashieringConfigAPIDeleteTemplateTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTemplateTransactionGroupsExecute(r CashieringConfigAPIDeleteTemplateTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTemplateTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.templateTransactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "templateTransactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "templateTransactionCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	subgroup *[]string
	group *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Template transaction subgroup configuration code
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) Subgroup(subgroup []string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.subgroup = &subgroup
	return r
}

// Template transaction group configuration code
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) Group(group []string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.group = &group
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateTransactionSubgroupsExecute(r)
}

/*
DeleteTemplateTransactionSubgroups Operation to delete TemplateTransactionSubgroups.

Operation to remove template transaction subgroups <p><strong>OperationId:</strong>deleteTemplateTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) DeleteTemplateTransactionSubgroups(ctx context.Context) CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest {
	return CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTemplateTransactionSubgroupsExecute(r CashieringConfigAPIDeleteTemplateTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTemplateTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.subgroup != nil {
		t := *r.subgroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subgroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subgroup", t, "multi")
		}
  }
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	transactionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIDeleteTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTransactionCodesExecute(r)
}

/*
DeleteTransactionCodes Operation to delete TransactionCodes.

Operation to remove transaction codes. <p><strong>OperationId:</strong>deleteTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionCode Transaction Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIDeleteTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) DeleteTransactionCodes(ctx context.Context, transactionCode string, hotelId string) CashieringConfigAPIDeleteTransactionCodesRequest {
	return CashieringConfigAPIDeleteTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		transactionCode: transactionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTransactionCodesExecute(r CashieringConfigAPIDeleteTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes/{transactionCode}/transactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionCode"+"}", url.PathEscape(parameterValueToString(r.transactionCode, "transactionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionCode must have at least 1 elements")
	}
	if strlen(r.transactionCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTransactionDiscountsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	transactionDiscountCode string
}

func (r CashieringConfigAPIDeleteTransactionDiscountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTransactionDiscountsExecute(r)
}

/*
DeleteTransactionDiscounts Operation to delete TransactionDiscounts.

Operation to remove Transaction Discounts. <p><strong>OperationId:</strong>deleteTransactionDiscounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @param transactionDiscountCode Unique code for transaction discount
 @return CashieringConfigAPIDeleteTransactionDiscountsRequest
*/
func (a *CashieringConfigAPIService) DeleteTransactionDiscounts(ctx context.Context, hotelId string, transactionDiscountCode string) CashieringConfigAPIDeleteTransactionDiscountsRequest {
	return CashieringConfigAPIDeleteTransactionDiscountsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		transactionDiscountCode: transactionDiscountCode,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTransactionDiscountsExecute(r CashieringConfigAPIDeleteTransactionDiscountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTransactionDiscounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionDiscounts/{transactionDiscountCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionDiscountCode"+"}", url.PathEscape(parameterValueToString(r.transactionDiscountCode, "transactionDiscountCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.transactionDiscountCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionDiscountCode must have at least 1 elements")
	}
	if strlen(r.transactionDiscountCode) > 20 {
		return localVarReturnValue, nil, reportError("transactionDiscountCode must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	hotelId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) Code(code []string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.code = &code
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTransactionGroupsExecute(r)
}

/*
DeleteTransactionGroups Operation to delete TransactionGroups.

Operation to remove transaction groups. <p><strong>OperationId:</strong>deleteTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) DeleteTransactionGroups(ctx context.Context) CashieringConfigAPIDeleteTransactionGroupsRequest {
	return CashieringConfigAPIDeleteTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTransactionGroupsExecute(r CashieringConfigAPIDeleteTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIDeleteTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	subgroup *[]string
	group *[]string
	hotelId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Template transaction subgroup configuration code
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) Subgroup(subgroup []string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.subgroup = &subgroup
	return r
}

// Template transaction group configuration code
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) Group(group []string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.group = &group
	return r
}

// Hotel code where the transaction subgroup is configured.
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) HotelId(hotelId []string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIDeleteTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTransactionSubgroupsExecute(r)
}

/*
DeleteTransactionSubgroups Operation to delete TransactionSubgroups.

Operation to remove transaction sub groups. <p><strong>OperationId:</strong>deleteTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIDeleteTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) DeleteTransactionSubgroups(ctx context.Context) CashieringConfigAPIDeleteTransactionSubgroupsRequest {
	return CashieringConfigAPIDeleteTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) DeleteTransactionSubgroupsExecute(r CashieringConfigAPIDeleteTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.DeleteTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.subgroup != nil {
		t := *r.subgroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "subgroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "subgroup", t, "multi")
		}
  }
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "multi")
		}
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetAdjustmentCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes []string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetAdjustmentCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetAdjustmentCodesRequest) Execute() (*AdjustmentCodes, *http.Response, error) {
	return r.ApiService.GetAdjustmentCodesExecute(r)
}

/*
GetAdjustmentCodes Operation to fetch AdjustmentCodes.

Operation to fetch Adjustment Codes. <p><strong>OperationId:</strong>getAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetAdjustmentCodesRequest
*/
func (a *CashieringConfigAPIService) GetAdjustmentCodes(ctx context.Context) CashieringConfigAPIGetAdjustmentCodesRequest {
	return CashieringConfigAPIGetAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdjustmentCodes
func (a *CashieringConfigAPIService) GetAdjustmentCodesExecute(r CashieringConfigAPIGetAdjustmentCodesRequest) (*AdjustmentCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustmentCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.adjustmentCodes != nil {
		t := *r.adjustmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodes *[]string
	articleCodes *[]string
	universalProductCode *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetArticlesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetArticlesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetArticlesRequest) Authorization(authorization string) CashieringConfigAPIGetArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetArticlesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetArticlesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetArticlesRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetArticlesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigAPIGetArticlesRequest) ArticleCodes(articleCodes []string) CashieringConfigAPIGetArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigAPIGetArticlesRequest) UniversalProductCode(universalProductCode string) CashieringConfigAPIGetArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// Indicator that tells whether to include inactive articles in search results.
func (r CashieringConfigAPIGetArticlesRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetArticlesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigAPIGetArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetArticlesRequest) Execute() (*ArticlesInfo, *http.Response, error) {
	return r.ApiService.GetArticlesExecute(r)
}

/*
GetArticles Get articles

Use this API to return articles for one or multiple properties based on search criteria such as hotelIds, transactionCodes, articleCodes, etc. One transaction code can sometimes serve as an umbrella for multiple articles, which can be posted using that transaction code.  For example, a single mini bar food transaction code might cover potato chips, crackers, peanuts, pretzels, and so on.<p><strong>OperationId:</strong>getArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetArticlesRequest
*/
func (a *CashieringConfigAPIService) GetArticles(ctx context.Context) CashieringConfigAPIGetArticlesRequest {
	return CashieringConfigAPIGetArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArticlesInfo
func (a *CashieringConfigAPIService) GetArticlesExecute(r CashieringConfigAPIGetArticlesRequest) (*ArticlesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArticlesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	if r.articleCodes != nil {
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
  }
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetAuthorizationConfigRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) Authorization(authorization string) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) HotelId(hotelId string) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetAuthorizationConfigRulesRequest) Execute() (*AuthorizationConfigRulesInfo, *http.Response, error) {
	return r.ApiService.GetAuthorizationConfigRulesExecute(r)
}

/*
GetAuthorizationConfigRules Operation to fetch AuthorizationConfigRules.

 <p><strong>OperationId:</strong>getAuthorizationConfigRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetAuthorizationConfigRulesRequest
*/
func (a *CashieringConfigAPIService) GetAuthorizationConfigRules(ctx context.Context) CashieringConfigAPIGetAuthorizationConfigRulesRequest {
	return CashieringConfigAPIGetAuthorizationConfigRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizationConfigRulesInfo
func (a *CashieringConfigAPIService) GetAuthorizationConfigRulesExecute(r CashieringConfigAPIGetAuthorizationConfigRulesRequest) (*AuthorizationConfigRulesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationConfigRulesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetAuthorizationConfigRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetAuthorizerGroupsRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) AuthorizerGroupsCodes(authorizerGroupsCodes []string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.authorizerGroupsCodes = &authorizerGroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) WildCard(wildCard string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetAuthorizerGroupsRequest) Execute() (*AuthorizerGroups, *http.Response, error) {
	return r.ApiService.GetAuthorizerGroupsExecute(r)
}

/*
GetAuthorizerGroups Operation to fetch AuthorizerGroups.

Operation to fetch Authorizer Groups. <p><strong>OperationId:</strong>getAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetAuthorizerGroupsRequest
*/
func (a *CashieringConfigAPIService) GetAuthorizerGroups(ctx context.Context) CashieringConfigAPIGetAuthorizerGroupsRequest {
	return CashieringConfigAPIGetAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizerGroups
func (a *CashieringConfigAPIService) GetAuthorizerGroupsExecute(r CashieringConfigAPIGetAuthorizerGroupsRequest) (*AuthorizerGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizerGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.authorizerGroupsCodes != nil {
		t := *r.authorizerGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetAvailableCashierNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetAvailableCashierNumberRequest) Authorization(authorization string) CashieringConfigAPIGetAvailableCashierNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetAvailableCashierNumberRequest) XAppKey(xAppKey string) CashieringConfigAPIGetAvailableCashierNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetAvailableCashierNumberRequest) XHotelid(xHotelid string) CashieringConfigAPIGetAvailableCashierNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIGetAvailableCashierNumberRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetAvailableCashierNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetAvailableCashierNumberRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetAvailableCashierNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetAvailableCashierNumberRequest) Execute() (*CashierNumber, *http.Response, error) {
	return r.ApiService.GetAvailableCashierNumberExecute(r)
}

/*
GetAvailableCashierNumber Operation to fetch AvailableCashierNumber.

The operation returns a next available Cashier Number to be used while creating a new Cashier. <p><strong>OperationId:</strong>getAvailableCashierNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetAvailableCashierNumberRequest
*/
func (a *CashieringConfigAPIService) GetAvailableCashierNumber(ctx context.Context) CashieringConfigAPIGetAvailableCashierNumberRequest {
	return CashieringConfigAPIGetAvailableCashierNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashierNumber
func (a *CashieringConfigAPIService) GetAvailableCashierNumberExecute(r CashieringConfigAPIGetAvailableCashierNumberRequest) (*CashierNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetAvailableCashierNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/nextAvailable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetBudgetForecastRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	year *string
	marketSegmentNights *bool
	marketSegmentRevenue *bool
	marketSegmentABVariance *bool
	marketSegmentAFVariance *bool
	marketSegmentActual *bool
	marketSegmentBudget *bool
	marketSegmentFBVariance *bool
	marketSegmentForecast *bool
	marketSegmentMarketCodes *[]string
	rateSegmentNights *bool
	rateSegmentRevenue *bool
	rateSegmentABVariance *bool
	rateSegmentAFVariance *bool
	rateSegmentActual *bool
	rateSegmentBudget *bool
	rateSegmentFBVariance *bool
	rateSegmentForecast *bool
	rateSegmentRateCodes *[]string
	customSegmentCustomValue *bool
	customSegmentABVariance *bool
	customSegmentAFVariance *bool
	customSegmentActual *bool
	customSegmentBudget *bool
	customSegmentFBVariance *bool
	customSegmentForecast *bool
	customSegmentCustomCodes *[]string
	transactionSegmentRevenue *bool
	transactionSegmentABVariance *bool
	transactionSegmentAFVariance *bool
	transactionSegmentActual *bool
	transactionSegmentBudget *bool
	transactionSegmentFBVariance *bool
	transactionSegmentForecast *bool
	transactionSegmentTransactionCodes *[]string
	transactionSegmentTransactionCodeGrp *string
	cateringSegmentCovers *bool
	cateringSegmentRevenue *bool
	cateringSegmentABVariance *bool
	cateringSegmentAFVariance *bool
	cateringSegmentActual *bool
	cateringSegmentBudget *bool
	cateringSegmentFBVariance *bool
	cateringSegmentForecast *bool
	cateringSegmentCateringCodeGrp *string
	cateringSegmentCateringCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetBudgetForecastRequest) Authorization(authorization string) CashieringConfigAPIGetBudgetForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetBudgetForecastRequest) XAppKey(xAppKey string) CashieringConfigAPIGetBudgetForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetBudgetForecastRequest) XHotelid(xHotelid string) CashieringConfigAPIGetBudgetForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

// Opera Hotel code for the Fetch Revenue information.
func (r CashieringConfigAPIGetBudgetForecastRequest) HotelId(hotelId string) CashieringConfigAPIGetBudgetForecastRequest {
	r.hotelId = &hotelId
	return r
}

// Year of revenue to be fetched.
func (r CashieringConfigAPIGetBudgetForecastRequest) Year(year string) CashieringConfigAPIGetBudgetForecastRequest {
	r.year = &year
	return r
}

// Flag to indicate if nights information has to be included.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentNights(marketSegmentNights bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentNights = &marketSegmentNights
	return r
}

// Flag to indicate if revenue information has to be included.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentRevenue(marketSegmentRevenue bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentRevenue = &marketSegmentRevenue
	return r
}

// Flag to include ABVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentABVariance(marketSegmentABVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentABVariance = &marketSegmentABVariance
	return r
}

// Flag to include AFVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentAFVariance(marketSegmentAFVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentAFVariance = &marketSegmentAFVariance
	return r
}

// Flag to include Actual revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentActual(marketSegmentActual bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentActual = &marketSegmentActual
	return r
}

// Flag to include Budget revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentBudget(marketSegmentBudget bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentBudget = &marketSegmentBudget
	return r
}

// Flag to include FBVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentFBVariance(marketSegmentFBVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentFBVariance = &marketSegmentFBVariance
	return r
}

// Flag to include Forecast revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentForecast(marketSegmentForecast bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentForecast = &marketSegmentForecast
	return r
}

func (r CashieringConfigAPIGetBudgetForecastRequest) MarketSegmentMarketCodes(marketSegmentMarketCodes []string) CashieringConfigAPIGetBudgetForecastRequest {
	r.marketSegmentMarketCodes = &marketSegmentMarketCodes
	return r
}

// Flag to indicate if nights information has to be included.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentNights(rateSegmentNights bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentNights = &rateSegmentNights
	return r
}

// Flag to indicate if revenue information has to be included.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentRevenue(rateSegmentRevenue bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentRevenue = &rateSegmentRevenue
	return r
}

// Flag to include ABVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentABVariance(rateSegmentABVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentABVariance = &rateSegmentABVariance
	return r
}

// Flag to include AFVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentAFVariance(rateSegmentAFVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentAFVariance = &rateSegmentAFVariance
	return r
}

// Flag to include Actual revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentActual(rateSegmentActual bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentActual = &rateSegmentActual
	return r
}

// Flag to include Budget revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentBudget(rateSegmentBudget bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentBudget = &rateSegmentBudget
	return r
}

// Flag to include FBVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentFBVariance(rateSegmentFBVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentFBVariance = &rateSegmentFBVariance
	return r
}

// Flag to include Forecast revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentForecast(rateSegmentForecast bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentForecast = &rateSegmentForecast
	return r
}

func (r CashieringConfigAPIGetBudgetForecastRequest) RateSegmentRateCodes(rateSegmentRateCodes []string) CashieringConfigAPIGetBudgetForecastRequest {
	r.rateSegmentRateCodes = &rateSegmentRateCodes
	return r
}

// Flag to indicate if Value information has to be fetched.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentCustomValue(customSegmentCustomValue bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentCustomValue = &customSegmentCustomValue
	return r
}

// Flag to include ABVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentABVariance(customSegmentABVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentABVariance = &customSegmentABVariance
	return r
}

// Flag to include AFVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentAFVariance(customSegmentAFVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentAFVariance = &customSegmentAFVariance
	return r
}

// Flag to include Actual revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentActual(customSegmentActual bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentActual = &customSegmentActual
	return r
}

// Flag to include Budget revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentBudget(customSegmentBudget bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentBudget = &customSegmentBudget
	return r
}

// Flag to include FBVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentFBVariance(customSegmentFBVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentFBVariance = &customSegmentFBVariance
	return r
}

// Flag to include Forecast revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentForecast(customSegmentForecast bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentForecast = &customSegmentForecast
	return r
}

func (r CashieringConfigAPIGetBudgetForecastRequest) CustomSegmentCustomCodes(customSegmentCustomCodes []string) CashieringConfigAPIGetBudgetForecastRequest {
	r.customSegmentCustomCodes = &customSegmentCustomCodes
	return r
}

// Flag to indicate if revenue information has to be fetched.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentRevenue(transactionSegmentRevenue bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentRevenue = &transactionSegmentRevenue
	return r
}

// Flag to include ABVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentABVariance(transactionSegmentABVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentABVariance = &transactionSegmentABVariance
	return r
}

// Flag to include AFVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentAFVariance(transactionSegmentAFVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentAFVariance = &transactionSegmentAFVariance
	return r
}

// Flag to include Actual revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentActual(transactionSegmentActual bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentActual = &transactionSegmentActual
	return r
}

// Flag to include Budget revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentBudget(transactionSegmentBudget bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentBudget = &transactionSegmentBudget
	return r
}

// Flag to include FBVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentFBVariance(transactionSegmentFBVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentFBVariance = &transactionSegmentFBVariance
	return r
}

// Flag to include Forecast revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentForecast(transactionSegmentForecast bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentForecast = &transactionSegmentForecast
	return r
}

func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentTransactionCodes(transactionSegmentTransactionCodes []string) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentTransactionCodes = &transactionSegmentTransactionCodes
	return r
}

// Transaction code group of segment code.
func (r CashieringConfigAPIGetBudgetForecastRequest) TransactionSegmentTransactionCodeGrp(transactionSegmentTransactionCodeGrp string) CashieringConfigAPIGetBudgetForecastRequest {
	r.transactionSegmentTransactionCodeGrp = &transactionSegmentTransactionCodeGrp
	return r
}

// Flag to indicate if Covers information has to be included.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentCovers(cateringSegmentCovers bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentCovers = &cateringSegmentCovers
	return r
}

// Flag to indicate if revenue information has to be included.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentRevenue(cateringSegmentRevenue bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentRevenue = &cateringSegmentRevenue
	return r
}

// Flag to include ABVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentABVariance(cateringSegmentABVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentABVariance = &cateringSegmentABVariance
	return r
}

// Flag to include AFVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentAFVariance(cateringSegmentAFVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentAFVariance = &cateringSegmentAFVariance
	return r
}

// Flag to include Actual revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentActual(cateringSegmentActual bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentActual = &cateringSegmentActual
	return r
}

// Flag to include Budget revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentBudget(cateringSegmentBudget bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentBudget = &cateringSegmentBudget
	return r
}

// Flag to include FBVariance revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentFBVariance(cateringSegmentFBVariance bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentFBVariance = &cateringSegmentFBVariance
	return r
}

// Flag to include Forecast revenue/nights information.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentForecast(cateringSegmentForecast bool) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentForecast = &cateringSegmentForecast
	return r
}

// Catering code group of segment code.
func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentCateringCodeGrp(cateringSegmentCateringCodeGrp string) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentCateringCodeGrp = &cateringSegmentCateringCodeGrp
	return r
}

func (r CashieringConfigAPIGetBudgetForecastRequest) CateringSegmentCateringCodes(cateringSegmentCateringCodes []string) CashieringConfigAPIGetBudgetForecastRequest {
	r.cateringSegmentCateringCodes = &cateringSegmentCateringCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetBudgetForecastRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetBudgetForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetBudgetForecastRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetBudgetForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetBudgetForecastRequest) Execute() (*BudgetForecastInformation, *http.Response, error) {
	return r.ApiService.GetBudgetForecastExecute(r)
}

/*
GetBudgetForecast Operation to fetch BudgetForecast.

Operation to fetch Budget Forecast information. <p><strong>OperationId:</strong>getBudgetForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetBudgetForecastRequest
*/
func (a *CashieringConfigAPIService) GetBudgetForecast(ctx context.Context) CashieringConfigAPIGetBudgetForecastRequest {
	return CashieringConfigAPIGetBudgetForecastRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BudgetForecastInformation
func (a *CashieringConfigAPIService) GetBudgetForecastExecute(r CashieringConfigAPIGetBudgetForecastRequest) (*BudgetForecastInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BudgetForecastInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetBudgetForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/budgetForecast"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "year", r.year, "")
  }
	if r.marketSegmentNights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentNights", r.marketSegmentNights, "")
  }
	if r.marketSegmentRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentRevenue", r.marketSegmentRevenue, "")
  }
	if r.marketSegmentABVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentABVariance", r.marketSegmentABVariance, "")
  }
	if r.marketSegmentAFVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentAFVariance", r.marketSegmentAFVariance, "")
  }
	if r.marketSegmentActual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentActual", r.marketSegmentActual, "")
  }
	if r.marketSegmentBudget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentBudget", r.marketSegmentBudget, "")
  }
	if r.marketSegmentFBVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentFBVariance", r.marketSegmentFBVariance, "")
  }
	if r.marketSegmentForecast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentForecast", r.marketSegmentForecast, "")
  }
	if r.marketSegmentMarketCodes != nil {
		t := *r.marketSegmentMarketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentMarketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketSegmentMarketCodes", t, "multi")
		}
  }
	if r.rateSegmentNights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentNights", r.rateSegmentNights, "")
  }
	if r.rateSegmentRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentRevenue", r.rateSegmentRevenue, "")
  }
	if r.rateSegmentABVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentABVariance", r.rateSegmentABVariance, "")
  }
	if r.rateSegmentAFVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentAFVariance", r.rateSegmentAFVariance, "")
  }
	if r.rateSegmentActual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentActual", r.rateSegmentActual, "")
  }
	if r.rateSegmentBudget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentBudget", r.rateSegmentBudget, "")
  }
	if r.rateSegmentFBVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentFBVariance", r.rateSegmentFBVariance, "")
  }
	if r.rateSegmentForecast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentForecast", r.rateSegmentForecast, "")
  }
	if r.rateSegmentRateCodes != nil {
		t := *r.rateSegmentRateCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentRateCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateSegmentRateCodes", t, "multi")
		}
  }
	if r.customSegmentCustomValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentCustomValue", r.customSegmentCustomValue, "")
  }
	if r.customSegmentABVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentABVariance", r.customSegmentABVariance, "")
  }
	if r.customSegmentAFVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentAFVariance", r.customSegmentAFVariance, "")
  }
	if r.customSegmentActual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentActual", r.customSegmentActual, "")
  }
	if r.customSegmentBudget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentBudget", r.customSegmentBudget, "")
  }
	if r.customSegmentFBVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentFBVariance", r.customSegmentFBVariance, "")
  }
	if r.customSegmentForecast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentForecast", r.customSegmentForecast, "")
  }
	if r.customSegmentCustomCodes != nil {
		t := *r.customSegmentCustomCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentCustomCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customSegmentCustomCodes", t, "multi")
		}
  }
	if r.transactionSegmentRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentRevenue", r.transactionSegmentRevenue, "")
  }
	if r.transactionSegmentABVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentABVariance", r.transactionSegmentABVariance, "")
  }
	if r.transactionSegmentAFVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentAFVariance", r.transactionSegmentAFVariance, "")
  }
	if r.transactionSegmentActual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentActual", r.transactionSegmentActual, "")
  }
	if r.transactionSegmentBudget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentBudget", r.transactionSegmentBudget, "")
  }
	if r.transactionSegmentFBVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentFBVariance", r.transactionSegmentFBVariance, "")
  }
	if r.transactionSegmentForecast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentForecast", r.transactionSegmentForecast, "")
  }
	if r.transactionSegmentTransactionCodes != nil {
		t := *r.transactionSegmentTransactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentTransactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentTransactionCodes", t, "multi")
		}
  }
	if r.transactionSegmentTransactionCodeGrp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSegmentTransactionCodeGrp", r.transactionSegmentTransactionCodeGrp, "")
  }
	if r.cateringSegmentCovers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentCovers", r.cateringSegmentCovers, "")
  }
	if r.cateringSegmentRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentRevenue", r.cateringSegmentRevenue, "")
  }
	if r.cateringSegmentABVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentABVariance", r.cateringSegmentABVariance, "")
  }
	if r.cateringSegmentAFVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentAFVariance", r.cateringSegmentAFVariance, "")
  }
	if r.cateringSegmentActual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentActual", r.cateringSegmentActual, "")
  }
	if r.cateringSegmentBudget != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentBudget", r.cateringSegmentBudget, "")
  }
	if r.cateringSegmentFBVariance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentFBVariance", r.cateringSegmentFBVariance, "")
  }
	if r.cateringSegmentForecast != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentForecast", r.cateringSegmentForecast, "")
  }
	if r.cateringSegmentCateringCodeGrp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentCateringCodeGrp", r.cateringSegmentCateringCodeGrp, "")
  }
	if r.cateringSegmentCateringCodes != nil {
		t := *r.cateringSegmentCateringCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentCateringCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cateringSegmentCateringCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	cashierIDs *[]float32
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	includeInactive *bool
	appUser *string
	xExternalsystem *string
	acceptLanguage *string
}

// Numberic code for cashier ID.
func (r CashieringConfigAPIGetCashiersRequest) CashierIDs(cashierIDs []float32) CashieringConfigAPIGetCashiersRequest {
	r.cashierIDs = &cashierIDs
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCashiersRequest) Authorization(authorization string) CashieringConfigAPIGetCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCashiersRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCashiersRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringConfigAPIGetCashiersRequest) Limit(limit int32) CashieringConfigAPIGetCashiersRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringConfigAPIGetCashiersRequest) Offset(offset int32) CashieringConfigAPIGetCashiersRequest {
	r.offset = &offset
	return r
}

// Partial name of a cashier.
func (r CashieringConfigAPIGetCashiersRequest) Name(name string) CashieringConfigAPIGetCashiersRequest {
	r.name = &name
	return r
}

// Indicator that tells whether to include inactive cashiers in search results.
func (r CashieringConfigAPIGetCashiersRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetCashiersRequest {
	r.includeInactive = &includeInactive
	return r
}

// Name of the application user associated with the cashier id
func (r CashieringConfigAPIGetCashiersRequest) AppUser(appUser string) CashieringConfigAPIGetCashiersRequest {
	r.appUser = &appUser
	return r
}

// External system code.
func (r CashieringConfigAPIGetCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCashiersRequest) Execute() (*CashiersDetails, *http.Response, error) {
	return r.ApiService.GetCashiersExecute(r)
}

/*
GetCashiers Get cashiers

Use this API to return Cashier information based on search criteria such as cashierIDs, limit, name. <p><strong>OperationId:</strong>getCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetCashiersRequest
*/
func (a *CashieringConfigAPIService) GetCashiers(ctx context.Context) CashieringConfigAPIGetCashiersRequest {
	return CashieringConfigAPIGetCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashiersDetails
func (a *CashieringConfigAPIService) GetCashiersExecute(r CashieringConfigAPIGetCashiersRequest) (*CashiersDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashiersDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierDetails/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.cashierIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.appUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appUser", r.appUser, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCollectingAgentTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	taxCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) Authorization(authorization string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// It represents Hotel Code
func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) HotelId(hotelId string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.hotelId = &hotelId
	return r
}

func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) TaxCodes(taxCodes []string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.taxCodes = &taxCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCollectingAgentTaxesRequest) Execute() (*CollectingAgentTaxes, *http.Response, error) {
	return r.ApiService.GetCollectingAgentTaxesExecute(r)
}

/*
GetCollectingAgentTaxes Operation to fetch CollectingAgentTaxes.

Operation to fetch Collecting Agent Taxes. <p><strong>OperationId:</strong>getCollectingAgentTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetCollectingAgentTaxesRequest
*/
func (a *CashieringConfigAPIService) GetCollectingAgentTaxes(ctx context.Context) CashieringConfigAPIGetCollectingAgentTaxesRequest {
	return CashieringConfigAPIGetCollectingAgentTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectingAgentTaxes
func (a *CashieringConfigAPIService) GetCollectingAgentTaxesExecute(r CashieringConfigAPIGetCollectingAgentTaxesRequest) (*CollectingAgentTaxes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectingAgentTaxes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCollectingAgentTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/collectingAgentTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.taxCodes != nil {
		t := *r.taxCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCompAuthorizersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeCompAuthorizerDetails *bool
	includeInactiveAuthorizers *bool
	includeTerminatedAuthorizers *bool
	authorizer *string
	firstName *string
	lastName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCompAuthorizersRequest) Authorization(authorization string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCompAuthorizersRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCompAuthorizersRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuring this flag to be TRUE will return the details of the comp authorizers.
func (r CashieringConfigAPIGetCompAuthorizersRequest) IncludeCompAuthorizerDetails(includeCompAuthorizerDetails bool) CashieringConfigAPIGetCompAuthorizersRequest {
	r.includeCompAuthorizerDetails = &includeCompAuthorizerDetails
	return r
}

// Configuring this flag to be TRUE will return also the inactive authorizers.
func (r CashieringConfigAPIGetCompAuthorizersRequest) IncludeInactiveAuthorizers(includeInactiveAuthorizers bool) CashieringConfigAPIGetCompAuthorizersRequest {
	r.includeInactiveAuthorizers = &includeInactiveAuthorizers
	return r
}

// Configuring this flag to be TRUE will return the terminated authorizers.
func (r CashieringConfigAPIGetCompAuthorizersRequest) IncludeTerminatedAuthorizers(includeTerminatedAuthorizers bool) CashieringConfigAPIGetCompAuthorizersRequest {
	r.includeTerminatedAuthorizers = &includeTerminatedAuthorizers
	return r
}

// Name for the authorizer.
func (r CashieringConfigAPIGetCompAuthorizersRequest) Authorizer(authorizer string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.authorizer = &authorizer
	return r
}

// First name for the authorizer.
func (r CashieringConfigAPIGetCompAuthorizersRequest) FirstName(firstName string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.firstName = &firstName
	return r
}

// Last name for the authorizer.
func (r CashieringConfigAPIGetCompAuthorizersRequest) LastName(lastName string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.lastName = &lastName
	return r
}

// External system code.
func (r CashieringConfigAPIGetCompAuthorizersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCompAuthorizersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCompAuthorizersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCompAuthorizersRequest) Execute() (*CompAuthorizers, *http.Response, error) {
	return r.ApiService.GetCompAuthorizersExecute(r)
}

/*
GetCompAuthorizers Operation to fetch CompAuthorizers.

Operation to fetch Authorizer Groups. <p><strong>OperationId:</strong>getCompAuthorizers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCompAuthorizersRequest
*/
func (a *CashieringConfigAPIService) GetCompAuthorizers(ctx context.Context, hotelId string) CashieringConfigAPIGetCompAuthorizersRequest {
	return CashieringConfigAPIGetCompAuthorizersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompAuthorizers
func (a *CashieringConfigAPIService) GetCompAuthorizersExecute(r CashieringConfigAPIGetCompAuthorizersRequest) (*CompAuthorizers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompAuthorizers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCompAuthorizers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compAuthorizers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeCompAuthorizerDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompAuthorizerDetails", r.includeCompAuthorizerDetails, "")
  }
	if r.includeInactiveAuthorizers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveAuthorizers", r.includeInactiveAuthorizers, "")
  }
	if r.includeTerminatedAuthorizers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTerminatedAuthorizers", r.includeTerminatedAuthorizers, "")
  }
	if r.authorizer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizer", r.authorizer, "")
  }
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
  }
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCompBucketRedemptionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	redemptionCode *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) Authorization(authorization string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) RedemptionCode(redemptionCode []string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.redemptionCode = &redemptionCode
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) Execute() (*CompBucketRedemptionConfigDetails, *http.Response, error) {
	return r.ApiService.GetCompBucketRedemptionCodesExecute(r)
}

/*
GetCompBucketRedemptionCodes Operation to fetch Comp Bucket Redemption Codes.

You can use this API to fetch Comp Bucket Redemption Codes. <p><strong>OperationId:</strong>getCompBucketRedemptionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCompBucketRedemptionCodesRequest
*/
func (a *CashieringConfigAPIService) GetCompBucketRedemptionCodes(ctx context.Context, hotelId string) CashieringConfigAPIGetCompBucketRedemptionCodesRequest {
	return CashieringConfigAPIGetCompBucketRedemptionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompBucketRedemptionConfigDetails
func (a *CashieringConfigAPIService) GetCompBucketRedemptionCodesExecute(r CashieringConfigAPIGetCompBucketRedemptionCodesRequest) (*CompBucketRedemptionConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompBucketRedemptionConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCompBucketRedemptionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compBucket/redemption"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.redemptionCode != nil {
		t := *r.redemptionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "redemptionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "redemptionCode", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCompBucketRedemptionConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	redemptionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) Authorization(authorization string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) WildCard(wildCard string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) Execute() (*CompBucketRedemptionConfigDetails, *http.Response, error) {
	return r.ApiService.GetCompBucketRedemptionConfigExecute(r)
}

/*
GetCompBucketRedemptionConfig Operation to fetch Comp Bucket Redemption Codes.

You can use this API to fetch Comp Bucket Redemption Codes.<br><p><strong><mark>This API is deprecated. Please use getCompBucketRedemptionCodes instead</mark></strong></p> <p><strong>OperationId:</strong>getCompBucketRedemptionConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param redemptionCode Bucket Redemption Code
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCompBucketRedemptionConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) GetCompBucketRedemptionConfig(ctx context.Context, redemptionCode string, hotelId string) CashieringConfigAPIGetCompBucketRedemptionConfigRequest {
	return CashieringConfigAPIGetCompBucketRedemptionConfigRequest{
		ApiService: a,
		ctx: ctx,
		redemptionCode: redemptionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompBucketRedemptionConfigDetails
// Deprecated
func (a *CashieringConfigAPIService) GetCompBucketRedemptionConfigExecute(r CashieringConfigAPIGetCompBucketRedemptionConfigRequest) (*CompBucketRedemptionConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompBucketRedemptionConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCompBucketRedemptionConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compBucket/redemption/{redemptionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"redemptionCode"+"}", url.PathEscape(parameterValueToString(r.redemptionCode, "redemptionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.redemptionCode) < 1 {
		return localVarReturnValue, nil, reportError("redemptionCode must have at least 1 elements")
	}
	if strlen(r.redemptionCode) > 2000 {
		return localVarReturnValue, nil, reportError("redemptionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypeCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCompTypesRequest) Authorization(authorization string) CashieringConfigAPIGetCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCompTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCompTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code is used to identify the CompType.
func (r CashieringConfigAPIGetCompTypesRequest) CompTypeCode(compTypeCode string) CashieringConfigAPIGetCompTypesRequest {
	r.compTypeCode = &compTypeCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCompTypesRequest) Execute() (*CompTypesDetails, *http.Response, error) {
	return r.ApiService.GetCompTypesExecute(r)
}

/*
GetCompTypes Operation to Fetch Comp Types.

Operation to Fetch Comp TYpes. <p><strong>OperationId:</strong>getCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigAPIGetCompTypesRequest
*/
func (a *CashieringConfigAPIService) GetCompTypes(ctx context.Context, hotelId string) CashieringConfigAPIGetCompTypesRequest {
	return CashieringConfigAPIGetCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompTypesDetails
func (a *CashieringConfigAPIService) GetCompTypesExecute(r CashieringConfigAPIGetCompTypesRequest) (*CompTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.compTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTypeCode", r.compTypeCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) Codes(codes []string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) Execute() (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeServiceTaxesExecute(r)
}

/*
GetCurrencyExchangeServiceTaxes Operation to fetch CurrencyExchangeServiceTaxes.

Operation to fetch currency exchange service taxes. <p><strong>OperationId:</strong>getCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigAPIService) GetCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrencyExchangeServiceTaxes
func (a *CashieringConfigAPIService) GetCurrencyExchangeServiceTaxesExecute(r CashieringConfigAPIGetCurrencyExchangeServiceTaxesRequest) (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrencyExchangeServiceTaxes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCustomChargeCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	configurationId *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCustomChargeCodesRequest) Authorization(authorization string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCustomChargeCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCustomChargeCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r CashieringConfigAPIGetCustomChargeCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetCustomChargeCodesRequest) ConfigurationId(configurationId []string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.configurationId = &configurationId
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCustomChargeCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetCustomChargeCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCustomChargeCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCustomChargeCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCustomChargeCodesRequest) Execute() (*CustomChargesConfigDetails, *http.Response, error) {
	return r.ApiService.GetCustomChargeCodesExecute(r)
}

/*
GetCustomChargeCodes Operation to fetch Custom Charge Codes.

You can use this API to fetch Custom Charge Codes. <p><strong>OperationId:</strong>getCustomChargeCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCustomChargeCodesRequest
*/
func (a *CashieringConfigAPIService) GetCustomChargeCodes(ctx context.Context, hotelId string) CashieringConfigAPIGetCustomChargeCodesRequest {
	return CashieringConfigAPIGetCustomChargeCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomChargesConfigDetails
func (a *CashieringConfigAPIService) GetCustomChargeCodesExecute(r CashieringConfigAPIGetCustomChargeCodesRequest) (*CustomChargesConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomChargesConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCustomChargeCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.configurationId != nil {
		t := *r.configurationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCustomChargeExemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	configurationId *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) Authorization(authorization string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) HotelId(hotelId []string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.hotelId = &hotelId
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) ConfigurationId(configurationId []string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.configurationId = &configurationId
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) WildCard(wildCard string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.wildCard = &wildCard
	return r
}

// Indicator that tells whether to include inactive articles in search results.
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCustomChargeExemptionsRequest) Execute() (*CustomChargeExemptionsConfig, *http.Response, error) {
	return r.ApiService.GetCustomChargeExemptionsExecute(r)
}

/*
GetCustomChargeExemptions Operation to fetch Custom Charge Exemptions Config.

You can use this API to fetch Custom Charge Exemptions Config. <p><strong>OperationId:</strong>getCustomChargeExemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetCustomChargeExemptionsRequest
*/
func (a *CashieringConfigAPIService) GetCustomChargeExemptions(ctx context.Context) CashieringConfigAPIGetCustomChargeExemptionsRequest {
	return CashieringConfigAPIGetCustomChargeExemptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomChargeExemptionsConfig
func (a *CashieringConfigAPIService) GetCustomChargeExemptionsExecute(r CashieringConfigAPIGetCustomChargeExemptionsRequest) (*CustomChargeExemptionsConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomChargeExemptionsConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCustomChargeExemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customCharges/exemptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.configurationId != nil {
		t := *r.configurationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCustomChargeExemptionsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) Authorization(authorization string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) WildCard(wildCard string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.wildCard = &wildCard
	return r
}

// Indicator that tells whether to include inactive articles in search results.
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) Execute() (*CustomChargeExemptionsConfig, *http.Response, error) {
	return r.ApiService.GetCustomChargeExemptionsConfigExecute(r)
}

/*
GetCustomChargeExemptionsConfig Operation to fetch Custom Charge Exemptions Config.

You can use this API to fetch Custom Charge Exemptions Config.<br><p><strong><mark>This API is deprecated. Please use getCustomChargeExemptions instead</mark></strong></p> <p><strong>OperationId:</strong>getCustomChargeExemptionsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCustomChargeExemptionsConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) GetCustomChargeExemptionsConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIGetCustomChargeExemptionsConfigRequest {
	return CashieringConfigAPIGetCustomChargeExemptionsConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomChargeExemptionsConfig
// Deprecated
func (a *CashieringConfigAPIService) GetCustomChargeExemptionsConfigExecute(r CashieringConfigAPIGetCustomChargeExemptionsConfigRequest) (*CustomChargeExemptionsConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomChargeExemptionsConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCustomChargeExemptionsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/exemptions/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCustomChargesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCustomChargesConfigRequest) Authorization(authorization string) CashieringConfigAPIGetCustomChargesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCustomChargesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCustomChargesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCustomChargesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCustomChargesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCustomChargesConfigRequest) WildCard(wildCard string) CashieringConfigAPIGetCustomChargesConfigRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetCustomChargesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCustomChargesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCustomChargesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCustomChargesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCustomChargesConfigRequest) Execute() (*CustomChargesConfigDetails, *http.Response, error) {
	return r.ApiService.GetCustomChargesConfigExecute(r)
}

/*
GetCustomChargesConfig Operation to fetch Custom Charge Codes.

You can use this API to fetch Custom Charge Codes.<br><p><strong><mark>This API is deprecated. Please use getCustomChargeCodes instead</mark></strong></p> <p><strong>OperationId:</strong>getCustomChargesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCustomChargesConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) GetCustomChargesConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIGetCustomChargesConfigRequest {
	return CashieringConfigAPIGetCustomChargesConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomChargesConfigDetails
// Deprecated
func (a *CashieringConfigAPIService) GetCustomChargesConfigExecute(r CashieringConfigAPIGetCustomChargesConfigRequest) (*CustomChargesConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomChargesConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCustomChargesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	wildCard *string
	description *string
	area *string
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator that tells whether to return the inactive custom number configuration in search results.
func (r CashieringConfigAPIGetCustomNumberConfigRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.includeInactive = &includeInactive
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCustomNumberConfigRequest) WildCard(wildCard string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.wildCard = &wildCard
	return r
}

// The description of the custom number configuration code.
func (r CashieringConfigAPIGetCustomNumberConfigRequest) Description(description string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.description = &description
	return r
}

// Receipt
func (r CashieringConfigAPIGetCustomNumberConfigRequest) Area(area string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.area = &area
	return r
}

func (r CashieringConfigAPIGetCustomNumberConfigRequest) StartDate(startDate string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringConfigAPIGetCustomNumberConfigRequest) EndDate(endDate string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringConfigAPIGetCustomNumberConfigRequest) Duration(duration string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r CashieringConfigAPIGetCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCustomNumberConfigRequest) Execute() (*CustomNumberConfigDetails, *http.Response, error) {
	return r.ApiService.GetCustomNumberConfigExecute(r)
}

/*
GetCustomNumberConfig Operation to fetch custom number config.

You can use this API to fetch custom number config.<br><p><strong><mark>This API is deprecated. Please use getCustomNumbers instead</mark></strong></p> <p><strong>OperationId:</strong>getCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCustomNumberConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) GetCustomNumberConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIGetCustomNumberConfigRequest {
	return CashieringConfigAPIGetCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomNumberConfigDetails
// Deprecated
func (a *CashieringConfigAPIService) GetCustomNumberConfigExecute(r CashieringConfigAPIGetCustomNumberConfigRequest) (*CustomNumberConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomNumberConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customNumbers/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetCustomNumbersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	includeInactive *bool
	configurationId *[]string
	wildCard *string
	description *string
	area *string
	startDate *string
	endDate *string
	duration *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetCustomNumbersRequest) Authorization(authorization string) CashieringConfigAPIGetCustomNumbersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetCustomNumbersRequest) XAppKey(xAppKey string) CashieringConfigAPIGetCustomNumbersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetCustomNumbersRequest) XHotelid(xHotelid string) CashieringConfigAPIGetCustomNumbersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r CashieringConfigAPIGetCustomNumbersRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetCustomNumbersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicator that tells whether to return the inactive custom number configuration in search results.
func (r CashieringConfigAPIGetCustomNumbersRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetCustomNumbersRequest {
	r.includeInactive = &includeInactive
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetCustomNumbersRequest) ConfigurationId(configurationId []string) CashieringConfigAPIGetCustomNumbersRequest {
	r.configurationId = &configurationId
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetCustomNumbersRequest) WildCard(wildCard string) CashieringConfigAPIGetCustomNumbersRequest {
	r.wildCard = &wildCard
	return r
}

// The description of the custom number configuration code.
func (r CashieringConfigAPIGetCustomNumbersRequest) Description(description string) CashieringConfigAPIGetCustomNumbersRequest {
	r.description = &description
	return r
}

// Receipt
func (r CashieringConfigAPIGetCustomNumbersRequest) Area(area string) CashieringConfigAPIGetCustomNumbersRequest {
	r.area = &area
	return r
}

func (r CashieringConfigAPIGetCustomNumbersRequest) StartDate(startDate string) CashieringConfigAPIGetCustomNumbersRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringConfigAPIGetCustomNumbersRequest) EndDate(endDate string) CashieringConfigAPIGetCustomNumbersRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringConfigAPIGetCustomNumbersRequest) Duration(duration string) CashieringConfigAPIGetCustomNumbersRequest {
	r.duration = &duration
	return r
}

// External system code.
func (r CashieringConfigAPIGetCustomNumbersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetCustomNumbersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetCustomNumbersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetCustomNumbersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetCustomNumbersRequest) Execute() (*CustomNumberConfigDetails, *http.Response, error) {
	return r.ApiService.GetCustomNumbersExecute(r)
}

/*
GetCustomNumbers Operation to fetch custom number config.

You can use this API to fetch custom number config. <p><strong>OperationId:</strong>getCustomNumbers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetCustomNumbersRequest
*/
func (a *CashieringConfigAPIService) GetCustomNumbers(ctx context.Context, hotelId string) CashieringConfigAPIGetCustomNumbersRequest {
	return CashieringConfigAPIGetCustomNumbersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CustomNumberConfigDetails
func (a *CashieringConfigAPIService) GetCustomNumbersExecute(r CashieringConfigAPIGetCustomNumbersRequest) (*CustomNumberConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomNumberConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetCustomNumbers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customNumbers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.configurationId != nil {
		t := *r.configurationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetDailyPlanCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetDailyPlanCodesRequest) Authorization(authorization string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetDailyPlanCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetDailyPlanCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigAPIGetDailyPlanCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetDailyPlanCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetDailyPlanCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetDailyPlanCodesRequest) Execute() (*DailyPlanCodes, *http.Response, error) {
	return r.ApiService.GetDailyPlanCodesExecute(r)
}

/*
GetDailyPlanCodes Operation to fetch DailyPlanCodes.

 <p><strong>OperationId:</strong>getDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetDailyPlanCodesRequest
*/
func (a *CashieringConfigAPIService) GetDailyPlanCodes(ctx context.Context) CashieringConfigAPIGetDailyPlanCodesRequest {
	return CashieringConfigAPIGetDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DailyPlanCodes
func (a *CashieringConfigAPIService) GetDailyPlanCodesExecute(r CashieringConfigAPIGetDailyPlanCodesRequest) (*DailyPlanCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyPlanCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
  }
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetDefaultPaymentMethodRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	transactionCodes *[]string
	paymentMethods *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) PaymentMethods(paymentMethods []string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.paymentMethods = &paymentMethods
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) Authorization(authorization string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) XAppKey(xAppKey string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) XHotelid(xHotelid string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) Limit(limit int32) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) Offset(offset int32) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.offset = &offset
	return r
}

// Simple Type for payment method fetch instruction.
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) FetchInstructions(fetchInstructions []string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) Execute() (*DefaultPaymentMethodRule, *http.Response, error) {
	return r.ApiService.GetDefaultPaymentMethodRuleExecute(r)
}

/*
GetDefaultPaymentMethodRule Operation to fetch DefaultPaymentMethodRule.

Operation to fetch payment method rule. <p><strong>OperationId:</strong>getDefaultPaymentMethodRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetDefaultPaymentMethodRuleRequest
*/
func (a *CashieringConfigAPIService) GetDefaultPaymentMethodRule(ctx context.Context) CashieringConfigAPIGetDefaultPaymentMethodRuleRequest {
	return CashieringConfigAPIGetDefaultPaymentMethodRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultPaymentMethodRule
func (a *CashieringConfigAPIService) GetDefaultPaymentMethodRuleExecute(r CashieringConfigAPIGetDefaultPaymentMethodRuleRequest) (*DefaultPaymentMethodRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultPaymentMethodRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetDefaultPaymentMethodRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/defaultPaymentMethodRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	{
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	{
		t := *r.paymentMethods
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethods", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethods", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exchangeTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetExchangeRatesRequest) Authorization(authorization string) CashieringConfigAPIGetExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetExchangeRatesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// E-certificate conversion.
func (r CashieringConfigAPIGetExchangeRatesRequest) ExchangeTypes(exchangeTypes []string) CashieringConfigAPIGetExchangeRatesRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// External system code.
func (r CashieringConfigAPIGetExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetExchangeRatesRequest) Execute() (*ExchangeRatesDetails, *http.Response, error) {
	return r.ApiService.GetExchangeRatesExecute(r)
}

/*
GetExchangeRates Operation to fetch ExchangeRates.

You can use this API to retrieve exchange rate information for a hotel. You can search by hotel, Currency Code and exchange types. Results can include past, current and future exchange rate information for a currency.<br><p><strong><mark>This API is deprecated. Please use getExchangeRatesInfo instead</mark></strong></p> <p><strong>OperationId:</strong>getExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetExchangeRatesRequest

Deprecated
*/
func (a *CashieringConfigAPIService) GetExchangeRates(ctx context.Context, hotelId string) CashieringConfigAPIGetExchangeRatesRequest {
	return CashieringConfigAPIGetExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExchangeRatesDetails
// Deprecated
func (a *CashieringConfigAPIService) GetExchangeRatesExecute(r CashieringConfigAPIGetExchangeRatesRequest) (*ExchangeRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExchangeRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exchangeRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.exchangeTypes != nil {
		t := *r.exchangeTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetExchangeRatesInfoRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	exchangeTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) Authorization(authorization string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) XAppKey(xAppKey string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) XHotelid(xHotelid string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where exchange rate is set.
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) HotelId(hotelId string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.hotelId = &hotelId
	return r
}

// E-certificate conversion.
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) ExchangeTypes(exchangeTypes []string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// External system code.
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetExchangeRatesInfoRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetExchangeRatesInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetExchangeRatesInfoRequest) Execute() (*ExchangeRatesDetails, *http.Response, error) {
	return r.ApiService.GetExchangeRatesInfoExecute(r)
}

/*
GetExchangeRatesInfo Operation to fetch ExchangeRates.

You can use this API to retrieve exchange rate information for a hotel. You can search by hotel, Currency Code and exchange types. Results can include past, current and future exchange rate information for a currency. <p><strong>OperationId:</strong>getExchangeRatesInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetExchangeRatesInfoRequest
*/
func (a *CashieringConfigAPIService) GetExchangeRatesInfo(ctx context.Context) CashieringConfigAPIGetExchangeRatesInfoRequest {
	return CashieringConfigAPIGetExchangeRatesInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExchangeRatesDetails
func (a *CashieringConfigAPIService) GetExchangeRatesInfoExecute(r CashieringConfigAPIGetExchangeRatesInfoRequest) (*ExchangeRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExchangeRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetExchangeRatesInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exchangeRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.exchangeTypes != nil {
		t := *r.exchangeTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetExpenseArrangementCodesRequest) Execute() (*ExpenseArrangementCodes, *http.Response, error) {
	return r.ApiService.GetExpenseArrangementCodesExecute(r)
}

/*
GetExpenseArrangementCodes Operation to fetch ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>getExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetExpenseArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) GetExpenseArrangementCodes(ctx context.Context) CashieringConfigAPIGetExpenseArrangementCodesRequest {
	return CashieringConfigAPIGetExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExpenseArrangementCodes
func (a *CashieringConfigAPIService) GetExpenseArrangementCodesExecute(r CashieringConfigAPIGetExpenseArrangementCodesRequest) (*ExpenseArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
  }
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFiscalCommandsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	code *[]string
	partnerCode *[]string
	operationType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFiscalCommandsRequest) Authorization(authorization string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFiscalCommandsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFiscalCommandsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Inactive flag used to include/exclude inactive transaction codes from the search result
func (r CashieringConfigAPIGetFiscalCommandsRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetFiscalCommandsRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r CashieringConfigAPIGetFiscalCommandsRequest) Code(code []string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.code = &code
	return r
}

// Used for fiscal partner codes. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIGetFiscalCommandsRequest) PartnerCode(partnerCode []string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.partnerCode = &partnerCode
	return r
}

// List of Fiscal Operations supported.
func (r CashieringConfigAPIGetFiscalCommandsRequest) OperationType(operationType string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.operationType = &operationType
	return r
}

// External system code.
func (r CashieringConfigAPIGetFiscalCommandsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFiscalCommandsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFiscalCommandsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFiscalCommandsRequest) Execute() (*FiscalCommandsDetails, *http.Response, error) {
	return r.ApiService.GetFiscalCommandsExecute(r)
}

/*
GetFiscalCommands Get Fiscal Commands

Use this API to get fiscal commands. <p><strong>OperationId:</strong>getFiscalCommands</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return CashieringConfigAPIGetFiscalCommandsRequest
*/
func (a *CashieringConfigAPIService) GetFiscalCommands(ctx context.Context, hotelId string) CashieringConfigAPIGetFiscalCommandsRequest {
	return CashieringConfigAPIGetFiscalCommandsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCommandsDetails
func (a *CashieringConfigAPIService) GetFiscalCommandsExecute(r CashieringConfigAPIGetFiscalCommandsRequest) (*FiscalCommandsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCommandsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFiscalCommands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalCommands"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.partnerCode != nil {
		t := *r.partnerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partnerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partnerCode", t, "multi")
		}
  }
	if r.operationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operationType", r.operationType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	codes *[]string
	wildCard *string
	internal *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetFiscalFolioParametersRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetFiscalFolioParametersRequest) Code(code []string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) Codes(codes []string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) WildCard(wildCard string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.wildCard = &wildCard
	return r
}

// Indicates whether the Fiscal Folio Parameter is user created or from seed data. Set this true to see the standard Fiscal Folio Parameters that are seeded along with the manually created Fiscal Folio Parameters.
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) Internal(internal bool) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.internal = &internal
	return r
}

// External system code.
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFiscalFolioParametersRequest) Execute() (*FiscalFolioParameters, *http.Response, error) {
	return r.ApiService.GetFiscalFolioParametersExecute(r)
}

/*
GetFiscalFolioParameters Operation to fetch FiscalFolioParameters.

Operation to fetch Fiscal Folio Parameters. <p><strong>OperationId:</strong>getFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFiscalFolioParametersRequest
*/
func (a *CashieringConfigAPIService) GetFiscalFolioParameters(ctx context.Context) CashieringConfigAPIGetFiscalFolioParametersRequest {
	return CashieringConfigAPIGetFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalFolioParameters
func (a *CashieringConfigAPIService) GetFiscalFolioParametersExecute(r CashieringConfigAPIGetFiscalFolioParametersRequest) (*FiscalFolioParameters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalFolioParameters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFiscalPartnersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	partnerCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFiscalPartnersRequest) Authorization(authorization string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFiscalPartnersRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFiscalPartnersRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r CashieringConfigAPIGetFiscalPartnersRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Used for fiscal partner codes. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIGetFiscalPartnersRequest) PartnerCode(partnerCode []string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.partnerCode = &partnerCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetFiscalPartnersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFiscalPartnersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFiscalPartnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFiscalPartnersRequest) Execute() (*FiscalPartnersDetails, *http.Response, error) {
	return r.ApiService.GetFiscalPartnersExecute(r)
}

/*
GetFiscalPartners Get fiscal partners

Use this API to get fiscal partners. <p><strong>OperationId:</strong>getFiscalPartners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return CashieringConfigAPIGetFiscalPartnersRequest
*/
func (a *CashieringConfigAPIService) GetFiscalPartners(ctx context.Context, hotelId string) CashieringConfigAPIGetFiscalPartnersRequest {
	return CashieringConfigAPIGetFiscalPartnersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalPartnersDetails
func (a *CashieringConfigAPIService) GetFiscalPartnersExecute(r CashieringConfigAPIGetFiscalPartnersRequest) (*FiscalPartnersDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalPartnersDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFiscalPartners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalPartners"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.partnerCode != nil {
		t := *r.partnerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partnerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partnerCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFiscalPeriodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	year *float32
	periodType *string
	period *string
	xExternalsystem *string
	acceptLanguage *string
}

// Resort for which the Period is defined.
func (r CashieringConfigAPIGetFiscalPeriodsRequest) HotelId(hotelId string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFiscalPeriodsRequest) Authorization(authorization string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFiscalPeriodsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFiscalPeriodsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Year to search for.
func (r CashieringConfigAPIGetFiscalPeriodsRequest) Year(year float32) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.year = &year
	return r
}

// Defined Values for Fiscal Year Type.
func (r CashieringConfigAPIGetFiscalPeriodsRequest) PeriodType(periodType string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.periodType = &periodType
	return r
}

// Period to search.
func (r CashieringConfigAPIGetFiscalPeriodsRequest) Period(period string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.period = &period
	return r
}

// External system code.
func (r CashieringConfigAPIGetFiscalPeriodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFiscalPeriodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFiscalPeriodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFiscalPeriodsRequest) Execute() (*FiscalPeriodsInfo, *http.Response, error) {
	return r.ApiService.GetFiscalPeriodsExecute(r)
}

/*
GetFiscalPeriods Operation to fetch FiscalPeriods.

Operation to fetch Fiscal Periods. <p><strong>OperationId:</strong>getFiscalPeriods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFiscalPeriodsRequest
*/
func (a *CashieringConfigAPIService) GetFiscalPeriods(ctx context.Context) CashieringConfigAPIGetFiscalPeriodsRequest {
	return CashieringConfigAPIGetFiscalPeriodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalPeriodsInfo
func (a *CashieringConfigAPIService) GetFiscalPeriodsExecute(r CashieringConfigAPIGetFiscalPeriodsRequest) (*FiscalPeriodsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalPeriodsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFiscalPeriods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalPeriods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "year", r.year, "")
  }
	if r.periodType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periodType", r.periodType, "")
  }
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFiscalYearsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	year *float32
	yearType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Search all years for this Resort.
func (r CashieringConfigAPIGetFiscalYearsRequest) HotelId(hotelId string) CashieringConfigAPIGetFiscalYearsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFiscalYearsRequest) Authorization(authorization string) CashieringConfigAPIGetFiscalYearsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFiscalYearsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFiscalYearsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFiscalYearsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFiscalYearsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Year to Search.
func (r CashieringConfigAPIGetFiscalYearsRequest) Year(year float32) CashieringConfigAPIGetFiscalYearsRequest {
	r.year = &year
	return r
}

// Defined Values for Fiscal Year Type.
func (r CashieringConfigAPIGetFiscalYearsRequest) YearType(yearType string) CashieringConfigAPIGetFiscalYearsRequest {
	r.yearType = &yearType
	return r
}

// External system code.
func (r CashieringConfigAPIGetFiscalYearsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFiscalYearsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFiscalYearsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFiscalYearsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFiscalYearsRequest) Execute() (*FiscalYears, *http.Response, error) {
	return r.ApiService.GetFiscalYearsExecute(r)
}

/*
GetFiscalYears Operation to fetch FiscalYears.

Operation to fetch Fiscal Years. <p><strong>OperationId:</strong>getFiscalYears</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFiscalYearsRequest
*/
func (a *CashieringConfigAPIService) GetFiscalYears(ctx context.Context) CashieringConfigAPIGetFiscalYearsRequest {
	return CashieringConfigAPIGetFiscalYearsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalYears
func (a *CashieringConfigAPIService) GetFiscalYearsExecute(r CashieringConfigAPIGetFiscalYearsRequest) (*FiscalYears, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalYears
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFiscalYears")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalYears"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "year", r.year, "")
  }
	if r.yearType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "yearType", r.yearType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFolioArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetFolioArrangementCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFolioArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFolioArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFolioArrangementCodesRequest) Execute() (*FolioArrangementCodes, *http.Response, error) {
	return r.ApiService.GetFolioArrangementCodesExecute(r)
}

/*
GetFolioArrangementCodes Operation to fetch FolioArrangementCodes.

 <p><strong>OperationId:</strong>getFolioArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFolioArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) GetFolioArrangementCodes(ctx context.Context) CashieringConfigAPIGetFolioArrangementCodesRequest {
	return CashieringConfigAPIGetFolioArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioArrangementCodes
func (a *CashieringConfigAPIService) GetFolioArrangementCodesExecute(r CashieringConfigAPIGetFolioArrangementCodesRequest) (*FolioArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFolioArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
  }
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFolioCopyLegendsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	languageCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFolioCopyLegendsRequest) Authorization(authorization string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFolioCopyLegendsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFolioCopyLegendsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetFolioCopyLegendsRequest) Codes(codes []string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.codes = &codes
	return r
}

// Language code to be searched.
func (r CashieringConfigAPIGetFolioCopyLegendsRequest) LanguageCode(languageCode string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.languageCode = &languageCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetFolioCopyLegendsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFolioCopyLegendsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFolioCopyLegendsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFolioCopyLegendsRequest) Execute() (*FolioCopyLegends, *http.Response, error) {
	return r.ApiService.GetFolioCopyLegendsExecute(r)
}

/*
GetFolioCopyLegends Operation to fetch FolioCopyLegends.

Operation to fetch folio copy legends. <p><strong>OperationId:</strong>getFolioCopyLegends</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFolioCopyLegendsRequest
*/
func (a *CashieringConfigAPIService) GetFolioCopyLegends(ctx context.Context) CashieringConfigAPIGetFolioCopyLegendsRequest {
	return CashieringConfigAPIGetFolioCopyLegendsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioCopyLegends
func (a *CashieringConfigAPIService) GetFolioCopyLegendsExecute(r CashieringConfigAPIGetFolioCopyLegendsRequest) (*FolioCopyLegends, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioCopyLegends
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFolioCopyLegends")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioCopyLegends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFolioPrintQueuesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	queueName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property to be searched for
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) HotelId(hotelId string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) Authorization(authorization string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines whether to fetch inactive records or not.
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) FetchInactive(fetchInactive bool) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Queue name to be searched for
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) QueueName(queueName string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.queueName = &queueName
	return r
}

// External system code.
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFolioPrintQueuesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFolioPrintQueuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFolioPrintQueuesRequest) Execute() (*FolioPrintQueues, *http.Response, error) {
	return r.ApiService.GetFolioPrintQueuesExecute(r)
}

/*
GetFolioPrintQueues Operation to fetch FolioPrintQueues.

Operation to folio fetch print queues. <p><strong>OperationId:</strong>getFolioPrintQueues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFolioPrintQueuesRequest
*/
func (a *CashieringConfigAPIService) GetFolioPrintQueues(ctx context.Context) CashieringConfigAPIGetFolioPrintQueuesRequest {
	return CashieringConfigAPIGetFolioPrintQueuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioPrintQueues
func (a *CashieringConfigAPIService) GetFolioPrintQueuesExecute(r CashieringConfigAPIGetFolioPrintQueuesRequest) (*FolioPrintQueues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioPrintQueues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFolioPrintQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioPrintQueues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.queueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", r.queueName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	legendCode *string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with folio type legend mapping
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) HotelId(hotelId string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.hotelId = &hotelId
	return r
}

// Legend code to which folio types attached.
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) LegendCode(legendCode string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.legendCode = &legendCode
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) Authorization(authorization string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio type to be searched.
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) FolioType(folioType string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.folioType = &folioType
	return r
}

// External system code.
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) Execute() (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	return r.ApiService.GetFolioTypeLegendMappingsConfigExecute(r)
}

/*
GetFolioTypeLegendMappingsConfig Operation to fetch folio type legend mappings config.

Operation to fetch folio type legend mappings config. <p><strong>OperationId:</strong>getFolioTypeLegendMappingsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest
*/
func (a *CashieringConfigAPIService) GetFolioTypeLegendMappingsConfig(ctx context.Context) CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest {
	return CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingsConfigDetails
func (a *CashieringConfigAPIService) GetFolioTypeLegendMappingsConfigExecute(r CashieringConfigAPIGetFolioTypeLegendMappingsConfigRequest) (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingsConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFolioTypeLegendMappingsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "legendCode", r.legendCode, "")
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFolioTypesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeNamesCodes *[]string
	taxTypeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Folio Type Names belong to Hotels.
func (r CashieringConfigAPIGetFolioTypesConfigRequest) HotelId(hotelId string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFolioTypesConfigRequest) Authorization(authorization string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFolioTypesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFolioTypesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetFolioTypesConfigRequest) FolioTypeNamesCodes(folioTypeNamesCodes []string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.folioTypeNamesCodes = &folioTypeNamesCodes
	return r
}

func (r CashieringConfigAPIGetFolioTypesConfigRequest) TaxTypeCodes(taxTypeCodes []string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.taxTypeCodes = &taxTypeCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetFolioTypesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFolioTypesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFolioTypesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFolioTypesConfigRequest) Execute() (*FolioTypesConfig, *http.Response, error) {
	return r.ApiService.GetFolioTypesConfigExecute(r)
}

/*
GetFolioTypesConfig Operation to fetch FolioTypesConfig.

Operation to fetch Folio Type Names. <p><strong>OperationId:</strong>getFolioTypesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetFolioTypesConfigRequest
*/
func (a *CashieringConfigAPIService) GetFolioTypesConfig(ctx context.Context) CashieringConfigAPIGetFolioTypesConfigRequest {
	return CashieringConfigAPIGetFolioTypesConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypesConfig
func (a *CashieringConfigAPIService) GetFolioTypesConfigExecute(r CashieringConfigAPIGetFolioTypesConfigRequest) (*FolioTypesConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypesConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFolioTypesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypesConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.folioTypeNamesCodes != nil {
		t := *r.folioTypeNamesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeNamesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeNamesCodes", t, "multi")
		}
  }
	if r.taxTypeCodes != nil {
		t := *r.taxTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetForeignCurrenciesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencies *[]string
	wildCard *string
	description *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetForeignCurrenciesRequest) Authorization(authorization string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetForeignCurrenciesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetForeignCurrenciesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetForeignCurrenciesRequest) Currencies(currencies []string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.currencies = &currencies
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetForeignCurrenciesRequest) WildCard(wildCard string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.wildCard = &wildCard
	return r
}

// Description text set to the search criteria
func (r CashieringConfigAPIGetForeignCurrenciesRequest) Description(description string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.description = &description
	return r
}

// Inactive flag used to include/exclude inactive foreign currencies from the search result
func (r CashieringConfigAPIGetForeignCurrenciesRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigAPIGetForeignCurrenciesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetForeignCurrenciesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetForeignCurrenciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetForeignCurrenciesRequest) Execute() (*ForeignCurrencies, *http.Response, error) {
	return r.ApiService.GetForeignCurrenciesExecute(r)
}

/*
GetForeignCurrencies Operation to fetch ForeignCurrencies.

Operation to fetch Foreign Currencies. <p><strong>OperationId:</strong>getForeignCurrencies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetForeignCurrenciesRequest
*/
func (a *CashieringConfigAPIService) GetForeignCurrencies(ctx context.Context) CashieringConfigAPIGetForeignCurrenciesRequest {
	return CashieringConfigAPIGetForeignCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForeignCurrencies
func (a *CashieringConfigAPIService) GetForeignCurrenciesExecute(r CashieringConfigAPIGetForeignCurrenciesRequest) (*ForeignCurrencies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForeignCurrencies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetForeignCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.currencies != nil {
		t := *r.currencies
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetFuturePastExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	currencyCode string
	hotelId string
	exchangeTypes *string
	authorization *string
	xAppKey *string
	xHotelid *string
	dateRangeStart *string
	dateRangeEnd *string
	xExternalsystem *string
	acceptLanguage *string
}

// E-certificate conversion.
func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) ExchangeTypes(exchangeTypes string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) Authorization(authorization string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) DateRangeStart(dateRangeStart string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) DateRangeEnd(dateRangeEnd string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// External system code.
func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetFuturePastExchangeRatesRequest) Execute() ([]ExchangeRateType, *http.Response, error) {
	return r.ApiService.GetFuturePastExchangeRatesExecute(r)
}

/*
GetFuturePastExchangeRates Operation to fetch FuturePastExchangeRates.

Operation to Fetch Future Past Exchange Rates. <p><strong>OperationId:</strong>getFuturePastExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyCode Currency Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetFuturePastExchangeRatesRequest
*/
func (a *CashieringConfigAPIService) GetFuturePastExchangeRates(ctx context.Context, currencyCode string, hotelId string) CashieringConfigAPIGetFuturePastExchangeRatesRequest {
	return CashieringConfigAPIGetFuturePastExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
		currencyCode: currencyCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []ExchangeRateType
func (a *CashieringConfigAPIService) GetFuturePastExchangeRatesExecute(r CashieringConfigAPIGetFuturePastExchangeRatesRequest) ([]ExchangeRateType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExchangeRateType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetFuturePastExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exchangeRates/{currencyCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", r.exchangeTypes, "")
	if r.dateRangeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
  }
	if r.dateRangeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetGUINumberRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code.
func (r CashieringConfigAPIGetGUINumberRulesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetGUINumberRulesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetGUINumberRulesRequest) Authorization(authorization string) CashieringConfigAPIGetGUINumberRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetGUINumberRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetGUINumberRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetGUINumberRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetGUINumberRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIGetGUINumberRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetGUINumberRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetGUINumberRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetGUINumberRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetGUINumberRulesRequest) Execute() (*GUINumberRulesDetails, *http.Response, error) {
	return r.ApiService.GetGUINumberRulesExecute(r)
}

/*
GetGUINumberRules Operation to fetch GUINumberRules.

Operation to fetch GUI Number rules <p><strong>OperationId:</strong>getGUINumberRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetGUINumberRulesRequest
*/
func (a *CashieringConfigAPIService) GetGUINumberRules(ctx context.Context) CashieringConfigAPIGetGUINumberRulesRequest {
	return CashieringConfigAPIGetGUINumberRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GUINumberRulesDetails
func (a *CashieringConfigAPIService) GetGUINumberRulesExecute(r CashieringConfigAPIGetGUINumberRulesRequest) (*GUINumberRulesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GUINumberRulesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetGUINumberRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guiNumberRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetGenerateTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetGenerateTaxTypesRequest) Authorization(authorization string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetGenerateTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetGenerateTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIGetGenerateTaxTypesRequest) TransactionCode(transactionCode string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	r.transactionCode = &transactionCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetGenerateTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetGenerateTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetGenerateTaxTypesRequest) Execute() (*TaxTypesGenerate, *http.Response, error) {
	return r.ApiService.GetGenerateTaxTypesExecute(r)
}

/*
GetGenerateTaxTypes Operation to fetch GenerateTaxTypes.

Operation to fetch tax types. <p><strong>OperationId:</strong>getGenerateTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetGenerateTaxTypesRequest
*/
func (a *CashieringConfigAPIService) GetGenerateTaxTypes(ctx context.Context, hotelId string) CashieringConfigAPIGetGenerateTaxTypesRequest {
	return CashieringConfigAPIGetGenerateTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TaxTypesGenerate
func (a *CashieringConfigAPIService) GetGenerateTaxTypesExecute(r CashieringConfigAPIGetGenerateTaxTypesRequest) (*TaxTypesGenerate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxTypesGenerate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetGenerateTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/generates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.transactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", r.transactionCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetGlobalExchangeRatesInfoRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	exchangeTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) Authorization(authorization string) CashieringConfigAPIGetGlobalExchangeRatesInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) XAppKey(xAppKey string) CashieringConfigAPIGetGlobalExchangeRatesInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// E-certificate conversion.
func (r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) ExchangeTypes(exchangeTypes []string) CashieringConfigAPIGetGlobalExchangeRatesInfoRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// External system code.
func (r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetGlobalExchangeRatesInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetGlobalExchangeRatesInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) Execute() (*ExchangeRatesDetails, *http.Response, error) {
	return r.ApiService.GetGlobalExchangeRatesInfoExecute(r)
}

/*
GetGlobalExchangeRatesInfo Operation to fetch GlobalExchangeRates.

You can use this API to retrieve global exchange rate information for a chain. You can search by Currency Code and exchange types. Results can include past, current and future exchange rate information for a currency. <p><strong>OperationId:</strong>getGlobalExchangeRatesInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetGlobalExchangeRatesInfoRequest
*/
func (a *CashieringConfigAPIService) GetGlobalExchangeRatesInfo(ctx context.Context) CashieringConfigAPIGetGlobalExchangeRatesInfoRequest {
	return CashieringConfigAPIGetGlobalExchangeRatesInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExchangeRatesDetails
func (a *CashieringConfigAPIService) GetGlobalExchangeRatesInfoExecute(r CashieringConfigAPIGetGlobalExchangeRatesInfoRequest) (*ExchangeRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExchangeRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetGlobalExchangeRatesInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/globalExchangeRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exchangeTypes != nil {
		t := *r.exchangeTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetGroupArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetGroupArrangementCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetGroupArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetGroupArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetGroupArrangementCodesRequest) Execute() (*GroupArrangementCodes, *http.Response, error) {
	return r.ApiService.GetGroupArrangementCodesExecute(r)
}

/*
GetGroupArrangementCodes Operation to create GroupArrangementCodes.

 <p><strong>OperationId:</strong>getGroupArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetGroupArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) GetGroupArrangementCodes(ctx context.Context) CashieringConfigAPIGetGroupArrangementCodesRequest {
	return CashieringConfigAPIGetGroupArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GroupArrangementCodes
func (a *CashieringConfigAPIService) GetGroupArrangementCodesExecute(r CashieringConfigAPIGetGroupArrangementCodesRequest) (*GroupArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetGroupArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groupArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
  }
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetNoShowPostingRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	sourceCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetNoShowPostingRulesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) Authorization(authorization string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) SourceCodes(sourceCodes []string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.sourceCodes = &sourceCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) WildCard(wildCard string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetNoShowPostingRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetNoShowPostingRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetNoShowPostingRulesRequest) Execute() (*NoShowPostingRules, *http.Response, error) {
	return r.ApiService.GetNoShowPostingRulesExecute(r)
}

/*
GetNoShowPostingRules Operation to fetch NoShowPostingRules.

Operation to fetch No Show Posting Rules. <p><strong>OperationId:</strong>getNoShowPostingRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetNoShowPostingRulesRequest
*/
func (a *CashieringConfigAPIService) GetNoShowPostingRules(ctx context.Context) CashieringConfigAPIGetNoShowPostingRulesRequest {
	return CashieringConfigAPIGetNoShowPostingRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NoShowPostingRules
func (a *CashieringConfigAPIService) GetNoShowPostingRulesExecute(r CashieringConfigAPIGetNoShowPostingRulesRequest) (*NoShowPostingRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NoShowPostingRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetNoShowPostingRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noShowPostingRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.sourceCodes != nil {
		t := *r.sourceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetNumberDescriptionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	numberCodes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetNumberDescriptionsRequest) Authorization(authorization string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetNumberDescriptionsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetNumberDescriptionsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for Number specific codes for OPERA tables. Possible values of this pattern are 1, 10, 17, THOUSAND, BILLION, etc.
func (r CashieringConfigAPIGetNumberDescriptionsRequest) NumberCodes(numberCodes []string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.numberCodes = &numberCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetNumberDescriptionsRequest) WildCard(wildCard string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.wildCard = &wildCard
	return r
}

// Description text set to the search criteria
func (r CashieringConfigAPIGetNumberDescriptionsRequest) Description(description string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.description = &description
	return r
}

// External system code.
func (r CashieringConfigAPIGetNumberDescriptionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetNumberDescriptionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetNumberDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetNumberDescriptionsRequest) Execute() (*NumberDescriptions, *http.Response, error) {
	return r.ApiService.GetNumberDescriptionsExecute(r)
}

/*
GetNumberDescriptions Operation to fetch NumberDescriptions.

The operation accepts code and/or descriptions for numbers as search criteria in fetch request and returns numbers, descriptions that match the criteria. <p><strong>OperationId:</strong>getNumberDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetNumberDescriptionsRequest
*/
func (a *CashieringConfigAPIService) GetNumberDescriptions(ctx context.Context) CashieringConfigAPIGetNumberDescriptionsRequest {
	return CashieringConfigAPIGetNumberDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NumberDescriptions
func (a *CashieringConfigAPIService) GetNumberDescriptionsExecute(r CashieringConfigAPIGetNumberDescriptionsRequest) (*NumberDescriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NumberDescriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetNumberDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/numberDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.numberCodes != nil {
		t := *r.numberCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "numberCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "numberCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetOperaControlSequencesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	countryCode *string
	code *[]string
	hotelCode *[]string
	fetchInstruction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code of fetch criteria
func (r CashieringConfigAPIGetOperaControlSequencesRequest) HotelId(hotelId string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetOperaControlSequencesRequest) Authorization(authorization string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetOperaControlSequencesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetOperaControlSequencesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Country Code of fetch criteria
func (r CashieringConfigAPIGetOperaControlSequencesRequest) CountryCode(countryCode string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.countryCode = &countryCode
	return r
}

// Configuration code.
func (r CashieringConfigAPIGetOperaControlSequencesRequest) Code(code []string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.code = &code
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigAPIGetOperaControlSequencesRequest) HotelCode(hotelCode []string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.hotelCode = &hotelCode
	return r
}

// Simple type for opera sequence instructions that can be used for partial operations.
func (r CashieringConfigAPIGetOperaControlSequencesRequest) FetchInstruction(fetchInstruction []string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.fetchInstruction = &fetchInstruction
	return r
}

// External system code.
func (r CashieringConfigAPIGetOperaControlSequencesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetOperaControlSequencesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetOperaControlSequencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetOperaControlSequencesRequest) Execute() (*OperaControlSequences, *http.Response, error) {
	return r.ApiService.GetOperaControlSequencesExecute(r)
}

/*
GetOperaControlSequences Operation to fetch OperaControlSequences.

Operation to fetch Opera Document Sequences. <p><strong>OperationId:</strong>getOperaControlSequences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetOperaControlSequencesRequest
*/
func (a *CashieringConfigAPIService) GetOperaControlSequences(ctx context.Context) CashieringConfigAPIGetOperaControlSequencesRequest {
	return CashieringConfigAPIGetOperaControlSequencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaControlSequences
func (a *CashieringConfigAPIService) GetOperaControlSequencesExecute(r CashieringConfigAPIGetOperaControlSequencesRequest) (*OperaControlSequences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaControlSequences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetOperaControlSequences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/operaControlSequences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.hotelCode != nil {
		t := *r.hotelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "HotelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "HotelCode", t, "multi")
		}
  }
	if r.fetchInstruction != nil {
		t := *r.fetchInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetPackageArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	arrangementCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetPackageArrangementCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// A flag that determines whether to fetch active records or inactive records
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetPackageArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetPackageArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetPackageArrangementCodesRequest) Execute() (*PackageArrangementCodes, *http.Response, error) {
	return r.ApiService.GetPackageArrangementCodesExecute(r)
}

/*
GetPackageArrangementCodes Operation to fetch PackageArrangementCodes.

 <p><strong>OperationId:</strong>getPackageArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetPackageArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) GetPackageArrangementCodes(ctx context.Context) CashieringConfigAPIGetPackageArrangementCodesRequest {
	return CashieringConfigAPIGetPackageArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackageArrangementCodes
func (a *CashieringConfigAPIService) GetPackageArrangementCodesExecute(r CashieringConfigAPIGetPackageArrangementCodesRequest) (*PackageArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetPackageArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	transactionCodes *[]string
	paymentMethods *[]string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetPaymentMethodsRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetPaymentMethodsRequest) Authorization(authorization string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetPaymentMethodsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetPaymentMethodsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringConfigAPIGetPaymentMethodsRequest) Limit(limit int32) CashieringConfigAPIGetPaymentMethodsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringConfigAPIGetPaymentMethodsRequest) Offset(offset int32) CashieringConfigAPIGetPaymentMethodsRequest {
	r.offset = &offset
	return r
}

func (r CashieringConfigAPIGetPaymentMethodsRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigAPIGetPaymentMethodsRequest) PaymentMethods(paymentMethods []string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.paymentMethods = &paymentMethods
	return r
}

// Simple Type for payment method fetch instruction.
func (r CashieringConfigAPIGetPaymentMethodsRequest) FetchInstructions(fetchInstructions []string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIGetPaymentMethodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetPaymentMethodsRequest) Execute() (*PaymentMethodsInfo, *http.Response, error) {
	return r.ApiService.GetPaymentMethodsExecute(r)
}

/*
GetPaymentMethods Operation to fetch PaymentMethods.

Operation to fetch payment methods. <p><strong>OperationId:</strong>getPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetPaymentMethodsRequest
*/
func (a *CashieringConfigAPIService) GetPaymentMethods(ctx context.Context) CashieringConfigAPIGetPaymentMethodsRequest {
	return CashieringConfigAPIGetPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentMethodsInfo
func (a *CashieringConfigAPIService) GetPaymentMethodsExecute(r CashieringConfigAPIGetPaymentMethodsRequest) (*PaymentMethodsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentMethodsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelPaymentMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	if r.paymentMethods != nil {
		t := *r.paymentMethods
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethods", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethods", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetRevenueBucketCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	trxCodeArrangementCodes *[]string
	wildCard *string
	trxCodeArrangementType *string
	code *[]string
	revenueBucketTypesWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetRevenueBucketCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) Authorization(authorization string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) TrxCodeArrangementCodes(trxCodeArrangementCodes []string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.trxCodeArrangementCodes = &trxCodeArrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Fiscal Bucket Type.
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) TrxCodeArrangementType(trxCodeArrangementType string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.trxCodeArrangementType = &trxCodeArrangementType
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) Code(code []string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.code = &code
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) RevenueBucketTypesWildCard(revenueBucketTypesWildCard string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.revenueBucketTypesWildCard = &revenueBucketTypesWildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetRevenueBucketCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetRevenueBucketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetRevenueBucketCodesRequest) Execute() (*RevenueBucketCodes, *http.Response, error) {
	return r.ApiService.GetRevenueBucketCodesExecute(r)
}

/*
GetRevenueBucketCodes Operation to fetch RevenueBucketCodes.

Operation to fetch Revenue Bucket Codes. <p><strong>OperationId:</strong>getRevenueBucketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetRevenueBucketCodesRequest
*/
func (a *CashieringConfigAPIService) GetRevenueBucketCodes(ctx context.Context) CashieringConfigAPIGetRevenueBucketCodesRequest {
	return CashieringConfigAPIGetRevenueBucketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevenueBucketCodes
func (a *CashieringConfigAPIService) GetRevenueBucketCodesExecute(r CashieringConfigAPIGetRevenueBucketCodesRequest) (*RevenueBucketCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueBucketCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetRevenueBucketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.trxCodeArrangementCodes != nil {
		t := *r.trxCodeArrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.trxCodeArrangementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementType", r.trxCodeArrangementType, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.revenueBucketTypesWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketTypesWildCard", r.revenueBucketTypesWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetRevenueBucketTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketTypeCodes *[]string
	wildCard *string
	bucketType *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetRevenueBucketTypesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) Authorization(authorization string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) RevenueBucketTypeCodes(revenueBucketTypeCodes []string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.revenueBucketTypeCodes = &revenueBucketTypeCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) WildCard(wildCard string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Fiscal Bucket Type.
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) BucketType(bucketType string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.bucketType = &bucketType
	return r
}

// External system code.
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetRevenueBucketTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetRevenueBucketTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetRevenueBucketTypesRequest) Execute() (*RevenueBucketTypes, *http.Response, error) {
	return r.ApiService.GetRevenueBucketTypesExecute(r)
}

/*
GetRevenueBucketTypes Operation to fetch RevenueBucketTypes.

Operation to fetch Revenue Bucket Types. <p><strong>OperationId:</strong>getRevenueBucketTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetRevenueBucketTypesRequest
*/
func (a *CashieringConfigAPIService) GetRevenueBucketTypes(ctx context.Context) CashieringConfigAPIGetRevenueBucketTypesRequest {
	return CashieringConfigAPIGetRevenueBucketTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevenueBucketTypes
func (a *CashieringConfigAPIService) GetRevenueBucketTypesExecute(r CashieringConfigAPIGetRevenueBucketTypesRequest) (*RevenueBucketTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueBucketTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetRevenueBucketTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.revenueBucketTypeCodes != nil {
		t := *r.revenueBucketTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketTypeCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.bucketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucketType", r.bucketType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetRevenueTypeMappingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventTypeCodes *[]string
	revenueTypeCodes *[]string
	transactionCodes *[]string
	spaceCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code.
func (r CashieringConfigAPIGetRevenueTypeMappingRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetRevenueTypeMappingRequest) Authorization(authorization string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetRevenueTypeMappingRequest) XAppKey(xAppKey string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetRevenueTypeMappingRequest) XHotelid(xHotelid string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetRevenueTypeMappingRequest) EventTypeCodes(eventTypeCodes []string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.eventTypeCodes = &eventTypeCodes
	return r
}

func (r CashieringConfigAPIGetRevenueTypeMappingRequest) RevenueTypeCodes(revenueTypeCodes []string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.revenueTypeCodes = &revenueTypeCodes
	return r
}

func (r CashieringConfigAPIGetRevenueTypeMappingRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigAPIGetRevenueTypeMappingRequest) SpaceCodes(spaceCodes []string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.spaceCodes = &spaceCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetRevenueTypeMappingRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetRevenueTypeMappingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetRevenueTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetRevenueTypeMappingRequest) Execute() (*RevenueTypeMappingList, *http.Response, error) {
	return r.ApiService.GetRevenueTypeMappingExecute(r)
}

/*
GetRevenueTypeMapping Operation to fetch RevenueTypeMapping.

 <p><strong>OperationId:</strong>getRevenueTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetRevenueTypeMappingRequest
*/
func (a *CashieringConfigAPIService) GetRevenueTypeMapping(ctx context.Context) CashieringConfigAPIGetRevenueTypeMappingRequest {
	return CashieringConfigAPIGetRevenueTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevenueTypeMappingList
func (a *CashieringConfigAPIService) GetRevenueTypeMappingExecute(r CashieringConfigAPIGetRevenueTypeMappingRequest) (*RevenueTypeMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueTypeMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetRevenueTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypeMapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.eventTypeCodes != nil {
		t := *r.eventTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventTypeCodes", t, "multi")
		}
  }
	if r.revenueTypeCodes != nil {
		t := *r.revenueTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueTypeCodes", t, "multi")
		}
  }
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	if r.spaceCodes != nil {
		t := *r.spaceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "spaceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "spaceCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	trxCodeArrangementCode *[]string
	wildCard *string
	compAccounting *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetRoutingInstructionsRequest) HotelId(hotelId []string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetRoutingInstructionsRequest) Authorization(authorization string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetRoutingInstructionsRequest) TrxCodeArrangementCode(trxCodeArrangementCode []string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.trxCodeArrangementCode = &trxCodeArrangementCode
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetRoutingInstructionsRequest) WildCard(wildCard string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.wildCard = &wildCard
	return r
}

// Determines if this is a comp routing code or a routing code.
func (r CashieringConfigAPIGetRoutingInstructionsRequest) CompAccounting(compAccounting bool) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.compAccounting = &compAccounting
	return r
}

// External system code.
func (r CashieringConfigAPIGetRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetRoutingInstructionsRequest) Execute() (*RoutingInstructions, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsExecute(r)
}

/*
GetRoutingInstructions Get routing instructions

Use this API to return routing instructions based on search criteria such as hotelId, trxCodeArrangementCode, wildCard.  Routing instructions are used to route specific charges to different destinations.<p><strong>OperationId:</strong>getRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetRoutingInstructionsRequest
*/
func (a *CashieringConfigAPIService) GetRoutingInstructions(ctx context.Context) CashieringConfigAPIGetRoutingInstructionsRequest {
	return CashieringConfigAPIGetRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoutingInstructions
func (a *CashieringConfigAPIService) GetRoutingInstructionsExecute(r CashieringConfigAPIGetRoutingInstructionsRequest) (*RoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if len(*r.hotelId) > 4000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 4000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
	if r.trxCodeArrangementCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementCode", r.trxCodeArrangementCode, "csv")
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.compAccounting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccounting", r.compAccounting, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTaxBracketsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxPercentagesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTaxBracketsRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTaxBracketsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTaxBracketsRequest) Authorization(authorization string) CashieringConfigAPIGetTaxBracketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTaxBracketsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTaxBracketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTaxBracketsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTaxBracketsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetTaxBracketsRequest) TaxPercentagesCodes(taxPercentagesCodes []string) CashieringConfigAPIGetTaxBracketsRequest {
	r.taxPercentagesCodes = &taxPercentagesCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetTaxBracketsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTaxBracketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTaxBracketsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTaxBracketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTaxBracketsRequest) Execute() (*TaxBrackets, *http.Response, error) {
	return r.ApiService.GetTaxBracketsExecute(r)
}

/*
GetTaxBrackets Operation to fetch TaxBrackets.

Operation to fetch Tax Brackets. This function only be available when the parameter "Tax Bracket Calculation" is on. <p><strong>OperationId:</strong>getTaxBrackets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTaxBracketsRequest
*/
func (a *CashieringConfigAPIService) GetTaxBrackets(ctx context.Context) CashieringConfigAPIGetTaxBracketsRequest {
	return CashieringConfigAPIGetTaxBracketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxBrackets
func (a *CashieringConfigAPIService) GetTaxBracketsExecute(r CashieringConfigAPIGetTaxBracketsRequest) (*TaxBrackets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxBrackets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTaxBrackets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxBrackets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.taxPercentagesCodes != nil {
		t := *r.taxPercentagesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxPercentagesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxPercentagesCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypeCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTaxTypesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTaxTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTaxTypesRequest) Authorization(authorization string) CashieringConfigAPIGetTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTaxTypesRequest) TaxTypeCodes(taxTypeCodes []string) CashieringConfigAPIGetTaxTypesRequest {
	r.taxTypeCodes = &taxTypeCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTaxTypesRequest) WildCard(wildCard string) CashieringConfigAPIGetTaxTypesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTaxTypesRequest) Execute() (*TaxTypes, *http.Response, error) {
	return r.ApiService.GetTaxTypesExecute(r)
}

/*
GetTaxTypes Operation to fetch TaxTypes.

Operation to fetch Tax Types. <p><strong>OperationId:</strong>getTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTaxTypesRequest
*/
func (a *CashieringConfigAPIService) GetTaxTypes(ctx context.Context) CashieringConfigAPIGetTaxTypesRequest {
	return CashieringConfigAPIGetTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxTypes
func (a *CashieringConfigAPIService) GetTaxTypesExecute(r CashieringConfigAPIGetTaxTypesRequest) (*TaxTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.taxTypeCodes != nil {
		t := *r.taxTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTemplateCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	wildCard *string
	startDate *string
	endDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator that tells whether to return the inactive custom number configuration in search results.
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.includeInactive = &includeInactive
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) WildCard(wildCard string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.wildCard = &wildCard
	return r
}

func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) StartDate(startDate string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) EndDate(endDate string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.endDate = &endDate
	return r
}

// External system code.
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) Execute() (*TemplateCustomNumberConfigDetails, *http.Response, error) {
	return r.ApiService.GetTemplateCustomNumberConfigExecute(r)
}

/*
GetTemplateCustomNumberConfig Operation to fetch template custom number configuration.

You can use this API to fetch template custom number configuration.<br><p><strong><mark>This API is deprecated. Please use getTemplateCustomNumbers instead</mark></strong></p> <p><strong>OperationId:</strong>getTemplateCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetTemplateCustomNumberConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) GetTemplateCustomNumberConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIGetTemplateCustomNumberConfigRequest {
	return CashieringConfigAPIGetTemplateCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TemplateCustomNumberConfigDetails
// Deprecated
func (a *CashieringConfigAPIService) GetTemplateCustomNumberConfigExecute(r CashieringConfigAPIGetTemplateCustomNumberConfigRequest) (*TemplateCustomNumberConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateCustomNumberConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTemplateCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/template/customNumbers/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTemplateCustomNumbersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	configurationId *[]string
	wildCard *string
	startDate *string
	endDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) Authorization(authorization string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicator that tells whether to return the inactive custom number configuration in search results.
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.includeInactive = &includeInactive
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) ConfigurationId(configurationId []string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.configurationId = &configurationId
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) WildCard(wildCard string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.wildCard = &wildCard
	return r
}

func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) StartDate(startDate string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) EndDate(endDate string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.endDate = &endDate
	return r
}

// External system code.
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTemplateCustomNumbersRequest) Execute() (*TemplateCustomNumberConfigDetails, *http.Response, error) {
	return r.ApiService.GetTemplateCustomNumbersExecute(r)
}

/*
GetTemplateCustomNumbers Operation to fetch template custom number configuration.

You can use this API to fetch template custom number configuration. <p><strong>OperationId:</strong>getTemplateCustomNumbers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTemplateCustomNumbersRequest
*/
func (a *CashieringConfigAPIService) GetTemplateCustomNumbers(ctx context.Context) CashieringConfigAPIGetTemplateCustomNumbersRequest {
	return CashieringConfigAPIGetTemplateCustomNumbersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateCustomNumberConfigDetails
func (a *CashieringConfigAPIService) GetTemplateCustomNumbersExecute(r CashieringConfigAPIGetTemplateCustomNumbersRequest) (*TemplateCustomNumberConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateCustomNumberConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTemplateCustomNumbers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/customNumbers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.configurationId != nil {
		t := *r.configurationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationId", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTransactionCodes *bool
	includeInactive *bool
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	transactionCodes *[]string
	wildCard *string
	description *string
	brandCode *string
	universalProductCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate whether comp accounting transaction codes are being requested. If true, only comp accounting transaction codes will be returned. If false, only standard transaction codes will be returned.
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) CompTransactionCodes(compTransactionCodes bool) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.compTransactionCodes = &compTransactionCodes
	return r
}

// Inactive flag used to include/exclude inactive transaction codes from the search result
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the Transaction code.
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) Description(description string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.description = &description
	return r
}

// Property associated with the corporate information brand code in the search criteria
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) BrandCode(brandCode string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.brandCode = &brandCode
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) UniversalProductCode(universalProductCode string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTemplateTransactionCodesRequest) Execute() (*TemplateTransactionCodes, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionCodesExecute(r)
}

/*
GetTemplateTransactionCodes Get template transaction codes

Use this API to return template transaction codes summaries based on search criteria such as transactionGroupCodes, transactionSubgroupsCodes, transactionCodes, wildCard, etc.<p><strong>OperationId:</strong>getTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTemplateTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) GetTemplateTransactionCodes(ctx context.Context) CashieringConfigAPIGetTemplateTransactionCodesRequest {
	return CashieringConfigAPIGetTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTransactionCodes
func (a *CashieringConfigAPIService) GetTemplateTransactionCodesExecute(r CashieringConfigAPIGetTemplateTransactionCodesRequest) (*TemplateTransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.compTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTransactionCodes", r.compTransactionCodes, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
  }
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
  }
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.brandCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brandCode", r.brandCode, "")
  }
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTemplateTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	wildCard *string
	transactionGroupType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) WildCard(wildCard string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Wrapper Transaction Type.
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) TransactionGroupType(transactionGroupType string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.transactionGroupType = &transactionGroupType
	return r
}

// External system code.
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTemplateTransactionGroupsRequest) Execute() (*TemplateTransactionGroups, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionGroupsExecute(r)
}

/*
GetTemplateTransactionGroups Operation to fetch TemplateTransactionGroups.

Operation to fetch template transaction group. <p><strong>OperationId:</strong>getTemplateTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTemplateTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) GetTemplateTransactionGroups(ctx context.Context) CashieringConfigAPIGetTemplateTransactionGroupsRequest {
	return CashieringConfigAPIGetTemplateTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTransactionGroups
func (a *CashieringConfigAPIService) GetTemplateTransactionGroupsExecute(r CashieringConfigAPIGetTemplateTransactionGroupsRequest) (*TemplateTransactionGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTransactionGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTemplateTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.transactionGroupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupType", r.transactionGroupType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTemplateTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) WildCard(wildCard string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) Execute() (*TemplateTransactionSubgroups, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionSubgroupsExecute(r)
}

/*
GetTemplateTransactionSubgroups Operation to fetch TemplateTransactionSubgroups.

Operation to fetch template transaction subgroups <p><strong>OperationId:</strong>getTemplateTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTemplateTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) GetTemplateTransactionSubgroups(ctx context.Context) CashieringConfigAPIGetTemplateTransactionSubgroupsRequest {
	return CashieringConfigAPIGetTemplateTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTransactionSubgroups
func (a *CashieringConfigAPIService) GetTemplateTransactionSubgroupsExecute(r CashieringConfigAPIGetTemplateTransactionSubgroupsRequest) (*TemplateTransactionSubgroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTransactionSubgroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTemplateTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
  }
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code for which the transaction codes belong to.
func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) HotelId(hotelId string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionArrangementCodesRequest) Execute() (*TransactionArrangementCodes, *http.Response, error) {
	return r.ApiService.GetTransactionArrangementCodesExecute(r)
}

/*
GetTransactionArrangementCodes Operation to fetch TransactionArrangementCodes.

 <p><strong>OperationId:</strong>getTransactionArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTransactionArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) GetTransactionArrangementCodes(ctx context.Context) CashieringConfigAPIGetTransactionArrangementCodesRequest {
	return CashieringConfigAPIGetTransactionArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionArrangementCodes
func (a *CashieringConfigAPIService) GetTransactionArrangementCodesExecute(r CashieringConfigAPIGetTransactionArrangementCodesRequest) (*TransactionArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionCodeRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	transactionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionCodeRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionCodeRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionCodeRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for transaction code instructions that can be used for partial operations.
func (r CashieringConfigAPIGetTransactionCodeRequest) FetchInstructions(fetchInstructions []string) CashieringConfigAPIGetTransactionCodeRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionCodeRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionCodeRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionCodeRequest) Execute() (*HotelTransactionCode, *http.Response, error) {
	return r.ApiService.GetTransactionCodeExecute(r)
}

/*
GetTransactionCode Get transaction codes

Use this API to return transaction codes based on search criteria such as hotelIds, transactionGroupCodes, transactionSubgroupsCodes, transactionCodes, description, etc.<p><strong>OperationId:</strong>getTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionCode Transaction Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetTransactionCodeRequest
*/
func (a *CashieringConfigAPIService) GetTransactionCode(ctx context.Context, transactionCode string, hotelId string) CashieringConfigAPIGetTransactionCodeRequest {
	return CashieringConfigAPIGetTransactionCodeRequest{
		ApiService: a,
		ctx: ctx,
		transactionCode: transactionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelTransactionCode
func (a *CashieringConfigAPIService) GetTransactionCodeExecute(r CashieringConfigAPIGetTransactionCodeRequest) (*HotelTransactionCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes/{transactionCode}/hotelTransactionCode"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionCode"+"}", url.PathEscape(parameterValueToString(r.transactionCode, "transactionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionCode must have at least 1 elements")
	}
	if strlen(r.transactionCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionCodeAccessRolesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roleCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes
func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) RoleCode(roleCode string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	r.roleCode = &roleCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) Execute() (*TransactionCodeAccessRoles, *http.Response, error) {
	return r.ApiService.GetTransactionCodeAccessRolesExecute(r)
}

/*
GetTransactionCodeAccessRoles Operation to fetch TransactionCodeAccessRoles.

Operation to Fetch Transaction Code Access Roles. <p><strong>OperationId:</strong>getTransactionCodeAccessRoles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetTransactionCodeAccessRolesRequest
*/
func (a *CashieringConfigAPIService) GetTransactionCodeAccessRoles(ctx context.Context, hotelId string) CashieringConfigAPIGetTransactionCodeAccessRolesRequest {
	return CashieringConfigAPIGetTransactionCodeAccessRolesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransactionCodeAccessRoles
func (a *CashieringConfigAPIService) GetTransactionCodeAccessRolesExecute(r CashieringConfigAPIGetTransactionCodeAccessRolesRequest) (*TransactionCodeAccessRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCodeAccessRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionCodeAccessRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodeAccessRoles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roleCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roleCode", r.roleCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTransactionCodes *bool
	includeInactive *bool
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	transactionCodes *[]string
	wildCard *string
	description *string
	brandCode *string
	universalProductCode *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTransactionCodesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTransactionCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate whether comp accounting transaction codes are being requested. If true, only comp accounting transaction codes will be returned. If false, only standard transaction codes will be returned.
func (r CashieringConfigAPIGetTransactionCodesRequest) CompTransactionCodes(compTransactionCodes bool) CashieringConfigAPIGetTransactionCodesRequest {
	r.compTransactionCodes = &compTransactionCodes
	return r
}

// Inactive flag used to include/exclude inactive transaction codes from the search result
func (r CashieringConfigAPIGetTransactionCodesRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetTransactionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r CashieringConfigAPIGetTransactionCodesRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigAPIGetTransactionCodesRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

func (r CashieringConfigAPIGetTransactionCodesRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigAPIGetTransactionCodesRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTransactionCodesRequest) TransactionCodes(transactionCodes []string) CashieringConfigAPIGetTransactionCodesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTransactionCodesRequest) WildCard(wildCard string) CashieringConfigAPIGetTransactionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the Transaction code.
func (r CashieringConfigAPIGetTransactionCodesRequest) Description(description string) CashieringConfigAPIGetTransactionCodesRequest {
	r.description = &description
	return r
}

// Property associated with the corporate information brand code in the search criteria
func (r CashieringConfigAPIGetTransactionCodesRequest) BrandCode(brandCode string) CashieringConfigAPIGetTransactionCodesRequest {
	r.brandCode = &brandCode
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigAPIGetTransactionCodesRequest) UniversalProductCode(universalProductCode string) CashieringConfigAPIGetTransactionCodesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionCodesRequest) Execute() (*HotelTransactionCodes, *http.Response, error) {
	return r.ApiService.GetTransactionCodesExecute(r)
}

/*
GetTransactionCodes Operation to fetch TransactionCodes.

Use this API to return transaction codes based on search criteria such as hotelIds, transactionGroupCodes, transactionSubgroupsCodes, transactionCodes, description, etc.. <p><strong>OperationId:</strong>getTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) GetTransactionCodes(ctx context.Context) CashieringConfigAPIGetTransactionCodesRequest {
	return CashieringConfigAPIGetTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HotelTransactionCodes
func (a *CashieringConfigAPIService) GetTransactionCodesExecute(r CashieringConfigAPIGetTransactionCodesRequest) (*HotelTransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.compTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTransactionCodes", r.compTransactionCodes, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
  }
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
  }
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.brandCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brandCode", r.brandCode, "")
  }
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionDiscountsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiscountCodes *[]string
	description *string
	ruleType *string
	membershipTypes *[]string
	membershipLevels *[]string
	fetchInstructions *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTransactionDiscountsRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionDiscountsRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionDiscountsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionDiscountsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Discount codes to be searched.
func (r CashieringConfigAPIGetTransactionDiscountsRequest) TransactionDiscountCodes(transactionDiscountCodes []string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.transactionDiscountCodes = &transactionDiscountCodes
	return r
}

// Description text set to the search criteria
func (r CashieringConfigAPIGetTransactionDiscountsRequest) Description(description string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.description = &description
	return r
}

// The rule type on which the transaction discount is based.
func (r CashieringConfigAPIGetTransactionDiscountsRequest) RuleType(ruleType string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.ruleType = &ruleType
	return r
}

// Membership Types set to the search criteria
func (r CashieringConfigAPIGetTransactionDiscountsRequest) MembershipTypes(membershipTypes []string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.membershipTypes = &membershipTypes
	return r
}

// Membership Levels set to the search criteria
func (r CashieringConfigAPIGetTransactionDiscountsRequest) MembershipLevels(membershipLevels []string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.membershipLevels = &membershipLevels
	return r
}

// When this fetch instruction is passed, the details of article codes and transaction codes attached to the transaction discount are fetched.
func (r CashieringConfigAPIGetTransactionDiscountsRequest) FetchInstructions(fetchInstructions []string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Indicator that tells whether to include inactive transaction discounts in search results.
func (r CashieringConfigAPIGetTransactionDiscountsRequest) IncludeInactive(includeInactive bool) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionDiscountsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionDiscountsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionDiscountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionDiscountsRequest) Execute() (*TransactionDiscounts, *http.Response, error) {
	return r.ApiService.GetTransactionDiscountsExecute(r)
}

/*
GetTransactionDiscounts Operation to fetch TransactionDiscounts.

Operation to fetch Transaction Discounts. <p><strong>OperationId:</strong>getTransactionDiscounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTransactionDiscountsRequest
*/
func (a *CashieringConfigAPIService) GetTransactionDiscounts(ctx context.Context) CashieringConfigAPIGetTransactionDiscountsRequest {
	return CashieringConfigAPIGetTransactionDiscountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionDiscounts
func (a *CashieringConfigAPIService) GetTransactionDiscountsExecute(r CashieringConfigAPIGetTransactionDiscountsRequest) (*TransactionDiscounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionDiscounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionDiscounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionDiscounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionDiscountCodes != nil {
		t := *r.transactionDiscountCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDiscountCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDiscountCodes", t, "multi")
		}
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.ruleType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ruleType", r.ruleType, "")
  }
	if r.membershipTypes != nil {
		t := *r.membershipTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypes", t, "multi")
		}
  }
	if r.membershipLevels != nil {
		t := *r.membershipLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevels", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionDiversionRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	ruleCodes *[]string
	wildCard *string
	type_ *string
	description *string
	level *string
	membershipTypeCodes *[]string
	membershipTypeLevels *[]string
	vipCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) RuleCodes(ruleCodes []string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.ruleCodes = &ruleCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) WildCard(wildCard string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.wildCard = &wildCard
	return r
}

// The rule type on which the Transaction Diversion Rule is based. If a reservation has any of the following code, Transaction Diversion rule gets active for that reservation
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) Type_(type_ string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.type_ = &type_
	return r
}

// User defined message for the Transaction Diversion Rule.
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) Description(description string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.description = &description
	return r
}

// Reservation level.
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) Level(level string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.level = &level
	return r
}

func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) MembershipTypeCodes(membershipTypeCodes []string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.membershipTypeCodes = &membershipTypeCodes
	return r
}

func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) MembershipTypeLevels(membershipTypeLevels []string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.membershipTypeLevels = &membershipTypeLevels
	return r
}

func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) VipCodes(vipCodes []string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.vipCodes = &vipCodes
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionDiversionRulesRequest) Execute() (*TransactionDiversionRules, *http.Response, error) {
	return r.ApiService.GetTransactionDiversionRulesExecute(r)
}

/*
GetTransactionDiversionRules Operation to fetch TransactionDiversionRules.

Operation to fetch Transaction Diversion Rules. <p><strong>OperationId:</strong>getTransactionDiversionRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTransactionDiversionRulesRequest
*/
func (a *CashieringConfigAPIService) GetTransactionDiversionRules(ctx context.Context) CashieringConfigAPIGetTransactionDiversionRulesRequest {
	return CashieringConfigAPIGetTransactionDiversionRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionDiversionRules
func (a *CashieringConfigAPIService) GetTransactionDiversionRulesExecute(r CashieringConfigAPIGetTransactionDiversionRulesRequest) (*TransactionDiversionRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionDiversionRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionDiversionRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionDiversionRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.ruleCodes != nil {
		t := *r.ruleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ruleCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ruleCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "")
  }
	if r.membershipTypeCodes != nil {
		t := *r.membershipTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCodes", t, "multi")
		}
  }
	if r.membershipTypeLevels != nil {
		t := *r.membershipTypeLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeLevels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeLevels", t, "multi")
		}
  }
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionGroupRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	transactionGroupCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionGroupRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionGroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionGroupRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionGroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionGroupRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionGroupRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for transaction group instructions that can be used for partial operations.
func (r CashieringConfigAPIGetTransactionGroupRequest) FetchInstructions(fetchInstructions []string) CashieringConfigAPIGetTransactionGroupRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionGroupRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionGroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionGroupRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionGroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionGroupRequest) Execute() (*TransactionGroup, *http.Response, error) {
	return r.ApiService.GetTransactionGroupExecute(r)
}

/*
GetTransactionGroup Operation to fetch TransactionGroup.

Operation to fetch detailed transaction group. <p><strong>OperationId:</strong>getTransactionGroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionGroupCode Transaction Group Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetTransactionGroupRequest
*/
func (a *CashieringConfigAPIService) GetTransactionGroup(ctx context.Context, transactionGroupCode string, hotelId string) CashieringConfigAPIGetTransactionGroupRequest {
	return CashieringConfigAPIGetTransactionGroupRequest{
		ApiService: a,
		ctx: ctx,
		transactionGroupCode: transactionGroupCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransactionGroup
func (a *CashieringConfigAPIService) GetTransactionGroupExecute(r CashieringConfigAPIGetTransactionGroupRequest) (*TransactionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionGroupCode/{transactionGroupCode}/transactionGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionGroupCode"+"}", url.PathEscape(parameterValueToString(r.transactionGroupCode, "transactionGroupCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionGroupCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionGroupCode must have at least 1 elements")
	}
	if strlen(r.transactionGroupCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionGroupCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	wildCard *string
	transactionGroupType *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTransactionGroupsRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTransactionGroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTransactionGroupsRequest) WildCard(wildCard string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Wrapper Transaction Type.
func (r CashieringConfigAPIGetTransactionGroupsRequest) TransactionGroupType(transactionGroupType string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.transactionGroupType = &transactionGroupType
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionGroupsRequest) Execute() (*TransactionGroups, *http.Response, error) {
	return r.ApiService.GetTransactionGroupsExecute(r)
}

/*
GetTransactionGroups Operation to fetch TransactionGroups.

Operation to fetch transaction groups. <p><strong>OperationId:</strong>getTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) GetTransactionGroups(ctx context.Context) CashieringConfigAPIGetTransactionGroupsRequest {
	return CashieringConfigAPIGetTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionGroups
func (a *CashieringConfigAPIService) GetTransactionGroupsExecute(r CashieringConfigAPIGetTransactionGroupsRequest) (*TransactionGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.transactionGroupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupType", r.transactionGroupType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionSubgroupRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	transactionGroupCode string
	transactionSubGroupCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionSubgroupRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionSubgroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionSubgroupRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionSubgroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionSubgroupRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionSubgroupRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for transaction sub group instructions that can be used for partial operations.
func (r CashieringConfigAPIGetTransactionSubgroupRequest) FetchInstructions(fetchInstructions []string) CashieringConfigAPIGetTransactionSubgroupRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionSubgroupRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionSubgroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionSubgroupRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionSubgroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionSubgroupRequest) Execute() (*HotelTransactionSubgroup, *http.Response, error) {
	return r.ApiService.GetTransactionSubgroupExecute(r)
}

/*
GetTransactionSubgroup Operation to fetch TransactionGroup.

Operation to fetch detailed transaction sub group. <p><strong>OperationId:</strong>getTransactionSubgroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionGroupCode Transaction Group Code in OPERA
 @param transactionSubGroupCode Transaction SubGroup Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIGetTransactionSubgroupRequest
*/
func (a *CashieringConfigAPIService) GetTransactionSubgroup(ctx context.Context, transactionGroupCode string, transactionSubGroupCode string, hotelId string) CashieringConfigAPIGetTransactionSubgroupRequest {
	return CashieringConfigAPIGetTransactionSubgroupRequest{
		ApiService: a,
		ctx: ctx,
		transactionGroupCode: transactionGroupCode,
		transactionSubGroupCode: transactionSubGroupCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelTransactionSubgroup
func (a *CashieringConfigAPIService) GetTransactionSubgroupExecute(r CashieringConfigAPIGetTransactionSubgroupRequest) (*HotelTransactionSubgroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionSubgroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionSubgroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionSubGroupCodes/{transactionSubGroupCode}/transactionGroupCodes/{transactionGroupCode}/transactionSubGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionGroupCode"+"}", url.PathEscape(parameterValueToString(r.transactionGroupCode, "transactionGroupCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionSubGroupCode"+"}", url.PathEscape(parameterValueToString(r.transactionSubGroupCode, "transactionSubGroupCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionGroupCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionGroupCode must have at least 1 elements")
	}
	if strlen(r.transactionGroupCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionGroupCode must have less than 2000 elements")
	}
	if strlen(r.transactionSubGroupCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionSubGroupCode must have at least 1 elements")
	}
	if strlen(r.transactionSubGroupCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionSubGroupCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIGetTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigAPIGetTransactionSubgroupsRequest) HotelIds(hotelIds []string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigAPIGetTransactionSubgroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) WildCard(wildCard string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIGetTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIGetTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIGetTransactionSubgroupsRequest) Execute() (*HotelTransactionSubgroups, *http.Response, error) {
	return r.ApiService.GetTransactionSubgroupsExecute(r)
}

/*
GetTransactionSubgroups Operation to fetch TransactionSubgroups.

Operation to fetch transaction sub groups. <p><strong>OperationId:</strong>getTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIGetTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) GetTransactionSubgroups(ctx context.Context) CashieringConfigAPIGetTransactionSubgroupsRequest {
	return CashieringConfigAPIGetTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HotelTransactionSubgroups
func (a *CashieringConfigAPIService) GetTransactionSubgroupsExecute(r CashieringConfigAPIGetTransactionSubgroupsRequest) (*HotelTransactionSubgroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionSubgroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.GetTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
  }
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *AdjustmentCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigAPIPostAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Adjustment Code Configurations.
func (r CashieringConfigAPIPostAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes AdjustmentCodes) CashieringConfigAPIPostAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdjustmentCodesExecute(r)
}

/*
PostAdjustmentCodes Operation to create AdjustmentCodes.

Operation to create Adjustment Codes. <p><strong>OperationId:</strong>postAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostAdjustmentCodesRequest
*/
func (a *CashieringConfigAPIService) PostAdjustmentCodes(ctx context.Context) CashieringConfigAPIPostAdjustmentCodesRequest {
	return CashieringConfigAPIPostAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostAdjustmentCodesExecute(r CashieringConfigAPIPostAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *Articles
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostArticlesRequest) Authorization(authorization string) CashieringConfigAPIPostArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostArticlesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostArticlesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create articles.
func (r CashieringConfigAPIPostArticlesRequest) Articles(articles Articles) CashieringConfigAPIPostArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r CashieringConfigAPIPostArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostArticlesExecute(r)
}

/*
PostArticles Operation to create Articles.

Operation to create articles. <p><strong>OperationId:</strong>postArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostArticlesRequest
*/
func (a *CashieringConfigAPIService) PostArticles(ctx context.Context) CashieringConfigAPIPostArticlesRequest {
	return CashieringConfigAPIPostArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostArticlesExecute(r CashieringConfigAPIPostArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *AuthorizationConfigRules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new authorization rule for given hotel code.
func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules AuthorizationConfigRules) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizationConfigRuleExecute(r)
}

/*
PostAuthorizationConfigRule Operation to create AuthorizationConfigRule.

 <p><strong>OperationId:</strong>postAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigAPIService) PostAuthorizationConfigRule(ctx context.Context) CashieringConfigAPIPostAuthorizationConfigRuleRequest {
	return CashieringConfigAPIPostAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostAuthorizationConfigRuleExecute(r CashieringConfigAPIPostAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroups *AuthorizerGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigAPIPostAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Authorizer Group Configuration.
func (r CashieringConfigAPIPostAuthorizerGroupsRequest) AuthorizerGroups(authorizerGroups AuthorizerGroups) CashieringConfigAPIPostAuthorizerGroupsRequest {
	r.authorizerGroups = &authorizerGroups
	return r
}

// External system code.
func (r CashieringConfigAPIPostAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizerGroupsExecute(r)
}

/*
PostAuthorizerGroups Operation to create AuthorizerGroups.

Operation to create Authorizer Groups. <p><strong>OperationId:</strong>postAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostAuthorizerGroupsRequest
*/
func (a *CashieringConfigAPIService) PostAuthorizerGroups(ctx context.Context) CashieringConfigAPIPostAuthorizerGroupsRequest {
	return CashieringConfigAPIPostAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostAuthorizerGroupsExecute(r CashieringConfigAPIPostAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *Cashiers
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCashiersRequest) Authorization(authorization string) CashieringConfigAPIPostCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCashiersRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCashiersRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating cashiers.
func (r CashieringConfigAPIPostCashiersRequest) Cashiers(cashiers Cashiers) CashieringConfigAPIPostCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r CashieringConfigAPIPostCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCashiersExecute(r)
}

/*
PostCashiers Operation to create Cashiers.

Operation to Create Cashier. <p><strong>OperationId:</strong>postCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostCashiersRequest
*/
func (a *CashieringConfigAPIService) PostCashiers(ctx context.Context) CashieringConfigAPIPostCashiersRequest {
	return CashieringConfigAPIPostCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCashiersExecute(r CashieringConfigAPIPostCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCollectingAgentTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	collectingAgentTaxes *CollectingAgentTaxes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) Authorization(authorization string) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Collecting Agent Taxes.
func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) CollectingAgentTaxes(collectingAgentTaxes CollectingAgentTaxes) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	r.collectingAgentTaxes = &collectingAgentTaxes
	return r
}

// External system code.
func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCollectingAgentTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCollectingAgentTaxesExecute(r)
}

/*
PostCollectingAgentTaxes Operation to create CollectingAgentTaxes.

Operation to create Collecting Agent Taxes. <p><strong>OperationId:</strong>postCollectingAgentTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostCollectingAgentTaxesRequest
*/
func (a *CashieringConfigAPIService) PostCollectingAgentTaxes(ctx context.Context) CashieringConfigAPIPostCollectingAgentTaxesRequest {
	return CashieringConfigAPIPostCollectingAgentTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCollectingAgentTaxesExecute(r CashieringConfigAPIPostCollectingAgentTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCollectingAgentTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/collectingAgentTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.collectingAgentTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCompBucketRedemptionConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compBucketRedemptionConfig *CompBucketRedemptionConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) Authorization(authorization string) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Comp Bucket Redemption Codes configurations.
func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) CompBucketRedemptionConfig(compBucketRedemptionConfig CompBucketRedemptionConfig) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	r.compBucketRedemptionConfig = &compBucketRedemptionConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompBucketRedemptionConfigExecute(r)
}

/*
PostCompBucketRedemptionConfig Operation to create Comp Bucket Redemption Codes.

Operation to create Comp Bucket Redemption Codes. <p><strong>OperationId:</strong>postCompBucketRedemptionConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPostCompBucketRedemptionConfigRequest
*/
func (a *CashieringConfigAPIService) PostCompBucketRedemptionConfig(ctx context.Context, hotelId string) CashieringConfigAPIPostCompBucketRedemptionConfigRequest {
	return CashieringConfigAPIPostCompBucketRedemptionConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCompBucketRedemptionConfigExecute(r CashieringConfigAPIPostCompBucketRedemptionConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCompBucketRedemptionConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compBucket/redemption"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compBucketRedemptionConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesCriteria *CompTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCompTypesRequest) Authorization(authorization string) CashieringConfigAPIPostCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCompTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCompTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating CompTypes.
func (r CashieringConfigAPIPostCompTypesRequest) CompTypesCriteria(compTypesCriteria CompTypesCriteria) CashieringConfigAPIPostCompTypesRequest {
	r.compTypesCriteria = &compTypesCriteria
	return r
}

// External system code.
func (r CashieringConfigAPIPostCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompTypesExecute(r)
}

/*
PostCompTypes Operation to Create Comp Types

Operation to Create Comp Types <p><strong>OperationId:</strong>postCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostCompTypesRequest
*/
func (a *CashieringConfigAPIService) PostCompTypes(ctx context.Context) CashieringConfigAPIPostCompTypesRequest {
	return CashieringConfigAPIPostCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCompTypesExecute(r CashieringConfigAPIPostCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *CurrencyExchangeServiceTaxes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new currency exchange service taxes
func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes CurrencyExchangeServiceTaxes) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCurrencyExchangeServiceTaxesExecute(r)
}

/*
PostCurrencyExchangeServiceTaxes Operation to create CurrencyExchangeServiceTaxes.

Operation to create currency exchange service taxes. <p><strong>OperationId:</strong>postCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigAPIService) PostCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCurrencyExchangeServiceTaxesExecute(r CashieringConfigAPIPostCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCustomChargeExemptionsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customChargeExemptionsConfigToBeCreated *CustomChargeExemptionsConfigToBeCreated
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) Authorization(authorization string) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// New one or more Custom Charge Exemptions to be created.
func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) CustomChargeExemptionsConfigToBeCreated(customChargeExemptionsConfigToBeCreated CustomChargeExemptionsConfigToBeCreated) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	r.customChargeExemptionsConfigToBeCreated = &customChargeExemptionsConfigToBeCreated
	return r
}

// External system code.
func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCustomChargeExemptionsConfigExecute(r)
}

/*
PostCustomChargeExemptionsConfig Operation to create Custom Charge Exemptions Config.

Operation to create Custom Charge Exemptions Config. <p><strong>OperationId:</strong>postCustomChargeExemptionsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPostCustomChargeExemptionsConfigRequest
*/
func (a *CashieringConfigAPIService) PostCustomChargeExemptionsConfig(ctx context.Context, hotelId string) CashieringConfigAPIPostCustomChargeExemptionsConfigRequest {
	return CashieringConfigAPIPostCustomChargeExemptionsConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCustomChargeExemptionsConfigExecute(r CashieringConfigAPIPostCustomChargeExemptionsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCustomChargeExemptionsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/exemptions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customChargeExemptionsConfigToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCustomChargesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customChargesConfig *CustomChargesConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCustomChargesConfigRequest) Authorization(authorization string) CashieringConfigAPIPostCustomChargesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCustomChargesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCustomChargesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCustomChargesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCustomChargesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Custom Charges.
func (r CashieringConfigAPIPostCustomChargesConfigRequest) CustomChargesConfig(customChargesConfig CustomChargesConfig) CashieringConfigAPIPostCustomChargesConfigRequest {
	r.customChargesConfig = &customChargesConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPostCustomChargesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCustomChargesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCustomChargesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCustomChargesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCustomChargesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCustomChargesConfigExecute(r)
}

/*
PostCustomChargesConfig Operation to create Custom Charge Codes.

Operation to create Custom Charge Codes. <p><strong>OperationId:</strong>postCustomChargesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPostCustomChargesConfigRequest
*/
func (a *CashieringConfigAPIService) PostCustomChargesConfig(ctx context.Context, hotelId string) CashieringConfigAPIPostCustomChargesConfigRequest {
	return CashieringConfigAPIPostCustomChargesConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCustomChargesConfigExecute(r CashieringConfigAPIPostCustomChargesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCustomChargesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customChargesConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customNumberConfiguration *CustomNumberConfiguration
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIPostCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create custom number configuration.
func (r CashieringConfigAPIPostCustomNumberConfigRequest) CustomNumberConfiguration(customNumberConfiguration CustomNumberConfiguration) CashieringConfigAPIPostCustomNumberConfigRequest {
	r.customNumberConfiguration = &customNumberConfiguration
	return r
}

// External system code.
func (r CashieringConfigAPIPostCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostCustomNumberConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCustomNumberConfigExecute(r)
}

/*
PostCustomNumberConfig Operation to create custom number config.

 <p><strong>OperationId:</strong>postCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPostCustomNumberConfigRequest
*/
func (a *CashieringConfigAPIService) PostCustomNumberConfig(ctx context.Context, hotelId string) CashieringConfigAPIPostCustomNumberConfigRequest {
	return CashieringConfigAPIPostCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostCustomNumberConfigExecute(r CashieringConfigAPIPostCustomNumberConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customNumbers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customNumberConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *ExpenseArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new expense arrangement codes.
func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes ExpenseArrangementCodes) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExpenseArrangementCodesExecute(r)
}

/*
PostExpenseArrangementCodes Operation to create ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>postExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostExpenseArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PostExpenseArrangementCodes(ctx context.Context) CashieringConfigAPIPostExpenseArrangementCodesRequest {
	return CashieringConfigAPIPostExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostExpenseArrangementCodesExecute(r CashieringConfigAPIPostExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFiscalPartnersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createFiscalPartners *CreateFiscalPartners
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFiscalPartnersRequest) Authorization(authorization string) CashieringConfigAPIPostFiscalPartnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFiscalPartnersRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFiscalPartnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFiscalPartnersRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFiscalPartnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Fiscal Partners.
func (r CashieringConfigAPIPostFiscalPartnersRequest) CreateFiscalPartners(createFiscalPartners CreateFiscalPartners) CashieringConfigAPIPostFiscalPartnersRequest {
	r.createFiscalPartners = &createFiscalPartners
	return r
}

// External system code.
func (r CashieringConfigAPIPostFiscalPartnersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFiscalPartnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFiscalPartnersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFiscalPartnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFiscalPartnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalPartnersExecute(r)
}

/*
PostFiscalPartners Create fiscal partners

Use this API to create fiscal partners. <p><strong>OperationId:</strong>postFiscalPartners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return CashieringConfigAPIPostFiscalPartnersRequest
*/
func (a *CashieringConfigAPIService) PostFiscalPartners(ctx context.Context, hotelId string) CashieringConfigAPIPostFiscalPartnersRequest {
	return CashieringConfigAPIPostFiscalPartnersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFiscalPartnersExecute(r CashieringConfigAPIPostFiscalPartnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFiscalPartners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalPartners"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createFiscalPartners
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFiscalPeriodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalPeriods *FiscalPeriods
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFiscalPeriodsRequest) Authorization(authorization string) CashieringConfigAPIPostFiscalPeriodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFiscalPeriodsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFiscalPeriodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFiscalPeriodsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFiscalPeriodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Fiscal Periods
func (r CashieringConfigAPIPostFiscalPeriodsRequest) FiscalPeriods(fiscalPeriods FiscalPeriods) CashieringConfigAPIPostFiscalPeriodsRequest {
	r.fiscalPeriods = &fiscalPeriods
	return r
}

// External system code.
func (r CashieringConfigAPIPostFiscalPeriodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFiscalPeriodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFiscalPeriodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFiscalPeriodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFiscalPeriodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalPeriodsExecute(r)
}

/*
PostFiscalPeriods Operation to create FiscalPeriods.

Operation to create Fiscal Periods. <p><strong>OperationId:</strong>postFiscalPeriods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostFiscalPeriodsRequest
*/
func (a *CashieringConfigAPIService) PostFiscalPeriods(ctx context.Context) CashieringConfigAPIPostFiscalPeriodsRequest {
	return CashieringConfigAPIPostFiscalPeriodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFiscalPeriodsExecute(r CashieringConfigAPIPostFiscalPeriodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFiscalPeriods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalPeriods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalPeriods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFiscalYearsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalYears *FiscalYears
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFiscalYearsRequest) Authorization(authorization string) CashieringConfigAPIPostFiscalYearsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFiscalYearsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFiscalYearsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFiscalYearsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFiscalYearsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Fiscal Years
func (r CashieringConfigAPIPostFiscalYearsRequest) FiscalYears(fiscalYears FiscalYears) CashieringConfigAPIPostFiscalYearsRequest {
	r.fiscalYears = &fiscalYears
	return r
}

// External system code.
func (r CashieringConfigAPIPostFiscalYearsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFiscalYearsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFiscalYearsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFiscalYearsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFiscalYearsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalYearsExecute(r)
}

/*
PostFiscalYears Operation to create FiscalYears.

Operation to create Fiscal Years. <p><strong>OperationId:</strong>postFiscalYears</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostFiscalYearsRequest
*/
func (a *CashieringConfigAPIService) PostFiscalYears(ctx context.Context) CashieringConfigAPIPostFiscalYearsRequest {
	return CashieringConfigAPIPostFiscalYearsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFiscalYearsExecute(r CashieringConfigAPIPostFiscalYearsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFiscalYears")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalYears"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalYears
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFolioArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioArrangementCodes *FolioArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFolioArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPostFolioArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFolioArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFolioArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFolioArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFolioArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new folio arrangement codes.
func (r CashieringConfigAPIPostFolioArrangementCodesRequest) FolioArrangementCodes(folioArrangementCodes FolioArrangementCodes) CashieringConfigAPIPostFolioArrangementCodesRequest {
	r.folioArrangementCodes = &folioArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostFolioArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFolioArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFolioArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFolioArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFolioArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioArrangementCodesExecute(r)
}

/*
PostFolioArrangementCodes Operation to create FolioArrangementCodes.

 <p><strong>OperationId:</strong>postFolioArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostFolioArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PostFolioArrangementCodes(ctx context.Context) CashieringConfigAPIPostFolioArrangementCodesRequest {
	return CashieringConfigAPIPostFolioArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFolioArrangementCodesExecute(r CashieringConfigAPIPostFolioArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFolioArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFolioPrintQueuesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioPrintQueues *FolioPrintQueues
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFolioPrintQueuesRequest) Authorization(authorization string) CashieringConfigAPIPostFolioPrintQueuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFolioPrintQueuesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFolioPrintQueuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFolioPrintQueuesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFolioPrintQueuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new folio print queues
func (r CashieringConfigAPIPostFolioPrintQueuesRequest) FolioPrintQueues(folioPrintQueues FolioPrintQueues) CashieringConfigAPIPostFolioPrintQueuesRequest {
	r.folioPrintQueues = &folioPrintQueues
	return r
}

// External system code.
func (r CashieringConfigAPIPostFolioPrintQueuesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFolioPrintQueuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFolioPrintQueuesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFolioPrintQueuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFolioPrintQueuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioPrintQueuesExecute(r)
}

/*
PostFolioPrintQueues Operation to create FolioPrintQueues.

Operation to create folio print queues. <p><strong>OperationId:</strong>postFolioPrintQueues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostFolioPrintQueuesRequest
*/
func (a *CashieringConfigAPIService) PostFolioPrintQueues(ctx context.Context) CashieringConfigAPIPostFolioPrintQueuesRequest {
	return CashieringConfigAPIPostFolioPrintQueuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFolioPrintQueuesExecute(r CashieringConfigAPIPostFolioPrintQueuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFolioPrintQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioPrintQueues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioPrintQueues
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigCriteria *FolioTypeLegendMappingConfigCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create folio type legend mapping information.
func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigCriteria(folioTypeLegendMappingConfigCriteria FolioTypeLegendMappingConfigCriteria) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigCriteria = &folioTypeLegendMappingConfigCriteria
	return r
}

// External system code.
func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioTypeLegendMappingConfigExecute(r)
}

/*
PostFolioTypeLegendMappingConfig Operation to create folio type legend mappings config.

Operation to create folio type legend mappings config. <p><strong>OperationId:</strong>postFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigAPIService) PostFolioTypeLegendMappingConfig(ctx context.Context) CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest {
	return CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFolioTypeLegendMappingConfigExecute(r CashieringConfigAPIPostFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostFolioTypesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypesConfig *FolioTypesConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostFolioTypesConfigRequest) Authorization(authorization string) CashieringConfigAPIPostFolioTypesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostFolioTypesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostFolioTypesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostFolioTypesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostFolioTypesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Folio Type Name.
func (r CashieringConfigAPIPostFolioTypesConfigRequest) FolioTypesConfig(folioTypesConfig FolioTypesConfig) CashieringConfigAPIPostFolioTypesConfigRequest {
	r.folioTypesConfig = &folioTypesConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPostFolioTypesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostFolioTypesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostFolioTypesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostFolioTypesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostFolioTypesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioTypesConfigExecute(r)
}

/*
PostFolioTypesConfig Operation to create FolioTypesConfig.

Operation to Create Folio Type Names. <p><strong>OperationId:</strong>postFolioTypesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostFolioTypesConfigRequest
*/
func (a *CashieringConfigAPIService) PostFolioTypesConfig(ctx context.Context) CashieringConfigAPIPostFolioTypesConfigRequest {
	return CashieringConfigAPIPostFolioTypesConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostFolioTypesConfigExecute(r CashieringConfigAPIPostFolioTypesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostFolioTypesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypesConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypesConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostForeignCurrenciesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	foreignCurrencies *ForeignCurrencies
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostForeignCurrenciesRequest) Authorization(authorization string) CashieringConfigAPIPostForeignCurrenciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostForeignCurrenciesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostForeignCurrenciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostForeignCurrenciesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostForeignCurrenciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Foreign Currencies
func (r CashieringConfigAPIPostForeignCurrenciesRequest) ForeignCurrencies(foreignCurrencies ForeignCurrencies) CashieringConfigAPIPostForeignCurrenciesRequest {
	r.foreignCurrencies = &foreignCurrencies
	return r
}

// External system code.
func (r CashieringConfigAPIPostForeignCurrenciesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostForeignCurrenciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostForeignCurrenciesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostForeignCurrenciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostForeignCurrenciesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostForeignCurrenciesExecute(r)
}

/*
PostForeignCurrencies Operation to create ForeignCurrencies.

Operation to create Foreign Currencies. <p><strong>OperationId:</strong>postForeignCurrencies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostForeignCurrenciesRequest
*/
func (a *CashieringConfigAPIService) PostForeignCurrencies(ctx context.Context) CashieringConfigAPIPostForeignCurrenciesRequest {
	return CashieringConfigAPIPostForeignCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostForeignCurrenciesExecute(r CashieringConfigAPIPostForeignCurrenciesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostForeignCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.foreignCurrencies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostGroupArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	groupArrangementCodes *GroupArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostGroupArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPostGroupArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostGroupArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostGroupArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostGroupArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostGroupArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new group arrangement codes.
func (r CashieringConfigAPIPostGroupArrangementCodesRequest) GroupArrangementCodes(groupArrangementCodes GroupArrangementCodes) CashieringConfigAPIPostGroupArrangementCodesRequest {
	r.groupArrangementCodes = &groupArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostGroupArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostGroupArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostGroupArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostGroupArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostGroupArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGroupArrangementCodesExecute(r)
}

/*
PostGroupArrangementCodes Operation to create GroupArrangementCodes.

 <p><strong>OperationId:</strong>postGroupArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostGroupArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PostGroupArrangementCodes(ctx context.Context) CashieringConfigAPIPostGroupArrangementCodesRequest {
	return CashieringConfigAPIPostGroupArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostGroupArrangementCodesExecute(r CashieringConfigAPIPostGroupArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostGroupArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groupArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.groupArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostNoShowPostingRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	noShowPostingRules *NoShowPostingRules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostNoShowPostingRulesRequest) Authorization(authorization string) CashieringConfigAPIPostNoShowPostingRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostNoShowPostingRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostNoShowPostingRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostNoShowPostingRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostNoShowPostingRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new No Show Posting Rule Configuration.
func (r CashieringConfigAPIPostNoShowPostingRulesRequest) NoShowPostingRules(noShowPostingRules NoShowPostingRules) CashieringConfigAPIPostNoShowPostingRulesRequest {
	r.noShowPostingRules = &noShowPostingRules
	return r
}

// External system code.
func (r CashieringConfigAPIPostNoShowPostingRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostNoShowPostingRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostNoShowPostingRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostNoShowPostingRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostNoShowPostingRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostNoShowPostingRulesExecute(r)
}

/*
PostNoShowPostingRules Operation to create NoShowPostingRules.

Operation to create No Show Posting Rules. <p><strong>OperationId:</strong>postNoShowPostingRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostNoShowPostingRulesRequest
*/
func (a *CashieringConfigAPIService) PostNoShowPostingRules(ctx context.Context) CashieringConfigAPIPostNoShowPostingRulesRequest {
	return CashieringConfigAPIPostNoShowPostingRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostNoShowPostingRulesExecute(r CashieringConfigAPIPostNoShowPostingRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostNoShowPostingRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noShowPostingRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.noShowPostingRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostPackageArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	packageArrangementCodes *PackageArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostPackageArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPostPackageArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostPackageArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostPackageArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostPackageArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostPackageArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new package arrangement codes.
func (r CashieringConfigAPIPostPackageArrangementCodesRequest) PackageArrangementCodes(packageArrangementCodes PackageArrangementCodes) CashieringConfigAPIPostPackageArrangementCodesRequest {
	r.packageArrangementCodes = &packageArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostPackageArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostPackageArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostPackageArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostPackageArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostPackageArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPackageArrangementCodesExecute(r)
}

/*
PostPackageArrangementCodes Operation to create PackageArrangementCodes.

 <p><strong>OperationId:</strong>postPackageArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostPackageArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PostPackageArrangementCodes(ctx context.Context) CashieringConfigAPIPostPackageArrangementCodesRequest {
	return CashieringConfigAPIPostPackageArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostPackageArrangementCodesExecute(r CashieringConfigAPIPostPackageArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostPackageArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	paymentMethods *PaymentMethods
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostPaymentMethodsRequest) Authorization(authorization string) CashieringConfigAPIPostPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostPaymentMethodsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostPaymentMethodsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create payment methods.
func (r CashieringConfigAPIPostPaymentMethodsRequest) PaymentMethods(paymentMethods PaymentMethods) CashieringConfigAPIPostPaymentMethodsRequest {
	r.paymentMethods = &paymentMethods
	return r
}

// External system code.
func (r CashieringConfigAPIPostPaymentMethodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostPaymentMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPaymentMethodsExecute(r)
}

/*
PostPaymentMethods Operation to create PaymentMethods.

Operation to create payment methods. <p><strong>OperationId:</strong>postPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostPaymentMethodsRequest
*/
func (a *CashieringConfigAPIService) PostPaymentMethods(ctx context.Context) CashieringConfigAPIPostPaymentMethodsRequest {
	return CashieringConfigAPIPostPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostPaymentMethodsExecute(r CashieringConfigAPIPostPaymentMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelPaymentMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.paymentMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostRevenueBucketCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketCodes *RevenueBucketCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostRevenueBucketCodesRequest) Authorization(authorization string) CashieringConfigAPIPostRevenueBucketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostRevenueBucketCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostRevenueBucketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostRevenueBucketCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostRevenueBucketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Revenue Bucket Codes Configurations.
func (r CashieringConfigAPIPostRevenueBucketCodesRequest) RevenueBucketCodes(revenueBucketCodes RevenueBucketCodes) CashieringConfigAPIPostRevenueBucketCodesRequest {
	r.revenueBucketCodes = &revenueBucketCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostRevenueBucketCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostRevenueBucketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostRevenueBucketCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostRevenueBucketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostRevenueBucketCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRevenueBucketCodesExecute(r)
}

/*
PostRevenueBucketCodes Operation to create RevenueBucketCodes.

Operation to create Revenue Bucket Codes. <p><strong>OperationId:</strong>postRevenueBucketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostRevenueBucketCodesRequest
*/
func (a *CashieringConfigAPIService) PostRevenueBucketCodes(ctx context.Context) CashieringConfigAPIPostRevenueBucketCodesRequest {
	return CashieringConfigAPIPostRevenueBucketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostRevenueBucketCodesExecute(r CashieringConfigAPIPostRevenueBucketCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostRevenueBucketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueBucketCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostRevenueBucketTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketTypes *RevenueBucketTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostRevenueBucketTypesRequest) Authorization(authorization string) CashieringConfigAPIPostRevenueBucketTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostRevenueBucketTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostRevenueBucketTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostRevenueBucketTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostRevenueBucketTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Revenue Bucket Types Configurations.
func (r CashieringConfigAPIPostRevenueBucketTypesRequest) RevenueBucketTypes(revenueBucketTypes RevenueBucketTypes) CashieringConfigAPIPostRevenueBucketTypesRequest {
	r.revenueBucketTypes = &revenueBucketTypes
	return r
}

// External system code.
func (r CashieringConfigAPIPostRevenueBucketTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostRevenueBucketTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostRevenueBucketTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostRevenueBucketTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostRevenueBucketTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRevenueBucketTypesExecute(r)
}

/*
PostRevenueBucketTypes Operation to create RevenueBucketTypes.

Operation to create Revenue Bucket Types. <p><strong>OperationId:</strong>postRevenueBucketTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostRevenueBucketTypesRequest
*/
func (a *CashieringConfigAPIService) PostRevenueBucketTypes(ctx context.Context) CashieringConfigAPIPostRevenueBucketTypesRequest {
	return CashieringConfigAPIPostRevenueBucketTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostRevenueBucketTypesExecute(r CashieringConfigAPIPostRevenueBucketTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostRevenueBucketTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueBucketTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostRevenueTypeMappingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueTypeMapping *RevenueTypeMapping
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostRevenueTypeMappingRequest) Authorization(authorization string) CashieringConfigAPIPostRevenueTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostRevenueTypeMappingRequest) XAppKey(xAppKey string) CashieringConfigAPIPostRevenueTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostRevenueTypeMappingRequest) XHotelid(xHotelid string) CashieringConfigAPIPostRevenueTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Revenue Type Mapping configurations.
func (r CashieringConfigAPIPostRevenueTypeMappingRequest) RevenueTypeMapping(revenueTypeMapping RevenueTypeMapping) CashieringConfigAPIPostRevenueTypeMappingRequest {
	r.revenueTypeMapping = &revenueTypeMapping
	return r
}

// External system code.
func (r CashieringConfigAPIPostRevenueTypeMappingRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostRevenueTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostRevenueTypeMappingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostRevenueTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostRevenueTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRevenueTypeMappingExecute(r)
}

/*
PostRevenueTypeMapping Post revenue type mapping

Use this API to update transaction generates for a specific property.  Generates are rules used to calculate and post additional charges, such as service charges and taxes, when a particular sales charge transaction code is posted to guest, package or AR ledgers.<p><strong>OperationId:</strong>putTransactionGenerates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostRevenueTypeMappingRequest
*/
func (a *CashieringConfigAPIService) PostRevenueTypeMapping(ctx context.Context) CashieringConfigAPIPostRevenueTypeMappingRequest {
	return CashieringConfigAPIPostRevenueTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostRevenueTypeMappingExecute(r CashieringConfigAPIPostRevenueTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostRevenueTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypeMapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueTypeMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructions *RoutingInstructions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostRoutingInstructionsRequest) Authorization(authorization string) CashieringConfigAPIPostRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a routing instruction.
func (r CashieringConfigAPIPostRoutingInstructionsRequest) RoutingInstructions(routingInstructions RoutingInstructions) CashieringConfigAPIPostRoutingInstructionsRequest {
	r.routingInstructions = &routingInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIPostRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoutingInstructionsExecute(r)
}

/*
PostRoutingInstructions Operation to create RoutingInstructions.

Operation to create routing instructions. <p><strong>OperationId:</strong>postRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostRoutingInstructionsRequest
*/
func (a *CashieringConfigAPIService) PostRoutingInstructions(ctx context.Context) CashieringConfigAPIPostRoutingInstructionsRequest {
	return CashieringConfigAPIPostRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostRoutingInstructionsExecute(r CashieringConfigAPIPostRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTaxBracketsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxBrackets *TaxBrackets
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTaxBracketsRequest) Authorization(authorization string) CashieringConfigAPIPostTaxBracketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTaxBracketsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTaxBracketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTaxBracketsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTaxBracketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating tax brackets.
func (r CashieringConfigAPIPostTaxBracketsRequest) TaxBrackets(taxBrackets TaxBrackets) CashieringConfigAPIPostTaxBracketsRequest {
	r.taxBrackets = &taxBrackets
	return r
}

// External system code.
func (r CashieringConfigAPIPostTaxBracketsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTaxBracketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTaxBracketsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTaxBracketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTaxBracketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTaxBracketsExecute(r)
}

/*
PostTaxBrackets Operation to create TaxBrackets.

Operation to Create Tax Brackets. This function only be available when the parameter "Tax Bracket Calculation" is on. <p><strong>OperationId:</strong>postTaxBrackets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTaxBracketsRequest
*/
func (a *CashieringConfigAPIService) PostTaxBrackets(ctx context.Context) CashieringConfigAPIPostTaxBracketsRequest {
	return CashieringConfigAPIPostTaxBracketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTaxBracketsExecute(r CashieringConfigAPIPostTaxBracketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTaxBrackets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxBrackets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxBrackets
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypes *TaxTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTaxTypesRequest) Authorization(authorization string) CashieringConfigAPIPostTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Tax Type Configurations.
func (r CashieringConfigAPIPostTaxTypesRequest) TaxTypes(taxTypes TaxTypes) CashieringConfigAPIPostTaxTypesRequest {
	r.taxTypes = &taxTypes
	return r
}

// External system code.
func (r CashieringConfigAPIPostTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTaxTypesExecute(r)
}

/*
PostTaxTypes Operation to create TaxTypes.

Operation to create Tax Types. <p><strong>OperationId:</strong>postTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTaxTypesRequest
*/
func (a *CashieringConfigAPIService) PostTaxTypes(ctx context.Context) CashieringConfigAPIPostTaxTypesRequest {
	return CashieringConfigAPIPostTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTaxTypesExecute(r CashieringConfigAPIPostTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTemplateCustomNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCustomNumberConfig *TemplateCustomNumberConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTemplateCustomNumberRequest) Authorization(authorization string) CashieringConfigAPIPostTemplateCustomNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTemplateCustomNumberRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTemplateCustomNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTemplateCustomNumberRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTemplateCustomNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create a new template custom number configuration.
func (r CashieringConfigAPIPostTemplateCustomNumberRequest) TemplateCustomNumberConfig(templateCustomNumberConfig TemplateCustomNumberConfig) CashieringConfigAPIPostTemplateCustomNumberRequest {
	r.templateCustomNumberConfig = &templateCustomNumberConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPostTemplateCustomNumberRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTemplateCustomNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTemplateCustomNumberRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTemplateCustomNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTemplateCustomNumberRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateCustomNumberExecute(r)
}

/*
PostTemplateCustomNumber Operation to create a new template custom number configuration.

You can use this API to create a new template custom number configuration. <p><strong>OperationId:</strong>postTemplateCustomNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTemplateCustomNumberRequest
*/
func (a *CashieringConfigAPIService) PostTemplateCustomNumber(ctx context.Context) CashieringConfigAPIPostTemplateCustomNumberRequest {
	return CashieringConfigAPIPostTemplateCustomNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTemplateCustomNumberExecute(r CashieringConfigAPIPostTemplateCustomNumberRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTemplateCustomNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/customNumbers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCustomNumberConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTemplateCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCustomNumberConfig *TemplateCustomNumberConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create a new template custom number configuration.
func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) TemplateCustomNumberConfig(templateCustomNumberConfig TemplateCustomNumberConfig) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	r.templateCustomNumberConfig = &templateCustomNumberConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateCustomNumberConfigExecute(r)
}

/*
PostTemplateCustomNumberConfig Operation to create a new template custom number configuration.

You can use this API to create a new template custom number configuration.<br><p><strong><mark>This API is deprecated. Please use postTemplateCustomNumber instead</mark></strong></p> <p><strong>OperationId:</strong>postTemplateCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPostTemplateCustomNumberConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) PostTemplateCustomNumberConfig(ctx context.Context, hotelId string) CashieringConfigAPIPostTemplateCustomNumberConfigRequest {
	return CashieringConfigAPIPostTemplateCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringConfigAPIService) PostTemplateCustomNumberConfigExecute(r CashieringConfigAPIPostTemplateCustomNumberConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTemplateCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/template/customNumbers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCustomNumberConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionCodes *TemplateTransactionCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template transaction codes configuration.
func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) TemplateTransactionCodes(templateTransactionCodes TemplateTransactionCodes) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	r.templateTransactionCodes = &templateTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTemplateTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateTransactionCodesExecute(r)
}

/*
PostTemplateTransactionCodes Post template transaction codes

Use this API to create template transaction codes.<p><strong>OperationId:</strong>postTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTemplateTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) PostTemplateTransactionCodes(ctx context.Context) CashieringConfigAPIPostTemplateTransactionCodesRequest {
	return CashieringConfigAPIPostTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTemplateTransactionCodesExecute(r CashieringConfigAPIPostTemplateTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTemplateTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionGroups *TemplateTransactionGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Template Transaction Groups Configuration.
func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) TemplateTransactionGroups(templateTransactionGroups TemplateTransactionGroups) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	r.templateTransactionGroups = &templateTransactionGroups
	return r
}

// External system code.
func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTemplateTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateTransactionGroupsExecute(r)
}

/*
PostTemplateTransactionGroups Operation to create TemplateTransactionGroups.

Operation to create new template transaction group. <p><strong>OperationId:</strong>postTemplateTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTemplateTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) PostTemplateTransactionGroups(ctx context.Context) CashieringConfigAPIPostTemplateTransactionGroupsRequest {
	return CashieringConfigAPIPostTemplateTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTemplateTransactionGroupsExecute(r CashieringConfigAPIPostTemplateTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTemplateTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTemplateTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionSubgroups *TemplateTransactionSubgroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template transaction subgroups configuration.
func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) TemplateTransactionSubgroups(templateTransactionSubgroups TemplateTransactionSubgroups) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	r.templateTransactionSubgroups = &templateTransactionSubgroups
	return r
}

// External system code.
func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateTransactionSubgroupsExecute(r)
}

/*
PostTemplateTransactionSubgroups Operation to create TemplateTransactionSubgroups.

Operation to create template transaction subgroups <p><strong>OperationId:</strong>postTemplateTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTemplateTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) PostTemplateTransactionSubgroups(ctx context.Context) CashieringConfigAPIPostTemplateTransactionSubgroupsRequest {
	return CashieringConfigAPIPostTemplateTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTemplateTransactionSubgroupsExecute(r CashieringConfigAPIPostTemplateTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTemplateTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionSubgroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionCodes *HotelTransactionCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIPostTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Transaction Codes Configuration.
func (r CashieringConfigAPIPostTransactionCodesRequest) HotelTransactionCodes(hotelTransactionCodes HotelTransactionCodes) CashieringConfigAPIPostTransactionCodesRequest {
	r.hotelTransactionCodes = &hotelTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPostTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionCodesExecute(r)
}

/*
PostTransactionCodes Post transaction codes

Use this API to create transaction codes for a specific property.<p><strong>OperationId:</strong>postTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) PostTransactionCodes(ctx context.Context) CashieringConfigAPIPostTransactionCodesRequest {
	return CashieringConfigAPIPostTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTransactionCodesExecute(r CashieringConfigAPIPostTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTransactionDiscountsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiscount *TransactionDiscount
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTransactionDiscountsRequest) Authorization(authorization string) CashieringConfigAPIPostTransactionDiscountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTransactionDiscountsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTransactionDiscountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTransactionDiscountsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTransactionDiscountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Transaction Discount Configuration.
func (r CashieringConfigAPIPostTransactionDiscountsRequest) TransactionDiscount(transactionDiscount TransactionDiscount) CashieringConfigAPIPostTransactionDiscountsRequest {
	r.transactionDiscount = &transactionDiscount
	return r
}

// External system code.
func (r CashieringConfigAPIPostTransactionDiscountsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTransactionDiscountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTransactionDiscountsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTransactionDiscountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTransactionDiscountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionDiscountsExecute(r)
}

/*
PostTransactionDiscounts Operation to create TransactionDiscounts.

Use this API to create transaction discounts for a specific hotel. <p><strong>OperationId:</strong>postTransactionDiscounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTransactionDiscountsRequest
*/
func (a *CashieringConfigAPIService) PostTransactionDiscounts(ctx context.Context) CashieringConfigAPIPostTransactionDiscountsRequest {
	return CashieringConfigAPIPostTransactionDiscountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTransactionDiscountsExecute(r CashieringConfigAPIPostTransactionDiscountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTransactionDiscounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionDiscounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiscount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTransactionDiversionRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiversionRules *TransactionDiversionRules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) Authorization(authorization string) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a Transaction Diversion Rule
func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) TransactionDiversionRules(transactionDiversionRules TransactionDiversionRules) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	r.transactionDiversionRules = &transactionDiversionRules
	return r
}

// External system code.
func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTransactionDiversionRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionDiversionRulesExecute(r)
}

/*
PostTransactionDiversionRules Operation to create TransactionDiversionRules.

Operation to create Transaction Diversion Rules. <p><strong>OperationId:</strong>postTransactionDiversionRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTransactionDiversionRulesRequest
*/
func (a *CashieringConfigAPIService) PostTransactionDiversionRules(ctx context.Context) CashieringConfigAPIPostTransactionDiversionRulesRequest {
	return CashieringConfigAPIPostTransactionDiversionRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTransactionDiversionRulesExecute(r CashieringConfigAPIPostTransactionDiversionRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTransactionDiversionRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionDiversionRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiversionRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTransactionGeneratesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionGenerates *HotelTransactionGenerates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTransactionGeneratesRequest) Authorization(authorization string) CashieringConfigAPIPostTransactionGeneratesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTransactionGeneratesRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTransactionGeneratesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTransactionGeneratesRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTransactionGeneratesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create transaction generates.
func (r CashieringConfigAPIPostTransactionGeneratesRequest) HotelTransactionGenerates(hotelTransactionGenerates HotelTransactionGenerates) CashieringConfigAPIPostTransactionGeneratesRequest {
	r.hotelTransactionGenerates = &hotelTransactionGenerates
	return r
}

// External system code.
func (r CashieringConfigAPIPostTransactionGeneratesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTransactionGeneratesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTransactionGeneratesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTransactionGeneratesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTransactionGeneratesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionGeneratesExecute(r)
}

/*
PostTransactionGenerates Post transaction generates

Use this API to create transaction generates for a specific property.  Generates are rules used to calculate and post additional charges, such as service charges and taxes, when a particular sales charge transaction code is posted to guest, package or AR ledgers.<p><strong>OperationId:</strong>postTransactionGenerates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTransactionGeneratesRequest
*/
func (a *CashieringConfigAPIService) PostTransactionGenerates(ctx context.Context) CashieringConfigAPIPostTransactionGeneratesRequest {
	return CashieringConfigAPIPostTransactionGeneratesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTransactionGeneratesExecute(r CashieringConfigAPIPostTransactionGeneratesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTransactionGenerates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/generates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionGenerates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroups *TransactionGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIPostTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Transaction Groups Configuration.
func (r CashieringConfigAPIPostTransactionGroupsRequest) TransactionGroups(transactionGroups TransactionGroups) CashieringConfigAPIPostTransactionGroupsRequest {
	r.transactionGroups = &transactionGroups
	return r
}

// External system code.
func (r CashieringConfigAPIPostTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionGroupsExecute(r)
}

/*
PostTransactionGroups Operation to create TransactionGroups.

Operation to create transaction groups. <p><strong>OperationId:</strong>postTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) PostTransactionGroups(ctx context.Context) CashieringConfigAPIPostTransactionGroupsRequest {
	return CashieringConfigAPIPostTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTransactionGroupsExecute(r CashieringConfigAPIPostTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPostTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionSubgroups *HotelTransactionSubgroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPostTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIPostTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPostTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPostTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPostTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPostTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Transaction Subgroups Configuration.
func (r CashieringConfigAPIPostTransactionSubgroupsRequest) HotelTransactionSubgroups(hotelTransactionSubgroups HotelTransactionSubgroups) CashieringConfigAPIPostTransactionSubgroupsRequest {
	r.hotelTransactionSubgroups = &hotelTransactionSubgroups
	return r
}

// External system code.
func (r CashieringConfigAPIPostTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPostTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPostTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPostTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPostTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionSubgroupsExecute(r)
}

/*
PostTransactionSubgroups Operation to create TransactionSubgroups.

Operation to create transaction sub groups. <p><strong>OperationId:</strong>postTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPostTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) PostTransactionSubgroups(ctx context.Context) CashieringConfigAPIPostTransactionSubgroupsRequest {
	return CashieringConfigAPIPostTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PostTransactionSubgroupsExecute(r CashieringConfigAPIPostTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PostTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionSubgroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *AdjustmentCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigAPIPutAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Adjustment Code Configurations.
func (r CashieringConfigAPIPutAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes AdjustmentCodes) CashieringConfigAPIPutAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAdjustmentCodesExecute(r)
}

/*
PutAdjustmentCodes Operation to change AdjustmentCodes.

Operation to change Adjustment Codes. <p><strong>OperationId:</strong>putAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutAdjustmentCodesRequest
*/
func (a *CashieringConfigAPIService) PutAdjustmentCodes(ctx context.Context) CashieringConfigAPIPutAdjustmentCodesRequest {
	return CashieringConfigAPIPutAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutAdjustmentCodesExecute(r CashieringConfigAPIPutAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *Articles
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutArticlesRequest) Authorization(authorization string) CashieringConfigAPIPutArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutArticlesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutArticlesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change articles.
func (r CashieringConfigAPIPutArticlesRequest) Articles(articles Articles) CashieringConfigAPIPutArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r CashieringConfigAPIPutArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutArticlesExecute(r)
}

/*
PutArticles Operation to change Articles.

Operation to change articles. <p><strong>OperationId:</strong>putArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutArticlesRequest
*/
func (a *CashieringConfigAPIService) PutArticles(ctx context.Context) CashieringConfigAPIPutArticlesRequest {
	return CashieringConfigAPIPutArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutArticlesExecute(r CashieringConfigAPIPutArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *AuthorizationConfigRules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change authorization rule.
func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules AuthorizationConfigRules) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizationConfigRuleExecute(r)
}

/*
PutAuthorizationConfigRule Operation to change AuthorizationConfigRule.

 <p><strong>OperationId:</strong>putAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigAPIService) PutAuthorizationConfigRule(ctx context.Context) CashieringConfigAPIPutAuthorizationConfigRuleRequest {
	return CashieringConfigAPIPutAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutAuthorizationConfigRuleExecute(r CashieringConfigAPIPutAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsToChange *AuthorizerGroupsToChange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigAPIPutAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Authorizer Group Configuration.
func (r CashieringConfigAPIPutAuthorizerGroupsRequest) AuthorizerGroupsToChange(authorizerGroupsToChange AuthorizerGroupsToChange) CashieringConfigAPIPutAuthorizerGroupsRequest {
	r.authorizerGroupsToChange = &authorizerGroupsToChange
	return r
}

// External system code.
func (r CashieringConfigAPIPutAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizerGroupsExecute(r)
}

/*
PutAuthorizerGroups Operation to change AuthorizerGroups.

Operation to change Authorizer Groups. <p><strong>OperationId:</strong>putAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutAuthorizerGroupsRequest
*/
func (a *CashieringConfigAPIService) PutAuthorizerGroups(ctx context.Context) CashieringConfigAPIPutAuthorizerGroupsRequest {
	return CashieringConfigAPIPutAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutAuthorizerGroupsExecute(r CashieringConfigAPIPutAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroupsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *Cashiers
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCashiersRequest) Authorization(authorization string) CashieringConfigAPIPutCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCashiersRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCashiersRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request objects for modifying cashiers
func (r CashieringConfigAPIPutCashiersRequest) Cashiers(cashiers Cashiers) CashieringConfigAPIPutCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r CashieringConfigAPIPutCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCashiersExecute(r)
}

/*
PutCashiers Operation to change CashiersDetails.

This Operation to Change a Cashier. <p><strong>OperationId:</strong>putCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutCashiersRequest
*/
func (a *CashieringConfigAPIService) PutCashiers(ctx context.Context) CashieringConfigAPIPutCashiersRequest {
	return CashieringConfigAPIPutCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCashiersExecute(r CashieringConfigAPIPutCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCollectingAgentTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	collectingAgentTaxes *CollectingAgentTaxes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) Authorization(authorization string) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change Collecting Agent Taxes.
func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) CollectingAgentTaxes(collectingAgentTaxes CollectingAgentTaxes) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	r.collectingAgentTaxes = &collectingAgentTaxes
	return r
}

// External system code.
func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCollectingAgentTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCollectingAgentTaxesExecute(r)
}

/*
PutCollectingAgentTaxes Operation to change CollectingAgentTaxes.

Operation to change Collecting Agent Taxes. <p><strong>OperationId:</strong>putCollectingAgentTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutCollectingAgentTaxesRequest
*/
func (a *CashieringConfigAPIService) PutCollectingAgentTaxes(ctx context.Context) CashieringConfigAPIPutCollectingAgentTaxesRequest {
	return CashieringConfigAPIPutCollectingAgentTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCollectingAgentTaxesExecute(r CashieringConfigAPIPutCollectingAgentTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCollectingAgentTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/collectingAgentTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.collectingAgentTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCompBucketRedemptionConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	redemptionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compBucketRedemptionConfig *CompBucketRedemptionConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) Authorization(authorization string) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Comp Bucket Redemption Codes configurations.
func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) CompBucketRedemptionConfig(compBucketRedemptionConfig CompBucketRedemptionConfig) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	r.compBucketRedemptionConfig = &compBucketRedemptionConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCompBucketRedemptionConfigExecute(r)
}

/*
PutCompBucketRedemptionConfig Operation to change Comp Bucket Redemption Codes.

Operation to change Comp Bucket Redemption Codes. <p><strong>OperationId:</strong>putCompBucketRedemptionConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param redemptionCode Bucket Redemption Code
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPutCompBucketRedemptionConfigRequest
*/
func (a *CashieringConfigAPIService) PutCompBucketRedemptionConfig(ctx context.Context, redemptionCode string, hotelId string) CashieringConfigAPIPutCompBucketRedemptionConfigRequest {
	return CashieringConfigAPIPutCompBucketRedemptionConfigRequest{
		ApiService: a,
		ctx: ctx,
		redemptionCode: redemptionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCompBucketRedemptionConfigExecute(r CashieringConfigAPIPutCompBucketRedemptionConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCompBucketRedemptionConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compBucket/redemption/{redemptionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"redemptionCode"+"}", url.PathEscape(parameterValueToString(r.redemptionCode, "redemptionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.redemptionCode) < 1 {
		return localVarReturnValue, nil, reportError("redemptionCode must have at least 1 elements")
	}
	if strlen(r.redemptionCode) > 2000 {
		return localVarReturnValue, nil, reportError("redemptionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compBucketRedemptionConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *CurrencyExchangeServiceTaxes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing currency exchange service taxes
func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes CurrencyExchangeServiceTaxes) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCurrencyExchangeServiceTaxesExecute(r)
}

/*
PutCurrencyExchangeServiceTaxes Operation to change ExchangeServiceTaxes.

Operation to change currency exchange service taxes. <p><strong>OperationId:</strong>putCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigAPIService) PutCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCurrencyExchangeServiceTaxesExecute(r CashieringConfigAPIPutCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCustomChargeExemptionsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customChargeExemptionsConfigToBeChanged *CustomChargeExemptionsConfigToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) Authorization(authorization string) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Existing Custom Charge Exemptions to be changed.
func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) CustomChargeExemptionsConfigToBeChanged(customChargeExemptionsConfigToBeChanged CustomChargeExemptionsConfigToBeChanged) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	r.customChargeExemptionsConfigToBeChanged = &customChargeExemptionsConfigToBeChanged
	return r
}

// External system code.
func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCustomChargeExemptionsConfigExecute(r)
}

/*
PutCustomChargeExemptionsConfig Operation to change Custom Charge Exemptions Config.

Operation to change Custom Charge Exemptions Config. <p><strong>OperationId:</strong>putCustomChargeExemptionsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPutCustomChargeExemptionsConfigRequest
*/
func (a *CashieringConfigAPIService) PutCustomChargeExemptionsConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIPutCustomChargeExemptionsConfigRequest {
	return CashieringConfigAPIPutCustomChargeExemptionsConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCustomChargeExemptionsConfigExecute(r CashieringConfigAPIPutCustomChargeExemptionsConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCustomChargeExemptionsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/exemptions/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customChargeExemptionsConfigToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCustomChargesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customChargesConfig *CustomChargesConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCustomChargesConfigRequest) Authorization(authorization string) CashieringConfigAPIPutCustomChargesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCustomChargesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCustomChargesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCustomChargesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCustomChargesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Custom Charges.
func (r CashieringConfigAPIPutCustomChargesConfigRequest) CustomChargesConfig(customChargesConfig CustomChargesConfig) CashieringConfigAPIPutCustomChargesConfigRequest {
	r.customChargesConfig = &customChargesConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPutCustomChargesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCustomChargesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCustomChargesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCustomChargesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCustomChargesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCustomChargesConfigExecute(r)
}

/*
PutCustomChargesConfig Operation to change Custom Charge Codes.

Operation to change Custom ChargeCodes. <p><strong>OperationId:</strong>putCustomChargesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPutCustomChargesConfigRequest
*/
func (a *CashieringConfigAPIService) PutCustomChargesConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIPutCustomChargesConfigRequest {
	return CashieringConfigAPIPutCustomChargesConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCustomChargesConfigExecute(r CashieringConfigAPIPutCustomChargesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCustomChargesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customCharges/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customChargesConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customNumberConfiguration *CustomNumberConfiguration
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIPutCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPutCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPutCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change custom number configuration.
func (r CashieringConfigAPIPutCustomNumberConfigRequest) CustomNumberConfiguration(customNumberConfiguration CustomNumberConfiguration) CashieringConfigAPIPutCustomNumberConfigRequest {
	r.customNumberConfiguration = &customNumberConfiguration
	return r
}

// External system code.
func (r CashieringConfigAPIPutCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutCustomNumberConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCustomNumberConfigExecute(r)
}

/*
PutCustomNumberConfig Operation to change custom number config.

 <p><strong>OperationId:</strong>putCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPutCustomNumberConfigRequest
*/
func (a *CashieringConfigAPIService) PutCustomNumberConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIPutCustomNumberConfigRequest {
	return CashieringConfigAPIPutCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutCustomNumberConfigExecute(r CashieringConfigAPIPutCustomNumberConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/customNumbers/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customNumberConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyPlanCodes *DailyPlanCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutDailyPlanCodesRequest) Authorization(authorization string) CashieringConfigAPIPutDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutDailyPlanCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutDailyPlanCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing daily plan codes.
func (r CashieringConfigAPIPutDailyPlanCodesRequest) DailyPlanCodes(dailyPlanCodes DailyPlanCodes) CashieringConfigAPIPutDailyPlanCodesRequest {
	r.dailyPlanCodes = &dailyPlanCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutDailyPlanCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDailyPlanCodesExecute(r)
}

/*
PutDailyPlanCodes Operation to change DailyPlanCodes.

 <p><strong>OperationId:</strong>putDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutDailyPlanCodesRequest
*/
func (a *CashieringConfigAPIService) PutDailyPlanCodes(ctx context.Context) CashieringConfigAPIPutDailyPlanCodesRequest {
	return CashieringConfigAPIPutDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutDailyPlanCodesExecute(r CashieringConfigAPIPutDailyPlanCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyPlanCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *ExpenseArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing expense arrangement codes.
func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes ExpenseArrangementCodes) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutExpenseArrangementCodesExecute(r)
}

/*
PutExpenseArrangementCodes Operation to change ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>putExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutExpenseArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PutExpenseArrangementCodes(ctx context.Context) CashieringConfigAPIPutExpenseArrangementCodesRequest {
	return CashieringConfigAPIPutExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutExpenseArrangementCodesExecute(r CashieringConfigAPIPutExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioParameters *FiscalFolioParameters
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigAPIPutFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Fiscal Folio Parameter Configurations.
func (r CashieringConfigAPIPutFiscalFolioParametersRequest) FiscalFolioParameters(fiscalFolioParameters FiscalFolioParameters) CashieringConfigAPIPutFiscalFolioParametersRequest {
	r.fiscalFolioParameters = &fiscalFolioParameters
	return r
}

// External system code.
func (r CashieringConfigAPIPutFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFiscalFolioParametersExecute(r)
}

/*
PutFiscalFolioParameters Operation to change FiscalFolioParameters.

Operation to change Fiscal Folio Parameters. <p><strong>OperationId:</strong>putFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFiscalFolioParametersRequest
*/
func (a *CashieringConfigAPIService) PutFiscalFolioParameters(ctx context.Context) CashieringConfigAPIPutFiscalFolioParametersRequest {
	return CashieringConfigAPIPutFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFiscalFolioParametersExecute(r CashieringConfigAPIPutFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFiscalPeriodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalPeriodsEdit *FiscalPeriodsEdit
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFiscalPeriodsRequest) Authorization(authorization string) CashieringConfigAPIPutFiscalPeriodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFiscalPeriodsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFiscalPeriodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFiscalPeriodsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFiscalPeriodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit Fiscal Periods
func (r CashieringConfigAPIPutFiscalPeriodsRequest) FiscalPeriodsEdit(fiscalPeriodsEdit FiscalPeriodsEdit) CashieringConfigAPIPutFiscalPeriodsRequest {
	r.fiscalPeriodsEdit = &fiscalPeriodsEdit
	return r
}

// External system code.
func (r CashieringConfigAPIPutFiscalPeriodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFiscalPeriodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFiscalPeriodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFiscalPeriodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFiscalPeriodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFiscalPeriodsExecute(r)
}

/*
PutFiscalPeriods Operation to change FiscalPeriods.

Operation to change Fiscal Periods. <p><strong>OperationId:</strong>putFiscalPeriods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFiscalPeriodsRequest
*/
func (a *CashieringConfigAPIService) PutFiscalPeriods(ctx context.Context) CashieringConfigAPIPutFiscalPeriodsRequest {
	return CashieringConfigAPIPutFiscalPeriodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFiscalPeriodsExecute(r CashieringConfigAPIPutFiscalPeriodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFiscalPeriods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalPeriods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalPeriodsEdit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFiscalYearsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalYears *FiscalYears
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFiscalYearsRequest) Authorization(authorization string) CashieringConfigAPIPutFiscalYearsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFiscalYearsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFiscalYearsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFiscalYearsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFiscalYearsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit Fiscal Years
func (r CashieringConfigAPIPutFiscalYearsRequest) FiscalYears(fiscalYears FiscalYears) CashieringConfigAPIPutFiscalYearsRequest {
	r.fiscalYears = &fiscalYears
	return r
}

// External system code.
func (r CashieringConfigAPIPutFiscalYearsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFiscalYearsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFiscalYearsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFiscalYearsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFiscalYearsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFiscalYearsExecute(r)
}

/*
PutFiscalYears Operation to change FiscalYears.

Operation to change Fiscal Years. <p><strong>OperationId:</strong>putFiscalYears</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFiscalYearsRequest
*/
func (a *CashieringConfigAPIService) PutFiscalYears(ctx context.Context) CashieringConfigAPIPutFiscalYearsRequest {
	return CashieringConfigAPIPutFiscalYearsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFiscalYearsExecute(r CashieringConfigAPIPutFiscalYearsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFiscalYears")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalYears"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalYears
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFolioArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioArrangementCodes *FolioArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFolioArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPutFolioArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFolioArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFolioArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFolioArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFolioArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing folio arrangement codes.
func (r CashieringConfigAPIPutFolioArrangementCodesRequest) FolioArrangementCodes(folioArrangementCodes FolioArrangementCodes) CashieringConfigAPIPutFolioArrangementCodesRequest {
	r.folioArrangementCodes = &folioArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutFolioArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFolioArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFolioArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFolioArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFolioArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFolioArrangementCodesExecute(r)
}

/*
PutFolioArrangementCodes Operation to change FolioArrangementCodes.

 <p><strong>OperationId:</strong>putFolioArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFolioArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PutFolioArrangementCodes(ctx context.Context) CashieringConfigAPIPutFolioArrangementCodesRequest {
	return CashieringConfigAPIPutFolioArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFolioArrangementCodesExecute(r CashieringConfigAPIPutFolioArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFolioArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFolioCopyLegendsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioCopyLegend *FolioCopyLegend
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFolioCopyLegendsRequest) Authorization(authorization string) CashieringConfigAPIPutFolioCopyLegendsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFolioCopyLegendsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFolioCopyLegendsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFolioCopyLegendsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFolioCopyLegendsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit description of folio copy legends
func (r CashieringConfigAPIPutFolioCopyLegendsRequest) FolioCopyLegend(folioCopyLegend FolioCopyLegend) CashieringConfigAPIPutFolioCopyLegendsRequest {
	r.folioCopyLegend = &folioCopyLegend
	return r
}

// External system code.
func (r CashieringConfigAPIPutFolioCopyLegendsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFolioCopyLegendsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFolioCopyLegendsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFolioCopyLegendsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFolioCopyLegendsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFolioCopyLegendsExecute(r)
}

/*
PutFolioCopyLegends Operation to change FolioCopyLegends.

Operation to change folio copy legends information <p><strong>OperationId:</strong>putFolioCopyLegends</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFolioCopyLegendsRequest
*/
func (a *CashieringConfigAPIService) PutFolioCopyLegends(ctx context.Context) CashieringConfigAPIPutFolioCopyLegendsRequest {
	return CashieringConfigAPIPutFolioCopyLegendsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFolioCopyLegendsExecute(r CashieringConfigAPIPutFolioCopyLegendsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFolioCopyLegends")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioCopyLegends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioCopyLegend
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFolioPrintQueuesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioPrintQueues *FolioPrintQueues
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFolioPrintQueuesRequest) Authorization(authorization string) CashieringConfigAPIPutFolioPrintQueuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFolioPrintQueuesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFolioPrintQueuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFolioPrintQueuesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFolioPrintQueuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing folio print queues
func (r CashieringConfigAPIPutFolioPrintQueuesRequest) FolioPrintQueues(folioPrintQueues FolioPrintQueues) CashieringConfigAPIPutFolioPrintQueuesRequest {
	r.folioPrintQueues = &folioPrintQueues
	return r
}

// External system code.
func (r CashieringConfigAPIPutFolioPrintQueuesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFolioPrintQueuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFolioPrintQueuesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFolioPrintQueuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFolioPrintQueuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFolioPrintQueuesExecute(r)
}

/*
PutFolioPrintQueues Operation to change FolioPrintQueues.

Operation to change folio print queues. <p><strong>OperationId:</strong>putFolioPrintQueues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFolioPrintQueuesRequest
*/
func (a *CashieringConfigAPIService) PutFolioPrintQueues(ctx context.Context) CashieringConfigAPIPutFolioPrintQueuesRequest {
	return CashieringConfigAPIPutFolioPrintQueuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFolioPrintQueuesExecute(r CashieringConfigAPIPutFolioPrintQueuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFolioPrintQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioPrintQueues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioPrintQueues
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutFolioTypesConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypesConfig *FolioTypesConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutFolioTypesConfigRequest) Authorization(authorization string) CashieringConfigAPIPutFolioTypesConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutFolioTypesConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPutFolioTypesConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutFolioTypesConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPutFolioTypesConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change Folio Type Names.
func (r CashieringConfigAPIPutFolioTypesConfigRequest) FolioTypesConfig(folioTypesConfig FolioTypesConfig) CashieringConfigAPIPutFolioTypesConfigRequest {
	r.folioTypesConfig = &folioTypesConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPutFolioTypesConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutFolioTypesConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutFolioTypesConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutFolioTypesConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutFolioTypesConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFolioTypesConfigExecute(r)
}

/*
PutFolioTypesConfig Operation to change FolioTypesConfig.

Operation to change Folio Type Names. <p><strong>OperationId:</strong>putFolioTypesConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutFolioTypesConfigRequest
*/
func (a *CashieringConfigAPIService) PutFolioTypesConfig(ctx context.Context) CashieringConfigAPIPutFolioTypesConfigRequest {
	return CashieringConfigAPIPutFolioTypesConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutFolioTypesConfigExecute(r CashieringConfigAPIPutFolioTypesConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutFolioTypesConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypesConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypesConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutForeignCurrenciesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	foreignCurrencies *ForeignCurrencies
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutForeignCurrenciesRequest) Authorization(authorization string) CashieringConfigAPIPutForeignCurrenciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutForeignCurrenciesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutForeignCurrenciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutForeignCurrenciesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutForeignCurrenciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit Foreign Currencies
func (r CashieringConfigAPIPutForeignCurrenciesRequest) ForeignCurrencies(foreignCurrencies ForeignCurrencies) CashieringConfigAPIPutForeignCurrenciesRequest {
	r.foreignCurrencies = &foreignCurrencies
	return r
}

// External system code.
func (r CashieringConfigAPIPutForeignCurrenciesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutForeignCurrenciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutForeignCurrenciesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutForeignCurrenciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutForeignCurrenciesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutForeignCurrenciesExecute(r)
}

/*
PutForeignCurrencies Operation to change ForeignCurrencies.

Operation to change Foreign Currencies. <p><strong>OperationId:</strong>putForeignCurrencies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutForeignCurrenciesRequest
*/
func (a *CashieringConfigAPIService) PutForeignCurrencies(ctx context.Context) CashieringConfigAPIPutForeignCurrenciesRequest {
	return CashieringConfigAPIPutForeignCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutForeignCurrenciesExecute(r CashieringConfigAPIPutForeignCurrenciesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutForeignCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.foreignCurrencies
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutGUINumberRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	gUINumberRulesDetails *GUINumberRulesDetails
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutGUINumberRulesRequest) Authorization(authorization string) CashieringConfigAPIPutGUINumberRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutGUINumberRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutGUINumberRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutGUINumberRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutGUINumberRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit GUI number rules.
func (r CashieringConfigAPIPutGUINumberRulesRequest) GUINumberRulesDetails(gUINumberRulesDetails GUINumberRulesDetails) CashieringConfigAPIPutGUINumberRulesRequest {
	r.gUINumberRulesDetails = &gUINumberRulesDetails
	return r
}

// External system code.
func (r CashieringConfigAPIPutGUINumberRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutGUINumberRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutGUINumberRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutGUINumberRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutGUINumberRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGUINumberRulesExecute(r)
}

/*
PutGUINumberRules Operation to change GUINumberRules.

Operation to change GUI Number rules <p><strong>OperationId:</strong>putGUINumberRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutGUINumberRulesRequest
*/
func (a *CashieringConfigAPIService) PutGUINumberRules(ctx context.Context) CashieringConfigAPIPutGUINumberRulesRequest {
	return CashieringConfigAPIPutGUINumberRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutGUINumberRulesExecute(r CashieringConfigAPIPutGUINumberRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutGUINumberRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guiNumberRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.gUINumberRulesDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutGroupArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	groupArrangementCodes *GroupArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutGroupArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPutGroupArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutGroupArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutGroupArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutGroupArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutGroupArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing group arrangement codes.
func (r CashieringConfigAPIPutGroupArrangementCodesRequest) GroupArrangementCodes(groupArrangementCodes GroupArrangementCodes) CashieringConfigAPIPutGroupArrangementCodesRequest {
	r.groupArrangementCodes = &groupArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutGroupArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutGroupArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutGroupArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutGroupArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutGroupArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGroupArrangementCodesExecute(r)
}

/*
PutGroupArrangementCodes Operation to change GroupArrangementCodes.

 <p><strong>OperationId:</strong>putGroupArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutGroupArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PutGroupArrangementCodes(ctx context.Context) CashieringConfigAPIPutGroupArrangementCodesRequest {
	return CashieringConfigAPIPutGroupArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutGroupArrangementCodesExecute(r CashieringConfigAPIPutGroupArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutGroupArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groupArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.groupArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutNoShowPostingRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	noShowPostingRulesEdit *NoShowPostingRulesEdit
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutNoShowPostingRulesRequest) Authorization(authorization string) CashieringConfigAPIPutNoShowPostingRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutNoShowPostingRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutNoShowPostingRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutNoShowPostingRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutNoShowPostingRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing No Show Posting Rule Configurations.
func (r CashieringConfigAPIPutNoShowPostingRulesRequest) NoShowPostingRulesEdit(noShowPostingRulesEdit NoShowPostingRulesEdit) CashieringConfigAPIPutNoShowPostingRulesRequest {
	r.noShowPostingRulesEdit = &noShowPostingRulesEdit
	return r
}

// External system code.
func (r CashieringConfigAPIPutNoShowPostingRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutNoShowPostingRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutNoShowPostingRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutNoShowPostingRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutNoShowPostingRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutNoShowPostingRulesExecute(r)
}

/*
PutNoShowPostingRules Operation to change NoShowPostingRules.

Operation to change No Show Posting Rules. <p><strong>OperationId:</strong>putNoShowPostingRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutNoShowPostingRulesRequest
*/
func (a *CashieringConfigAPIService) PutNoShowPostingRules(ctx context.Context) CashieringConfigAPIPutNoShowPostingRulesRequest {
	return CashieringConfigAPIPutNoShowPostingRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutNoShowPostingRulesExecute(r CashieringConfigAPIPutNoShowPostingRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutNoShowPostingRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noShowPostingRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.noShowPostingRulesEdit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutNumberDescriptionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	numberDescriptions *NumberDescriptions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutNumberDescriptionsRequest) Authorization(authorization string) CashieringConfigAPIPutNumberDescriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutNumberDescriptionsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutNumberDescriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutNumberDescriptionsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutNumberDescriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit description of numbers
func (r CashieringConfigAPIPutNumberDescriptionsRequest) NumberDescriptions(numberDescriptions NumberDescriptions) CashieringConfigAPIPutNumberDescriptionsRequest {
	r.numberDescriptions = &numberDescriptions
	return r
}

// External system code.
func (r CashieringConfigAPIPutNumberDescriptionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutNumberDescriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutNumberDescriptionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutNumberDescriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutNumberDescriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutNumberDescriptionsExecute(r)
}

/*
PutNumberDescriptions Operation to change NumberDescriptions.

The operation is to change the description corresponding to a number. <p><strong>OperationId:</strong>putNumberDescriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutNumberDescriptionsRequest
*/
func (a *CashieringConfigAPIService) PutNumberDescriptions(ctx context.Context) CashieringConfigAPIPutNumberDescriptionsRequest {
	return CashieringConfigAPIPutNumberDescriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutNumberDescriptionsExecute(r CashieringConfigAPIPutNumberDescriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutNumberDescriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/numberDescriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.numberDescriptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutOperaControlSequencesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	operaControlSequences *OperaControlSequences
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutOperaControlSequencesRequest) Authorization(authorization string) CashieringConfigAPIPutOperaControlSequencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutOperaControlSequencesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutOperaControlSequencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutOperaControlSequencesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutOperaControlSequencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request objects for updating Opera Control Sequences
func (r CashieringConfigAPIPutOperaControlSequencesRequest) OperaControlSequences(operaControlSequences OperaControlSequences) CashieringConfigAPIPutOperaControlSequencesRequest {
	r.operaControlSequences = &operaControlSequences
	return r
}

// External system code.
func (r CashieringConfigAPIPutOperaControlSequencesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutOperaControlSequencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutOperaControlSequencesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutOperaControlSequencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutOperaControlSequencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutOperaControlSequencesExecute(r)
}

/*
PutOperaControlSequences Operation to change OperaControlSequences.

Operation to change Opera Document Sequences. <p><strong>OperationId:</strong>putOperaControlSequences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutOperaControlSequencesRequest
*/
func (a *CashieringConfigAPIService) PutOperaControlSequences(ctx context.Context) CashieringConfigAPIPutOperaControlSequencesRequest {
	return CashieringConfigAPIPutOperaControlSequencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutOperaControlSequencesExecute(r CashieringConfigAPIPutOperaControlSequencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutOperaControlSequences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/operaControlSequences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.operaControlSequences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutPackageArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	packageArrangementCodes *PackageArrangementCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutPackageArrangementCodesRequest) Authorization(authorization string) CashieringConfigAPIPutPackageArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutPackageArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutPackageArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutPackageArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutPackageArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing package arrangement codes.
func (r CashieringConfigAPIPutPackageArrangementCodesRequest) PackageArrangementCodes(packageArrangementCodes PackageArrangementCodes) CashieringConfigAPIPutPackageArrangementCodesRequest {
	r.packageArrangementCodes = &packageArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutPackageArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutPackageArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutPackageArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutPackageArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutPackageArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPackageArrangementCodesExecute(r)
}

/*
PutPackageArrangementCodes Operation to change PackageArrangementCodes.

 <p><strong>OperationId:</strong>putPackageArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutPackageArrangementCodesRequest
*/
func (a *CashieringConfigAPIService) PutPackageArrangementCodes(ctx context.Context) CashieringConfigAPIPutPackageArrangementCodesRequest {
	return CashieringConfigAPIPutPackageArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutPackageArrangementCodesExecute(r CashieringConfigAPIPutPackageArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutPackageArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	paymentMethods *PaymentMethods
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutPaymentMethodsRequest) Authorization(authorization string) CashieringConfigAPIPutPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutPaymentMethodsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutPaymentMethodsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change payment methods.
func (r CashieringConfigAPIPutPaymentMethodsRequest) PaymentMethods(paymentMethods PaymentMethods) CashieringConfigAPIPutPaymentMethodsRequest {
	r.paymentMethods = &paymentMethods
	return r
}

// External system code.
func (r CashieringConfigAPIPutPaymentMethodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutPaymentMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPaymentMethodsExecute(r)
}

/*
PutPaymentMethods Operation to change PaymentMethods.

Operation to change payment methods. <p><strong>OperationId:</strong>putPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutPaymentMethodsRequest
*/
func (a *CashieringConfigAPIService) PutPaymentMethods(ctx context.Context) CashieringConfigAPIPutPaymentMethodsRequest {
	return CashieringConfigAPIPutPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutPaymentMethodsExecute(r CashieringConfigAPIPutPaymentMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelPaymentMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.paymentMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutRevenueBucketCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketCodes *RevenueBucketCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutRevenueBucketCodesRequest) Authorization(authorization string) CashieringConfigAPIPutRevenueBucketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutRevenueBucketCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutRevenueBucketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutRevenueBucketCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutRevenueBucketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Revenue Bucket Codes Configurations.
func (r CashieringConfigAPIPutRevenueBucketCodesRequest) RevenueBucketCodes(revenueBucketCodes RevenueBucketCodes) CashieringConfigAPIPutRevenueBucketCodesRequest {
	r.revenueBucketCodes = &revenueBucketCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutRevenueBucketCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutRevenueBucketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutRevenueBucketCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutRevenueBucketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutRevenueBucketCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRevenueBucketCodesExecute(r)
}

/*
PutRevenueBucketCodes Operation to change RevenueBucketCodes.

Operation to change Revenue Bucket Codes. <p><strong>OperationId:</strong>putRevenueBucketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutRevenueBucketCodesRequest
*/
func (a *CashieringConfigAPIService) PutRevenueBucketCodes(ctx context.Context) CashieringConfigAPIPutRevenueBucketCodesRequest {
	return CashieringConfigAPIPutRevenueBucketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutRevenueBucketCodesExecute(r CashieringConfigAPIPutRevenueBucketCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutRevenueBucketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueBucketCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutRevenueBucketTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueBucketTypes *RevenueBucketTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutRevenueBucketTypesRequest) Authorization(authorization string) CashieringConfigAPIPutRevenueBucketTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutRevenueBucketTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutRevenueBucketTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutRevenueBucketTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutRevenueBucketTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Revenue Bucket Types Configurations.
func (r CashieringConfigAPIPutRevenueBucketTypesRequest) RevenueBucketTypes(revenueBucketTypes RevenueBucketTypes) CashieringConfigAPIPutRevenueBucketTypesRequest {
	r.revenueBucketTypes = &revenueBucketTypes
	return r
}

// External system code.
func (r CashieringConfigAPIPutRevenueBucketTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutRevenueBucketTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutRevenueBucketTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutRevenueBucketTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutRevenueBucketTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRevenueBucketTypesExecute(r)
}

/*
PutRevenueBucketTypes Operation to change RevenueBucketTypes.

Operation to change Revenue Bucket Types. <p><strong>OperationId:</strong>putRevenueBucketTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutRevenueBucketTypesRequest
*/
func (a *CashieringConfigAPIService) PutRevenueBucketTypes(ctx context.Context) CashieringConfigAPIPutRevenueBucketTypesRequest {
	return CashieringConfigAPIPutRevenueBucketTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutRevenueBucketTypesExecute(r CashieringConfigAPIPutRevenueBucketTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutRevenueBucketTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueBucketTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutRevenueTypeMappingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueTypeMapping *RevenueTypeMapping
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutRevenueTypeMappingRequest) Authorization(authorization string) CashieringConfigAPIPutRevenueTypeMappingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutRevenueTypeMappingRequest) XAppKey(xAppKey string) CashieringConfigAPIPutRevenueTypeMappingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutRevenueTypeMappingRequest) XHotelid(xHotelid string) CashieringConfigAPIPutRevenueTypeMappingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change Revenue Type Mapping configurations.
func (r CashieringConfigAPIPutRevenueTypeMappingRequest) RevenueTypeMapping(revenueTypeMapping RevenueTypeMapping) CashieringConfigAPIPutRevenueTypeMappingRequest {
	r.revenueTypeMapping = &revenueTypeMapping
	return r
}

// External system code.
func (r CashieringConfigAPIPutRevenueTypeMappingRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutRevenueTypeMappingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutRevenueTypeMappingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutRevenueTypeMappingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutRevenueTypeMappingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRevenueTypeMappingExecute(r)
}

/*
PutRevenueTypeMapping Operation to change RevenueTypeMapping.

 <p><strong>OperationId:</strong>putRevenueTypeMapping</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutRevenueTypeMappingRequest
*/
func (a *CashieringConfigAPIService) PutRevenueTypeMapping(ctx context.Context) CashieringConfigAPIPutRevenueTypeMappingRequest {
	return CashieringConfigAPIPutRevenueTypeMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutRevenueTypeMappingExecute(r CashieringConfigAPIPutRevenueTypeMappingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutRevenueTypeMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueTypeMapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.revenueTypeMapping
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructions *RoutingInstructions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutRoutingInstructionsRequest) Authorization(authorization string) CashieringConfigAPIPutRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request when changing a routing instruction.
func (r CashieringConfigAPIPutRoutingInstructionsRequest) RoutingInstructions(routingInstructions RoutingInstructions) CashieringConfigAPIPutRoutingInstructionsRequest {
	r.routingInstructions = &routingInstructions
	return r
}

// External system code.
func (r CashieringConfigAPIPutRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoutingInstructionsExecute(r)
}

/*
PutRoutingInstructions Operation to change RoutingInstructions.

Operation to change routing instructions. <p><strong>OperationId:</strong>putRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutRoutingInstructionsRequest
*/
func (a *CashieringConfigAPIService) PutRoutingInstructions(ctx context.Context) CashieringConfigAPIPutRoutingInstructionsRequest {
	return CashieringConfigAPIPutRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutRoutingInstructionsExecute(r CashieringConfigAPIPutRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTaxBracketsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxBrackets *TaxBrackets
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTaxBracketsRequest) Authorization(authorization string) CashieringConfigAPIPutTaxBracketsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTaxBracketsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTaxBracketsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTaxBracketsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTaxBracketsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing tax brackets.
func (r CashieringConfigAPIPutTaxBracketsRequest) TaxBrackets(taxBrackets TaxBrackets) CashieringConfigAPIPutTaxBracketsRequest {
	r.taxBrackets = &taxBrackets
	return r
}

// External system code.
func (r CashieringConfigAPIPutTaxBracketsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTaxBracketsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTaxBracketsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTaxBracketsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTaxBracketsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTaxBracketsExecute(r)
}

/*
PutTaxBrackets Operation to change TaxBrackets.

Operation to change Tax Brackets. This function only be available when the parameter "Tax Bracket Calculation" is on. <p><strong>OperationId:</strong>putTaxBrackets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTaxBracketsRequest
*/
func (a *CashieringConfigAPIService) PutTaxBrackets(ctx context.Context) CashieringConfigAPIPutTaxBracketsRequest {
	return CashieringConfigAPIPutTaxBracketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTaxBracketsExecute(r CashieringConfigAPIPutTaxBracketsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTaxBrackets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxBrackets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxBrackets
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypes *TaxTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTaxTypesRequest) Authorization(authorization string) CashieringConfigAPIPutTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Tax Type Configurations.
func (r CashieringConfigAPIPutTaxTypesRequest) TaxTypes(taxTypes TaxTypes) CashieringConfigAPIPutTaxTypesRequest {
	r.taxTypes = &taxTypes
	return r
}

// External system code.
func (r CashieringConfigAPIPutTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTaxTypesExecute(r)
}

/*
PutTaxTypes Operation to change TaxTypes.

Operation to change Tax Types. <p><strong>OperationId:</strong>putTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTaxTypesRequest
*/
func (a *CashieringConfigAPIService) PutTaxTypes(ctx context.Context) CashieringConfigAPIPutTaxTypesRequest {
	return CashieringConfigAPIPutTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTaxTypesExecute(r CashieringConfigAPIPutTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTemplateCustomNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCustomNumberConfig *TemplateCustomNumberConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTemplateCustomNumberRequest) Authorization(authorization string) CashieringConfigAPIPutTemplateCustomNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTemplateCustomNumberRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTemplateCustomNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTemplateCustomNumberRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTemplateCustomNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change template custom number configuration.
func (r CashieringConfigAPIPutTemplateCustomNumberRequest) TemplateCustomNumberConfig(templateCustomNumberConfig TemplateCustomNumberConfig) CashieringConfigAPIPutTemplateCustomNumberRequest {
	r.templateCustomNumberConfig = &templateCustomNumberConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPutTemplateCustomNumberRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTemplateCustomNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTemplateCustomNumberRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTemplateCustomNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTemplateCustomNumberRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateCustomNumberExecute(r)
}

/*
PutTemplateCustomNumber Operation to change template custom number configuration.

You can use this API to change template custom number configuration. <p><strong>OperationId:</strong>putTemplateCustomNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTemplateCustomNumberRequest
*/
func (a *CashieringConfigAPIService) PutTemplateCustomNumber(ctx context.Context) CashieringConfigAPIPutTemplateCustomNumberRequest {
	return CashieringConfigAPIPutTemplateCustomNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTemplateCustomNumberExecute(r CashieringConfigAPIPutTemplateCustomNumberRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTemplateCustomNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/customNumbers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCustomNumberConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTemplateCustomNumberConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	configurationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCustomNumberConfig *TemplateCustomNumberConfig
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) Authorization(authorization string) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change template custom number configuration.
func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) TemplateCustomNumberConfig(templateCustomNumberConfig TemplateCustomNumberConfig) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	r.templateCustomNumberConfig = &templateCustomNumberConfig
	return r
}

// External system code.
func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateCustomNumberConfigExecute(r)
}

/*
PutTemplateCustomNumberConfig Operation to change template custom number configuration.

You can use this API to change template custom number configuration.<br><p><strong><mark>This API is deprecated. Please use putTemplateCustomNumber instead</mark></strong></p> <p><strong>OperationId:</strong>putTemplateCustomNumberConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationId Unique ID of the configuration
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigAPIPutTemplateCustomNumberConfigRequest

Deprecated
*/
func (a *CashieringConfigAPIService) PutTemplateCustomNumberConfig(ctx context.Context, configurationId string, hotelId string) CashieringConfigAPIPutTemplateCustomNumberConfigRequest {
	return CashieringConfigAPIPutTemplateCustomNumberConfigRequest{
		ApiService: a,
		ctx: ctx,
		configurationId: configurationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringConfigAPIService) PutTemplateCustomNumberConfigExecute(r CashieringConfigAPIPutTemplateCustomNumberConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTemplateCustomNumberConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/template/customNumbers/configuration/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", url.PathEscape(parameterValueToString(r.configurationId, "configurationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if strlen(r.configurationId) > 2000 {
		return localVarReturnValue, nil, reportError("configurationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCustomNumberConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionCodes *TemplateTransactionCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing template transaction codes configuration.
func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) TemplateTransactionCodes(templateTransactionCodes TemplateTransactionCodes) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	r.templateTransactionCodes = &templateTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTemplateTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateTransactionCodesExecute(r)
}

/*
PutTemplateTransactionCodes Operation to change TemplateTransactionCodes.

Operation to change template transaction codes. <p><strong>OperationId:</strong>putTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTemplateTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) PutTemplateTransactionCodes(ctx context.Context) CashieringConfigAPIPutTemplateTransactionCodesRequest {
	return CashieringConfigAPIPutTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTemplateTransactionCodesExecute(r CashieringConfigAPIPutTemplateTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTemplateTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionGroups *TemplateTransactionGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to changing Template Transaction Groups Configuration.
func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) TemplateTransactionGroups(templateTransactionGroups TemplateTransactionGroups) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	r.templateTransactionGroups = &templateTransactionGroups
	return r
}

// External system code.
func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTemplateTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateTransactionGroupsExecute(r)
}

/*
PutTemplateTransactionGroups Operation to change TemplateTransactionGroups.

Operation to change existing template transaction group. <p><strong>OperationId:</strong>putTemplateTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTemplateTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) PutTemplateTransactionGroups(ctx context.Context) CashieringConfigAPIPutTemplateTransactionGroupsRequest {
	return CashieringConfigAPIPutTemplateTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTemplateTransactionGroupsExecute(r CashieringConfigAPIPutTemplateTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTemplateTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTemplateTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionSubgroups *TemplateTransactionSubgroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing template transaction subgroups configuration.
func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) TemplateTransactionSubgroups(templateTransactionSubgroups TemplateTransactionSubgroups) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	r.templateTransactionSubgroups = &templateTransactionSubgroups
	return r
}

// External system code.
func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateTransactionSubgroupsExecute(r)
}

/*
PutTemplateTransactionSubgroups Operation to change TemplateTransactionSubgroups.

Operation to change template transaction subgroups <p><strong>OperationId:</strong>putTemplateTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTemplateTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) PutTemplateTransactionSubgroups(ctx context.Context) CashieringConfigAPIPutTemplateTransactionSubgroupsRequest {
	return CashieringConfigAPIPutTemplateTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTemplateTransactionSubgroupsExecute(r CashieringConfigAPIPutTemplateTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTemplateTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionSubgroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionCodeOwnershipRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodeOwnership *TransactionCodeOwnership
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing ownership of selected transaction codes operation.
func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) TransactionCodeOwnership(transactionCodeOwnership TransactionCodeOwnership) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	r.transactionCodeOwnership = &transactionCodeOwnership
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionCodeOwnershipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTransactionCodeOwnershipExecute(r)
}

/*
PutTransactionCodeOwnership Operation to change TransactionCodeOwnership.

Operation to change ownership of transaction code. <p><strong>OperationId:</strong>putTransactionCodeOwnership</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTransactionCodeOwnershipRequest
*/
func (a *CashieringConfigAPIService) PutTransactionCodeOwnership(ctx context.Context) CashieringConfigAPIPutTransactionCodeOwnershipRequest {
	return CashieringConfigAPIPutTransactionCodeOwnershipRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTransactionCodeOwnershipExecute(r CashieringConfigAPIPutTransactionCodeOwnershipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionCodeOwnership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodeOwnership"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionCodeOwnership
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionCodes *HotelTransactionCodes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionCodesRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Transaction Codes Configuration.
func (r CashieringConfigAPIPutTransactionCodesRequest) HotelTransactionCodes(hotelTransactionCodes HotelTransactionCodes) CashieringConfigAPIPutTransactionCodesRequest {
	r.hotelTransactionCodes = &hotelTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionCodesRequest) Execute() (*TransactionCodes, *http.Response, error) {
	return r.ApiService.PutTransactionCodesExecute(r)
}

/*
PutTransactionCodes Put transaction codes

Use this API to update transaction codes for a specific property.<p><strong>OperationId:</strong>putTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTransactionCodesRequest
*/
func (a *CashieringConfigAPIService) PutTransactionCodes(ctx context.Context) CashieringConfigAPIPutTransactionCodesRequest {
	return CashieringConfigAPIPutTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionCodes
func (a *CashieringConfigAPIService) PutTransactionCodesExecute(r CashieringConfigAPIPutTransactionCodesRequest) (*TransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionDiscountsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	transactionDiscountCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiscount *TransactionDiscount
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionDiscountsRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionDiscountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionDiscountsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionDiscountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionDiscountsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionDiscountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing a Transaction Discount Configuration.
func (r CashieringConfigAPIPutTransactionDiscountsRequest) TransactionDiscount(transactionDiscount TransactionDiscount) CashieringConfigAPIPutTransactionDiscountsRequest {
	r.transactionDiscount = &transactionDiscount
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionDiscountsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionDiscountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionDiscountsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionDiscountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionDiscountsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTransactionDiscountsExecute(r)
}

/*
PutTransactionDiscounts Operation to change TransactionDiscounts.

Operation to change Transaction Discounts. <p><strong>OperationId:</strong>putTransactionDiscounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @param transactionDiscountCode Unique code for transaction discount
 @return CashieringConfigAPIPutTransactionDiscountsRequest
*/
func (a *CashieringConfigAPIService) PutTransactionDiscounts(ctx context.Context, hotelId string, transactionDiscountCode string) CashieringConfigAPIPutTransactionDiscountsRequest {
	return CashieringConfigAPIPutTransactionDiscountsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		transactionDiscountCode: transactionDiscountCode,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTransactionDiscountsExecute(r CashieringConfigAPIPutTransactionDiscountsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionDiscounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionDiscounts/{transactionDiscountCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionDiscountCode"+"}", url.PathEscape(parameterValueToString(r.transactionDiscountCode, "transactionDiscountCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.transactionDiscountCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionDiscountCode must have at least 1 elements")
	}
	if strlen(r.transactionDiscountCode) > 20 {
		return localVarReturnValue, nil, reportError("transactionDiscountCode must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiscount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionDiversionRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiversionRules *TransactionDiversionRules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing Transaction Diversion Rule
func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) TransactionDiversionRules(transactionDiversionRules TransactionDiversionRules) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	r.transactionDiversionRules = &transactionDiversionRules
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionDiversionRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTransactionDiversionRulesExecute(r)
}

/*
PutTransactionDiversionRules Operation to change TransactionDiversionRules.

Operation to change Transaction Diversion Rules. <p><strong>OperationId:</strong>putTransactionDiversionRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTransactionDiversionRulesRequest
*/
func (a *CashieringConfigAPIService) PutTransactionDiversionRules(ctx context.Context) CashieringConfigAPIPutTransactionDiversionRulesRequest {
	return CashieringConfigAPIPutTransactionDiversionRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTransactionDiversionRulesExecute(r CashieringConfigAPIPutTransactionDiversionRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionDiversionRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionDiversionRules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiversionRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionGeneratesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionGenerates *HotelTransactionGenerates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionGeneratesRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionGeneratesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionGeneratesRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionGeneratesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionGeneratesRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionGeneratesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change transaction generates.
func (r CashieringConfigAPIPutTransactionGeneratesRequest) HotelTransactionGenerates(hotelTransactionGenerates HotelTransactionGenerates) CashieringConfigAPIPutTransactionGeneratesRequest {
	r.hotelTransactionGenerates = &hotelTransactionGenerates
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionGeneratesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionGeneratesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionGeneratesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionGeneratesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionGeneratesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTransactionGeneratesExecute(r)
}

/*
PutTransactionGenerates Put transaction generates

Use this API to update transaction generates for a specific property.<p><strong>OperationId:</strong>putTransactionGenerates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTransactionGeneratesRequest
*/
func (a *CashieringConfigAPIService) PutTransactionGenerates(ctx context.Context) CashieringConfigAPIPutTransactionGeneratesRequest {
	return CashieringConfigAPIPutTransactionGeneratesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTransactionGeneratesExecute(r CashieringConfigAPIPutTransactionGeneratesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionGenerates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/generates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionGenerates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroups *TransactionGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionGroupsRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Transaction Groups Configuration.
func (r CashieringConfigAPIPutTransactionGroupsRequest) TransactionGroups(transactionGroups TransactionGroups) CashieringConfigAPIPutTransactionGroupsRequest {
	r.transactionGroups = &transactionGroups
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTransactionGroupsExecute(r)
}

/*
PutTransactionGroups Operation to change TransactionGroups.

Operation to change transaction groups. <p><strong>OperationId:</strong>putTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTransactionGroupsRequest
*/
func (a *CashieringConfigAPIService) PutTransactionGroups(ctx context.Context) CashieringConfigAPIPutTransactionGroupsRequest {
	return CashieringConfigAPIPutTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTransactionGroupsExecute(r CashieringConfigAPIPutTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIPutTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionSubgroups *HotelTransactionSubgroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIPutTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigAPIPutTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIPutTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigAPIPutTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIPutTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigAPIPutTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Transaction Subgroups Configuration.
func (r CashieringConfigAPIPutTransactionSubgroupsRequest) HotelTransactionSubgroups(hotelTransactionSubgroups HotelTransactionSubgroups) CashieringConfigAPIPutTransactionSubgroupsRequest {
	r.hotelTransactionSubgroups = &hotelTransactionSubgroups
	return r
}

// External system code.
func (r CashieringConfigAPIPutTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIPutTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIPutTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIPutTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIPutTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTransactionSubgroupsExecute(r)
}

/*
PutTransactionSubgroups Operation to change TransactionSubgroups.

Operation to change transaction sub groups. <p><strong>OperationId:</strong>putTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIPutTransactionSubgroupsRequest
*/
func (a *CashieringConfigAPIService) PutTransactionSubgroups(ctx context.Context) CashieringConfigAPIPutTransactionSubgroupsRequest {
	return CashieringConfigAPIPutTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) PutTransactionSubgroupsExecute(r CashieringConfigAPIPutTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.PutTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionSubgroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIRemoveCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	compTypesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIRemoveCompTypesRequest) Authorization(authorization string) CashieringConfigAPIRemoveCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIRemoveCompTypesRequest) XAppKey(xAppKey string) CashieringConfigAPIRemoveCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIRemoveCompTypesRequest) XHotelid(xHotelid string) CashieringConfigAPIRemoveCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIRemoveCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIRemoveCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIRemoveCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIRemoveCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIRemoveCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCompTypesExecute(r)
}

/*
RemoveCompTypes Operation to Remove Comp Types.

Operation to Remove Comp Types. <p><strong>OperationId:</strong>removeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param compTypesCode Comp Types Code to be deleted.
 @return CashieringConfigAPIRemoveCompTypesRequest
*/
func (a *CashieringConfigAPIService) RemoveCompTypes(ctx context.Context, compTypesCode string) CashieringConfigAPIRemoveCompTypesRequest {
	return CashieringConfigAPIRemoveCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		compTypesCode: compTypesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) RemoveCompTypesExecute(r CashieringConfigAPIRemoveCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.RemoveCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes/codes/{compTypesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"compTypesCode"+"}", url.PathEscape(parameterValueToString(r.compTypesCode, "compTypesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.compTypesCode) < 1 {
		return localVarReturnValue, nil, reportError("compTypesCode must have at least 1 elements")
	}
	if strlen(r.compTypesCode) > 2000 {
		return localVarReturnValue, nil, reportError("compTypesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIRemoveFiscalPartnersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	partnerCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIRemoveFiscalPartnersRequest) Authorization(authorization string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIRemoveFiscalPartnersRequest) XAppKey(xAppKey string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIRemoveFiscalPartnersRequest) XHotelid(xHotelid string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for fiscal partner codes. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigAPIRemoveFiscalPartnersRequest) PartnerCode(partnerCode []string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	r.partnerCode = &partnerCode
	return r
}

// External system code.
func (r CashieringConfigAPIRemoveFiscalPartnersRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIRemoveFiscalPartnersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIRemoveFiscalPartnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFiscalPartnersExecute(r)
}

/*
RemoveFiscalPartners Delete configuration fiscal partners

Use this API to delete configuration fiscal partners. <p><strong>OperationId:</strong>removeFiscalPartners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return CashieringConfigAPIRemoveFiscalPartnersRequest
*/
func (a *CashieringConfigAPIService) RemoveFiscalPartners(ctx context.Context, hotelId string) CashieringConfigAPIRemoveFiscalPartnersRequest {
	return CashieringConfigAPIRemoveFiscalPartnersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) RemoveFiscalPartnersExecute(r CashieringConfigAPIRemoveFiscalPartnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.RemoveFiscalPartners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalPartners"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.partnerCode != nil {
		t := *r.partnerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partnerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partnerCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	legendCode string
	folioType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFolioTypeLegendMappingConfigExecute(r)
}

/*
RemoveFolioTypeLegendMappingConfig Operation to remove folio type legend mappings config.

Operation to remove folio type legend mappings config. <p><strong>OperationId:</strong>removeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param legendCode Legend Code
 @param folioType Folio Type
 @param hotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigAPIService) RemoveFolioTypeLegendMappingConfig(ctx context.Context, legendCode string, folioType string, hotelId string) CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest {
	return CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
		legendCode: legendCode,
		folioType: folioType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) RemoveFolioTypeLegendMappingConfigExecute(r CashieringConfigAPIRemoveFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.RemoveFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folios/{folioType}/legends/{legendCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"legendCode"+"}", url.PathEscape(parameterValueToString(r.legendCode, "legendCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folioType"+"}", url.PathEscape(parameterValueToString(r.folioType, "folioType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.legendCode) < 1 {
		return localVarReturnValue, nil, reportError("legendCode must have at least 1 elements")
	}
	if strlen(r.legendCode) > 2000 {
		return localVarReturnValue, nil, reportError("legendCode must have less than 2000 elements")
	}
	if strlen(r.folioType) < 1 {
		return localVarReturnValue, nil, reportError("folioType must have at least 1 elements")
	}
	if strlen(r.folioType) > 2000 {
		return localVarReturnValue, nil, reportError("folioType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIRemovePaymentMethodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	paymentMethods *PaymentMethods
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIRemovePaymentMethodsRequest) Authorization(authorization string) CashieringConfigAPIRemovePaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIRemovePaymentMethodsRequest) XAppKey(xAppKey string) CashieringConfigAPIRemovePaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIRemovePaymentMethodsRequest) XHotelid(xHotelid string) CashieringConfigAPIRemovePaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to remove payment methods.
func (r CashieringConfigAPIRemovePaymentMethodsRequest) PaymentMethods(paymentMethods PaymentMethods) CashieringConfigAPIRemovePaymentMethodsRequest {
	r.paymentMethods = &paymentMethods
	return r
}

// External system code.
func (r CashieringConfigAPIRemovePaymentMethodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIRemovePaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIRemovePaymentMethodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIRemovePaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIRemovePaymentMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemovePaymentMethodsExecute(r)
}

/*
RemovePaymentMethods Operation to delete TransactionArrangementCodes.

Operation to remove payment methods. <p><strong>OperationId:</strong>removePaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIRemovePaymentMethodsRequest
*/
func (a *CashieringConfigAPIService) RemovePaymentMethods(ctx context.Context) CashieringConfigAPIRemovePaymentMethodsRequest {
	return CashieringConfigAPIRemovePaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) RemovePaymentMethodsExecute(r CashieringConfigAPIRemovePaymentMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.RemovePaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/paymentMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.paymentMethods
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIRemoveTransactionDiversionRulesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionDiversionRules *TransactionDiversionRules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) Authorization(authorization string) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) XAppKey(xAppKey string) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) XHotelid(xHotelid string) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for deleting an existing Transaction Diversion Rule
func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) TransactionDiversionRules(transactionDiversionRules TransactionDiversionRules) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	r.transactionDiversionRules = &transactionDiversionRules
	return r
}

// External system code.
func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTransactionDiversionRulesExecute(r)
}

/*
RemoveTransactionDiversionRules Operation to delete TransactionDiversionRules.

Operation to remove Transaction Diversion Rules. <p><strong>OperationId:</strong>removeTransactionDiversionRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIRemoveTransactionDiversionRulesRequest
*/
func (a *CashieringConfigAPIService) RemoveTransactionDiversionRules(ctx context.Context) CashieringConfigAPIRemoveTransactionDiversionRulesRequest {
	return CashieringConfigAPIRemoveTransactionDiversionRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) RemoveTransactionDiversionRulesExecute(r CashieringConfigAPIRemoveTransactionDiversionRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.RemoveTransactionDiversionRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionDiversionRules/remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionDiversionRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPIRemoveTransactionGeneratesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionGenerates *HotelTransactionGenerates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) Authorization(authorization string) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) XAppKey(xAppKey string) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) XHotelid(xHotelid string) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to remove transaction generates.
func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) HotelTransactionGenerates(hotelTransactionGenerates HotelTransactionGenerates) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	r.hotelTransactionGenerates = &hotelTransactionGenerates
	return r
}

// External system code.
func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPIRemoveTransactionGeneratesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTransactionGeneratesExecute(r)
}

/*
RemoveTransactionGenerates Operation to delete TransactionGenerates.

Operation to remove transaction generates. <p><strong>OperationId:</strong>removeTransactionGenerates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPIRemoveTransactionGeneratesRequest
*/
func (a *CashieringConfigAPIService) RemoveTransactionGenerates(ctx context.Context) CashieringConfigAPIRemoveTransactionGeneratesRequest {
	return CashieringConfigAPIRemoveTransactionGeneratesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) RemoveTransactionGeneratesExecute(r CashieringConfigAPIRemoveTransactionGeneratesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.RemoveTransactionGenerates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGenerates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionGenerates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPISetBudgetForecastRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	budgetForecastInformationBase *BudgetForecastInformationBase
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPISetBudgetForecastRequest) Authorization(authorization string) CashieringConfigAPISetBudgetForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPISetBudgetForecastRequest) XAppKey(xAppKey string) CashieringConfigAPISetBudgetForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPISetBudgetForecastRequest) XHotelid(xHotelid string) CashieringConfigAPISetBudgetForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to load the Budget or Forecast information.
func (r CashieringConfigAPISetBudgetForecastRequest) BudgetForecastInformationBase(budgetForecastInformationBase BudgetForecastInformationBase) CashieringConfigAPISetBudgetForecastRequest {
	r.budgetForecastInformationBase = &budgetForecastInformationBase
	return r
}

// External system code.
func (r CashieringConfigAPISetBudgetForecastRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPISetBudgetForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPISetBudgetForecastRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPISetBudgetForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPISetBudgetForecastRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetBudgetForecastExecute(r)
}

/*
SetBudgetForecast Operation to set BudgetForecast.

Operation to add/update Budget Forecast information. <p><strong>OperationId:</strong>setBudgetForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPISetBudgetForecastRequest
*/
func (a *CashieringConfigAPIService) SetBudgetForecast(ctx context.Context) CashieringConfigAPISetBudgetForecastRequest {
	return CashieringConfigAPISetBudgetForecastRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) SetBudgetForecastExecute(r CashieringConfigAPISetBudgetForecastRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.SetBudgetForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/budgetForecast/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.budgetForecastInformationBase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPISetCompAuthorizerRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	compAuthorizer *CompAuthorizer
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPISetCompAuthorizerRequest) Authorization(authorization string) CashieringConfigAPISetCompAuthorizerRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPISetCompAuthorizerRequest) XAppKey(xAppKey string) CashieringConfigAPISetCompAuthorizerRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPISetCompAuthorizerRequest) XHotelid(xHotelid string) CashieringConfigAPISetCompAuthorizerRequest {
	r.xHotelid = &xHotelid
	return r
}

// Retrieve a summary of transactions for a guest or a set of guests.
func (r CashieringConfigAPISetCompAuthorizerRequest) CompAuthorizer(compAuthorizer CompAuthorizer) CashieringConfigAPISetCompAuthorizerRequest {
	r.compAuthorizer = &compAuthorizer
	return r
}

// External system code.
func (r CashieringConfigAPISetCompAuthorizerRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPISetCompAuthorizerRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPISetCompAuthorizerRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPISetCompAuthorizerRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPISetCompAuthorizerRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetCompAuthorizerExecute(r)
}

/*
SetCompAuthorizer Operation to set CompAuthorizer.

Operation to Set Comp Authorizer. <p><strong>OperationId:</strong>setCompAuthorizer</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPISetCompAuthorizerRequest
*/
func (a *CashieringConfigAPIService) SetCompAuthorizer(ctx context.Context) CashieringConfigAPISetCompAuthorizerRequest {
	return CashieringConfigAPISetCompAuthorizerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) SetCompAuthorizerExecute(r CashieringConfigAPISetCompAuthorizerRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.SetCompAuthorizer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compAuthorizers/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compAuthorizer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPISetExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	exchangeRates *ExchangeRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPISetExchangeRatesRequest) Authorization(authorization string) CashieringConfigAPISetExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPISetExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigAPISetExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPISetExchangeRatesRequest) XHotelid(xHotelid string) CashieringConfigAPISetExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Exchange Rates to be Set.
func (r CashieringConfigAPISetExchangeRatesRequest) ExchangeRates(exchangeRates ExchangeRates) CashieringConfigAPISetExchangeRatesRequest {
	r.exchangeRates = &exchangeRates
	return r
}

// External system code.
func (r CashieringConfigAPISetExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPISetExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPISetExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPISetExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPISetExchangeRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetExchangeRatesExecute(r)
}

/*
SetExchangeRates Operation to set ExchangeRates.

The operation sets exchange rates. <p><strong>OperationId:</strong>setExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPISetExchangeRatesRequest
*/
func (a *CashieringConfigAPIService) SetExchangeRates(ctx context.Context) CashieringConfigAPISetExchangeRatesRequest {
	return CashieringConfigAPISetExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) SetExchangeRatesExecute(r CashieringConfigAPISetExchangeRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.SetExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exchangeRates/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exchangeRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPISetGlobalExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	exchangeRates *ExchangeRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPISetGlobalExchangeRatesRequest) Authorization(authorization string) CashieringConfigAPISetGlobalExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPISetGlobalExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigAPISetGlobalExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Exchange Rates to be Set.
func (r CashieringConfigAPISetGlobalExchangeRatesRequest) ExchangeRates(exchangeRates ExchangeRates) CashieringConfigAPISetGlobalExchangeRatesRequest {
	r.exchangeRates = &exchangeRates
	return r
}

// External system code.
func (r CashieringConfigAPISetGlobalExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPISetGlobalExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPISetGlobalExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPISetGlobalExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPISetGlobalExchangeRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetGlobalExchangeRatesExecute(r)
}

/*
SetGlobalExchangeRates Operation to set GlobalExchangeRates.

The operation sets global exchange rates. <p><strong>OperationId:</strong>setGlobalExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPISetGlobalExchangeRatesRequest
*/
func (a *CashieringConfigAPIService) SetGlobalExchangeRates(ctx context.Context) CashieringConfigAPISetGlobalExchangeRatesRequest {
	return CashieringConfigAPISetGlobalExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) SetGlobalExchangeRatesExecute(r CashieringConfigAPISetGlobalExchangeRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.SetGlobalExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/globalExchangeRates/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exchangeRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigAPISetTransactionCodeAccessRolesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodeAccessRoles *TransactionCodeAccessRoles
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) Authorization(authorization string) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) XAppKey(xAppKey string) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) XHotelid(xHotelid string) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Setting a Transaction Code Access Roles
func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) TransactionCodeAccessRoles(transactionCodeAccessRoles TransactionCodeAccessRoles) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	r.transactionCodeAccessRoles = &transactionCodeAccessRoles
	return r
}

// External system code.
func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) XExternalsystem(xExternalsystem string) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigAPISetTransactionCodeAccessRolesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetTransactionCodeAccessRolesExecute(r)
}

/*
SetTransactionCodeAccessRoles Operation to set TransactionCodeAccessRoles.

Operation to Set Transaction Code Access Roles. <p><strong>OperationId:</strong>setTransactionCodeAccessRoles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigAPISetTransactionCodeAccessRolesRequest
*/
func (a *CashieringConfigAPIService) SetTransactionCodeAccessRoles(ctx context.Context) CashieringConfigAPISetTransactionCodeAccessRolesRequest {
	return CashieringConfigAPISetTransactionCodeAccessRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigAPIService) SetTransactionCodeAccessRolesExecute(r CashieringConfigAPISetTransactionCodeAccessRolesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigAPIService.SetTransactionCodeAccessRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodeAccessRoles/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionCodeAccessRoles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
