/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CashieringConfigApiService CashieringConfigApi service
type CashieringConfigApiService service

type CashieringConfigApiCalculatePostingRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	transactionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postingAmount *float32
	taxType *string
	guestBalance *float32
	roomType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiCalculatePostingRequest) Authorization(authorization string) CashieringConfigApiCalculatePostingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiCalculatePostingRequest) XAppKey(xAppKey string) CashieringConfigApiCalculatePostingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiCalculatePostingRequest) XHotelid(xHotelid string) CashieringConfigApiCalculatePostingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Base amount to test for posting.
func (r CashieringConfigApiCalculatePostingRequest) PostingAmount(postingAmount float32) CashieringConfigApiCalculatePostingRequest {
	r.postingAmount = &postingAmount
	return r
}

// Specify this criteria if calculation is based on the tax type.
func (r CashieringConfigApiCalculatePostingRequest) TaxType(taxType string) CashieringConfigApiCalculatePostingRequest {
	r.taxType = &taxType
	return r
}

// Specify this criteria if calculation is based on the guest balance.
func (r CashieringConfigApiCalculatePostingRequest) GuestBalance(guestBalance float32) CashieringConfigApiCalculatePostingRequest {
	r.guestBalance = &guestBalance
	return r
}

// Specify this criteria if calculation is based on room type.
func (r CashieringConfigApiCalculatePostingRequest) RoomType(roomType string) CashieringConfigApiCalculatePostingRequest {
	r.roomType = &roomType
	return r
}

// External system code.
func (r CashieringConfigApiCalculatePostingRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiCalculatePostingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiCalculatePostingRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiCalculatePostingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiCalculatePostingRequest) Execute() (*CalculatedPosting, *http.Response, error) {
	return r.ApiService.CalculatePostingExecute(r)
}

/*
CalculatePosting Operation to CalculatePosting.

Operation to test posting amount. <p><strong>OperationId:</strong>calculatePosting</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionCode Transaction Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigApiCalculatePostingRequest
*/
func (a *CashieringConfigApiService) CalculatePosting(ctx context.Context, transactionCode string, hotelId string) CashieringConfigApiCalculatePostingRequest {
	return CashieringConfigApiCalculatePostingRequest{
		ApiService: a,
		ctx: ctx,
		transactionCode: transactionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CalculatedPosting
func (a *CashieringConfigApiService) CalculatePostingExecute(r CashieringConfigApiCalculatePostingRequest) (*CalculatedPosting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalculatedPosting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.CalculatePosting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes/{transactionCode}/chargeSimulations"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionCode"+"}", url.PathEscape(parameterValueToString(r.transactionCode, "transactionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionCode must have at least 1 elements")
	}
	if strlen(r.transactionCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.postingAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmount", r.postingAmount, "")
	}
	if r.taxType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxType", r.taxType, "")
	}
	if r.guestBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestBalance", r.guestBalance, "")
	}
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiChangeCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesToBeChanged *ChangeCompTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiChangeCompTypesRequest) Authorization(authorization string) CashieringConfigApiChangeCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiChangeCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiChangeCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiChangeCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiChangeCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Comp Types.
func (r CashieringConfigApiChangeCompTypesRequest) CompTypesToBeChanged(compTypesToBeChanged ChangeCompTypesRequest) CashieringConfigApiChangeCompTypesRequest {
	r.compTypesToBeChanged = &compTypesToBeChanged
	return r
}

// External system code.
func (r CashieringConfigApiChangeCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiChangeCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiChangeCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiChangeCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiChangeCompTypesRequest) Execute() (*CompTypesStatus, *http.Response, error) {
	return r.ApiService.ChangeCompTypesExecute(r)
}

/*
ChangeCompTypes Operation to Change Comp Types.

Operation to Change Comp Types. <p><strong>OperationId:</strong>changeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiChangeCompTypesRequest
*/
func (a *CashieringConfigApiService) ChangeCompTypes(ctx context.Context) CashieringConfigApiChangeCompTypesRequest {
	return CashieringConfigApiChangeCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompTypesStatus
func (a *CashieringConfigApiService) ChangeCompTypesExecute(r CashieringConfigApiChangeCompTypesRequest) (*CompTypesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.ChangeCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigToBeChanged *ChangeFolioTypeLegendMappingConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit folio type legend mapping information.
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigToBeChanged(folioTypeLegendMappingConfigToBeChanged ChangeFolioTypeLegendMappingConfigRequest) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigToBeChanged = &folioTypeLegendMappingConfigToBeChanged
	return r
}

// External system code.
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) Execute() (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	return r.ApiService.ChangeFolioTypeLegendMappingConfigExecute(r)
}

/*
ChangeFolioTypeLegendMappingConfig Operation to change folio type legend mappings config.

Operation to change folio type legend mappings config. <p><strong>OperationId:</strong>changeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) ChangeFolioTypeLegendMappingConfig(ctx context.Context) CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest {
	return CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingConfigStatus
func (a *CashieringConfigApiService) ChangeFolioTypeLegendMappingConfigExecute(r CashieringConfigApiChangeFolioTypeLegendMappingConfigRequest) (*FolioTypeLegendMappingConfigStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingConfigStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.ChangeFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCode *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) AdjustmentCode(adjustmentCode string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.adjustmentCode = &adjustmentCode
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) HotelId(hotelId string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdjustmentCodesExecute(r)
}

/*
DeleteAdjustmentCodes Operation to delete AdjustmentCodes.

Operation to remove Adjustment Codes. <p><strong>OperationId:</strong>deleteAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) DeleteAdjustmentCodes(ctx context.Context) CashieringConfigApiDeleteAdjustmentCodesRequest {
	return CashieringConfigApiDeleteAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAdjustmentCodesExecute(r CashieringConfigApiDeleteAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adjustmentCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCode", r.adjustmentCode, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	articleCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	articleHotelId *[]string
	inactive *[]bool
	orderSequence *[]float32
	description *[]string
	transactionCode *[]string
	amount *float32
	currencyCode *string
	availableForPostIt *bool
	color *string
	universalProductCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringConfigApiDeleteArticlesRequest) HotelId(hotelId string) CashieringConfigApiDeleteArticlesRequest {
	r.hotelId = &hotelId
	return r
}

// Unique code of the article.
func (r CashieringConfigApiDeleteArticlesRequest) ArticleCodes(articleCodes []string) CashieringConfigApiDeleteArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteArticlesRequest) Authorization(authorization string) CashieringConfigApiDeleteArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code to which the article belongs.
func (r CashieringConfigApiDeleteArticlesRequest) ArticleHotelId(articleHotelId []string) CashieringConfigApiDeleteArticlesRequest {
	r.articleHotelId = &articleHotelId
	return r
}

// Indicates whether the article is inactive or not.
func (r CashieringConfigApiDeleteArticlesRequest) Inactive(inactive []bool) CashieringConfigApiDeleteArticlesRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r CashieringConfigApiDeleteArticlesRequest) OrderSequence(orderSequence []float32) CashieringConfigApiDeleteArticlesRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r CashieringConfigApiDeleteArticlesRequest) Description(description []string) CashieringConfigApiDeleteArticlesRequest {
	r.description = &description
	return r
}

// Transaction code to which the article belongs.
func (r CashieringConfigApiDeleteArticlesRequest) TransactionCode(transactionCode []string) CashieringConfigApiDeleteArticlesRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r CashieringConfigApiDeleteArticlesRequest) Amount(amount float32) CashieringConfigApiDeleteArticlesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringConfigApiDeleteArticlesRequest) CurrencyCode(currencyCode string) CashieringConfigApiDeleteArticlesRequest {
	r.currencyCode = &currencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r CashieringConfigApiDeleteArticlesRequest) AvailableForPostIt(availableForPostIt bool) CashieringConfigApiDeleteArticlesRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r CashieringConfigApiDeleteArticlesRequest) Color(color string) CashieringConfigApiDeleteArticlesRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r CashieringConfigApiDeleteArticlesRequest) UniversalProductCode(universalProductCode []string) CashieringConfigApiDeleteArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigApiDeleteArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteArticlesExecute(r)
}

/*
DeleteArticles Operation to delete Articles.

Operation to remove articles. <p><strong>OperationId:</strong>deleteArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteArticlesRequest
*/
func (a *CashieringConfigApiService) DeleteArticles(ctx context.Context) CashieringConfigApiDeleteArticlesRequest {
	return CashieringConfigApiDeleteArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteArticlesExecute(r CashieringConfigApiDeleteArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	{
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.articleHotelId != nil {
		t := *r.articleHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", t, "multi")
		}
	}
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
	}
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
	}
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
	}
	if r.universalProductCode != nil {
		t := *r.universalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *[]string
	roomClassHotelId *string
	roomClassCode *string
	sourceCodeHotelId *string
	sourceCode *string
	rateCategory *string
	rateCode *[]string
	guaranteeCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with authorization rule
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) HotelId(hotelId []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Authorization rule Room type.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RoomType(roomType []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.roomType = &roomType
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RoomClassHotelId(roomClassHotelId string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RoomClassCode(roomClassCode string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) SourceCodeHotelId(sourceCodeHotelId string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.sourceCodeHotelId = &sourceCodeHotelId
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) SourceCode(sourceCode string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.sourceCode = &sourceCode
	return r
}

// Rate category Code.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RateCategory(rateCategory string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.rateCategory = &rateCategory
	return r
}

// Rate code associated to this rule.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) RateCode(rateCode []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.rateCode = &rateCode
	return r
}

// Guarantee code associated to this rule.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) GuaranteeCode(guaranteeCode []string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.guaranteeCode = &guaranteeCode
	return r
}

// External system code.
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationConfigRuleExecute(r)
}

/*
DeleteAuthorizationConfigRule Operation to delete AuthorizationConfigRule.

 <p><strong>OperationId:</strong>deleteAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) DeleteAuthorizationConfigRule(ctx context.Context) CashieringConfigApiDeleteAuthorizationConfigRuleRequest {
	return CashieringConfigApiDeleteAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAuthorizationConfigRuleExecute(r CashieringConfigApiDeleteAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
	}
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
	}
	if r.sourceCodeHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCodeHotelId", r.sourceCodeHotelId, "")
	}
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
	}
	if r.rateCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", r.rateCategory, "")
	}
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
	}
	if r.guaranteeCode != nil {
		t := *r.guaranteeCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroup *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) AuthorizerGroup(authorizerGroup string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.authorizerGroup = &authorizerGroup
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) HotelId(hotelId string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizerGroupsExecute(r)
}

/*
DeleteAuthorizerGroups Operation to delete AuthorizerGroups.

Operation to remove Authorizer Groups. <p><strong>OperationId:</strong>deleteAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) DeleteAuthorizerGroups(ctx context.Context) CashieringConfigApiDeleteAuthorizerGroupsRequest {
	return CashieringConfigApiDeleteAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteAuthorizerGroupsExecute(r CashieringConfigApiDeleteAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authorizerGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroup", r.authorizerGroup, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with currency exchange service tax
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) HotelId(hotelId []string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency exchange service tax code
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxCode(currencyExchangeServiceTaxCode []string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxCode = &currencyExchangeServiceTaxCode
	return r
}

// External system code.
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCurrencyExchangeServiceTaxesExecute(r)
}

/*
DeleteCurrencyExchangeServiceTaxes Operation to delete CurrencyExchangeServiceTaxes.

Operation to remove currency exchange service taxes. <p><strong>OperationId:</strong>deleteCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) DeleteCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiDeleteCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.currencyExchangeServiceTaxCode != nil {
		t := *r.currencyExchangeServiceTaxCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyExchangeServiceTaxCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) HotelId(hotelId []string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) Code(code []string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExpenseArrangementCodesExecute(r)
}

/*
DeleteExpenseArrangementCodes Operation to delete ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>deleteExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) DeleteExpenseArrangementCodes(ctx context.Context) CashieringConfigApiDeleteExpenseArrangementCodesRequest {
	return CashieringConfigApiDeleteExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteExpenseArrangementCodesExecute(r CashieringConfigApiDeleteExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiDeleteFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	partner *[]string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code of the Hotel.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) HotelId(hotelId []string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.hotelId = &hotelId
	return r
}

// Fiscal folio parameter associated with Partner.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Partner(partner []string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.partner = &partner
	return r
}

// Code of the Fiscal Folio Parameter.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Code(code []string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiDeleteFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFiscalFolioParametersExecute(r)
}

/*
DeleteFiscalFolioParameters Operation to delete FiscalFolioParameters.

Operation to remove Fiscal Folio Parameters. <p><strong>OperationId:</strong>deleteFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiDeleteFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) DeleteFiscalFolioParameters(ctx context.Context) CashieringConfigApiDeleteFiscalFolioParametersRequest {
	return CashieringConfigApiDeleteFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) DeleteFiscalFolioParametersExecute(r CashieringConfigApiDeleteFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.DeleteFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.partner != nil {
		t := *r.partner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partner", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partner", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetAdjustmentCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes []string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetAdjustmentCodesRequest) WildCard(wildCard string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetAdjustmentCodesRequest) Execute() (*AdjustmentCodes, *http.Response, error) {
	return r.ApiService.GetAdjustmentCodesExecute(r)
}

/*
GetAdjustmentCodes Operation to fetch AdjustmentCodes.

Operation to fetch Adjustment Codes. <p><strong>OperationId:</strong>getAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) GetAdjustmentCodes(ctx context.Context) CashieringConfigApiGetAdjustmentCodesRequest {
	return CashieringConfigApiGetAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdjustmentCodes
func (a *CashieringConfigApiService) GetAdjustmentCodesExecute(r CashieringConfigApiGetAdjustmentCodesRequest) (*AdjustmentCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustmentCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.adjustmentCodes != nil {
		t := *r.adjustmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjustmentCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionCodes *[]string
	articleCodes *[]string
	universalProductCode *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetArticlesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetArticlesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetArticlesRequest) Authorization(authorization string) CashieringConfigApiGetArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiGetArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiGetArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetArticlesRequest) TransactionCodes(transactionCodes []string) CashieringConfigApiGetArticlesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigApiGetArticlesRequest) ArticleCodes(articleCodes []string) CashieringConfigApiGetArticlesRequest {
	r.articleCodes = &articleCodes
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigApiGetArticlesRequest) UniversalProductCode(universalProductCode string) CashieringConfigApiGetArticlesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// Indicator that tells whether to include inactive articles in search results.
func (r CashieringConfigApiGetArticlesRequest) IncludeInactive(includeInactive bool) CashieringConfigApiGetArticlesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigApiGetArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetArticlesRequest) Execute() (*ArticlesInfo, *http.Response, error) {
	return r.ApiService.GetArticlesExecute(r)
}

/*
GetArticles Get articles

Use this API to return articles for one or multiple properties based on search criteria such as hotelIds, transactionCodes, articleCodes, etc. One transaction code can sometimes serve as an umbrella for multiple articles, which can be posted using that transaction code.  For example, a single mini bar food transaction code might cover potato chips, crackers, peanuts, pretzels, and so on.<p><strong>OperationId:</strong>getArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetArticlesRequest
*/
func (a *CashieringConfigApiService) GetArticles(ctx context.Context) CashieringConfigApiGetArticlesRequest {
	return CashieringConfigApiGetArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArticlesInfo
func (a *CashieringConfigApiService) GetArticlesExecute(r CashieringConfigApiGetArticlesRequest) (*ArticlesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArticlesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	if r.articleCodes != nil {
		t := *r.articleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCodes", t, "multi")
		}
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetAuthorizerGroupsRequest) HotelIds(hotelIds []string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetAuthorizerGroupsRequest) AuthorizerGroupsCodes(authorizerGroupsCodes []string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.authorizerGroupsCodes = &authorizerGroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetAuthorizerGroupsRequest) WildCard(wildCard string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetAuthorizerGroupsRequest) Execute() (*AuthorizerGroups, *http.Response, error) {
	return r.ApiService.GetAuthorizerGroupsExecute(r)
}

/*
GetAuthorizerGroups Operation to fetch AuthorizerGroups.

Operation to fetch Authorizer Groups. <p><strong>OperationId:</strong>getAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) GetAuthorizerGroups(ctx context.Context) CashieringConfigApiGetAuthorizerGroupsRequest {
	return CashieringConfigApiGetAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthorizerGroups
func (a *CashieringConfigApiService) GetAuthorizerGroupsExecute(r CashieringConfigApiGetAuthorizerGroupsRequest) (*AuthorizerGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizerGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.authorizerGroupsCodes != nil {
		t := *r.authorizerGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerGroupsCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetAvailableCashierNumberRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetAvailableCashierNumberRequest) Authorization(authorization string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetAvailableCashierNumberRequest) XAppKey(xAppKey string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetAvailableCashierNumberRequest) XHotelid(xHotelid string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigApiGetAvailableCashierNumberRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetAvailableCashierNumberRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetAvailableCashierNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetAvailableCashierNumberRequest) Execute() (*CashierNumber, *http.Response, error) {
	return r.ApiService.GetAvailableCashierNumberExecute(r)
}

/*
GetAvailableCashierNumber Operation to fetch AvailableCashierNumber.

The operation returns a next available Cashier Number to be used while creating a new Cashier. <p><strong>OperationId:</strong>getAvailableCashierNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetAvailableCashierNumberRequest
*/
func (a *CashieringConfigApiService) GetAvailableCashierNumber(ctx context.Context) CashieringConfigApiGetAvailableCashierNumberRequest {
	return CashieringConfigApiGetAvailableCashierNumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashierNumber
func (a *CashieringConfigApiService) GetAvailableCashierNumberExecute(r CashieringConfigApiGetAvailableCashierNumberRequest) (*CashierNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetAvailableCashierNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/nextAvailable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	cashierIDs *[]float32
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	name *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Numberic code for cashier ID.
func (r CashieringConfigApiGetCashiersRequest) CashierIDs(cashierIDs []float32) CashieringConfigApiGetCashiersRequest {
	r.cashierIDs = &cashierIDs
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetCashiersRequest) Authorization(authorization string) CashieringConfigApiGetCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetCashiersRequest) XAppKey(xAppKey string) CashieringConfigApiGetCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetCashiersRequest) XHotelid(xHotelid string) CashieringConfigApiGetCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringConfigApiGetCashiersRequest) Limit(limit int32) CashieringConfigApiGetCashiersRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringConfigApiGetCashiersRequest) Offset(offset int32) CashieringConfigApiGetCashiersRequest {
	r.offset = &offset
	return r
}

// Partial name of a cashier.
func (r CashieringConfigApiGetCashiersRequest) Name(name string) CashieringConfigApiGetCashiersRequest {
	r.name = &name
	return r
}

// Indicator that tells whether to include inactive cashiers in search results.
func (r CashieringConfigApiGetCashiersRequest) IncludeInactive(includeInactive bool) CashieringConfigApiGetCashiersRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r CashieringConfigApiGetCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetCashiersRequest) Execute() (*CashiersDetails, *http.Response, error) {
	return r.ApiService.GetCashiersExecute(r)
}

/*
GetCashiers Get cashiers

Use this API to return Cashier information based on search criteria such as cashierIDs, limit, name. <p><strong>OperationId:</strong>getCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetCashiersRequest
*/
func (a *CashieringConfigApiService) GetCashiers(ctx context.Context) CashieringConfigApiGetCashiersRequest {
	return CashieringConfigApiGetCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashiersDetails
func (a *CashieringConfigApiService) GetCashiersExecute(r CashieringConfigApiGetCashiersRequest) (*CashiersDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashiersDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierDetails/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.cashierIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashierIDs", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypeCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetCompTypesRequest) Authorization(authorization string) CashieringConfigApiGetCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiGetCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiGetCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Code is used to identify the CompType.
func (r CashieringConfigApiGetCompTypesRequest) CompTypeCode(compTypeCode string) CashieringConfigApiGetCompTypesRequest {
	r.compTypeCode = &compTypeCode
	return r
}

// External system code.
func (r CashieringConfigApiGetCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetCompTypesRequest) Execute() (*CompTypesDetails, *http.Response, error) {
	return r.ApiService.GetCompTypesExecute(r)
}

/*
GetCompTypes Operation to Fetch Comp Types.

Operation to Fetch Comp TYpes. <p><strong>OperationId:</strong>getCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigApiGetCompTypesRequest
*/
func (a *CashieringConfigApiService) GetCompTypes(ctx context.Context, hotelId string) CashieringConfigApiGetCompTypesRequest {
	return CashieringConfigApiGetCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompTypesDetails
func (a *CashieringConfigApiService) GetCompTypesExecute(r CashieringConfigApiGetCompTypesRequest) (*CompTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.compTypeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTypeCode", r.compTypeCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) Codes(codes []string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) Execute() (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeServiceTaxesExecute(r)
}

/*
GetCurrencyExchangeServiceTaxes Operation to fetch CurrencyExchangeServiceTaxes.

Operation to fetch currency exchange service taxes. <p><strong>OperationId:</strong>getCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) GetCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrencyExchangeServiceTaxes
func (a *CashieringConfigApiService) GetCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiGetCurrencyExchangeServiceTaxesRequest) (*CurrencyExchangeServiceTaxes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrencyExchangeServiceTaxes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetDailyPlanCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetDailyPlanCodesRequest) Authorization(authorization string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetDailyPlanCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetDailyPlanCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigApiGetDailyPlanCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigApiGetDailyPlanCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetDailyPlanCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetDailyPlanCodesRequest) WildCard(wildCard string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetDailyPlanCodesRequest) Execute() (*DailyPlanCodes, *http.Response, error) {
	return r.ApiService.GetDailyPlanCodesExecute(r)
}

/*
GetDailyPlanCodes Operation to fetch DailyPlanCodes.

 <p><strong>OperationId:</strong>getDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetDailyPlanCodesRequest
*/
func (a *CashieringConfigApiService) GetDailyPlanCodes(ctx context.Context) CashieringConfigApiGetDailyPlanCodesRequest {
	return CashieringConfigApiGetDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DailyPlanCodes
func (a *CashieringConfigApiService) GetDailyPlanCodesExecute(r CashieringConfigApiGetDailyPlanCodesRequest) (*DailyPlanCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyPlanCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	arrangementCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetExpenseArrangementCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A flag that determines whether or not to fetch associated transaction codes. Fetches only the arrangement codes when this flag is true.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) ArrangementCodes(arrangementCodes []string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.arrangementCodes = &arrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) WildCard(wildCard string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetExpenseArrangementCodesRequest) Execute() (*ExpenseArrangementCodes, *http.Response, error) {
	return r.ApiService.GetExpenseArrangementCodesExecute(r)
}

/*
GetExpenseArrangementCodes Operation to fetch ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>getExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) GetExpenseArrangementCodes(ctx context.Context) CashieringConfigApiGetExpenseArrangementCodesRequest {
	return CashieringConfigApiGetExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExpenseArrangementCodes
func (a *CashieringConfigApiService) GetExpenseArrangementCodesExecute(r CashieringConfigApiGetExpenseArrangementCodesRequest) (*ExpenseArrangementCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseArrangementCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
	}
	if r.arrangementCodes != nil {
		t := *r.arrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	codes *[]string
	wildCard *string
	internal *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetFiscalFolioParametersRequest) HotelIds(hotelIds []string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetFiscalFolioParametersRequest) Code(code []string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.code = &code
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) Codes(codes []string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) WildCard(wildCard string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.wildCard = &wildCard
	return r
}

// Indicates whether the Fiscal Folio Parameter is user created or from seed data. Set this true to see the standard Fiscal Folio Parameters that are seeded along with the manually created Fiscal Folio Parameters.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) Internal(internal bool) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.internal = &internal
	return r
}

// External system code.
func (r CashieringConfigApiGetFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetFiscalFolioParametersRequest) Execute() (*FiscalFolioParameters, *http.Response, error) {
	return r.ApiService.GetFiscalFolioParametersExecute(r)
}

/*
GetFiscalFolioParameters Operation to fetch FiscalFolioParameters.

Operation to fetch Fiscal Folio Parameters. <p><strong>OperationId:</strong>getFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) GetFiscalFolioParameters(ctx context.Context) CashieringConfigApiGetFiscalFolioParametersRequest {
	return CashieringConfigApiGetFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalFolioParameters
func (a *CashieringConfigApiService) GetFiscalFolioParametersExecute(r CashieringConfigApiGetFiscalFolioParametersRequest) (*FiscalFolioParameters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalFolioParameters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	legendCode *string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with folio type legend mapping
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) HotelId(hotelId string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.hotelId = &hotelId
	return r
}

// Legend code to which folio types attached.
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) LegendCode(legendCode string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.legendCode = &legendCode
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) Authorization(authorization string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) XAppKey(xAppKey string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) XHotelid(xHotelid string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio type to be searched.
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) FolioType(folioType string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.folioType = &folioType
	return r
}

// External system code.
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) Execute() (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	return r.ApiService.GetFolioTypeLegendMappingsConfigExecute(r)
}

/*
GetFolioTypeLegendMappingsConfig Operation to fetch folio type legend mappings config.

Operation to fetch folio type legend mappings config. <p><strong>OperationId:</strong>getFolioTypeLegendMappingsConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest
*/
func (a *CashieringConfigApiService) GetFolioTypeLegendMappingsConfig(ctx context.Context) CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest {
	return CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FolioTypeLegendMappingsConfigDetails
func (a *CashieringConfigApiService) GetFolioTypeLegendMappingsConfigExecute(r CashieringConfigApiGetFolioTypeLegendMappingsConfigRequest) (*FolioTypeLegendMappingsConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeLegendMappingsConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFolioTypeLegendMappingsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "legendCode", r.legendCode, "")
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetFuturePastExchangeRatesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	currencyCode string
	hotelId string
	exchangeTypes *string
	authorization *string
	xAppKey *string
	xHotelid *string
	dateRangeStart *string
	dateRangeEnd *string
	xExternalsystem *string
	acceptLanguage *string
}

// E-certificate conversion.
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) ExchangeTypes(exchangeTypes string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.exchangeTypes = &exchangeTypes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) Authorization(authorization string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) XAppKey(xAppKey string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) XHotelid(xHotelid string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) DateRangeStart(dateRangeStart string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) DateRangeEnd(dateRangeEnd string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// External system code.
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetFuturePastExchangeRatesRequest) Execute() ([]ExchangeRateType, *http.Response, error) {
	return r.ApiService.GetFuturePastExchangeRatesExecute(r)
}

/*
GetFuturePastExchangeRates Operation to fetch FuturePastExchangeRates.

Operation to Fetch Future Past Exchange Rates. <p><strong>OperationId:</strong>getFuturePastExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyCode Currency Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigApiGetFuturePastExchangeRatesRequest
*/
func (a *CashieringConfigApiService) GetFuturePastExchangeRates(ctx context.Context, currencyCode string, hotelId string) CashieringConfigApiGetFuturePastExchangeRatesRequest {
	return CashieringConfigApiGetFuturePastExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
		currencyCode: currencyCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return []ExchangeRateType
func (a *CashieringConfigApiService) GetFuturePastExchangeRatesExecute(r CashieringConfigApiGetFuturePastExchangeRatesRequest) ([]ExchangeRateType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExchangeRateType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetFuturePastExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exchangeRates/{currencyCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyCode"+"}", url.PathEscape(parameterValueToString(r.currencyCode, "currencyCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.currencyCode) < 1 {
		return localVarReturnValue, nil, reportError("currencyCode must have at least 1 elements")
	}
	if strlen(r.currencyCode) > 2000 {
		return localVarReturnValue, nil, reportError("currencyCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeTypes", r.exchangeTypes, "")
	if r.dateRangeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
	}
	if r.dateRangeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetOperaControlSequencesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	countryCode *string
	code *[]string
	hotelCode *[]string
	fetchInstruction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code of fetch criteria
func (r CashieringConfigApiGetOperaControlSequencesRequest) HotelId(hotelId string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetOperaControlSequencesRequest) Authorization(authorization string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetOperaControlSequencesRequest) XAppKey(xAppKey string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetOperaControlSequencesRequest) XHotelid(xHotelid string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Country Code of fetch criteria
func (r CashieringConfigApiGetOperaControlSequencesRequest) CountryCode(countryCode string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.countryCode = &countryCode
	return r
}

// Configuration code.
func (r CashieringConfigApiGetOperaControlSequencesRequest) Code(code []string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.code = &code
	return r
}

// Hotel where the code is configured.
func (r CashieringConfigApiGetOperaControlSequencesRequest) HotelCode(hotelCode []string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.hotelCode = &hotelCode
	return r
}

// Simple type for opera sequence instructions that can be used for partial operations.
func (r CashieringConfigApiGetOperaControlSequencesRequest) FetchInstruction(fetchInstruction []string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.fetchInstruction = &fetchInstruction
	return r
}

// External system code.
func (r CashieringConfigApiGetOperaControlSequencesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetOperaControlSequencesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetOperaControlSequencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetOperaControlSequencesRequest) Execute() (*OperaControlSequences, *http.Response, error) {
	return r.ApiService.GetOperaControlSequencesExecute(r)
}

/*
GetOperaControlSequences Operation to fetch OperaControlSequences.

Operation to fetch Opera Document Sequences. <p><strong>OperationId:</strong>getOperaControlSequences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetOperaControlSequencesRequest
*/
func (a *CashieringConfigApiService) GetOperaControlSequences(ctx context.Context) CashieringConfigApiGetOperaControlSequencesRequest {
	return CashieringConfigApiGetOperaControlSequencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaControlSequences
func (a *CashieringConfigApiService) GetOperaControlSequencesExecute(r CashieringConfigApiGetOperaControlSequencesRequest) (*OperaControlSequences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaControlSequences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetOperaControlSequences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/operaControlSequences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.hotelCode != nil {
		t := *r.hotelCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "HotelCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "HotelCode", t, "multi")
		}
	}
	if r.fetchInstruction != nil {
		t := *r.fetchInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetPaymentMethodsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	transactionCodes *[]string
	paymentMethods *[]string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetPaymentMethodsRequest) HotelIds(hotelIds []string) CashieringConfigApiGetPaymentMethodsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetPaymentMethodsRequest) Authorization(authorization string) CashieringConfigApiGetPaymentMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetPaymentMethodsRequest) XAppKey(xAppKey string) CashieringConfigApiGetPaymentMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetPaymentMethodsRequest) XHotelid(xHotelid string) CashieringConfigApiGetPaymentMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringConfigApiGetPaymentMethodsRequest) Limit(limit int32) CashieringConfigApiGetPaymentMethodsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringConfigApiGetPaymentMethodsRequest) Offset(offset int32) CashieringConfigApiGetPaymentMethodsRequest {
	r.offset = &offset
	return r
}

func (r CashieringConfigApiGetPaymentMethodsRequest) TransactionCodes(transactionCodes []string) CashieringConfigApiGetPaymentMethodsRequest {
	r.transactionCodes = &transactionCodes
	return r
}

func (r CashieringConfigApiGetPaymentMethodsRequest) PaymentMethods(paymentMethods []string) CashieringConfigApiGetPaymentMethodsRequest {
	r.paymentMethods = &paymentMethods
	return r
}

// Simple Type for payment method fetch instruction.
func (r CashieringConfigApiGetPaymentMethodsRequest) FetchInstructions(fetchInstructions []string) CashieringConfigApiGetPaymentMethodsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigApiGetPaymentMethodsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetPaymentMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetPaymentMethodsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetPaymentMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetPaymentMethodsRequest) Execute() (*PaymentMethodsInfo, *http.Response, error) {
	return r.ApiService.GetPaymentMethodsExecute(r)
}

/*
GetPaymentMethods Operation to fetch PaymentMethods.

Operation to fetch payment methods. <p><strong>OperationId:</strong>getPaymentMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetPaymentMethodsRequest
*/
func (a *CashieringConfigApiService) GetPaymentMethods(ctx context.Context) CashieringConfigApiGetPaymentMethodsRequest {
	return CashieringConfigApiGetPaymentMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentMethodsInfo
func (a *CashieringConfigApiService) GetPaymentMethodsExecute(r CashieringConfigApiGetPaymentMethodsRequest) (*PaymentMethodsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentMethodsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetPaymentMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelPaymentMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	if r.paymentMethods != nil {
		t := *r.paymentMethods
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethods", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethods", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetRevenueBucketCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	trxCodeArrangementCodes *[]string
	wildCard *string
	trxCodeArrangementType *string
	code *[]string
	revenueBucketTypesWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetRevenueBucketCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetRevenueBucketCodesRequest) Authorization(authorization string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetRevenueBucketCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetRevenueBucketCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetRevenueBucketCodesRequest) TrxCodeArrangementCodes(trxCodeArrangementCodes []string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.trxCodeArrangementCodes = &trxCodeArrangementCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetRevenueBucketCodesRequest) WildCard(wildCard string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Fiscal Bucket Type.
func (r CashieringConfigApiGetRevenueBucketCodesRequest) TrxCodeArrangementType(trxCodeArrangementType string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.trxCodeArrangementType = &trxCodeArrangementType
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetRevenueBucketCodesRequest) Code(code []string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.code = &code
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetRevenueBucketCodesRequest) RevenueBucketTypesWildCard(revenueBucketTypesWildCard string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.revenueBucketTypesWildCard = &revenueBucketTypesWildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetRevenueBucketCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetRevenueBucketCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetRevenueBucketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetRevenueBucketCodesRequest) Execute() (*RevenueBucketCodes, *http.Response, error) {
	return r.ApiService.GetRevenueBucketCodesExecute(r)
}

/*
GetRevenueBucketCodes Operation to fetch RevenueBucketCodes.

Operation to fetch Revenue Bucket Codes. <p><strong>OperationId:</strong>getRevenueBucketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetRevenueBucketCodesRequest
*/
func (a *CashieringConfigApiService) GetRevenueBucketCodes(ctx context.Context) CashieringConfigApiGetRevenueBucketCodesRequest {
	return CashieringConfigApiGetRevenueBucketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevenueBucketCodes
func (a *CashieringConfigApiService) GetRevenueBucketCodesExecute(r CashieringConfigApiGetRevenueBucketCodesRequest) (*RevenueBucketCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueBucketCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetRevenueBucketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revenueBucketCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.trxCodeArrangementCodes != nil {
		t := *r.trxCodeArrangementCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.trxCodeArrangementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementType", r.trxCodeArrangementType, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.revenueBucketTypesWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketTypesWildCard", r.revenueBucketTypesWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	trxCodeArrangementCode *[]string
	wildCard *string
	compAccounting *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetRoutingInstructionsRequest) HotelId(hotelId []string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetRoutingInstructionsRequest) Authorization(authorization string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetRoutingInstructionsRequest) TrxCodeArrangementCode(trxCodeArrangementCode []string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.trxCodeArrangementCode = &trxCodeArrangementCode
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetRoutingInstructionsRequest) WildCard(wildCard string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.wildCard = &wildCard
	return r
}

// Determines if this is a comp routing code or a routing code.
func (r CashieringConfigApiGetRoutingInstructionsRequest) CompAccounting(compAccounting bool) CashieringConfigApiGetRoutingInstructionsRequest {
	r.compAccounting = &compAccounting
	return r
}

// External system code.
func (r CashieringConfigApiGetRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetRoutingInstructionsRequest) Execute() (*RoutingInstructions, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsExecute(r)
}

/*
GetRoutingInstructions Get routing instructions

Use this API to return routing instructions based on search criteria such as hotelId, trxCodeArrangementCode, wildCard.  Routing instructions are used to route specific charges to different destinations.<p><strong>OperationId:</strong>getRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetRoutingInstructionsRequest
*/
func (a *CashieringConfigApiService) GetRoutingInstructions(ctx context.Context) CashieringConfigApiGetRoutingInstructionsRequest {
	return CashieringConfigApiGetRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoutingInstructions
func (a *CashieringConfigApiService) GetRoutingInstructionsExecute(r CashieringConfigApiGetRoutingInstructionsRequest) (*RoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if len(*r.hotelId) > 4000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 4000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "csv")
	if r.trxCodeArrangementCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeArrangementCode", r.trxCodeArrangementCode, "csv")
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.compAccounting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compAccounting", r.compAccounting, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTaxTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxTypeCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetTaxTypesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetTaxTypesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTaxTypesRequest) Authorization(authorization string) CashieringConfigApiGetTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTaxTypesRequest) XAppKey(xAppKey string) CashieringConfigApiGetTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTaxTypesRequest) XHotelid(xHotelid string) CashieringConfigApiGetTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTaxTypesRequest) TaxTypeCodes(taxTypeCodes []string) CashieringConfigApiGetTaxTypesRequest {
	r.taxTypeCodes = &taxTypeCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTaxTypesRequest) WildCard(wildCard string) CashieringConfigApiGetTaxTypesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetTaxTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTaxTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTaxTypesRequest) Execute() (*TaxTypes, *http.Response, error) {
	return r.ApiService.GetTaxTypesExecute(r)
}

/*
GetTaxTypes Operation to fetch TaxTypes.

Operation to fetch Tax Types. <p><strong>OperationId:</strong>getTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTaxTypesRequest
*/
func (a *CashieringConfigApiService) GetTaxTypes(ctx context.Context) CashieringConfigApiGetTaxTypesRequest {
	return CashieringConfigApiGetTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxTypes
func (a *CashieringConfigApiService) GetTaxTypesExecute(r CashieringConfigApiGetTaxTypesRequest) (*TaxTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.taxTypeCodes != nil {
		t := *r.taxTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTypeCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTransactionCodes *bool
	includeInactive *bool
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	transactionCodes *[]string
	wildCard *string
	description *string
	brandCode *string
	universalProductCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate whether comp accounting transaction codes are being requested. If true, only comp accounting transaction codes will be returned. If false, only standard transaction codes will be returned.
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) CompTransactionCodes(compTransactionCodes bool) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.compTransactionCodes = &compTransactionCodes
	return r
}

// Inactive flag used to include/exclude inactive transaction codes from the search result
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) IncludeInactive(includeInactive bool) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r CashieringConfigApiGetTemplateTransactionCodesRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

func (r CashieringConfigApiGetTemplateTransactionCodesRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) TransactionCodes(transactionCodes []string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) WildCard(wildCard string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the Transaction code.
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) Description(description string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.description = &description
	return r
}

// Property associated with the corporate information brand code in the search criteria
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) BrandCode(brandCode string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.brandCode = &brandCode
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) UniversalProductCode(universalProductCode string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTemplateTransactionCodesRequest) Execute() (*TemplateTransactionCodes, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionCodesExecute(r)
}

/*
GetTemplateTransactionCodes Get template transaction codes

Use this API to return template transaction codes summaries based on search criteria such as transactionGroupCodes, transactionSubgroupsCodes, transactionCodes, wildCard, etc.<p><strong>OperationId:</strong>getTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTemplateTransactionCodesRequest
*/
func (a *CashieringConfigApiService) GetTemplateTransactionCodes(ctx context.Context) CashieringConfigApiGetTemplateTransactionCodesRequest {
	return CashieringConfigApiGetTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTransactionCodes
func (a *CashieringConfigApiService) GetTemplateTransactionCodesExecute(r CashieringConfigApiGetTemplateTransactionCodesRequest) (*TemplateTransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.compTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTransactionCodes", r.compTransactionCodes, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
	}
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.brandCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brandCode", r.brandCode, "")
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTemplateTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	wildCard *string
	transactionGroupType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) Authorization(authorization string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) WildCard(wildCard string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Wrapper Transaction Type.
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) TransactionGroupType(transactionGroupType string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.transactionGroupType = &transactionGroupType
	return r
}

// External system code.
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTemplateTransactionGroupsRequest) Execute() (*TemplateTransactionGroups, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionGroupsExecute(r)
}

/*
GetTemplateTransactionGroups Operation to fetch TemplateTransactionGroups.

Operation to fetch template transaction group. <p><strong>OperationId:</strong>getTemplateTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTemplateTransactionGroupsRequest
*/
func (a *CashieringConfigApiService) GetTemplateTransactionGroups(ctx context.Context) CashieringConfigApiGetTemplateTransactionGroupsRequest {
	return CashieringConfigApiGetTemplateTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTransactionGroups
func (a *CashieringConfigApiService) GetTemplateTransactionGroupsExecute(r CashieringConfigApiGetTemplateTransactionGroupsRequest) (*TemplateTransactionGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTransactionGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTemplateTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.transactionGroupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupType", r.transactionGroupType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTemplateTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) WildCard(wildCard string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) Execute() (*TemplateTransactionSubgroups, *http.Response, error) {
	return r.ApiService.GetTemplateTransactionSubgroupsExecute(r)
}

/*
GetTemplateTransactionSubgroups Operation to fetch TemplateTransactionSubgroups.

Operation to fetch template transaction subgroups <p><strong>OperationId:</strong>getTemplateTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTemplateTransactionSubgroupsRequest
*/
func (a *CashieringConfigApiService) GetTemplateTransactionSubgroups(ctx context.Context) CashieringConfigApiGetTemplateTransactionSubgroupsRequest {
	return CashieringConfigApiGetTemplateTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTransactionSubgroups
func (a *CashieringConfigApiService) GetTemplateTransactionSubgroupsExecute(r CashieringConfigApiGetTemplateTransactionSubgroupsRequest) (*TemplateTransactionSubgroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTransactionSubgroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTemplateTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
	}
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTransactionCodeRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	transactionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTransactionCodeRequest) Authorization(authorization string) CashieringConfigApiGetTransactionCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTransactionCodeRequest) XAppKey(xAppKey string) CashieringConfigApiGetTransactionCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTransactionCodeRequest) XHotelid(xHotelid string) CashieringConfigApiGetTransactionCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for transaction code instructions that can be used for partial operations.
func (r CashieringConfigApiGetTransactionCodeRequest) FetchInstructions(fetchInstructions []string) CashieringConfigApiGetTransactionCodeRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r CashieringConfigApiGetTransactionCodeRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTransactionCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTransactionCodeRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTransactionCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTransactionCodeRequest) Execute() (*HotelTransactionCode, *http.Response, error) {
	return r.ApiService.GetTransactionCodeExecute(r)
}

/*
GetTransactionCode Get transaction codes

Use this API to return transaction codes based on search criteria such as hotelIds, transactionGroupCodes, transactionSubgroupsCodes, transactionCodes, description, etc.<p><strong>OperationId:</strong>getTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionCode Transaction Code in OPERA
 @param hotelId Unique ID of the hotel in OPERA
 @return CashieringConfigApiGetTransactionCodeRequest
*/
func (a *CashieringConfigApiService) GetTransactionCode(ctx context.Context, transactionCode string, hotelId string) CashieringConfigApiGetTransactionCodeRequest {
	return CashieringConfigApiGetTransactionCodeRequest{
		ApiService: a,
		ctx: ctx,
		transactionCode: transactionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelTransactionCode
func (a *CashieringConfigApiService) GetTransactionCodeExecute(r CashieringConfigApiGetTransactionCodeRequest) (*HotelTransactionCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTransactionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes/{transactionCode}/hotelTransactionCode"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionCode"+"}", url.PathEscape(parameterValueToString(r.transactionCode, "transactionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionCode) < 1 {
		return localVarReturnValue, nil, reportError("transactionCode must have at least 1 elements")
	}
	if strlen(r.transactionCode) > 2000 {
		return localVarReturnValue, nil, reportError("transactionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTransactionCodes *bool
	includeInactive *bool
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	transactionCodes *[]string
	wildCard *string
	description *string
	brandCode *string
	universalProductCode *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetTransactionCodesRequest) HotelIds(hotelIds []string) CashieringConfigApiGetTransactionCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTransactionCodesRequest) Authorization(authorization string) CashieringConfigApiGetTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigApiGetTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigApiGetTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate whether comp accounting transaction codes are being requested. If true, only comp accounting transaction codes will be returned. If false, only standard transaction codes will be returned.
func (r CashieringConfigApiGetTransactionCodesRequest) CompTransactionCodes(compTransactionCodes bool) CashieringConfigApiGetTransactionCodesRequest {
	r.compTransactionCodes = &compTransactionCodes
	return r
}

// Inactive flag used to include/exclude inactive transaction codes from the search result
func (r CashieringConfigApiGetTransactionCodesRequest) IncludeInactive(includeInactive bool) CashieringConfigApiGetTransactionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r CashieringConfigApiGetTransactionCodesRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigApiGetTransactionCodesRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

func (r CashieringConfigApiGetTransactionCodesRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigApiGetTransactionCodesRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTransactionCodesRequest) TransactionCodes(transactionCodes []string) CashieringConfigApiGetTransactionCodesRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTransactionCodesRequest) WildCard(wildCard string) CashieringConfigApiGetTransactionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the Transaction code.
func (r CashieringConfigApiGetTransactionCodesRequest) Description(description string) CashieringConfigApiGetTransactionCodesRequest {
	r.description = &description
	return r
}

// Property associated with the corporate information brand code in the search criteria
func (r CashieringConfigApiGetTransactionCodesRequest) BrandCode(brandCode string) CashieringConfigApiGetTransactionCodesRequest {
	r.brandCode = &brandCode
	return r
}

// Unique Universal product code search criteria.
func (r CashieringConfigApiGetTransactionCodesRequest) UniversalProductCode(universalProductCode string) CashieringConfigApiGetTransactionCodesRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// External system code.
func (r CashieringConfigApiGetTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTransactionCodesRequest) Execute() (*HotelTransactionCodes, *http.Response, error) {
	return r.ApiService.GetTransactionCodesExecute(r)
}

/*
GetTransactionCodes Operation to fetch TransactionCodes.

Operation to fetch transaction codes. <p><strong>OperationId:</strong>getTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTransactionCodesRequest
*/
func (a *CashieringConfigApiService) GetTransactionCodes(ctx context.Context) CashieringConfigApiGetTransactionCodesRequest {
	return CashieringConfigApiGetTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HotelTransactionCodes
func (a *CashieringConfigApiService) GetTransactionCodesExecute(r CashieringConfigApiGetTransactionCodesRequest) (*HotelTransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.compTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compTransactionCodes", r.compTransactionCodes, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
	}
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
	}
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.brandCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brandCode", r.brandCode, "")
	}
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	wildCard *string
	transactionGroupType *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetTransactionGroupsRequest) HotelIds(hotelIds []string) CashieringConfigApiGetTransactionGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTransactionGroupsRequest) Authorization(authorization string) CashieringConfigApiGetTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiGetTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiGetTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTransactionGroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigApiGetTransactionGroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTransactionGroupsRequest) WildCard(wildCard string) CashieringConfigApiGetTransactionGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Wrapper Transaction Type.
func (r CashieringConfigApiGetTransactionGroupsRequest) TransactionGroupType(transactionGroupType string) CashieringConfigApiGetTransactionGroupsRequest {
	r.transactionGroupType = &transactionGroupType
	return r
}

// External system code.
func (r CashieringConfigApiGetTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTransactionGroupsRequest) Execute() (*TransactionGroups, *http.Response, error) {
	return r.ApiService.GetTransactionGroupsExecute(r)
}

/*
GetTransactionGroups Operation to fetch TransactionGroups.

Operation to fetch transaction groups. <p><strong>OperationId:</strong>getTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTransactionGroupsRequest
*/
func (a *CashieringConfigApiService) GetTransactionGroups(ctx context.Context) CashieringConfigApiGetTransactionGroupsRequest {
	return CashieringConfigApiGetTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionGroups
func (a *CashieringConfigApiService) GetTransactionGroupsExecute(r CashieringConfigApiGetTransactionGroupsRequest) (*TransactionGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.transactionGroupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupType", r.transactionGroupType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiGetTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroupCodes *[]string
	transactionSubgroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r CashieringConfigApiGetTransactionSubgroupsRequest) HotelIds(hotelIds []string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiGetTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiGetTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiGetTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringConfigApiGetTransactionSubgroupsRequest) TransactionGroupCodes(transactionGroupCodes []string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.transactionGroupCodes = &transactionGroupCodes
	return r
}

// Codes to be searched.
func (r CashieringConfigApiGetTransactionSubgroupsRequest) TransactionSubgroupsCodes(transactionSubgroupsCodes []string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.transactionSubgroupsCodes = &transactionSubgroupsCodes
	return r
}

// Wildcard search on the code.
func (r CashieringConfigApiGetTransactionSubgroupsRequest) WildCard(wildCard string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r CashieringConfigApiGetTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiGetTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiGetTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiGetTransactionSubgroupsRequest) Execute() (*HotelTransactionSubgroups, *http.Response, error) {
	return r.ApiService.GetTransactionSubgroupsExecute(r)
}

/*
GetTransactionSubgroups Operation to fetch TransactionSubgroups.

Operation to fetch transaction sub groups. <p><strong>OperationId:</strong>getTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiGetTransactionSubgroupsRequest
*/
func (a *CashieringConfigApiService) GetTransactionSubgroups(ctx context.Context) CashieringConfigApiGetTransactionSubgroupsRequest {
	return CashieringConfigApiGetTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HotelTransactionSubgroups
func (a *CashieringConfigApiService) GetTransactionSubgroupsExecute(r CashieringConfigApiGetTransactionSubgroupsRequest) (*HotelTransactionSubgroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTransactionSubgroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.GetTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.transactionGroupCodes != nil {
		t := *r.transactionGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroupCodes", t, "multi")
		}
	}
	if r.transactionSubgroupsCodes != nil {
		t := *r.transactionSubgroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubgroupsCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *PutAdjustmentCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Adjustment Code Configurations.
func (r CashieringConfigApiPostAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes PutAdjustmentCodesRequest) CashieringConfigApiPostAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r CashieringConfigApiPostAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdjustmentCodesExecute(r)
}

/*
PostAdjustmentCodes Operation to create AdjustmentCodes.

Operation to create Adjustment Codes. <p><strong>OperationId:</strong>postAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) PostAdjustmentCodes(ctx context.Context) CashieringConfigApiPostAdjustmentCodesRequest {
	return CashieringConfigApiPostAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAdjustmentCodesExecute(r CashieringConfigApiPostAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *PutArticlesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostArticlesRequest) Authorization(authorization string) CashieringConfigApiPostArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiPostArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiPostArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create articles.
func (r CashieringConfigApiPostArticlesRequest) Articles(articles PutArticlesRequest) CashieringConfigApiPostArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r CashieringConfigApiPostArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostArticlesExecute(r)
}

/*
PostArticles Operation to create Articles.

Operation to create articles. <p><strong>OperationId:</strong>postArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostArticlesRequest
*/
func (a *CashieringConfigApiService) PostArticles(ctx context.Context) CashieringConfigApiPostArticlesRequest {
	return CashieringConfigApiPostArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostArticlesExecute(r CashieringConfigApiPostArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *PutAuthorizationConfigRuleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new authorization rule for given hotel code.
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules PutAuthorizationConfigRuleRequest) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizationConfigRuleExecute(r)
}

/*
PostAuthorizationConfigRule Operation to create AuthorizationConfigRule.

 <p><strong>OperationId:</strong>postAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) PostAuthorizationConfigRule(ctx context.Context) CashieringConfigApiPostAuthorizationConfigRuleRequest {
	return CashieringConfigApiPostAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAuthorizationConfigRuleExecute(r CashieringConfigApiPostAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroups *PostAuthorizerGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Authorizer Group Configuration.
func (r CashieringConfigApiPostAuthorizerGroupsRequest) AuthorizerGroups(authorizerGroups PostAuthorizerGroupsRequest) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.authorizerGroups = &authorizerGroups
	return r
}

// External system code.
func (r CashieringConfigApiPostAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAuthorizerGroupsExecute(r)
}

/*
PostAuthorizerGroups Operation to create AuthorizerGroups.

Operation to create Authorizer Groups. <p><strong>OperationId:</strong>postAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) PostAuthorizerGroups(ctx context.Context) CashieringConfigApiPostAuthorizerGroupsRequest {
	return CashieringConfigApiPostAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostAuthorizerGroupsExecute(r CashieringConfigApiPostAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *PutCashiersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostCashiersRequest) Authorization(authorization string) CashieringConfigApiPostCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostCashiersRequest) XAppKey(xAppKey string) CashieringConfigApiPostCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostCashiersRequest) XHotelid(xHotelid string) CashieringConfigApiPostCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating cashiers.
func (r CashieringConfigApiPostCashiersRequest) Cashiers(cashiers PutCashiersRequest) CashieringConfigApiPostCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r CashieringConfigApiPostCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCashiersExecute(r)
}

/*
PostCashiers Operation to create Cashiers.

Operation to Create Cashier. <p><strong>OperationId:</strong>postCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostCashiersRequest
*/
func (a *CashieringConfigApiService) PostCashiers(ctx context.Context) CashieringConfigApiPostCashiersRequest {
	return CashieringConfigApiPostCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCashiersExecute(r CashieringConfigApiPostCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	compTypesCriteria *PostCompTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostCompTypesRequest) Authorization(authorization string) CashieringConfigApiPostCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiPostCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiPostCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating CompTypes.
func (r CashieringConfigApiPostCompTypesRequest) CompTypesCriteria(compTypesCriteria PostCompTypesRequest) CashieringConfigApiPostCompTypesRequest {
	r.compTypesCriteria = &compTypesCriteria
	return r
}

// External system code.
func (r CashieringConfigApiPostCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompTypesExecute(r)
}

/*
PostCompTypes Operation to Create Comp Types

Operation to Create Comp Types <p><strong>OperationId:</strong>postCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostCompTypesRequest
*/
func (a *CashieringConfigApiService) PostCompTypes(ctx context.Context) CashieringConfigApiPostCompTypesRequest {
	return CashieringConfigApiPostCompTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCompTypesExecute(r CashieringConfigApiPostCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *PutCurrencyExchangeServiceTaxesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new currency exchange service taxes
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes PutCurrencyExchangeServiceTaxesRequest) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCurrencyExchangeServiceTaxesExecute(r)
}

/*
PostCurrencyExchangeServiceTaxes Operation to create CurrencyExchangeServiceTaxes.

Operation to create currency exchange service taxes. <p><strong>OperationId:</strong>postCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) PostCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiPostCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *PutExpenseArrangementCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new expense arrangement codes.
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes PutExpenseArrangementCodesRequest) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExpenseArrangementCodesExecute(r)
}

/*
PostExpenseArrangementCodes Operation to create ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>postExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) PostExpenseArrangementCodes(ctx context.Context) CashieringConfigApiPostExpenseArrangementCodesRequest {
	return CashieringConfigApiPostExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostExpenseArrangementCodesExecute(r CashieringConfigApiPostExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	folioTypeLegendMappingConfigCriteria *PostFolioTypeLegendMappingConfigRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create folio type legend mapping information.
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) FolioTypeLegendMappingConfigCriteria(folioTypeLegendMappingConfigCriteria PostFolioTypeLegendMappingConfigRequest) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.folioTypeLegendMappingConfigCriteria = &folioTypeLegendMappingConfigCriteria
	return r
}

// External system code.
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFolioTypeLegendMappingConfigExecute(r)
}

/*
PostFolioTypeLegendMappingConfig Operation to create folio type legend mappings config.

Operation to create folio type legend mappings config. <p><strong>OperationId:</strong>postFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) PostFolioTypeLegendMappingConfig(ctx context.Context) CashieringConfigApiPostFolioTypeLegendMappingConfigRequest {
	return CashieringConfigApiPostFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostFolioTypeLegendMappingConfigExecute(r CashieringConfigApiPostFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/folioTypeLegendMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioTypeLegendMappingConfigCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionCodes *PutTemplateTransactionCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigApiPostTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPostTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPostTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template transaction codes configuration.
func (r CashieringConfigApiPostTemplateTransactionCodesRequest) TemplateTransactionCodes(templateTransactionCodes PutTemplateTransactionCodesRequest) CashieringConfigApiPostTemplateTransactionCodesRequest {
	r.templateTransactionCodes = &templateTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigApiPostTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostTemplateTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateTransactionCodesExecute(r)
}

/*
PostTemplateTransactionCodes Post template transaction codes

Use this API to create template transaction codes.<p><strong>OperationId:</strong>postTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostTemplateTransactionCodesRequest
*/
func (a *CashieringConfigApiService) PostTemplateTransactionCodes(ctx context.Context) CashieringConfigApiPostTemplateTransactionCodesRequest {
	return CashieringConfigApiPostTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostTemplateTransactionCodesExecute(r CashieringConfigApiPostTemplateTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostTemplateTransactionSubgroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionSubgroups *PostTemplateTransactionSubgroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) Authorization(authorization string) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) XAppKey(xAppKey string) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) XHotelid(xHotelid string) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template transaction subgroups configuration.
func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) TemplateTransactionSubgroups(templateTransactionSubgroups PostTemplateTransactionSubgroupsRequest) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	r.templateTransactionSubgroups = &templateTransactionSubgroups
	return r
}

// External system code.
func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateTransactionSubgroupsExecute(r)
}

/*
PostTemplateTransactionSubgroups Operation to create TemplateTransactionSubgroups.

Operation to create template transaction subgroups <p><strong>OperationId:</strong>postTemplateTransactionSubgroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostTemplateTransactionSubgroupsRequest
*/
func (a *CashieringConfigApiService) PostTemplateTransactionSubgroups(ctx context.Context) CashieringConfigApiPostTemplateTransactionSubgroupsRequest {
	return CashieringConfigApiPostTemplateTransactionSubgroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostTemplateTransactionSubgroupsExecute(r CashieringConfigApiPostTemplateTransactionSubgroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostTemplateTransactionSubgroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionSubGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionSubgroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionCodes *PutTransactionCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostTransactionCodesRequest) Authorization(authorization string) CashieringConfigApiPostTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPostTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPostTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Transaction Codes Configuration.
func (r CashieringConfigApiPostTransactionCodesRequest) HotelTransactionCodes(hotelTransactionCodes PutTransactionCodesRequest) CashieringConfigApiPostTransactionCodesRequest {
	r.hotelTransactionCodes = &hotelTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigApiPostTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionCodesExecute(r)
}

/*
PostTransactionCodes Post transaction codes

Use this API to create transaction codes for a specific property.<p><strong>OperationId:</strong>postTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostTransactionCodesRequest
*/
func (a *CashieringConfigApiService) PostTransactionCodes(ctx context.Context) CashieringConfigApiPostTransactionCodesRequest {
	return CashieringConfigApiPostTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostTransactionCodesExecute(r CashieringConfigApiPostTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostTransactionGeneratesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionGenerates *PostTransactionGeneratesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostTransactionGeneratesRequest) Authorization(authorization string) CashieringConfigApiPostTransactionGeneratesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostTransactionGeneratesRequest) XAppKey(xAppKey string) CashieringConfigApiPostTransactionGeneratesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostTransactionGeneratesRequest) XHotelid(xHotelid string) CashieringConfigApiPostTransactionGeneratesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create transaction generates.
func (r CashieringConfigApiPostTransactionGeneratesRequest) HotelTransactionGenerates(hotelTransactionGenerates PostTransactionGeneratesRequest) CashieringConfigApiPostTransactionGeneratesRequest {
	r.hotelTransactionGenerates = &hotelTransactionGenerates
	return r
}

// External system code.
func (r CashieringConfigApiPostTransactionGeneratesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostTransactionGeneratesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostTransactionGeneratesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostTransactionGeneratesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostTransactionGeneratesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionGeneratesExecute(r)
}

/*
PostTransactionGenerates Post transaction generates

Use this API to create transaction generates for a specific property.  Generates are rules used to calculate and post additional charges, such as service charges and taxes, when a particular sales charge transaction code is posted to guest, package or AR ledgers.<p><strong>OperationId:</strong>postTransactionGenerates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostTransactionGeneratesRequest
*/
func (a *CashieringConfigApiService) PostTransactionGenerates(ctx context.Context) CashieringConfigApiPostTransactionGeneratesRequest {
	return CashieringConfigApiPostTransactionGeneratesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostTransactionGeneratesExecute(r CashieringConfigApiPostTransactionGeneratesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostTransactionGenerates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/generates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionGenerates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPostTransactionGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionGroups *PostTransactionGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPostTransactionGroupsRequest) Authorization(authorization string) CashieringConfigApiPostTransactionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPostTransactionGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiPostTransactionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPostTransactionGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiPostTransactionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Transaction Groups Configuration.
func (r CashieringConfigApiPostTransactionGroupsRequest) TransactionGroups(transactionGroups PostTransactionGroupsRequest) CashieringConfigApiPostTransactionGroupsRequest {
	r.transactionGroups = &transactionGroups
	return r
}

// External system code.
func (r CashieringConfigApiPostTransactionGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPostTransactionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPostTransactionGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPostTransactionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPostTransactionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransactionGroupsExecute(r)
}

/*
PostTransactionGroups Operation to create TransactionGroups.

Operation to create transaction groups. <p><strong>OperationId:</strong>postTransactionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPostTransactionGroupsRequest
*/
func (a *CashieringConfigApiService) PostTransactionGroups(ctx context.Context) CashieringConfigApiPostTransactionGroupsRequest {
	return CashieringConfigApiPostTransactionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PostTransactionGroupsExecute(r CashieringConfigApiPostTransactionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PostTransactionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutAdjustmentCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	adjustmentCodes *PutAdjustmentCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutAdjustmentCodesRequest) Authorization(authorization string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutAdjustmentCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutAdjustmentCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Adjustment Code Configurations.
func (r CashieringConfigApiPutAdjustmentCodesRequest) AdjustmentCodes(adjustmentCodes PutAdjustmentCodesRequest) CashieringConfigApiPutAdjustmentCodesRequest {
	r.adjustmentCodes = &adjustmentCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutAdjustmentCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutAdjustmentCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutAdjustmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutAdjustmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAdjustmentCodesExecute(r)
}

/*
PutAdjustmentCodes Operation to change AdjustmentCodes.

Operation to change Adjustment Codes. <p><strong>OperationId:</strong>putAdjustmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutAdjustmentCodesRequest
*/
func (a *CashieringConfigApiService) PutAdjustmentCodes(ctx context.Context) CashieringConfigApiPutAdjustmentCodesRequest {
	return CashieringConfigApiPutAdjustmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAdjustmentCodesExecute(r CashieringConfigApiPutAdjustmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAdjustmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelAdjustmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.adjustmentCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutArticlesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	articles *PutArticlesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutArticlesRequest) Authorization(authorization string) CashieringConfigApiPutArticlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutArticlesRequest) XAppKey(xAppKey string) CashieringConfigApiPutArticlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutArticlesRequest) XHotelid(xHotelid string) CashieringConfigApiPutArticlesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change articles.
func (r CashieringConfigApiPutArticlesRequest) Articles(articles PutArticlesRequest) CashieringConfigApiPutArticlesRequest {
	r.articles = &articles
	return r
}

// External system code.
func (r CashieringConfigApiPutArticlesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutArticlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutArticlesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutArticlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutArticlesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutArticlesExecute(r)
}

/*
PutArticles Operation to change Articles.

Operation to change articles. <p><strong>OperationId:</strong>putArticles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutArticlesRequest
*/
func (a *CashieringConfigApiService) PutArticles(ctx context.Context) CashieringConfigApiPutArticlesRequest {
	return CashieringConfigApiPutArticlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutArticlesExecute(r CashieringConfigApiPutArticlesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutArticles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/articles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutAuthorizationConfigRuleRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizationConfigRules *PutAuthorizationConfigRuleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) Authorization(authorization string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) XAppKey(xAppKey string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) XHotelid(xHotelid string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change authorization rule.
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) AuthorizationConfigRules(authorizationConfigRules PutAuthorizationConfigRuleRequest) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.authorizationConfigRules = &authorizationConfigRules
	return r
}

// External system code.
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutAuthorizationConfigRuleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizationConfigRuleExecute(r)
}

/*
PutAuthorizationConfigRule Operation to change AuthorizationConfigRule.

 <p><strong>OperationId:</strong>putAuthorizationConfigRule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutAuthorizationConfigRuleRequest
*/
func (a *CashieringConfigApiService) PutAuthorizationConfigRule(ctx context.Context) CashieringConfigApiPutAuthorizationConfigRuleRequest {
	return CashieringConfigApiPutAuthorizationConfigRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAuthorizationConfigRuleExecute(r CashieringConfigApiPutAuthorizationConfigRuleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAuthorizationConfigRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizationConfigRule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizationConfigRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutAuthorizerGroupsRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	authorizerGroupsToChange *PutAuthorizerGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutAuthorizerGroupsRequest) Authorization(authorization string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutAuthorizerGroupsRequest) XAppKey(xAppKey string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutAuthorizerGroupsRequest) XHotelid(xHotelid string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Authorizer Group Configuration.
func (r CashieringConfigApiPutAuthorizerGroupsRequest) AuthorizerGroupsToChange(authorizerGroupsToChange PutAuthorizerGroupsRequest) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.authorizerGroupsToChange = &authorizerGroupsToChange
	return r
}

// External system code.
func (r CashieringConfigApiPutAuthorizerGroupsRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutAuthorizerGroupsRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutAuthorizerGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutAuthorizerGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAuthorizerGroupsExecute(r)
}

/*
PutAuthorizerGroups Operation to change AuthorizerGroups.

Operation to change Authorizer Groups. <p><strong>OperationId:</strong>putAuthorizerGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutAuthorizerGroupsRequest
*/
func (a *CashieringConfigApiService) PutAuthorizerGroups(ctx context.Context) CashieringConfigApiPutAuthorizerGroupsRequest {
	return CashieringConfigApiPutAuthorizerGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutAuthorizerGroupsExecute(r CashieringConfigApiPutAuthorizerGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutAuthorizerGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizerGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.authorizerGroupsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutCashiersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	cashiers *PutCashiersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutCashiersRequest) Authorization(authorization string) CashieringConfigApiPutCashiersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutCashiersRequest) XAppKey(xAppKey string) CashieringConfigApiPutCashiersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutCashiersRequest) XHotelid(xHotelid string) CashieringConfigApiPutCashiersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request objects for modifying cashiers
func (r CashieringConfigApiPutCashiersRequest) Cashiers(cashiers PutCashiersRequest) CashieringConfigApiPutCashiersRequest {
	r.cashiers = &cashiers
	return r
}

// External system code.
func (r CashieringConfigApiPutCashiersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutCashiersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutCashiersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutCashiersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutCashiersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCashiersExecute(r)
}

/*
PutCashiers Operation to change CashiersDetails.

This Operation to Change a Cashier. <p><strong>OperationId:</strong>putCashiers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutCashiersRequest
*/
func (a *CashieringConfigApiService) PutCashiers(ctx context.Context) CashieringConfigApiPutCashiersRequest {
	return CashieringConfigApiPutCashiersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutCashiersExecute(r CashieringConfigApiPutCashiersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutCashiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashiers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	currencyExchangeServiceTaxes *PutCurrencyExchangeServiceTaxesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) Authorization(authorization string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) XAppKey(xAppKey string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) XHotelid(xHotelid string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing currency exchange service taxes
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) CurrencyExchangeServiceTaxes(currencyExchangeServiceTaxes PutCurrencyExchangeServiceTaxesRequest) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.currencyExchangeServiceTaxes = &currencyExchangeServiceTaxes
	return r
}

// External system code.
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCurrencyExchangeServiceTaxesExecute(r)
}

/*
PutCurrencyExchangeServiceTaxes Operation to change ExchangeServiceTaxes.

Operation to change currency exchange service taxes. <p><strong>OperationId:</strong>putCurrencyExchangeServiceTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest
*/
func (a *CashieringConfigApiService) PutCurrencyExchangeServiceTaxes(ctx context.Context) CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest {
	return CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutCurrencyExchangeServiceTaxesExecute(r CashieringConfigApiPutCurrencyExchangeServiceTaxesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutCurrencyExchangeServiceTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeServiceTaxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.currencyExchangeServiceTaxes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutDailyPlanCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyPlanCodes *PutDailyPlanCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutDailyPlanCodesRequest) Authorization(authorization string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutDailyPlanCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutDailyPlanCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing daily plan codes.
func (r CashieringConfigApiPutDailyPlanCodesRequest) DailyPlanCodes(dailyPlanCodes PutDailyPlanCodesRequest) CashieringConfigApiPutDailyPlanCodesRequest {
	r.dailyPlanCodes = &dailyPlanCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutDailyPlanCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutDailyPlanCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutDailyPlanCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutDailyPlanCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDailyPlanCodesExecute(r)
}

/*
PutDailyPlanCodes Operation to change DailyPlanCodes.

 <p><strong>OperationId:</strong>putDailyPlanCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutDailyPlanCodesRequest
*/
func (a *CashieringConfigApiService) PutDailyPlanCodes(ctx context.Context) CashieringConfigApiPutDailyPlanCodesRequest {
	return CashieringConfigApiPutDailyPlanCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutDailyPlanCodesExecute(r CashieringConfigApiPutDailyPlanCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutDailyPlanCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dailyPlanCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyPlanCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutExpenseArrangementCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	expenseArrangementCodes *PutExpenseArrangementCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) Authorization(authorization string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing expense arrangement codes.
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) ExpenseArrangementCodes(expenseArrangementCodes PutExpenseArrangementCodesRequest) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.expenseArrangementCodes = &expenseArrangementCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutExpenseArrangementCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutExpenseArrangementCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutExpenseArrangementCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutExpenseArrangementCodesExecute(r)
}

/*
PutExpenseArrangementCodes Operation to change ExpenseArrangementCodes.

 <p><strong>OperationId:</strong>putExpenseArrangementCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutExpenseArrangementCodesRequest
*/
func (a *CashieringConfigApiService) PutExpenseArrangementCodes(ctx context.Context) CashieringConfigApiPutExpenseArrangementCodesRequest {
	return CashieringConfigApiPutExpenseArrangementCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutExpenseArrangementCodesExecute(r CashieringConfigApiPutExpenseArrangementCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutExpenseArrangementCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expenseArrangementCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.expenseArrangementCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutFiscalFolioParametersRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioParameters *PutFiscalFolioParametersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutFiscalFolioParametersRequest) Authorization(authorization string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutFiscalFolioParametersRequest) XAppKey(xAppKey string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutFiscalFolioParametersRequest) XHotelid(xHotelid string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Fiscal Folio Parameter Configurations.
func (r CashieringConfigApiPutFiscalFolioParametersRequest) FiscalFolioParameters(fiscalFolioParameters PutFiscalFolioParametersRequest) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.fiscalFolioParameters = &fiscalFolioParameters
	return r
}

// External system code.
func (r CashieringConfigApiPutFiscalFolioParametersRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutFiscalFolioParametersRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutFiscalFolioParametersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutFiscalFolioParametersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutFiscalFolioParametersExecute(r)
}

/*
PutFiscalFolioParameters Operation to change FiscalFolioParameters.

Operation to change Fiscal Folio Parameters. <p><strong>OperationId:</strong>putFiscalFolioParameters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutFiscalFolioParametersRequest
*/
func (a *CashieringConfigApiService) PutFiscalFolioParameters(ctx context.Context) CashieringConfigApiPutFiscalFolioParametersRequest {
	return CashieringConfigApiPutFiscalFolioParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutFiscalFolioParametersExecute(r CashieringConfigApiPutFiscalFolioParametersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutFiscalFolioParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalFolioParameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioParameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutTemplateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTransactionCodes *PutTemplateTransactionCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutTemplateTransactionCodesRequest) Authorization(authorization string) CashieringConfigApiPutTemplateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutTemplateTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutTemplateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutTemplateTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutTemplateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing template transaction codes configuration.
func (r CashieringConfigApiPutTemplateTransactionCodesRequest) TemplateTransactionCodes(templateTransactionCodes PutTemplateTransactionCodesRequest) CashieringConfigApiPutTemplateTransactionCodesRequest {
	r.templateTransactionCodes = &templateTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutTemplateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutTemplateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutTemplateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutTemplateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutTemplateTransactionCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateTransactionCodesExecute(r)
}

/*
PutTemplateTransactionCodes Operation to change TemplateTransactionCodes.

Operation to change template transaction codes. <p><strong>OperationId:</strong>putTemplateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutTemplateTransactionCodesRequest
*/
func (a *CashieringConfigApiService) PutTemplateTransactionCodes(ctx context.Context) CashieringConfigApiPutTemplateTransactionCodesRequest {
	return CashieringConfigApiPutTemplateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) PutTemplateTransactionCodesExecute(r CashieringConfigApiPutTemplateTransactionCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutTemplateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateTransactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiPutTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTransactionCodes *PutTransactionCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiPutTransactionCodesRequest) Authorization(authorization string) CashieringConfigApiPutTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiPutTransactionCodesRequest) XAppKey(xAppKey string) CashieringConfigApiPutTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiPutTransactionCodesRequest) XHotelid(xHotelid string) CashieringConfigApiPutTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Transaction Codes Configuration.
func (r CashieringConfigApiPutTransactionCodesRequest) HotelTransactionCodes(hotelTransactionCodes PutTransactionCodesRequest) CashieringConfigApiPutTransactionCodesRequest {
	r.hotelTransactionCodes = &hotelTransactionCodes
	return r
}

// External system code.
func (r CashieringConfigApiPutTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiPutTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiPutTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiPutTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiPutTransactionCodesRequest) Execute() (*TransactionCodes, *http.Response, error) {
	return r.ApiService.PutTransactionCodesExecute(r)
}

/*
PutTransactionCodes Put transaction codes

Use this API to update transaction codes for a specific property.<p><strong>OperationId:</strong>putTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringConfigApiPutTransactionCodesRequest
*/
func (a *CashieringConfigApiService) PutTransactionCodes(ctx context.Context) CashieringConfigApiPutTransactionCodesRequest {
	return CashieringConfigApiPutTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionCodes
func (a *CashieringConfigApiService) PutTransactionCodesExecute(r CashieringConfigApiPutTransactionCodesRequest) (*TransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.PutTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTransactionCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiRemoveCompTypesRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	compTypesCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiRemoveCompTypesRequest) Authorization(authorization string) CashieringConfigApiRemoveCompTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiRemoveCompTypesRequest) XAppKey(xAppKey string) CashieringConfigApiRemoveCompTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiRemoveCompTypesRequest) XHotelid(xHotelid string) CashieringConfigApiRemoveCompTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigApiRemoveCompTypesRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiRemoveCompTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiRemoveCompTypesRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiRemoveCompTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiRemoveCompTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCompTypesExecute(r)
}

/*
RemoveCompTypes Operation to Remove Comp Types.

Operation to Remove Comp Types. <p><strong>OperationId:</strong>removeCompTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param compTypesCode Comp Types Code to be deleted.
 @return CashieringConfigApiRemoveCompTypesRequest
*/
func (a *CashieringConfigApiService) RemoveCompTypes(ctx context.Context, compTypesCode string) CashieringConfigApiRemoveCompTypesRequest {
	return CashieringConfigApiRemoveCompTypesRequest{
		ApiService: a,
		ctx: ctx,
		compTypesCode: compTypesCode,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) RemoveCompTypesExecute(r CashieringConfigApiRemoveCompTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.RemoveCompTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compTypes/codes/{compTypesCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"compTypesCode"+"}", url.PathEscape(parameterValueToString(r.compTypesCode, "compTypesCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.compTypesCode) < 1 {
		return localVarReturnValue, nil, reportError("compTypesCode must have at least 1 elements")
	}
	if strlen(r.compTypesCode) > 2000 {
		return localVarReturnValue, nil, reportError("compTypesCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest struct {
	ctx context.Context
	ApiService *CashieringConfigApiService
	legendCode string
	folioType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) Authorization(authorization string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) XAppKey(xAppKey string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) XHotelid(xHotelid string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) XExternalsystem(xExternalsystem string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) AcceptLanguage(acceptLanguage string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFolioTypeLegendMappingConfigExecute(r)
}

/*
RemoveFolioTypeLegendMappingConfig Operation to remove folio type legend mappings config.

Operation to remove folio type legend mappings config. <p><strong>OperationId:</strong>removeFolioTypeLegendMappingConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param legendCode Legend Code
 @param folioType Folio Type
 @param hotelId Unique ID of the source hotel in OPERA
 @return CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest
*/
func (a *CashieringConfigApiService) RemoveFolioTypeLegendMappingConfig(ctx context.Context, legendCode string, folioType string, hotelId string) CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest {
	return CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest{
		ApiService: a,
		ctx: ctx,
		legendCode: legendCode,
		folioType: folioType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringConfigApiService) RemoveFolioTypeLegendMappingConfigExecute(r CashieringConfigApiRemoveFolioTypeLegendMappingConfigRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringConfigApiService.RemoveFolioTypeLegendMappingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folios/{folioType}/legends/{legendCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"legendCode"+"}", url.PathEscape(parameterValueToString(r.legendCode, "legendCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folioType"+"}", url.PathEscape(parameterValueToString(r.folioType, "folioType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.legendCode) < 1 {
		return localVarReturnValue, nil, reportError("legendCode must have at least 1 elements")
	}
	if strlen(r.legendCode) > 2000 {
		return localVarReturnValue, nil, reportError("legendCode must have less than 2000 elements")
	}
	if strlen(r.folioType) < 1 {
		return localVarReturnValue, nil, reportError("folioType must have at least 1 elements")
	}
	if strlen(r.folioType) > 2000 {
		return localVarReturnValue, nil, reportError("folioType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
