/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChainConfigApiService ChainConfigApi service
type ChainConfigApiService service

type ChainConfigApiChangeCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	taxTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	customTaxTypesToBeChanged *ChangeCustomTaxTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiChangeCustomTaxTypesRequest) Authorization(authorization string) ChainConfigApiChangeCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiChangeCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigApiChangeCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiChangeCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigApiChangeCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Custom Tax Types.
func (r ChainConfigApiChangeCustomTaxTypesRequest) CustomTaxTypesToBeChanged(customTaxTypesToBeChanged ChangeCustomTaxTypesRequest) ChainConfigApiChangeCustomTaxTypesRequest {
	r.customTaxTypesToBeChanged = &customTaxTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiChangeCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiChangeCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiChangeCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiChangeCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiChangeCustomTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCustomTaxTypesExecute(r)
}

/*
ChangeCustomTaxTypes Change Custom Tax Types

Use this API to update Custom Tax Types. <p><strong>OperationId:</strong>changeCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxTypeCode Unique Code of Tax Types.
 @return ChainConfigApiChangeCustomTaxTypesRequest
*/
func (a *ChainConfigApiService) ChangeCustomTaxTypes(ctx context.Context, taxTypeCode string) ChainConfigApiChangeCustomTaxTypesRequest {
	return ChainConfigApiChangeCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
		taxTypeCode: taxTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) ChangeCustomTaxTypesExecute(r ChainConfigApiChangeCustomTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.ChangeCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes/{taxTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxTypeCode"+"}", url.PathEscape(parameterValueToString(r.taxTypeCode, "taxTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have at least 1 elements")
	}
	if strlen(r.taxTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customTaxTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiDeleteAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	code string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigApiDeleteAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigApiDeleteAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigApiDeleteAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutoFolioSettlementTypesExecute(r)
}

/*
DeleteAutoFolioSettlementTypes Delete Auto Folio Settlement Types

Use this API to delete Auto Folio Settlement Types. <p><strong>OperationId:</strong>deleteAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique ID of Auto Folio Settlement Types.
 @return ChainConfigApiDeleteAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigApiService) DeleteAutoFolioSettlementTypes(ctx context.Context, code string) ChainConfigApiDeleteAutoFolioSettlementTypesRequest {
	return ChainConfigApiDeleteAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteAutoFolioSettlementTypesExecute(r ChainConfigApiDeleteAutoFolioSettlementTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) Codes(codes []string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) WildCard(wildCard string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) Description(description string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetAutoFolioSettlementTypesRequest) Execute() (*AutoFolioSettlementTypesDetails, *http.Response, error) {
	return r.ApiService.GetAutoFolioSettlementTypesExecute(r)
}

/*
GetAutoFolioSettlementTypes Get Auto Folio Settlement Types

Use this API to get Auto Folio Settlement Types. <p><strong>OperationId:</strong>getAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigApiService) GetAutoFolioSettlementTypes(ctx context.Context) ChainConfigApiGetAutoFolioSettlementTypesRequest {
	return ChainConfigApiGetAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutoFolioSettlementTypesDetails
func (a *ChainConfigApiService) GetAutoFolioSettlementTypesExecute(r ChainConfigApiGetAutoFolioSettlementTypesRequest) (*AutoFolioSettlementTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoFolioSettlementTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetCustomTaxTypesRequest) Authorization(authorization string) ChainConfigApiGetCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiGetCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigApiGetCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigApiGetCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetCustomTaxTypesRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetCustomTaxTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetCustomTaxTypesRequest) Codes(codes []string) ChainConfigApiGetCustomTaxTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetCustomTaxTypesRequest) WildCard(wildCard string) ChainConfigApiGetCustomTaxTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetCustomTaxTypesRequest) Description(description string) ChainConfigApiGetCustomTaxTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetCustomTaxTypesRequest) Execute() (*CustomTaxTypesDetails, *http.Response, error) {
	return r.ApiService.GetCustomTaxTypesExecute(r)
}

/*
GetCustomTaxTypes Get Custom Tax Types

Use this API to get Custom Tax Types. <p><strong>OperationId:</strong>getCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetCustomTaxTypesRequest
*/
func (a *ChainConfigApiService) GetCustomTaxTypes(ctx context.Context) ChainConfigApiGetCustomTaxTypesRequest {
	return ChainConfigApiGetCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomTaxTypesDetails
func (a *ChainConfigApiService) GetCustomTaxTypesExecute(r ChainConfigApiGetCustomTaxTypesRequest) (*CustomTaxTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomTaxTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	autoFolioSettlementTypesCriteria *PostAutoFolioSettlementTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Auto Folio Settlement Types.
func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) AutoFolioSettlementTypesCriteria(autoFolioSettlementTypesCriteria PostAutoFolioSettlementTypesRequest) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	r.autoFolioSettlementTypesCriteria = &autoFolioSettlementTypesCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostAutoFolioSettlementTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutoFolioSettlementTypesExecute(r)
}

/*
PostAutoFolioSettlementTypes Create Auto Folio Settlement Types

Use this API to create Auto Folio Settlement Types. <p><strong>OperationId:</strong>postAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigApiService) PostAutoFolioSettlementTypes(ctx context.Context) ChainConfigApiPostAutoFolioSettlementTypesRequest {
	return ChainConfigApiPostAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostAutoFolioSettlementTypesExecute(r ChainConfigApiPostAutoFolioSettlementTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoFolioSettlementTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	customTaxTypesCriteria *PostCustomTaxTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostCustomTaxTypesRequest) Authorization(authorization string) ChainConfigApiPostCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiPostCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigApiPostCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigApiPostCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Custom Tax Types.
func (r ChainConfigApiPostCustomTaxTypesRequest) CustomTaxTypesCriteria(customTaxTypesCriteria PostCustomTaxTypesRequest) ChainConfigApiPostCustomTaxTypesRequest {
	r.customTaxTypesCriteria = &customTaxTypesCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostCustomTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCustomTaxTypesExecute(r)
}

/*
PostCustomTaxTypes Create Custom Tax Types

Use this API to create Custom Tax Types. <p><strong>OperationId:</strong>postCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostCustomTaxTypesRequest
*/
func (a *ChainConfigApiService) PostCustomTaxTypes(ctx context.Context) ChainConfigApiPostCustomTaxTypesRequest {
	return ChainConfigApiPostCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostCustomTaxTypesExecute(r ChainConfigApiPostCustomTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customTaxTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	code string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoFolioSettlementTypesToBeChanged *PutAutoFolioSettlementTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Auto Folio Settlement Types.
func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) AutoFolioSettlementTypesToBeChanged(autoFolioSettlementTypesToBeChanged PutAutoFolioSettlementTypesRequest) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	r.autoFolioSettlementTypesToBeChanged = &autoFolioSettlementTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutAutoFolioSettlementTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAutoFolioSettlementTypesExecute(r)
}

/*
PutAutoFolioSettlementTypes Change Auto Folio Settlement Types

Use this API to update Auto Folio Settlement Types. <p><strong>OperationId:</strong>putAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique ID of Auto Folio Settlement Types.
 @return ChainConfigApiPutAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigApiService) PutAutoFolioSettlementTypes(ctx context.Context, code string) ChainConfigApiPutAutoFolioSettlementTypesRequest {
	return ChainConfigApiPutAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutAutoFolioSettlementTypesExecute(r ChainConfigApiPutAutoFolioSettlementTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoFolioSettlementTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiRemoveCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	taxTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiRemoveCustomTaxTypesRequest) Authorization(authorization string) ChainConfigApiRemoveCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ChainConfigApiRemoveCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigApiRemoveCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiRemoveCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigApiRemoveCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigApiRemoveCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiRemoveCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiRemoveCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiRemoveCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiRemoveCustomTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCustomTaxTypesExecute(r)
}

/*
RemoveCustomTaxTypes Delete Custom Tax Types

Use this API to delete Custom Tax Types. <p><strong>OperationId:</strong>removeCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxTypeCode Unique Code of Tax Types.
 @return ChainConfigApiRemoveCustomTaxTypesRequest
*/
func (a *ChainConfigApiService) RemoveCustomTaxTypes(ctx context.Context, taxTypeCode string) ChainConfigApiRemoveCustomTaxTypesRequest {
	return ChainConfigApiRemoveCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
		taxTypeCode: taxTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) RemoveCustomTaxTypesExecute(r ChainConfigApiRemoveCustomTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.RemoveCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes/{taxTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxTypeCode"+"}", url.PathEscape(parameterValueToString(r.taxTypeCode, "taxTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have at least 1 elements")
	}
	if strlen(r.taxTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
