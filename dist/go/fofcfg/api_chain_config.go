/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChainConfigAPIService ChainConfigAPI service
type ChainConfigAPIService service

type ChainConfigAPIChangeCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	dropLocationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierShiftDropLocationsToBeChanged *CashierShiftDropLocationsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Cashier Shift Drop Locations.
func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) CashierShiftDropLocationsToBeChanged(cashierShiftDropLocationsToBeChanged CashierShiftDropLocationsToBeChanged) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	r.cashierShiftDropLocationsToBeChanged = &cashierShiftDropLocationsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCashierShiftDropLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCashierShiftDropLocationsExecute(r)
}

/*
ChangeCashierShiftDropLocations Change Cashier Shift Drop Locations

Use this API to update Cashier Shift Drop Locations. <p><strong>OperationId:</strong>changeCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dropLocationId Unique ID of drop location.
 @param hotelId Unique ID of hotel.
 @return ChainConfigAPIChangeCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) ChangeCashierShiftDropLocations(ctx context.Context, dropLocationId string, hotelId string) ChainConfigAPIChangeCashierShiftDropLocationsRequest {
	return ChainConfigAPIChangeCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
		dropLocationId: dropLocationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCashierShiftDropLocationsExecute(r ChainConfigAPIChangeCashierShiftDropLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashierShifts/dropLocations/{dropLocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"dropLocationId"+"}", url.PathEscape(parameterValueToString(r.dropLocationId, "dropLocationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.dropLocationId) < 1 {
		return localVarReturnValue, nil, reportError("dropLocationId must have at least 1 elements")
	}
	if strlen(r.dropLocationId) > 2000 {
		return localVarReturnValue, nil, reportError("dropLocationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashierShiftDropLocationsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	taxTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	customTaxTypesToBeChanged *CustomTaxTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCustomTaxTypesRequest) Authorization(authorization string) ChainConfigAPIChangeCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Custom Tax Types.
func (r ChainConfigAPIChangeCustomTaxTypesRequest) CustomTaxTypesToBeChanged(customTaxTypesToBeChanged CustomTaxTypesToBeChanged) ChainConfigAPIChangeCustomTaxTypesRequest {
	r.customTaxTypesToBeChanged = &customTaxTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCustomTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCustomTaxTypesExecute(r)
}

/*
ChangeCustomTaxTypes Change Custom Tax Types

Use this API to update Custom Tax Types. <p><strong>OperationId:</strong>changeCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxTypeCode Unique Code of Tax Types.
 @return ChainConfigAPIChangeCustomTaxTypesRequest
*/
func (a *ChainConfigAPIService) ChangeCustomTaxTypes(ctx context.Context, taxTypeCode string) ChainConfigAPIChangeCustomTaxTypesRequest {
	return ChainConfigAPIChangeCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
		taxTypeCode: taxTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCustomTaxTypesExecute(r ChainConfigAPIChangeCustomTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes/{taxTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxTypeCode"+"}", url.PathEscape(parameterValueToString(r.taxTypeCode, "taxTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have at least 1 elements")
	}
	if strlen(r.taxTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customTaxTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeFiscalGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	fiscalGuestTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalGuestTypesToBeChanged *FiscalGuestTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeFiscalGuestTypesRequest) Authorization(authorization string) ChainConfigAPIChangeFiscalGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeFiscalGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeFiscalGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeFiscalGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeFiscalGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Fiscal Guest Types.
func (r ChainConfigAPIChangeFiscalGuestTypesRequest) FiscalGuestTypesToBeChanged(fiscalGuestTypesToBeChanged FiscalGuestTypesToBeChanged) ChainConfigAPIChangeFiscalGuestTypesRequest {
	r.fiscalGuestTypesToBeChanged = &fiscalGuestTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeFiscalGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeFiscalGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeFiscalGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeFiscalGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeFiscalGuestTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFiscalGuestTypesExecute(r)
}

/*
ChangeFiscalGuestTypes Change Fiscal Guest Types

Use this API to update Fiscal Guest Types. <p><strong>OperationId:</strong>changeFiscalGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fiscalGuestTypeCode Unique Code of Fiscal Guest Types.
 @return ChainConfigAPIChangeFiscalGuestTypesRequest
*/
func (a *ChainConfigAPIService) ChangeFiscalGuestTypes(ctx context.Context, fiscalGuestTypeCode string) ChainConfigAPIChangeFiscalGuestTypesRequest {
	return ChainConfigAPIChangeFiscalGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
		fiscalGuestTypeCode: fiscalGuestTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeFiscalGuestTypesExecute(r ChainConfigAPIChangeFiscalGuestTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeFiscalGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalGuestTypes/{fiscalGuestTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"fiscalGuestTypeCode"+"}", url.PathEscape(parameterValueToString(r.fiscalGuestTypeCode, "fiscalGuestTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fiscalGuestTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("fiscalGuestTypeCode must have at least 1 elements")
	}
	if strlen(r.fiscalGuestTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("fiscalGuestTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalGuestTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeFiscalRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	regionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalRegionsToBeChanged *FiscalRegionsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeFiscalRegionsRequest) Authorization(authorization string) ChainConfigAPIChangeFiscalRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeFiscalRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeFiscalRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeFiscalRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeFiscalRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Fiscal Regions.
func (r ChainConfigAPIChangeFiscalRegionsRequest) FiscalRegionsToBeChanged(fiscalRegionsToBeChanged FiscalRegionsToBeChanged) ChainConfigAPIChangeFiscalRegionsRequest {
	r.fiscalRegionsToBeChanged = &fiscalRegionsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeFiscalRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeFiscalRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeFiscalRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeFiscalRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeFiscalRegionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFiscalRegionsExecute(r)
}

/*
ChangeFiscalRegions Change Fiscal Regions

Use this API to update Fiscal Regions. <p><strong>OperationId:</strong>changeFiscalRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionCode Unique Code of Region.
 @return ChainConfigAPIChangeFiscalRegionsRequest
*/
func (a *ChainConfigAPIService) ChangeFiscalRegions(ctx context.Context, regionCode string) ChainConfigAPIChangeFiscalRegionsRequest {
	return ChainConfigAPIChangeFiscalRegionsRequest{
		ApiService: a,
		ctx: ctx,
		regionCode: regionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeFiscalRegionsExecute(r ChainConfigAPIChangeFiscalRegionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeFiscalRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalRegions/{regionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"regionCode"+"}", url.PathEscape(parameterValueToString(r.regionCode, "regionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.regionCode) < 1 {
		return localVarReturnValue, nil, reportError("regionCode must have at least 1 elements")
	}
	if strlen(r.regionCode) > 2000 {
		return localVarReturnValue, nil, reportError("regionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalRegionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeTaxOfficesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	taxOfficeId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxOfficesToBeChanged *TaxOfficesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeTaxOfficesRequest) Authorization(authorization string) ChainConfigAPIChangeTaxOfficesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeTaxOfficesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeTaxOfficesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeTaxOfficesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeTaxOfficesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Tax Offices.
func (r ChainConfigAPIChangeTaxOfficesRequest) TaxOfficesToBeChanged(taxOfficesToBeChanged TaxOfficesToBeChanged) ChainConfigAPIChangeTaxOfficesRequest {
	r.taxOfficesToBeChanged = &taxOfficesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeTaxOfficesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeTaxOfficesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeTaxOfficesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeTaxOfficesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeTaxOfficesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTaxOfficesExecute(r)
}

/*
ChangeTaxOffices Change Tax Offices

Use this API to update Tax Offices. <p><strong>OperationId:</strong>changeTaxOffices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxOfficeId Unique ID of Tax Offices.
 @return ChainConfigAPIChangeTaxOfficesRequest
*/
func (a *ChainConfigAPIService) ChangeTaxOffices(ctx context.Context, taxOfficeId string) ChainConfigAPIChangeTaxOfficesRequest {
	return ChainConfigAPIChangeTaxOfficesRequest{
		ApiService: a,
		ctx: ctx,
		taxOfficeId: taxOfficeId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeTaxOfficesExecute(r ChainConfigAPIChangeTaxOfficesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeTaxOffices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxOffices/{taxOfficeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxOfficeId"+"}", url.PathEscape(parameterValueToString(r.taxOfficeId, "taxOfficeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxOfficeId) < 1 {
		return localVarReturnValue, nil, reportError("taxOfficeId must have at least 1 elements")
	}
	if strlen(r.taxOfficeId) > 2000 {
		return localVarReturnValue, nil, reportError("taxOfficeId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxOfficesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	dropLocationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCashierShiftDropLocationsToBeChanged *TemplateCashierShiftDropLocationsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Template Cashier Shift Drop Locations.
func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) TemplateCashierShiftDropLocationsToBeChanged(templateCashierShiftDropLocationsToBeChanged TemplateCashierShiftDropLocationsToBeChanged) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	r.templateCashierShiftDropLocationsToBeChanged = &templateCashierShiftDropLocationsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTemplateCashierShiftDropLocationsExecute(r)
}

/*
ChangeTemplateCashierShiftDropLocations Change Template Cashier Shift Drop Locations

Use this API to update Template Cashier Shift Drop Locations. <p><strong>OperationId:</strong>changeTemplateCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dropLocationId Unique ID of drop location.
 @return ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) ChangeTemplateCashierShiftDropLocations(ctx context.Context, dropLocationId string) ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest {
	return ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
		dropLocationId: dropLocationId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeTemplateCashierShiftDropLocationsExecute(r ChainConfigAPIChangeTemplateCashierShiftDropLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeTemplateCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierShifts/dropLocations/{dropLocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"dropLocationId"+"}", url.PathEscape(parameterValueToString(r.dropLocationId, "dropLocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.dropLocationId) < 1 {
		return localVarReturnValue, nil, reportError("dropLocationId must have at least 1 elements")
	}
	if strlen(r.dropLocationId) > 2000 {
		return localVarReturnValue, nil, reportError("dropLocationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCashierShiftDropLocationsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	code string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigAPIDeleteAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutoFolioSettlementTypesExecute(r)
}

/*
DeleteAutoFolioSettlementTypes Delete Auto Folio Settlement Types

Use this API to delete Auto Folio Settlement Types. <p><strong>OperationId:</strong>deleteAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique ID of Auto Folio Settlement Types.
 @return ChainConfigAPIDeleteAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigAPIService) DeleteAutoFolioSettlementTypes(ctx context.Context, code string) ChainConfigAPIDeleteAutoFolioSettlementTypesRequest {
	return ChainConfigAPIDeleteAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteAutoFolioSettlementTypesExecute(r ChainConfigAPIDeleteAutoFolioSettlementTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteContractBillingInstructionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	contractBillingInstructionsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteContractBillingInstructionsRequest) Authorization(authorization string) ChainConfigAPIDeleteContractBillingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteContractBillingInstructionsRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteContractBillingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteContractBillingInstructionsRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteContractBillingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIDeleteContractBillingInstructionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteContractBillingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteContractBillingInstructionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteContractBillingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteContractBillingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteContractBillingInstructionsExecute(r)
}

/*
DeleteContractBillingInstructions Delete Contract Billing Instructions

Use this API to delete Contract Billing Instructions. <p><strong>OperationId:</strong>deleteContractBillingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractBillingInstructionsId Unique ID of Contract Billing Instructions.
 @return ChainConfigAPIDeleteContractBillingInstructionsRequest
*/
func (a *ChainConfigAPIService) DeleteContractBillingInstructions(ctx context.Context, contractBillingInstructionsId string) ChainConfigAPIDeleteContractBillingInstructionsRequest {
	return ChainConfigAPIDeleteContractBillingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		contractBillingInstructionsId: contractBillingInstructionsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteContractBillingInstructionsExecute(r ChainConfigAPIDeleteContractBillingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteContractBillingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contractBillingInstructions/{contractBillingInstructionsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractBillingInstructionsId"+"}", url.PathEscape(parameterValueToString(r.contractBillingInstructionsId, "contractBillingInstructionsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contractBillingInstructionsId) < 1 {
		return localVarReturnValue, nil, reportError("contractBillingInstructionsId must have at least 1 elements")
	}
	if strlen(r.contractBillingInstructionsId) > 2000 {
		return localVarReturnValue, nil, reportError("contractBillingInstructionsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteTaxCategoryCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	taxCategoryCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteTaxCategoryCodesRequest) Authorization(authorization string) ChainConfigAPIDeleteTaxCategoryCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteTaxCategoryCodesRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteTaxCategoryCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteTaxCategoryCodesRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteTaxCategoryCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIDeleteTaxCategoryCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteTaxCategoryCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteTaxCategoryCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteTaxCategoryCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteTaxCategoryCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTaxCategoryCodesExecute(r)
}

/*
DeleteTaxCategoryCodes Delete Tax Category Codes

Use this API to delete Tax Category Codes. <p><strong>OperationId:</strong>deleteTaxCategoryCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxCategoryCode Unique ID of Tax Category Codes.
 @return ChainConfigAPIDeleteTaxCategoryCodesRequest
*/
func (a *ChainConfigAPIService) DeleteTaxCategoryCodes(ctx context.Context, taxCategoryCode string) ChainConfigAPIDeleteTaxCategoryCodesRequest {
	return ChainConfigAPIDeleteTaxCategoryCodesRequest{
		ApiService: a,
		ctx: ctx,
		taxCategoryCode: taxCategoryCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteTaxCategoryCodesExecute(r ChainConfigAPIDeleteTaxCategoryCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteTaxCategoryCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxCategories/{taxCategoryCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxCategoryCode"+"}", url.PathEscape(parameterValueToString(r.taxCategoryCode, "taxCategoryCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxCategoryCode) < 1 {
		return localVarReturnValue, nil, reportError("taxCategoryCode must have at least 1 elements")
	}
	if strlen(r.taxCategoryCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxCategoryCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) Codes(codes []string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) WildCard(wildCard string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) Description(description string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetAutoFolioSettlementTypesRequest) Execute() (*AutoFolioSettlementTypesDetails, *http.Response, error) {
	return r.ApiService.GetAutoFolioSettlementTypesExecute(r)
}

/*
GetAutoFolioSettlementTypes Get Auto Folio Settlement Types

Use this API to get Auto Folio Settlement Types. <p><strong>OperationId:</strong>getAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigAPIService) GetAutoFolioSettlementTypes(ctx context.Context) ChainConfigAPIGetAutoFolioSettlementTypesRequest {
	return ChainConfigAPIGetAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutoFolioSettlementTypesDetails
func (a *ChainConfigAPIService) GetAutoFolioSettlementTypesExecute(r ChainConfigAPIGetAutoFolioSettlementTypesRequest) (*AutoFolioSettlementTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoFolioSettlementTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) HotelIds(hotelIds []string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) Codes(codes []string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) WildCard(wildCard string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) Description(description string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCashierShiftDropLocationsRequest) Execute() (*CashierShiftDropLocationsDetails, *http.Response, error) {
	return r.ApiService.GetCashierShiftDropLocationsExecute(r)
}

/*
GetCashierShiftDropLocations Get Cashier Shift Drop Locations

Use this API to get Cashier Shift Drop Locations. <p><strong>OperationId:</strong>getCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ChainConfigAPIGetCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) GetCashierShiftDropLocations(ctx context.Context, hotelId string) ChainConfigAPIGetCashierShiftDropLocationsRequest {
	return ChainConfigAPIGetCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierShiftDropLocationsDetails
func (a *ChainConfigAPIService) GetCashierShiftDropLocationsExecute(r ChainConfigAPIGetCashierShiftDropLocationsRequest) (*CashierShiftDropLocationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierShiftDropLocationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashierShifts/dropLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetContractBillingInstructionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetContractBillingInstructionsRequest) Authorization(authorization string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetContractBillingInstructionsRequest) XAppKey(xAppKey string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetContractBillingInstructionsRequest) XHotelid(xHotelid string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetContractBillingInstructionsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetContractBillingInstructionsRequest) Codes(codes []string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetContractBillingInstructionsRequest) WildCard(wildCard string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetContractBillingInstructionsRequest) Description(description string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetContractBillingInstructionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetContractBillingInstructionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetContractBillingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetContractBillingInstructionsRequest) Execute() (*ContractBillingInstructionsDetails, *http.Response, error) {
	return r.ApiService.GetContractBillingInstructionsExecute(r)
}

/*
GetContractBillingInstructions Get Contract Billing Instructions

Use this API to get Contract Billing Instructions. <p><strong>OperationId:</strong>getContractBillingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetContractBillingInstructionsRequest
*/
func (a *ChainConfigAPIService) GetContractBillingInstructions(ctx context.Context) ChainConfigAPIGetContractBillingInstructionsRequest {
	return ChainConfigAPIGetContractBillingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContractBillingInstructionsDetails
func (a *ChainConfigAPIService) GetContractBillingInstructionsExecute(r ChainConfigAPIGetContractBillingInstructionsRequest) (*ContractBillingInstructionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractBillingInstructionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetContractBillingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contractBillingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCustomTaxTypesRequest) Authorization(authorization string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCustomTaxTypesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCustomTaxTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCustomTaxTypesRequest) Codes(codes []string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCustomTaxTypesRequest) WildCard(wildCard string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCustomTaxTypesRequest) Description(description string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCustomTaxTypesRequest) Execute() (*CustomTaxTypesDetails, *http.Response, error) {
	return r.ApiService.GetCustomTaxTypesExecute(r)
}

/*
GetCustomTaxTypes Get Custom Tax Types

Use this API to get Custom Tax Types. <p><strong>OperationId:</strong>getCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCustomTaxTypesRequest
*/
func (a *ChainConfigAPIService) GetCustomTaxTypes(ctx context.Context) ChainConfigAPIGetCustomTaxTypesRequest {
	return ChainConfigAPIGetCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomTaxTypesDetails
func (a *ChainConfigAPIService) GetCustomTaxTypesExecute(r ChainConfigAPIGetCustomTaxTypesRequest) (*CustomTaxTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomTaxTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetFetchTaxCategoryCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) Authorization(authorization string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) XAppKey(xAppKey string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) XHotelid(xHotelid string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) Codes(codes []string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) WildCard(wildCard string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) Description(description string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetFetchTaxCategoryCodesRequest) Execute() (*TaxCategoryCodesDetails, *http.Response, error) {
	return r.ApiService.GetFetchTaxCategoryCodesExecute(r)
}

/*
GetFetchTaxCategoryCodes Get Tax Category Codes

Use this API to get Tax Category Codes. <p><strong>OperationId:</strong>getFetchTaxCategoryCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetFetchTaxCategoryCodesRequest
*/
func (a *ChainConfigAPIService) GetFetchTaxCategoryCodes(ctx context.Context) ChainConfigAPIGetFetchTaxCategoryCodesRequest {
	return ChainConfigAPIGetFetchTaxCategoryCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxCategoryCodesDetails
func (a *ChainConfigAPIService) GetFetchTaxCategoryCodesExecute(r ChainConfigAPIGetFetchTaxCategoryCodesRequest) (*TaxCategoryCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxCategoryCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetFetchTaxCategoryCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetFiscalGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetFiscalGuestTypesRequest) Authorization(authorization string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetFiscalGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetFiscalGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetFiscalGuestTypesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetFiscalGuestTypesRequest) Codes(codes []string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetFiscalGuestTypesRequest) WildCard(wildCard string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetFiscalGuestTypesRequest) Description(description string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetFiscalGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetFiscalGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetFiscalGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetFiscalGuestTypesRequest) Execute() (*FiscalGuestTypesDetails, *http.Response, error) {
	return r.ApiService.GetFiscalGuestTypesExecute(r)
}

/*
GetFiscalGuestTypes Get Fiscal Guest Types

Use this API to get Fiscal Guest Types. <p><strong>OperationId:</strong>getFiscalGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetFiscalGuestTypesRequest
*/
func (a *ChainConfigAPIService) GetFiscalGuestTypes(ctx context.Context) ChainConfigAPIGetFiscalGuestTypesRequest {
	return ChainConfigAPIGetFiscalGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalGuestTypesDetails
func (a *ChainConfigAPIService) GetFiscalGuestTypesExecute(r ChainConfigAPIGetFiscalGuestTypesRequest) (*FiscalGuestTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalGuestTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetFiscalGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalGuestTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetFiscalRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetFiscalRegionsRequest) Authorization(authorization string) ChainConfigAPIGetFiscalRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetFiscalRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIGetFiscalRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetFiscalRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIGetFiscalRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetFiscalRegionsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetFiscalRegionsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetFiscalRegionsRequest) Codes(codes []string) ChainConfigAPIGetFiscalRegionsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetFiscalRegionsRequest) WildCard(wildCard string) ChainConfigAPIGetFiscalRegionsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetFiscalRegionsRequest) Description(description string) ChainConfigAPIGetFiscalRegionsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetFiscalRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetFiscalRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetFiscalRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetFiscalRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetFiscalRegionsRequest) Execute() (*FiscalRegionsDetails, *http.Response, error) {
	return r.ApiService.GetFiscalRegionsExecute(r)
}

/*
GetFiscalRegions Get Fiscal Regions

Use this API to get Fiscal Regions. <p><strong>OperationId:</strong>getFiscalRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetFiscalRegionsRequest
*/
func (a *ChainConfigAPIService) GetFiscalRegions(ctx context.Context) ChainConfigAPIGetFiscalRegionsRequest {
	return ChainConfigAPIGetFiscalRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FiscalRegionsDetails
func (a *ChainConfigAPIService) GetFiscalRegionsExecute(r ChainConfigAPIGetFiscalRegionsRequest) (*FiscalRegionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalRegionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetFiscalRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalRegions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetTaxOfficesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetTaxOfficesRequest) Authorization(authorization string) ChainConfigAPIGetTaxOfficesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetTaxOfficesRequest) XAppKey(xAppKey string) ChainConfigAPIGetTaxOfficesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetTaxOfficesRequest) XHotelid(xHotelid string) ChainConfigAPIGetTaxOfficesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetTaxOfficesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetTaxOfficesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetTaxOfficesRequest) Codes(codes []string) ChainConfigAPIGetTaxOfficesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetTaxOfficesRequest) WildCard(wildCard string) ChainConfigAPIGetTaxOfficesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetTaxOfficesRequest) Description(description string) ChainConfigAPIGetTaxOfficesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetTaxOfficesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetTaxOfficesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetTaxOfficesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetTaxOfficesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetTaxOfficesRequest) Execute() (*TaxOfficesDetails, *http.Response, error) {
	return r.ApiService.GetTaxOfficesExecute(r)
}

/*
GetTaxOffices Get Tax Offices

Use this API to get Tax Offices. <p><strong>OperationId:</strong>getTaxOffices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetTaxOfficesRequest
*/
func (a *ChainConfigAPIService) GetTaxOffices(ctx context.Context) ChainConfigAPIGetTaxOfficesRequest {
	return ChainConfigAPIGetTaxOfficesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxOfficesDetails
func (a *ChainConfigAPIService) GetTaxOfficesExecute(r ChainConfigAPIGetTaxOfficesRequest) (*TaxOfficesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxOfficesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetTaxOffices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxOffices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) Codes(codes []string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) WildCard(wildCard string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) Description(description string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) Execute() (*TemplateCashierShiftDropLocationsDetails, *http.Response, error) {
	return r.ApiService.GetTemplateCashierShiftDropLocationsExecute(r)
}

/*
GetTemplateCashierShiftDropLocations Get Template Cashier Shift Drop Locations

Use this API to get Template Cashier Shift Drop Locations. <p><strong>OperationId:</strong>getTemplateCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) GetTemplateCashierShiftDropLocations(ctx context.Context) ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest {
	return ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateCashierShiftDropLocationsDetails
func (a *ChainConfigAPIService) GetTemplateCashierShiftDropLocationsExecute(r ChainConfigAPIGetTemplateCashierShiftDropLocationsRequest) (*TemplateCashierShiftDropLocationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateCashierShiftDropLocationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetTemplateCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierShifts/dropLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	autoFolioSettlementTypesCriteria *AutoFolioSettlementTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Auto Folio Settlement Types.
func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) AutoFolioSettlementTypesCriteria(autoFolioSettlementTypesCriteria AutoFolioSettlementTypesCriteria) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	r.autoFolioSettlementTypesCriteria = &autoFolioSettlementTypesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostAutoFolioSettlementTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutoFolioSettlementTypesExecute(r)
}

/*
PostAutoFolioSettlementTypes Create Auto Folio Settlement Types

Use this API to create Auto Folio Settlement Types. <p><strong>OperationId:</strong>postAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigAPIService) PostAutoFolioSettlementTypes(ctx context.Context) ChainConfigAPIPostAutoFolioSettlementTypesRequest {
	return ChainConfigAPIPostAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostAutoFolioSettlementTypesExecute(r ChainConfigAPIPostAutoFolioSettlementTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoFolioSettlementTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierShiftDropLocationsCriteria *CashierShiftDropLocationsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Cashier Shift Drop Locations.
func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) CashierShiftDropLocationsCriteria(cashierShiftDropLocationsCriteria CashierShiftDropLocationsCriteria) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	r.cashierShiftDropLocationsCriteria = &cashierShiftDropLocationsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCashierShiftDropLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCashierShiftDropLocationsExecute(r)
}

/*
PostCashierShiftDropLocations Create Cashier Shift Drop Locations

Use this API to create Cashier Shift Drop Locations. <p><strong>OperationId:</strong>postCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ChainConfigAPIPostCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) PostCashierShiftDropLocations(ctx context.Context, hotelId string) ChainConfigAPIPostCashierShiftDropLocationsRequest {
	return ChainConfigAPIPostCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCashierShiftDropLocationsExecute(r ChainConfigAPIPostCashierShiftDropLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashierShifts/dropLocations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashierShiftDropLocationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostContractBillingInstructionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	contractBillingInstructionsCriteria *ContractBillingInstructionsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostContractBillingInstructionsRequest) Authorization(authorization string) ChainConfigAPIPostContractBillingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostContractBillingInstructionsRequest) XAppKey(xAppKey string) ChainConfigAPIPostContractBillingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostContractBillingInstructionsRequest) XHotelid(xHotelid string) ChainConfigAPIPostContractBillingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Contract Billing Instructions.
func (r ChainConfigAPIPostContractBillingInstructionsRequest) ContractBillingInstructionsCriteria(contractBillingInstructionsCriteria ContractBillingInstructionsCriteria) ChainConfigAPIPostContractBillingInstructionsRequest {
	r.contractBillingInstructionsCriteria = &contractBillingInstructionsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostContractBillingInstructionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostContractBillingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostContractBillingInstructionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostContractBillingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostContractBillingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostContractBillingInstructionsExecute(r)
}

/*
PostContractBillingInstructions Create Contract Billing Instructions

Use this API to create Contract Billing Instructions. <p><strong>OperationId:</strong>postContractBillingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostContractBillingInstructionsRequest
*/
func (a *ChainConfigAPIService) PostContractBillingInstructions(ctx context.Context) ChainConfigAPIPostContractBillingInstructionsRequest {
	return ChainConfigAPIPostContractBillingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostContractBillingInstructionsExecute(r ChainConfigAPIPostContractBillingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostContractBillingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contractBillingInstructions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.contractBillingInstructionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	customTaxTypesCriteria *CustomTaxTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCustomTaxTypesRequest) Authorization(authorization string) ChainConfigAPIPostCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPostCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPostCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Custom Tax Types.
func (r ChainConfigAPIPostCustomTaxTypesRequest) CustomTaxTypesCriteria(customTaxTypesCriteria CustomTaxTypesCriteria) ChainConfigAPIPostCustomTaxTypesRequest {
	r.customTaxTypesCriteria = &customTaxTypesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCustomTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCustomTaxTypesExecute(r)
}

/*
PostCustomTaxTypes Create Custom Tax Types

Use this API to create Custom Tax Types. <p><strong>OperationId:</strong>postCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCustomTaxTypesRequest
*/
func (a *ChainConfigAPIService) PostCustomTaxTypes(ctx context.Context) ChainConfigAPIPostCustomTaxTypesRequest {
	return ChainConfigAPIPostCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCustomTaxTypesExecute(r ChainConfigAPIPostCustomTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.customTaxTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostFiscalGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalGuestTypesCriteria *FiscalGuestTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostFiscalGuestTypesRequest) Authorization(authorization string) ChainConfigAPIPostFiscalGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostFiscalGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPostFiscalGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostFiscalGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPostFiscalGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Fiscal Guest Types.
func (r ChainConfigAPIPostFiscalGuestTypesRequest) FiscalGuestTypesCriteria(fiscalGuestTypesCriteria FiscalGuestTypesCriteria) ChainConfigAPIPostFiscalGuestTypesRequest {
	r.fiscalGuestTypesCriteria = &fiscalGuestTypesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostFiscalGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostFiscalGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostFiscalGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostFiscalGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostFiscalGuestTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalGuestTypesExecute(r)
}

/*
PostFiscalGuestTypes Create Fiscal Guest Types

Use this API to create Fiscal Guest Types. <p><strong>OperationId:</strong>postFiscalGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostFiscalGuestTypesRequest
*/
func (a *ChainConfigAPIService) PostFiscalGuestTypes(ctx context.Context) ChainConfigAPIPostFiscalGuestTypesRequest {
	return ChainConfigAPIPostFiscalGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostFiscalGuestTypesExecute(r ChainConfigAPIPostFiscalGuestTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostFiscalGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalGuestTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalGuestTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostFiscalRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalRegionsCriteria *FiscalRegionsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostFiscalRegionsRequest) Authorization(authorization string) ChainConfigAPIPostFiscalRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostFiscalRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIPostFiscalRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostFiscalRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIPostFiscalRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Fiscal Regions.
func (r ChainConfigAPIPostFiscalRegionsRequest) FiscalRegionsCriteria(fiscalRegionsCriteria FiscalRegionsCriteria) ChainConfigAPIPostFiscalRegionsRequest {
	r.fiscalRegionsCriteria = &fiscalRegionsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostFiscalRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostFiscalRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostFiscalRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostFiscalRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostFiscalRegionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalRegionsExecute(r)
}

/*
PostFiscalRegions Create Fiscal Regions

Use this API to create Fiscal Regions. <p><strong>OperationId:</strong>postFiscalRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostFiscalRegionsRequest
*/
func (a *ChainConfigAPIService) PostFiscalRegions(ctx context.Context) ChainConfigAPIPostFiscalRegionsRequest {
	return ChainConfigAPIPostFiscalRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostFiscalRegionsExecute(r ChainConfigAPIPostFiscalRegionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostFiscalRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalRegions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalRegionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostTaxCategoryCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxCategoryCodesCriteria *TaxCategoryCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostTaxCategoryCodesRequest) Authorization(authorization string) ChainConfigAPIPostTaxCategoryCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostTaxCategoryCodesRequest) XAppKey(xAppKey string) ChainConfigAPIPostTaxCategoryCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostTaxCategoryCodesRequest) XHotelid(xHotelid string) ChainConfigAPIPostTaxCategoryCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Tax Category Codes.
func (r ChainConfigAPIPostTaxCategoryCodesRequest) TaxCategoryCodesCriteria(taxCategoryCodesCriteria TaxCategoryCodesCriteria) ChainConfigAPIPostTaxCategoryCodesRequest {
	r.taxCategoryCodesCriteria = &taxCategoryCodesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostTaxCategoryCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostTaxCategoryCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostTaxCategoryCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostTaxCategoryCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostTaxCategoryCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTaxCategoryCodesExecute(r)
}

/*
PostTaxCategoryCodes Create Tax Category Codes

Use this API to create Tax Category Codes. <p><strong>OperationId:</strong>postTaxCategoryCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostTaxCategoryCodesRequest
*/
func (a *ChainConfigAPIService) PostTaxCategoryCodes(ctx context.Context) ChainConfigAPIPostTaxCategoryCodesRequest {
	return ChainConfigAPIPostTaxCategoryCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostTaxCategoryCodesExecute(r ChainConfigAPIPostTaxCategoryCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostTaxCategoryCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxCategoryCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostTaxOfficesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	taxOfficesCriteria *TaxOfficesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostTaxOfficesRequest) Authorization(authorization string) ChainConfigAPIPostTaxOfficesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostTaxOfficesRequest) XAppKey(xAppKey string) ChainConfigAPIPostTaxOfficesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostTaxOfficesRequest) XHotelid(xHotelid string) ChainConfigAPIPostTaxOfficesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Tax Offices.
func (r ChainConfigAPIPostTaxOfficesRequest) TaxOfficesCriteria(taxOfficesCriteria TaxOfficesCriteria) ChainConfigAPIPostTaxOfficesRequest {
	r.taxOfficesCriteria = &taxOfficesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostTaxOfficesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostTaxOfficesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostTaxOfficesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostTaxOfficesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostTaxOfficesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTaxOfficesExecute(r)
}

/*
PostTaxOffices Create Tax Offices

Use this API to create Tax Offices. <p><strong>OperationId:</strong>postTaxOffices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostTaxOfficesRequest
*/
func (a *ChainConfigAPIService) PostTaxOffices(ctx context.Context) ChainConfigAPIPostTaxOfficesRequest {
	return ChainConfigAPIPostTaxOfficesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostTaxOfficesExecute(r ChainConfigAPIPostTaxOfficesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostTaxOffices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxOffices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxOfficesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCashierShiftDropLocationsCriteria *TemplateCashierShiftDropLocationsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Template Cashier Shift Drop Locations.
func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) TemplateCashierShiftDropLocationsCriteria(templateCashierShiftDropLocationsCriteria TemplateCashierShiftDropLocationsCriteria) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	r.templateCashierShiftDropLocationsCriteria = &templateCashierShiftDropLocationsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateCashierShiftDropLocationsExecute(r)
}

/*
PostTemplateCashierShiftDropLocations Create Template Cashier Shift Drop Locations

Use this API to create Template Cashier Shift Drop Locations. <p><strong>OperationId:</strong>postTemplateCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) PostTemplateCashierShiftDropLocations(ctx context.Context) ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest {
	return ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostTemplateCashierShiftDropLocationsExecute(r ChainConfigAPIPostTemplateCashierShiftDropLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostTemplateCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierShifts/dropLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCashierShiftDropLocationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutAutoFolioSettlementTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	code string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoFolioSettlementTypesToBeChanged *AutoFolioSettlementTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) Authorization(authorization string) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Auto Folio Settlement Types.
func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) AutoFolioSettlementTypesToBeChanged(autoFolioSettlementTypesToBeChanged AutoFolioSettlementTypesToBeChanged) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	r.autoFolioSettlementTypesToBeChanged = &autoFolioSettlementTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutAutoFolioSettlementTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAutoFolioSettlementTypesExecute(r)
}

/*
PutAutoFolioSettlementTypes Change Auto Folio Settlement Types

Use this API to update Auto Folio Settlement Types. <p><strong>OperationId:</strong>putAutoFolioSettlementTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique ID of Auto Folio Settlement Types.
 @return ChainConfigAPIPutAutoFolioSettlementTypesRequest
*/
func (a *ChainConfigAPIService) PutAutoFolioSettlementTypes(ctx context.Context, code string) ChainConfigAPIPutAutoFolioSettlementTypesRequest {
	return ChainConfigAPIPutAutoFolioSettlementTypesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutAutoFolioSettlementTypesExecute(r ChainConfigAPIPutAutoFolioSettlementTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutAutoFolioSettlementTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoFolioSettlementTypes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoFolioSettlementTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutContractBillingInstructionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	contractBillingInstructionsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	contractBillingInstructionsToBeChanged *ContractBillingInstructionsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutContractBillingInstructionsRequest) Authorization(authorization string) ChainConfigAPIPutContractBillingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutContractBillingInstructionsRequest) XAppKey(xAppKey string) ChainConfigAPIPutContractBillingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutContractBillingInstructionsRequest) XHotelid(xHotelid string) ChainConfigAPIPutContractBillingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Contract Billing Instructions.
func (r ChainConfigAPIPutContractBillingInstructionsRequest) ContractBillingInstructionsToBeChanged(contractBillingInstructionsToBeChanged ContractBillingInstructionsToBeChanged) ChainConfigAPIPutContractBillingInstructionsRequest {
	r.contractBillingInstructionsToBeChanged = &contractBillingInstructionsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutContractBillingInstructionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutContractBillingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutContractBillingInstructionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutContractBillingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutContractBillingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutContractBillingInstructionsExecute(r)
}

/*
PutContractBillingInstructions Change Contract Billing Instructions

Use this API to update Contract Billing Instructions. <p><strong>OperationId:</strong>putContractBillingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractBillingInstructionsId Unique ID of Contract Billing Instructions.
 @return ChainConfigAPIPutContractBillingInstructionsRequest
*/
func (a *ChainConfigAPIService) PutContractBillingInstructions(ctx context.Context, contractBillingInstructionsId string) ChainConfigAPIPutContractBillingInstructionsRequest {
	return ChainConfigAPIPutContractBillingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		contractBillingInstructionsId: contractBillingInstructionsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutContractBillingInstructionsExecute(r ChainConfigAPIPutContractBillingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutContractBillingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contractBillingInstructions/{contractBillingInstructionsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractBillingInstructionsId"+"}", url.PathEscape(parameterValueToString(r.contractBillingInstructionsId, "contractBillingInstructionsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contractBillingInstructionsId) < 1 {
		return localVarReturnValue, nil, reportError("contractBillingInstructionsId must have at least 1 elements")
	}
	if strlen(r.contractBillingInstructionsId) > 2000 {
		return localVarReturnValue, nil, reportError("contractBillingInstructionsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.contractBillingInstructionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutTaxCategoryCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	taxCategoryCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxCategoryCodesToBeChanged *TaxCategoryCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutTaxCategoryCodesRequest) Authorization(authorization string) ChainConfigAPIPutTaxCategoryCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutTaxCategoryCodesRequest) XAppKey(xAppKey string) ChainConfigAPIPutTaxCategoryCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutTaxCategoryCodesRequest) XHotelid(xHotelid string) ChainConfigAPIPutTaxCategoryCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Tax Category Codes.
func (r ChainConfigAPIPutTaxCategoryCodesRequest) TaxCategoryCodesToBeChanged(taxCategoryCodesToBeChanged TaxCategoryCodesToBeChanged) ChainConfigAPIPutTaxCategoryCodesRequest {
	r.taxCategoryCodesToBeChanged = &taxCategoryCodesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutTaxCategoryCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutTaxCategoryCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutTaxCategoryCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutTaxCategoryCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutTaxCategoryCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTaxCategoryCodesExecute(r)
}

/*
PutTaxCategoryCodes Change Tax Category Codes

Use this API to update Tax Category Codes. <p><strong>OperationId:</strong>putTaxCategoryCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxCategoryCode Unique ID of Tax Category Codes.
 @return ChainConfigAPIPutTaxCategoryCodesRequest
*/
func (a *ChainConfigAPIService) PutTaxCategoryCodes(ctx context.Context, taxCategoryCode string) ChainConfigAPIPutTaxCategoryCodesRequest {
	return ChainConfigAPIPutTaxCategoryCodesRequest{
		ApiService: a,
		ctx: ctx,
		taxCategoryCode: taxCategoryCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutTaxCategoryCodesExecute(r ChainConfigAPIPutTaxCategoryCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutTaxCategoryCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxCategories/{taxCategoryCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxCategoryCode"+"}", url.PathEscape(parameterValueToString(r.taxCategoryCode, "taxCategoryCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxCategoryCode) < 1 {
		return localVarReturnValue, nil, reportError("taxCategoryCode must have at least 1 elements")
	}
	if strlen(r.taxCategoryCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxCategoryCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taxCategoryCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	dropLocationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIRemoveCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCashierShiftDropLocationsExecute(r)
}

/*
RemoveCashierShiftDropLocations Delete Cashier Shift Drop Locations

Use this API to delete Cashier Shift Drop Locations. <p><strong>OperationId:</strong>removeCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dropLocationId Unique ID of drop location.
 @param hotelId Unique ID of hotel.
 @return ChainConfigAPIRemoveCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) RemoveCashierShiftDropLocations(ctx context.Context, dropLocationId string, hotelId string) ChainConfigAPIRemoveCashierShiftDropLocationsRequest {
	return ChainConfigAPIRemoveCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
		dropLocationId: dropLocationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCashierShiftDropLocationsExecute(r ChainConfigAPIRemoveCashierShiftDropLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashierShifts/dropLocations/{dropLocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"dropLocationId"+"}", url.PathEscape(parameterValueToString(r.dropLocationId, "dropLocationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.dropLocationId) < 1 {
		return localVarReturnValue, nil, reportError("dropLocationId must have at least 1 elements")
	}
	if strlen(r.dropLocationId) > 2000 {
		return localVarReturnValue, nil, reportError("dropLocationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCustomTaxTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	taxTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCustomTaxTypesRequest) Authorization(authorization string) ChainConfigAPIRemoveCustomTaxTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCustomTaxTypesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCustomTaxTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCustomTaxTypesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCustomTaxTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCustomTaxTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCustomTaxTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCustomTaxTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCustomTaxTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCustomTaxTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCustomTaxTypesExecute(r)
}

/*
RemoveCustomTaxTypes Delete Custom Tax Types

Use this API to delete Custom Tax Types. <p><strong>OperationId:</strong>removeCustomTaxTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxTypeCode Unique Code of Tax Types.
 @return ChainConfigAPIRemoveCustomTaxTypesRequest
*/
func (a *ChainConfigAPIService) RemoveCustomTaxTypes(ctx context.Context, taxTypeCode string) ChainConfigAPIRemoveCustomTaxTypesRequest {
	return ChainConfigAPIRemoveCustomTaxTypesRequest{
		ApiService: a,
		ctx: ctx,
		taxTypeCode: taxTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCustomTaxTypesExecute(r ChainConfigAPIRemoveCustomTaxTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCustomTaxTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customTaxTypes/{taxTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxTypeCode"+"}", url.PathEscape(parameterValueToString(r.taxTypeCode, "taxTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have at least 1 elements")
	}
	if strlen(r.taxTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("taxTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveFiscalGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	fiscalGuestTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveFiscalGuestTypesRequest) Authorization(authorization string) ChainConfigAPIRemoveFiscalGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveFiscalGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveFiscalGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveFiscalGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveFiscalGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveFiscalGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveFiscalGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveFiscalGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveFiscalGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveFiscalGuestTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFiscalGuestTypesExecute(r)
}

/*
RemoveFiscalGuestTypes Delete Fiscal Guest Types

Use this API to delete Fiscal Guest Types. <p><strong>OperationId:</strong>removeFiscalGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fiscalGuestTypeCode Unique Code of Fiscal Guest Types.
 @return ChainConfigAPIRemoveFiscalGuestTypesRequest
*/
func (a *ChainConfigAPIService) RemoveFiscalGuestTypes(ctx context.Context, fiscalGuestTypeCode string) ChainConfigAPIRemoveFiscalGuestTypesRequest {
	return ChainConfigAPIRemoveFiscalGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
		fiscalGuestTypeCode: fiscalGuestTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveFiscalGuestTypesExecute(r ChainConfigAPIRemoveFiscalGuestTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveFiscalGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalGuestTypes/{fiscalGuestTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"fiscalGuestTypeCode"+"}", url.PathEscape(parameterValueToString(r.fiscalGuestTypeCode, "fiscalGuestTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fiscalGuestTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("fiscalGuestTypeCode must have at least 1 elements")
	}
	if strlen(r.fiscalGuestTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("fiscalGuestTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveFiscalRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	regionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveFiscalRegionsRequest) Authorization(authorization string) ChainConfigAPIRemoveFiscalRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveFiscalRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveFiscalRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveFiscalRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveFiscalRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveFiscalRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveFiscalRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveFiscalRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveFiscalRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveFiscalRegionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFiscalRegionsExecute(r)
}

/*
RemoveFiscalRegions Delete Fiscal Regions

Use this API to delete Fiscal Regions. <p><strong>OperationId:</strong>removeFiscalRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionCode Unique Code of Region.
 @return ChainConfigAPIRemoveFiscalRegionsRequest
*/
func (a *ChainConfigAPIService) RemoveFiscalRegions(ctx context.Context, regionCode string) ChainConfigAPIRemoveFiscalRegionsRequest {
	return ChainConfigAPIRemoveFiscalRegionsRequest{
		ApiService: a,
		ctx: ctx,
		regionCode: regionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveFiscalRegionsExecute(r ChainConfigAPIRemoveFiscalRegionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveFiscalRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fiscalRegions/{regionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"regionCode"+"}", url.PathEscape(parameterValueToString(r.regionCode, "regionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.regionCode) < 1 {
		return localVarReturnValue, nil, reportError("regionCode must have at least 1 elements")
	}
	if strlen(r.regionCode) > 2000 {
		return localVarReturnValue, nil, reportError("regionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveTaxOfficesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	taxOfficeId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveTaxOfficesRequest) Authorization(authorization string) ChainConfigAPIRemoveTaxOfficesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveTaxOfficesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveTaxOfficesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveTaxOfficesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveTaxOfficesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveTaxOfficesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveTaxOfficesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveTaxOfficesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveTaxOfficesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveTaxOfficesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTaxOfficesExecute(r)
}

/*
RemoveTaxOffices Delete Tax Offices

Use this API to delete Tax Offices. <p><strong>OperationId:</strong>removeTaxOffices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxOfficeId Unique ID of Tax Offices.
 @return ChainConfigAPIRemoveTaxOfficesRequest
*/
func (a *ChainConfigAPIService) RemoveTaxOffices(ctx context.Context, taxOfficeId string) ChainConfigAPIRemoveTaxOfficesRequest {
	return ChainConfigAPIRemoveTaxOfficesRequest{
		ApiService: a,
		ctx: ctx,
		taxOfficeId: taxOfficeId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveTaxOfficesExecute(r ChainConfigAPIRemoveTaxOfficesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveTaxOffices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/taxOffices/{taxOfficeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxOfficeId"+"}", url.PathEscape(parameterValueToString(r.taxOfficeId, "taxOfficeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxOfficeId) < 1 {
		return localVarReturnValue, nil, reportError("taxOfficeId must have at least 1 elements")
	}
	if strlen(r.taxOfficeId) > 2000 {
		return localVarReturnValue, nil, reportError("taxOfficeId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	dropLocationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) Authorization(authorization string) ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTemplateCashierShiftDropLocationsExecute(r)
}

/*
RemoveTemplateCashierShiftDropLocations Delete Template Cashier Shift Drop Locations

Use this API to delete Template Cashier Shift Drop Locations. <p><strong>OperationId:</strong>removeTemplateCashierShiftDropLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dropLocationId Unique ID of drop location.
 @return ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest
*/
func (a *ChainConfigAPIService) RemoveTemplateCashierShiftDropLocations(ctx context.Context, dropLocationId string) ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest {
	return ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest{
		ApiService: a,
		ctx: ctx,
		dropLocationId: dropLocationId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveTemplateCashierShiftDropLocationsExecute(r ChainConfigAPIRemoveTemplateCashierShiftDropLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveTemplateCashierShiftDropLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierShifts/dropLocations/{dropLocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"dropLocationId"+"}", url.PathEscape(parameterValueToString(r.dropLocationId, "dropLocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.dropLocationId) < 1 {
		return localVarReturnValue, nil, reportError("dropLocationId must have at least 1 elements")
	}
	if strlen(r.dropLocationId) > 2000 {
		return localVarReturnValue, nil, reportError("dropLocationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
