/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"encoding/json"
	"fmt"
)

// CurrencyExchangeType E-certificate conversion.
type CurrencyExchangeType string

// List of currencyExchangeType
const (
	CURRENCYEXCHANGETYPE_CASH CurrencyExchangeType = "Cash"
	CURRENCYEXCHANGETYPE_SETTLEMENT CurrencyExchangeType = "Settlement"
	CURRENCYEXCHANGETYPE_POSTING CurrencyExchangeType = "Posting"
	CURRENCYEXCHANGETYPE_CHECK CurrencyExchangeType = "Check"
	CURRENCYEXCHANGETYPE_TA_COMMISSION CurrencyExchangeType = "TACommission"
	CURRENCYEXCHANGETYPE_MEMBERSHIP CurrencyExchangeType = "Membership"
	CURRENCYEXCHANGETYPE_CERTIFICATE CurrencyExchangeType = "Certificate"
)

// All allowed values of CurrencyExchangeType enum
var AllowedCurrencyExchangeTypeEnumValues = []CurrencyExchangeType{
	"Cash",
	"Settlement",
	"Posting",
	"Check",
	"TACommission",
	"Membership",
	"Certificate",
}

func (v *CurrencyExchangeType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := CurrencyExchangeType(value)
	for _, existing := range AllowedCurrencyExchangeTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid CurrencyExchangeType", value)
}

// NewCurrencyExchangeTypeFromValue returns a pointer to a valid CurrencyExchangeType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewCurrencyExchangeTypeFromValue(v string) (*CurrencyExchangeType, error) {
	ev := CurrencyExchangeType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for CurrencyExchangeType: valid values are %v", v, AllowedCurrencyExchangeTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v CurrencyExchangeType) IsValid() bool {
	for _, existing := range AllowedCurrencyExchangeTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to currencyExchangeType value
func (v CurrencyExchangeType) Ptr() *CurrencyExchangeType {
	return &v
}

type NullableCurrencyExchangeType struct {
	value *CurrencyExchangeType
	isSet bool
}

func (v NullableCurrencyExchangeType) Get() *CurrencyExchangeType {
	return v.value
}

func (v *NullableCurrencyExchangeType) Set(val *CurrencyExchangeType) {
	v.value = val
	v.isSet = true
}

func (v NullableCurrencyExchangeType) IsSet() bool {
	return v.isSet
}

func (v *NullableCurrencyExchangeType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCurrencyExchangeType(val *CurrencyExchangeType) *NullableCurrencyExchangeType {
	return &NullableCurrencyExchangeType{value: val, isSet: true}
}

func (v NullableCurrencyExchangeType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCurrencyExchangeType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

