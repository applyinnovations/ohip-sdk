/*
OPERA Cloud Front Desk Configuration API

APIs to cater for Front Desk Configuration in OPERA Cloud. Here you can find operations to get, post, put and delete front desk codes such as commission codes, transaction groups, codes & subgroups, articles, payment methods and credit card types.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fofcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AccountsReceivablesConfigAPIService AccountsReceivablesConfigAPI service
type AccountsReceivablesConfigAPIService service

type AccountsReceivablesConfigAPIDeleteARAccountTypesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountTypes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Property associated with account type
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) HotelId(hotelId []string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) Authorization(authorization string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account receivable account type
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) AccountTypes(accountTypes []string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.accountTypes = &accountTypes
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteARAccountTypesExecute(r)
}

/*
DeleteARAccountTypes Operation to remove AR Account types.

Operation to remove account types. <p><strong>OperationId:</strong>deleteARAccountTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIDeleteARAccountTypesRequest
*/
func (a *AccountsReceivablesConfigAPIService) DeleteARAccountTypes(ctx context.Context) AccountsReceivablesConfigAPIDeleteARAccountTypesRequest {
	return AccountsReceivablesConfigAPIDeleteARAccountTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesConfigAPIService) DeleteARAccountTypesExecute(r AccountsReceivablesConfigAPIDeleteARAccountTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.DeleteARAccountTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.accountTypes != nil {
		t := *r.accountTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountTypes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel where the code is configured.
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) HotelIds(hotelIds []string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) Authorization(authorization string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) Codes(codes []string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteARFlaggedReasonsExecute(r)
}

/*
DeleteARFlaggedReasons Operation to remove AR flagged reasons.

 <p><strong>OperationId:</strong>deleteARFlaggedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest
*/
func (a *AccountsReceivablesConfigAPIService) DeleteARFlaggedReasons(ctx context.Context) AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest {
	return AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesConfigAPIService) DeleteARFlaggedReasonsExecute(r AccountsReceivablesConfigAPIDeleteARFlaggedReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.DeleteARFlaggedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flaggedReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIGetARAccountTypesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountType *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) Authorization(authorization string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account receivable account type
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) AccountType(accountType string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.accountType = &accountType
	return r
}

// Full description of account type
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) Description(description string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIGetARAccountTypesRequest) Execute() (*ArAccountTypes, *http.Response, error) {
	return r.ApiService.GetARAccountTypesExecute(r)
}

/*
GetARAccountTypes Operation to fetch AR account types.

Operation to fetch account types. <p><strong>OperationId:</strong>getARAccountTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel in OPERA
 @return AccountsReceivablesConfigAPIGetARAccountTypesRequest
*/
func (a *AccountsReceivablesConfigAPIService) GetARAccountTypes(ctx context.Context, hotelId string) AccountsReceivablesConfigAPIGetARAccountTypesRequest {
	return AccountsReceivablesConfigAPIGetARAccountTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArAccountTypes
func (a *AccountsReceivablesConfigAPIService) GetARAccountTypesExecute(r AccountsReceivablesConfigAPIGetARAccountTypesRequest) (*ArAccountTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArAccountTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.GetARAccountTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ARAccountTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	reasonCodes *[]string
	reasonWildCard *string
	description *string
	propertyCodes *[]string
	propertyWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) Authorization(authorization string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) ReasonCodes(reasonCodes []string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.reasonCodes = &reasonCodes
	return r
}

// Wildcard search on the code.
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) ReasonWildCard(reasonWildCard string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.reasonWildCard = &reasonWildCard
	return r
}

// Description text set to the search criteria
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) Description(description string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.description = &description
	return r
}

// Codes to be searched.
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) PropertyCodes(propertyCodes []string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.propertyCodes = &propertyCodes
	return r
}

// Wildcard search on the code.
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) PropertyWildCard(propertyWildCard string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.propertyWildCard = &propertyWildCard
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) Execute() (*ArFlaggedReasons, *http.Response, error) {
	return r.ApiService.GetARFlaggedReasonsExecute(r)
}

/*
GetARFlaggedReasons Operation to fetch AR flagged reasons.

 <p><strong>OperationId:</strong>getARFlaggedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest
*/
func (a *AccountsReceivablesConfigAPIService) GetARFlaggedReasons(ctx context.Context) AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest {
	return AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArFlaggedReasons
func (a *AccountsReceivablesConfigAPIService) GetARFlaggedReasonsExecute(r AccountsReceivablesConfigAPIGetARFlaggedReasonsRequest) (*ArFlaggedReasons, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArFlaggedReasons
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.GetARFlaggedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flaggedReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reasonCodes != nil {
		t := *r.reasonCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reasonCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reasonCodes", t, "multi")
		}
  }
	if r.reasonWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reasonWildCard", r.reasonWildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.propertyCodes != nil {
		t := *r.propertyCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "propertyCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "propertyCodes", t, "multi")
		}
  }
	if r.propertyWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertyWildCard", r.propertyWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIPostARAccountTypesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	arAccountTypes *ArAccountTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) Authorization(authorization string) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create account receivables account types
func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) ArAccountTypes(arAccountTypes ArAccountTypes) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	r.arAccountTypes = &arAccountTypes
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIPostARAccountTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostARAccountTypesExecute(r)
}

/*
PostARAccountTypes Operation to create AR Account Types.

Operation to create account types. <p><strong>OperationId:</strong>postARAccountTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIPostARAccountTypesRequest
*/
func (a *AccountsReceivablesConfigAPIService) PostARAccountTypes(ctx context.Context) AccountsReceivablesConfigAPIPostARAccountTypesRequest {
	return AccountsReceivablesConfigAPIPostARAccountTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesConfigAPIService) PostARAccountTypesExecute(r AccountsReceivablesConfigAPIPostARAccountTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.PostARAccountTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arAccountTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	arFlaggedReasons *ArFlaggedReasons
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) Authorization(authorization string) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Flagged Reason
func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) ArFlaggedReasons(arFlaggedReasons ArFlaggedReasons) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	r.arFlaggedReasons = &arFlaggedReasons
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostARFlaggedReasonsExecute(r)
}

/*
PostARFlaggedReasons Operation to create AR flagged reasons.

 <p><strong>OperationId:</strong>postARFlaggedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest
*/
func (a *AccountsReceivablesConfigAPIService) PostARFlaggedReasons(ctx context.Context) AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest {
	return AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesConfigAPIService) PostARFlaggedReasonsExecute(r AccountsReceivablesConfigAPIPostARFlaggedReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.PostARFlaggedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flaggedReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arFlaggedReasons
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIPutARAccountTypesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	arAccountTypes *ArAccountTypes
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) Authorization(authorization string) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing account types.
func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) ArAccountTypes(arAccountTypes ArAccountTypes) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	r.arAccountTypes = &arAccountTypes
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIPutARAccountTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutARAccountTypesExecute(r)
}

/*
PutARAccountTypes Operation to modify AR Account Types.

Operation to change account types. <p><strong>OperationId:</strong>putARAccountTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIPutARAccountTypesRequest
*/
func (a *AccountsReceivablesConfigAPIService) PutARAccountTypes(ctx context.Context) AccountsReceivablesConfigAPIPutARAccountTypesRequest {
	return AccountsReceivablesConfigAPIPutARAccountTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesConfigAPIService) PutARAccountTypesExecute(r AccountsReceivablesConfigAPIPutARAccountTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.PutARAccountTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arAccountTypes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	arFlaggedReasons *ArFlaggedReasons
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) Authorization(authorization string) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) XAppKey(xAppKey string) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) XHotelid(xHotelid string) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit Flagged Reasons.
func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) ArFlaggedReasons(arFlaggedReasons ArFlaggedReasons) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	r.arFlaggedReasons = &arFlaggedReasons
	return r
}

// External system code.
func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutARFlaggedReasonsExecute(r)
}

/*
PutARFlaggedReasons Operation to change AR flagged reasons.

 <p><strong>OperationId:</strong>putARFlaggedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest
*/
func (a *AccountsReceivablesConfigAPIService) PutARFlaggedReasons(ctx context.Context) AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest {
	return AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesConfigAPIService) PutARFlaggedReasonsExecute(r AccountsReceivablesConfigAPIPutARFlaggedReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesConfigAPIService.PutARFlaggedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flaggedReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arFlaggedReasons
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
