/*
OPERA Cloud Inventory API

APIs to cater for Inventory functionality in OPERA Cloud. This includes sell limits for date ranges, viewing and updating the property&apos;s inventory, as well as item inventory (such as rollaways, microwaves etc.).<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package inv

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// InventoryAPIService InventoryAPI service
type InventoryAPIService service

type InventoryAPIChangeSellLimitByDateRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	sellLimit *SellLimit
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIChangeSellLimitByDateRequest) Authorization(authorization string) InventoryAPIChangeSellLimitByDateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIChangeSellLimitByDateRequest) XAppKey(xAppKey string) InventoryAPIChangeSellLimitByDateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIChangeSellLimitByDateRequest) XHotelid(xHotelid string) InventoryAPIChangeSellLimitByDateRequest {
	r.xHotelid = &xHotelid
	return r
}

// A Request message that sets sell limit for a particular date for all the levels House, room type and room class. The request can contain the number type in which the sell limits is to be fetched for the different levels.
func (r InventoryAPIChangeSellLimitByDateRequest) SellLimit(sellLimit SellLimit) InventoryAPIChangeSellLimitByDateRequest {
	r.sellLimit = &sellLimit
	return r
}

// External system code.
func (r InventoryAPIChangeSellLimitByDateRequest) XExternalsystem(xExternalsystem string) InventoryAPIChangeSellLimitByDateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIChangeSellLimitByDateRequest) AcceptLanguage(acceptLanguage string) InventoryAPIChangeSellLimitByDateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIChangeSellLimitByDateRequest) Execute() (*SellLimitResponse, *http.Response, error) {
	return r.ApiService.ChangeSellLimitByDateExecute(r)
}

/*
ChangeSellLimitByDate Set sell limits by date

You can use this API to create sell limits in OPERA by date. <p><strong>OperationId:</strong>changeSellLimitByDate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where sell limit are created by date.
 @return InventoryAPIChangeSellLimitByDateRequest
*/
func (a *InventoryAPIService) ChangeSellLimitByDate(ctx context.Context, hotelId string) InventoryAPIChangeSellLimitByDateRequest {
	return InventoryAPIChangeSellLimitByDateRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SellLimitResponse
func (a *InventoryAPIService) ChangeSellLimitByDateExecute(r InventoryAPIChangeSellLimitByDateRequest) (*SellLimitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SellLimitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.ChangeSellLimitByDate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sellLimits"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.sellLimit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIChangeSellLimitByDateRangeRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	sellLimitByRange *SellLimitByRange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIChangeSellLimitByDateRangeRequest) Authorization(authorization string) InventoryAPIChangeSellLimitByDateRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIChangeSellLimitByDateRangeRequest) XAppKey(xAppKey string) InventoryAPIChangeSellLimitByDateRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIChangeSellLimitByDateRangeRequest) XHotelid(xHotelid string) InventoryAPIChangeSellLimitByDateRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Contains the sell limits for a given date range to be set.
func (r InventoryAPIChangeSellLimitByDateRangeRequest) SellLimitByRange(sellLimitByRange SellLimitByRange) InventoryAPIChangeSellLimitByDateRangeRequest {
	r.sellLimitByRange = &sellLimitByRange
	return r
}

// External system code.
func (r InventoryAPIChangeSellLimitByDateRangeRequest) XExternalsystem(xExternalsystem string) InventoryAPIChangeSellLimitByDateRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIChangeSellLimitByDateRangeRequest) AcceptLanguage(acceptLanguage string) InventoryAPIChangeSellLimitByDateRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIChangeSellLimitByDateRangeRequest) Execute() (*SellLimitByDateResponse, *http.Response, error) {
	return r.ApiService.ChangeSellLimitByDateRangeExecute(r)
}

/*
ChangeSellLimitByDateRange Set sell limits by date range

You can use this API to create sell limits in OPERA by date range. <p><strong>OperationId:</strong>changeSellLimitByDateRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where sell limits are created by date range.
 @return InventoryAPIChangeSellLimitByDateRangeRequest
*/
func (a *InventoryAPIService) ChangeSellLimitByDateRange(ctx context.Context, hotelId string) InventoryAPIChangeSellLimitByDateRangeRequest {
	return InventoryAPIChangeSellLimitByDateRangeRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SellLimitByDateResponse
func (a *InventoryAPIService) ChangeSellLimitByDateRangeExecute(r InventoryAPIChangeSellLimitByDateRangeRequest) (*SellLimitByDateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SellLimitByDateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.ChangeSellLimitByDateRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sellLimitsByDateRange"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.sellLimitByRange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIGetHoldItemsInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	itemHoldId *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIGetHoldItemsInventoryRequest) Authorization(authorization string) InventoryAPIGetHoldItemsInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIGetHoldItemsInventoryRequest) XAppKey(xAppKey string) InventoryAPIGetHoldItemsInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIGetHoldItemsInventoryRequest) XHotelid(xHotelid string) InventoryAPIGetHoldItemsInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// ID of an Hold Item
func (r InventoryAPIGetHoldItemsInventoryRequest) ItemHoldId(itemHoldId []float32) InventoryAPIGetHoldItemsInventoryRequest {
	r.itemHoldId = &itemHoldId
	return r
}

// External system code.
func (r InventoryAPIGetHoldItemsInventoryRequest) XExternalsystem(xExternalsystem string) InventoryAPIGetHoldItemsInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIGetHoldItemsInventoryRequest) AcceptLanguage(acceptLanguage string) InventoryAPIGetHoldItemsInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIGetHoldItemsInventoryRequest) Execute() (*HoldItemsInventory, *http.Response, error) {
	return r.ApiService.GetHoldItemsInventoryExecute(r)
}

/*
GetHoldItemsInventory Get items inventory that are held

Fetch item inventory that is currently being held. <p><strong>OperationId:</strong>getHoldItemsInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where items inventory is held.
 @return InventoryAPIGetHoldItemsInventoryRequest
*/
func (a *InventoryAPIService) GetHoldItemsInventory(ctx context.Context, hotelId string) InventoryAPIGetHoldItemsInventoryRequest {
	return InventoryAPIGetHoldItemsInventoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HoldItemsInventory
func (a *InventoryAPIService) GetHoldItemsInventoryExecute(r InventoryAPIGetHoldItemsInventoryRequest) (*HoldItemsInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HoldItemsInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.GetHoldItemsInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/itemInventoryHold"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.itemHoldId != nil {
		t := *r.itemHoldId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemHoldId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemHoldId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIGetHotelInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	dateRangeStart *string
	dateRangeEnd *string
	roomCountRequested *int32
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTentativeInventory *bool
	dailyInventory *bool
	houseLevel *bool
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r InventoryAPIGetHotelInventoryRequest) DateRangeStart(dateRangeStart string) InventoryAPIGetHotelInventoryRequest {
	r.dateRangeStart = &dateRangeStart
	return r
}

func (r InventoryAPIGetHotelInventoryRequest) DateRangeEnd(dateRangeEnd string) InventoryAPIGetHotelInventoryRequest {
	r.dateRangeEnd = &dateRangeEnd
	return r
}

// Number of rooms requested.
func (r InventoryAPIGetHotelInventoryRequest) RoomCountRequested(roomCountRequested int32) InventoryAPIGetHotelInventoryRequest {
	r.roomCountRequested = &roomCountRequested
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIGetHotelInventoryRequest) Authorization(authorization string) InventoryAPIGetHotelInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIGetHotelInventoryRequest) XAppKey(xAppKey string) InventoryAPIGetHotelInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIGetHotelInventoryRequest) XHotelid(xHotelid string) InventoryAPIGetHotelInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// If set to true, includes non-deduct/Tentative rooms for a date range.
func (r InventoryAPIGetHotelInventoryRequest) IncludeTentativeInventory(includeTentativeInventory bool) InventoryAPIGetHotelInventoryRequest {
	r.includeTentativeInventory = &includeTentativeInventory
	return r
}

// If false minimum inventory for the date range is requested, otherwise inventory is requested for every day.
func (r InventoryAPIGetHotelInventoryRequest) DailyInventory(dailyInventory bool) InventoryAPIGetHotelInventoryRequest {
	r.dailyInventory = &dailyInventory
	return r
}

// Indicates that House level inventory is requested.
func (r InventoryAPIGetHotelInventoryRequest) HouseLevel(houseLevel bool) InventoryAPIGetHotelInventoryRequest {
	r.houseLevel = &houseLevel
	return r
}

// Room Type Code.
func (r InventoryAPIGetHotelInventoryRequest) RoomTypes(roomTypes []string) InventoryAPIGetHotelInventoryRequest {
	r.roomTypes = &roomTypes
	return r
}

// Room Class Code.
func (r InventoryAPIGetHotelInventoryRequest) RoomClasses(roomClasses []string) InventoryAPIGetHotelInventoryRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r InventoryAPIGetHotelInventoryRequest) XExternalsystem(xExternalsystem string) InventoryAPIGetHotelInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIGetHotelInventoryRequest) AcceptLanguage(acceptLanguage string) InventoryAPIGetHotelInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIGetHotelInventoryRequest) Execute() (*HotelInventory, *http.Response, error) {
	return r.ApiService.GetHotelInventoryExecute(r)
}

/*
GetHotelInventory Get hotel inventory

You can use this API to retrieve the inventory for a specified hotel. Narrow down your results using the query parameters such as a date range, room type, room class, and/or tentative inventory included. <p><strong>OperationId:</strong>getHotelInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where hotel inventory is searched.
 @return InventoryAPIGetHotelInventoryRequest
*/
func (a *InventoryAPIService) GetHotelInventory(ctx context.Context, hotelId string) InventoryAPIGetHotelInventoryRequest {
	return InventoryAPIGetHotelInventoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelInventory
func (a *InventoryAPIService) GetHotelInventoryExecute(r InventoryAPIGetHotelInventoryRequest) (*HotelInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.GetHotelInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hotelInventory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeStart", r.dateRangeStart, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dateRangeEnd", r.dateRangeEnd, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "roomCountRequested", r.roomCountRequested, "")
	if r.includeTentativeInventory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTentativeInventory", r.includeTentativeInventory, "")
  }
	if r.dailyInventory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dailyInventory", r.dailyInventory, "")
  }
	if r.houseLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "houseLevel", r.houseLevel, "")
  }
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
  }
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIGetItemInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	startDate *string
	endDate *string
	duration *string
	endTime *string
	startTime *string
	itemClass *string
	itemPool *[]string
	itemCode *[]string
	defaultDuration *int32
	fixedCharge *bool
	outsideStay *bool
	requiredForBooking *bool
	sellInEvent *bool
	sellInReservation *bool
	sellSeparate *bool
	welcomeOffer *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIGetItemInventoryRequest) Authorization(authorization string) InventoryAPIGetItemInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIGetItemInventoryRequest) XAppKey(xAppKey string) InventoryAPIGetItemInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIGetItemInventoryRequest) XHotelid(xHotelid string) InventoryAPIGetItemInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r InventoryAPIGetItemInventoryRequest) StartDate(startDate string) InventoryAPIGetItemInventoryRequest {
	r.startDate = &startDate
	return r
}

func (r InventoryAPIGetItemInventoryRequest) EndDate(endDate string) InventoryAPIGetItemInventoryRequest {
	r.endDate = &endDate
	return r
}

func (r InventoryAPIGetItemInventoryRequest) Duration(duration string) InventoryAPIGetItemInventoryRequest {
	r.duration = &duration
	return r
}

// End Time of the Time window.
func (r InventoryAPIGetItemInventoryRequest) EndTime(endTime string) InventoryAPIGetItemInventoryRequest {
	r.endTime = &endTime
	return r
}

// Start Time of the Time window.
func (r InventoryAPIGetItemInventoryRequest) StartTime(startTime string) InventoryAPIGetItemInventoryRequest {
	r.startTime = &startTime
	return r
}

// Item Class to filter the Items/Item Pools in the response.
func (r InventoryAPIGetItemInventoryRequest) ItemClass(itemClass string) InventoryAPIGetItemInventoryRequest {
	r.itemClass = &itemClass
	return r
}

func (r InventoryAPIGetItemInventoryRequest) ItemPool(itemPool []string) InventoryAPIGetItemInventoryRequest {
	r.itemPool = &itemPool
	return r
}

func (r InventoryAPIGetItemInventoryRequest) ItemCode(itemCode []string) InventoryAPIGetItemInventoryRequest {
	r.itemCode = &itemCode
	return r
}

// Define the default duration in days when booking the item.
func (r InventoryAPIGetItemInventoryRequest) DefaultDuration(defaultDuration int32) InventoryAPIGetItemInventoryRequest {
	r.defaultDuration = &defaultDuration
	return r
}

// If true indicates that item has fixed charge when it is attached to a reservation.
func (r InventoryAPIGetItemInventoryRequest) FixedCharge(fixedCharge bool) InventoryAPIGetItemInventoryRequest {
	r.fixedCharge = &fixedCharge
	return r
}

// If true indicates that item could be held outside of the reservation stay days.
func (r InventoryAPIGetItemInventoryRequest) OutsideStay(outsideStay bool) InventoryAPIGetItemInventoryRequest {
	r.outsideStay = &outsideStay
	return r
}

// If true indicates that item is required for the reservation.
func (r InventoryAPIGetItemInventoryRequest) RequiredForBooking(requiredForBooking bool) InventoryAPIGetItemInventoryRequest {
	r.requiredForBooking = &requiredForBooking
	return r
}

// If true indicates that item can be sold in event.
func (r InventoryAPIGetItemInventoryRequest) SellInEvent(sellInEvent bool) InventoryAPIGetItemInventoryRequest {
	r.sellInEvent = &sellInEvent
	return r
}

// If true indicates that item can be sold in reservation.
func (r InventoryAPIGetItemInventoryRequest) SellInReservation(sellInReservation bool) InventoryAPIGetItemInventoryRequest {
	r.sellInReservation = &sellInReservation
	return r
}

// If true indicates that item is allowed to sell separately.
func (r InventoryAPIGetItemInventoryRequest) SellSeparate(sellSeparate bool) InventoryAPIGetItemInventoryRequest {
	r.sellSeparate = &sellSeparate
	return r
}

// When set to true will only return items that are Welcome Offer Eligible.
func (r InventoryAPIGetItemInventoryRequest) WelcomeOffer(welcomeOffer bool) InventoryAPIGetItemInventoryRequest {
	r.welcomeOffer = &welcomeOffer
	return r
}

// External system code.
func (r InventoryAPIGetItemInventoryRequest) XExternalsystem(xExternalsystem string) InventoryAPIGetItemInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIGetItemInventoryRequest) AcceptLanguage(acceptLanguage string) InventoryAPIGetItemInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIGetItemInventoryRequest) Execute() (*ItemInventory, *http.Response, error) {
	return r.ApiService.GetItemInventoryExecute(r)
}

/*
GetItemInventory Get item inventory

This will fetch a hotels Item inventory for a specified date range that you can provided in the request. <p><strong>OperationId:</strong>getItemInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where item inventory is searched.
 @return InventoryAPIGetItemInventoryRequest
*/
func (a *InventoryAPIService) GetItemInventory(ctx context.Context, hotelId string) InventoryAPIGetItemInventoryRequest {
	return InventoryAPIGetItemInventoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ItemInventory
func (a *InventoryAPIService) GetItemInventoryExecute(r InventoryAPIGetItemInventoryRequest) (*ItemInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ItemInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.GetItemInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/itemInventory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
  }
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
  }
	if r.itemClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemClass", r.itemClass, "")
  }
	if r.itemPool != nil {
		t := *r.itemPool
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemPool", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemPool", t, "multi")
		}
  }
	if r.itemCode != nil {
		t := *r.itemCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemCode", t, "multi")
		}
  }
	if r.defaultDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultDuration", r.defaultDuration, "")
  }
	if r.fixedCharge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fixedCharge", r.fixedCharge, "")
  }
	if r.outsideStay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outsideStay", r.outsideStay, "")
  }
	if r.requiredForBooking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requiredForBooking", r.requiredForBooking, "")
  }
	if r.sellInEvent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellInEvent", r.sellInEvent, "")
  }
	if r.sellInReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellInReservation", r.sellInReservation, "")
  }
	if r.sellSeparate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellSeparate", r.sellSeparate, "")
  }
	if r.welcomeOffer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "welcomeOffer", r.welcomeOffer, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIPostHoldItemInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	holdItemInventory *HoldItemInventory
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIPostHoldItemInventoryRequest) Authorization(authorization string) InventoryAPIPostHoldItemInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIPostHoldItemInventoryRequest) XAppKey(xAppKey string) InventoryAPIPostHoldItemInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIPostHoldItemInventoryRequest) XHotelid(xHotelid string) InventoryAPIPostHoldItemInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for holding an items inventory/availability.
func (r InventoryAPIPostHoldItemInventoryRequest) HoldItemInventory(holdItemInventory HoldItemInventory) InventoryAPIPostHoldItemInventoryRequest {
	r.holdItemInventory = &holdItemInventory
	return r
}

// External system code.
func (r InventoryAPIPostHoldItemInventoryRequest) XExternalsystem(xExternalsystem string) InventoryAPIPostHoldItemInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIPostHoldItemInventoryRequest) AcceptLanguage(acceptLanguage string) InventoryAPIPostHoldItemInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIPostHoldItemInventoryRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHoldItemInventoryExecute(r)
}

/*
PostHoldItemInventory Hold item inventory

Use this API to hold Item Inventory. <p><strong>OperationId:</strong>postHoldItemInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where item inventory is held.
 @return InventoryAPIPostHoldItemInventoryRequest
*/
func (a *InventoryAPIService) PostHoldItemInventory(ctx context.Context, hotelId string) InventoryAPIPostHoldItemInventoryRequest {
	return InventoryAPIPostHoldItemInventoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *InventoryAPIService) PostHoldItemInventoryExecute(r InventoryAPIPostHoldItemInventoryRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.PostHoldItemInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/itemInventoryHold"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.holdItemInventory
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIPutHoldItemsInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	holdItemInventory *HoldItemInventory
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIPutHoldItemsInventoryRequest) Authorization(authorization string) InventoryAPIPutHoldItemsInventoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIPutHoldItemsInventoryRequest) XAppKey(xAppKey string) InventoryAPIPutHoldItemsInventoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIPutHoldItemsInventoryRequest) XHotelid(xHotelid string) InventoryAPIPutHoldItemsInventoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change the item hold details
func (r InventoryAPIPutHoldItemsInventoryRequest) HoldItemInventory(holdItemInventory HoldItemInventory) InventoryAPIPutHoldItemsInventoryRequest {
	r.holdItemInventory = &holdItemInventory
	return r
}

// External system code.
func (r InventoryAPIPutHoldItemsInventoryRequest) XExternalsystem(xExternalsystem string) InventoryAPIPutHoldItemsInventoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIPutHoldItemsInventoryRequest) AcceptLanguage(acceptLanguage string) InventoryAPIPutHoldItemsInventoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIPutHoldItemsInventoryRequest) Execute() (*HoldItemInventory, *http.Response, error) {
	return r.ApiService.PutHoldItemsInventoryExecute(r)
}

/*
PutHoldItemsInventory update items inventory that are held

You can update item inventory that is being held using this API. <p><strong>OperationId:</strong>putHoldItemsInventory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where items inventory that are held is updated.
 @return InventoryAPIPutHoldItemsInventoryRequest
*/
func (a *InventoryAPIService) PutHoldItemsInventory(ctx context.Context, hotelId string) InventoryAPIPutHoldItemsInventoryRequest {
	return InventoryAPIPutHoldItemsInventoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HoldItemInventory
func (a *InventoryAPIService) PutHoldItemsInventoryExecute(r InventoryAPIPutHoldItemsInventoryRequest) (*HoldItemInventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HoldItemInventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.PutHoldItemsInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/itemInventoryHold"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.holdItemInventory
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InventoryAPIPutItemInventoryHoldRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	releaseItemInventoryHold *ReleaseItemInventoryHold
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r InventoryAPIPutItemInventoryHoldRequest) Authorization(authorization string) InventoryAPIPutItemInventoryHoldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r InventoryAPIPutItemInventoryHoldRequest) XAppKey(xAppKey string) InventoryAPIPutItemInventoryHoldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the endDate user is logged in
func (r InventoryAPIPutItemInventoryHoldRequest) XHotelid(xHotelid string) InventoryAPIPutItemInventoryHoldRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for releasing a held item inventory/availability.
func (r InventoryAPIPutItemInventoryHoldRequest) ReleaseItemInventoryHold(releaseItemInventoryHold ReleaseItemInventoryHold) InventoryAPIPutItemInventoryHoldRequest {
	r.releaseItemInventoryHold = &releaseItemInventoryHold
	return r
}

// External system code.
func (r InventoryAPIPutItemInventoryHoldRequest) XExternalsystem(xExternalsystem string) InventoryAPIPutItemInventoryHoldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r InventoryAPIPutItemInventoryHoldRequest) AcceptLanguage(acceptLanguage string) InventoryAPIPutItemInventoryHoldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r InventoryAPIPutItemInventoryHoldRequest) Execute() (*ReleasedItemInventoryHeld, *http.Response, error) {
	return r.ApiService.PutItemInventoryHoldExecute(r)
}

/*
PutItemInventoryHold Release item inventory held

This API will release item inventory that has been held. <p><strong>OperationId:</strong>putItemInventoryHold</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InventoryAPIPutItemInventoryHoldRequest
*/
func (a *InventoryAPIService) PutItemInventoryHold(ctx context.Context) InventoryAPIPutItemInventoryHoldRequest {
	return InventoryAPIPutItemInventoryHoldRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReleasedItemInventoryHeld
func (a *InventoryAPIService) PutItemInventoryHoldExecute(r InventoryAPIPutItemInventoryHoldRequest) (*ReleasedItemInventoryHeld, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReleasedItemInventoryHeld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.PutItemInventoryHold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/releasedItemInventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.releaseItemInventoryHold
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
