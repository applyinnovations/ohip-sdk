/*
OPERA Cloud CRM Configuration API

APIs for Customer Relationship Management (profile) configuration, such as creating preferences, or address types.  It also includes Membership Configuration, where you can retrieve membership levels that are configured for a property, or create new membership enrollment codes.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crmcfg

import (
	"encoding/json"
	"fmt"
)

// PointsCalculationDateType Tier Management based on date of transaction
type PointsCalculationDateType string

// List of pointsCalculationDateType
const (
	POINTSCALCULATIONDATETYPE_ARRIVAL_DATE PointsCalculationDateType = "ArrivalDate"
	POINTSCALCULATIONDATETYPE_DEPARTURE_DATE PointsCalculationDateType = "DepartureDate"
	POINTSCALCULATIONDATETYPE_POSTING_DATE PointsCalculationDateType = "PostingDate"
	POINTSCALCULATIONDATETYPE_TRANSACTION_DATE PointsCalculationDateType = "TransactionDate"
)

// All allowed values of PointsCalculationDateType enum
var AllowedPointsCalculationDateTypeEnumValues = []PointsCalculationDateType{
	"ArrivalDate",
	"DepartureDate",
	"PostingDate",
	"TransactionDate",
}

func (v *PointsCalculationDateType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := PointsCalculationDateType(value)
	for _, existing := range AllowedPointsCalculationDateTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid PointsCalculationDateType", value)
}

// NewPointsCalculationDateTypeFromValue returns a pointer to a valid PointsCalculationDateType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewPointsCalculationDateTypeFromValue(v string) (*PointsCalculationDateType, error) {
	ev := PointsCalculationDateType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for PointsCalculationDateType: valid values are %v", v, AllowedPointsCalculationDateTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v PointsCalculationDateType) IsValid() bool {
	for _, existing := range AllowedPointsCalculationDateTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to pointsCalculationDateType value
func (v PointsCalculationDateType) Ptr() *PointsCalculationDateType {
	return &v
}

type NullablePointsCalculationDateType struct {
	value *PointsCalculationDateType
	isSet bool
}

func (v NullablePointsCalculationDateType) Get() *PointsCalculationDateType {
	return v.value
}

func (v *NullablePointsCalculationDateType) Set(val *PointsCalculationDateType) {
	v.value = val
	v.isSet = true
}

func (v NullablePointsCalculationDateType) IsSet() bool {
	return v.isSet
}

func (v *NullablePointsCalculationDateType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePointsCalculationDateType(val *PointsCalculationDateType) *NullablePointsCalculationDateType {
	return &NullablePointsCalculationDateType{value: val, isSet: true}
}

func (v NullablePointsCalculationDateType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePointsCalculationDateType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

