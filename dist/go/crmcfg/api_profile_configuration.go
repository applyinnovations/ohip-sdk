/*
OPERA Cloud CRM Configuration API

APIs for Customer Relationship Management (profile) configuration, such as creating preferences, or address types.  It also includes Membership Configuration, where you can retrieve membership levels that are configured for a property, or create new membership enrollment codes.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProfileConfigurationApiService ProfileConfigurationApi service
type ProfileConfigurationApiService service

type ProfileConfigurationApiCopyExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exclusivePreferencesCopy *CopyExclusivePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying template Exclusive preferences to hotel(s).
func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) ExclusivePreferencesCopy(exclusivePreferencesCopy CopyExclusivePreferencesRequest) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	r.exclusivePreferencesCopy = &exclusivePreferencesCopy
	return r
}

// External system code.
func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiCopyExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyExclusivePreferencesExecute(r)
}

/*
CopyExclusivePreferences Copy Exclusive Preferences

You can use this API to copy Exclusive Preferences. <p><strong>OperationId:</strong>copyExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiCopyExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) CopyExclusivePreferences(ctx context.Context) ProfileConfigurationApiCopyExclusivePreferencesRequest {
	return ProfileConfigurationApiCopyExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) CopyExclusivePreferencesExecute(r ProfileConfigurationApiCopyExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.CopyExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exclusivePreferences/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exclusivePreferencesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiCopyPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	preferencesCopy *CopyPreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiCopyPreferencesRequest) Authorization(authorization string) ProfileConfigurationApiCopyPreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiCopyPreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiCopyPreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiCopyPreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiCopyPreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying template preferences to hotel(s).
func (r ProfileConfigurationApiCopyPreferencesRequest) PreferencesCopy(preferencesCopy CopyPreferencesRequest) ProfileConfigurationApiCopyPreferencesRequest {
	r.preferencesCopy = &preferencesCopy
	return r
}

// External system code.
func (r ProfileConfigurationApiCopyPreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiCopyPreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiCopyPreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiCopyPreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiCopyPreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyPreferencesExecute(r)
}

/*
CopyPreferences Copy preferences

Use this API to copy preferences. <p><strong>OperationId:</strong>copyPreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiCopyPreferencesRequest
*/
func (a *ProfileConfigurationApiService) CopyPreferences(ctx context.Context) ProfileConfigurationApiCopyPreferencesRequest {
	return ProfileConfigurationApiCopyPreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) CopyPreferencesExecute(r ProfileConfigurationApiCopyPreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.CopyPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferences/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preferencesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteAddressFormatsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	formatCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ProfileConfigurationApiDeleteAddressFormatsRequest) FormatCodes(formatCodes []string) ProfileConfigurationApiDeleteAddressFormatsRequest {
	r.formatCodes = &formatCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteAddressFormatsRequest) Authorization(authorization string) ProfileConfigurationApiDeleteAddressFormatsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteAddressFormatsRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteAddressFormatsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteAddressFormatsRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteAddressFormatsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteAddressFormatsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteAddressFormatsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteAddressFormatsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteAddressFormatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteAddressFormatsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAddressFormatsExecute(r)
}

/*
DeleteAddressFormats Delete address formats

You can use this API to delete address formats. <p><strong>OperationId:</strong>deleteAddressFormats</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteAddressFormatsRequest
*/
func (a *ProfileConfigurationApiService) DeleteAddressFormats(ctx context.Context) ProfileConfigurationApiDeleteAddressFormatsRequest {
	return ProfileConfigurationApiDeleteAddressFormatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteAddressFormatsExecute(r ProfileConfigurationApiDeleteAddressFormatsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteAddressFormats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addressFormats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.formatCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "formatCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "formatCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteCreditRatingsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	creditRatings *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ProfileConfigurationApiDeleteCreditRatingsRequest) CreditRatings(creditRatings []string) ProfileConfigurationApiDeleteCreditRatingsRequest {
	r.creditRatings = &creditRatings
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteCreditRatingsRequest) Authorization(authorization string) ProfileConfigurationApiDeleteCreditRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteCreditRatingsRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteCreditRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteCreditRatingsRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteCreditRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteCreditRatingsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteCreditRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteCreditRatingsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteCreditRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteCreditRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCreditRatingsExecute(r)
}

/*
DeleteCreditRatings Delete credit ratings

You can use this API to delete credit ratings. <p><strong>OperationId:</strong>deleteCreditRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteCreditRatingsRequest
*/
func (a *ProfileConfigurationApiService) DeleteCreditRatings(ctx context.Context) ProfileConfigurationApiDeleteCreditRatingsRequest {
	return ProfileConfigurationApiDeleteCreditRatingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteCreditRatingsExecute(r ProfileConfigurationApiDeleteCreditRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteCreditRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creditRatings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.creditRatings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditRatings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditRatings", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	exclusivePreferenceCode *string
	exclusivePreferenceGroup *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Specifies the Exclusive preference code.
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) ExclusivePreferenceCode(exclusivePreferenceCode string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.exclusivePreferenceCode = &exclusivePreferenceCode
	return r
}

// Specifies the preference group the Exclusive preference belongs to.
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) ExclusivePreferenceGroup(exclusivePreferenceGroup string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.exclusivePreferenceGroup = &exclusivePreferenceGroup
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteExclusivePreferencesExecute(r)
}

/*
DeleteExclusivePreferences Delete Exclusive Preferences

You can use this API to delete Exclusive Preferences at hotel Level. <p><strong>OperationId:</strong>deleteExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiDeleteExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) DeleteExclusivePreferences(ctx context.Context, hotelId string) ProfileConfigurationApiDeleteExclusivePreferencesRequest {
	return ProfileConfigurationApiDeleteExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteExclusivePreferencesExecute(r ProfileConfigurationApiDeleteExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exclusivePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceCode", r.exclusivePreferenceCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceGroup", r.exclusivePreferenceGroup, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	preferenceCode *string
	preferenceGroup *string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Specifies the preference code.
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) PreferenceCode(preferenceCode string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.preferenceCode = &preferenceCode
	return r
}

// Specifies the preference group the preference belongs to.
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) PreferenceGroup(preferenceGroup string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.preferenceGroup = &preferenceGroup
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) Authorization(authorization string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Specifies the hotel code for which the preference is specified.
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) HotelId(hotelId string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelAndGlobalPreferencesExecute(r)
}

/*
DeleteHotelAndGlobalPreferences Delete preferences

Use this API to delete preferences, this API allows us to delete both the Global and Hotel level preferences. <p><strong>OperationId:</strong>deleteHotelAndGlobalPreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest
*/
func (a *ProfileConfigurationApiService) DeleteHotelAndGlobalPreferences(ctx context.Context) ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest {
	return ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteHotelAndGlobalPreferencesExecute(r ProfileConfigurationApiDeleteHotelAndGlobalPreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteHotelAndGlobalPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preference"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCode", r.preferenceCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroup", r.preferenceGroup, "")
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeletePreferenceGroupsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	preferenceGroup *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Code identifying the preference group.
func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) PreferenceGroup(preferenceGroup string) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	r.preferenceGroup = &preferenceGroup
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) Authorization(authorization string) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeletePreferenceGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePreferenceGroupsExecute(r)
}

/*
DeletePreferenceGroups Delete preference groups

This will allow you to delete an existing Preference Group. <p><strong>OperationId:</strong>deletePreferenceGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeletePreferenceGroupsRequest
*/
func (a *ProfileConfigurationApiService) DeletePreferenceGroups(ctx context.Context) ProfileConfigurationApiDeletePreferenceGroupsRequest {
	return ProfileConfigurationApiDeletePreferenceGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeletePreferenceGroupsExecute(r ProfileConfigurationApiDeletePreferenceGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeletePreferenceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferenceGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroup", r.preferenceGroup, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeletePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	preferenceCode *string
	preferenceGroup *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Specifies the preference code.
func (r ProfileConfigurationApiDeletePreferencesRequest) PreferenceCode(preferenceCode string) ProfileConfigurationApiDeletePreferencesRequest {
	r.preferenceCode = &preferenceCode
	return r
}

// Specifies the preference group the preference belongs to.
func (r ProfileConfigurationApiDeletePreferencesRequest) PreferenceGroup(preferenceGroup string) ProfileConfigurationApiDeletePreferencesRequest {
	r.preferenceGroup = &preferenceGroup
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeletePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiDeletePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeletePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeletePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeletePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeletePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeletePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeletePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeletePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeletePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeletePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePreferencesExecute(r)
}

/*
DeletePreferences Delete preferences

Use this API to delete preferences. <p><strong>OperationId:</strong>deletePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiDeletePreferencesRequest
*/
func (a *ProfileConfigurationApiService) DeletePreferences(ctx context.Context, hotelId string) ProfileConfigurationApiDeletePreferencesRequest {
	return ProfileConfigurationApiDeletePreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeletePreferencesExecute(r ProfileConfigurationApiDeletePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeletePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCode", r.preferenceCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroup", r.preferenceGroup, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteProfileNameValidationsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	profileType *string
	profileName *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Simple Type for Profile Name Validations Type. e.g. Company,Travel Agent,Source.
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) ProfileType(profileType string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.profileType = &profileType
	return r
}

// Name of the Profile.
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) ProfileName(profileName string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.profileName = &profileName
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) Authorization(authorization string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteProfileNameValidationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileNameValidationsExecute(r)
}

/*
DeleteProfileNameValidations Delete Profile Name Validations

You can use this API to delete Profile Name Validations. <p><strong>OperationId:</strong>deleteProfileNameValidations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteProfileNameValidationsRequest
*/
func (a *ProfileConfigurationApiService) DeleteProfileNameValidations(ctx context.Context) ProfileConfigurationApiDeleteProfileNameValidationsRequest {
	return ProfileConfigurationApiDeleteProfileNameValidationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteProfileNameValidationsExecute(r ProfileConfigurationApiDeleteProfileNameValidationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteProfileNameValidations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileNameValidations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "profileName", r.profileName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteProfileRelationshipsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	fromType *string
	toType *string
	fromCode *string
	toCode *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// From type to process
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) FromType(fromType string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.fromType = &fromType
	return r
}

// To type to process
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) ToType(toType string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.toType = &toType
	return r
}

// From code to process
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) FromCode(fromCode string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.fromCode = &fromCode
	return r
}

// To code to process
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) ToCode(toCode string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.toCode = &toCode
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) Authorization(authorization string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteProfileRelationshipsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileRelationshipsExecute(r)
}

/*
DeleteProfileRelationships Delete profile relationships

You can use this API to delete profile relationships. <p><strong>OperationId:</strong>deleteProfileRelationships</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteProfileRelationshipsRequest
*/
func (a *ProfileConfigurationApiService) DeleteProfileRelationships(ctx context.Context) ProfileConfigurationApiDeleteProfileRelationshipsRequest {
	return ProfileConfigurationApiDeleteProfileRelationshipsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteProfileRelationshipsExecute(r ProfileConfigurationApiDeleteProfileRelationshipsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteProfileRelationships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relationships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromType", r.fromType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toType", r.toType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromCode", r.fromCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toCode", r.toCode, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	exclusivePreferenceCode *string
	exclusivePreferenceGroup *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Specifies the Exclusive preference code.
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) ExclusivePreferenceCode(exclusivePreferenceCode string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.exclusivePreferenceCode = &exclusivePreferenceCode
	return r
}

// Specifies the preference group the Exclusive preference belongs to.
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) ExclusivePreferenceGroup(exclusivePreferenceGroup string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.exclusivePreferenceGroup = &exclusivePreferenceGroup
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateExclusivePreferencesExecute(r)
}

/*
DeleteTemplateExclusivePreferences Delete template Exclusive Preferences

You can use this API to delete template Exclusive Preferences. <p><strong>OperationId:</strong>deleteTemplateExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) DeleteTemplateExclusivePreferences(ctx context.Context) ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest {
	return ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteTemplateExclusivePreferencesExecute(r ProfileConfigurationApiDeleteTemplateExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteTemplateExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exclusivePreferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceCode", r.exclusivePreferenceCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceGroup", r.exclusivePreferenceGroup, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiDeleteTemplatePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	preferenceCode *string
	preferenceGroup *string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Specifies the preference code.
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) PreferenceCode(preferenceCode string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.preferenceCode = &preferenceCode
	return r
}

// Specifies the preference group the preference belongs to.
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) PreferenceGroup(preferenceGroup string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.preferenceGroup = &preferenceGroup
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiDeleteTemplatePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplatePreferencesExecute(r)
}

/*
DeleteTemplatePreferences Delete template preferences

You can use this API to delete template preferences. <p><strong>OperationId:</strong>deleteTemplatePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiDeleteTemplatePreferencesRequest
*/
func (a *ProfileConfigurationApiService) DeleteTemplatePreferences(ctx context.Context) ProfileConfigurationApiDeleteTemplatePreferencesRequest {
	return ProfileConfigurationApiDeleteTemplatePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) DeleteTemplatePreferencesExecute(r ProfileConfigurationApiDeleteTemplatePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.DeleteTemplatePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCode", r.preferenceCode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroup", r.preferenceGroup, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetAddressFormatsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetAddressFormatsRequest) Authorization(authorization string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetAddressFormatsRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetAddressFormatsRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ProfileConfigurationApiGetAddressFormatsRequest) Codes(codes []string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ProfileConfigurationApiGetAddressFormatsRequest) WildCard(wildCard string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ProfileConfigurationApiGetAddressFormatsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetAddressFormatsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetAddressFormatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetAddressFormatsRequest) Execute() (*AddressFormats, *http.Response, error) {
	return r.ApiService.GetAddressFormatsExecute(r)
}

/*
GetAddressFormats Get address formats

You can use this API to get address formats. <p><strong>OperationId:</strong>getAddressFormats</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetAddressFormatsRequest
*/
func (a *ProfileConfigurationApiService) GetAddressFormats(ctx context.Context) ProfileConfigurationApiGetAddressFormatsRequest {
	return ProfileConfigurationApiGetAddressFormatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddressFormats
func (a *ProfileConfigurationApiService) GetAddressFormatsExecute(r ProfileConfigurationApiGetAddressFormatsRequest) (*AddressFormats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddressFormats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetAddressFormats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addressFormats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetCreditRatingsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetCreditRatingsRequest) Authorization(authorization string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetCreditRatingsRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetCreditRatingsRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ProfileConfigurationApiGetCreditRatingsRequest) FetchInactive(fetchInactive bool) ProfileConfigurationApiGetCreditRatingsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ProfileConfigurationApiGetCreditRatingsRequest) Codes(codes []string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ProfileConfigurationApiGetCreditRatingsRequest) WildCard(wildCard string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ProfileConfigurationApiGetCreditRatingsRequest) Description(description string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ProfileConfigurationApiGetCreditRatingsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetCreditRatingsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetCreditRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetCreditRatingsRequest) Execute() (*CreditRatings, *http.Response, error) {
	return r.ApiService.GetCreditRatingsExecute(r)
}

/*
GetCreditRatings Get credit ratings

You can use this API to get credit ratings. <p><strong>OperationId:</strong>getCreditRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetCreditRatingsRequest
*/
func (a *ProfileConfigurationApiService) GetCreditRatings(ctx context.Context) ProfileConfigurationApiGetCreditRatingsRequest {
	return ProfileConfigurationApiGetCreditRatingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreditRatings
func (a *ProfileConfigurationApiService) GetCreditRatingsExecute(r ProfileConfigurationApiGetCreditRatingsRequest) (*CreditRatings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditRatings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetCreditRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creditRatings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exclusivePreferenceCodes *[]string
	preferenceGroupsCodes *[]string
	preferenceCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileConfigurationApiGetExclusivePreferencesRequest) ExclusivePreferenceCodes(exclusivePreferenceCodes []string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.exclusivePreferenceCodes = &exclusivePreferenceCodes
	return r
}

func (r ProfileConfigurationApiGetExclusivePreferencesRequest) PreferenceGroupsCodes(preferenceGroupsCodes []string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.preferenceGroupsCodes = &preferenceGroupsCodes
	return r
}

func (r ProfileConfigurationApiGetExclusivePreferencesRequest) PreferenceCodes(preferenceCodes []string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.preferenceCodes = &preferenceCodes
	return r
}

// External system code.
func (r ProfileConfigurationApiGetExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetExclusivePreferencesRequest) Execute() (*ExclusivePreferences, *http.Response, error) {
	return r.ApiService.GetExclusivePreferencesExecute(r)
}

/*
GetExclusivePreferences Get Exclusive preferences

You can use this API to get Exclusive preferences at hotel Level. <p><strong>OperationId:</strong>getExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiGetExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) GetExclusivePreferences(ctx context.Context, hotelId string) ProfileConfigurationApiGetExclusivePreferencesRequest {
	return ProfileConfigurationApiGetExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExclusivePreferences
func (a *ProfileConfigurationApiService) GetExclusivePreferencesExecute(r ProfileConfigurationApiGetExclusivePreferencesRequest) (*ExclusivePreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExclusivePreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exclusivePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.exclusivePreferenceCodes != nil {
		t := *r.exclusivePreferenceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceCodes", t, "multi")
		}
	}
	if r.preferenceGroupsCodes != nil {
		t := *r.preferenceGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", t, "multi")
		}
	}
	if r.preferenceCodes != nil {
		t := *r.preferenceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetPreferenceGroupsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceGroupsCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetPreferenceGroupsRequest) Authorization(authorization string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetPreferenceGroupsRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetPreferenceGroupsRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileConfigurationApiGetPreferenceGroupsRequest) PreferenceGroupsCodes(preferenceGroupsCodes []string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.preferenceGroupsCodes = &preferenceGroupsCodes
	return r
}

// Preference group description to be searched.
func (r ProfileConfigurationApiGetPreferenceGroupsRequest) WildCard(wildCard string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ProfileConfigurationApiGetPreferenceGroupsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetPreferenceGroupsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetPreferenceGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetPreferenceGroupsRequest) Execute() (*PreferenceGroups, *http.Response, error) {
	return r.ApiService.GetPreferenceGroupsExecute(r)
}

/*
GetPreferenceGroups Get Preference Groups

The API can be used to retrieve preference groups that match the given criteria in the request. <p><strong>OperationId:</strong>getPreferenceGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetPreferenceGroupsRequest
*/
func (a *ProfileConfigurationApiService) GetPreferenceGroups(ctx context.Context) ProfileConfigurationApiGetPreferenceGroupsRequest {
	return ProfileConfigurationApiGetPreferenceGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PreferenceGroups
func (a *ProfileConfigurationApiService) GetPreferenceGroupsExecute(r ProfileConfigurationApiGetPreferenceGroupsRequest) (*PreferenceGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreferenceGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetPreferenceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferenceGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preferenceGroupsCodes != nil {
		t := *r.preferenceGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceCodes *[]string
	preferenceGroupsCodes *[]string
	createdByUserIds *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetPreferencesRequest) Authorization(authorization string) ProfileConfigurationApiGetPreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetPreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetPreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetPreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetPreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileConfigurationApiGetPreferencesRequest) PreferenceCodes(preferenceCodes []string) ProfileConfigurationApiGetPreferencesRequest {
	r.preferenceCodes = &preferenceCodes
	return r
}

func (r ProfileConfigurationApiGetPreferencesRequest) PreferenceGroupsCodes(preferenceGroupsCodes []string) ProfileConfigurationApiGetPreferencesRequest {
	r.preferenceGroupsCodes = &preferenceGroupsCodes
	return r
}

func (r ProfileConfigurationApiGetPreferencesRequest) CreatedByUserIds(createdByUserIds []int32) ProfileConfigurationApiGetPreferencesRequest {
	r.createdByUserIds = &createdByUserIds
	return r
}

// External system code.
func (r ProfileConfigurationApiGetPreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetPreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetPreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetPreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetPreferencesRequest) Execute() (*HotelPreferences, *http.Response, error) {
	return r.ApiService.GetPreferencesExecute(r)
}

/*
GetPreferences Get preferences

Use this API to get all configured guest preferences. Use preference grouping code or preference code to narrow down the results.<p><strong>OperationId:</strong>getPreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiGetPreferencesRequest
*/
func (a *ProfileConfigurationApiService) GetPreferences(ctx context.Context, hotelId string) ProfileConfigurationApiGetPreferencesRequest {
	return ProfileConfigurationApiGetPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelPreferences
func (a *ProfileConfigurationApiService) GetPreferencesExecute(r ProfileConfigurationApiGetPreferencesRequest) (*HotelPreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelPreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.preferenceCodes != nil {
		t := *r.preferenceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", t, "multi")
		}
	}
	if r.preferenceGroupsCodes != nil {
		t := *r.preferenceGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", t, "multi")
		}
	}
	if r.createdByUserIds != nil {
		t := *r.createdByUserIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "createdByUserIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetProfileNameValidationsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	typeCodes *[]string
	wildCard *string
	name *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) Authorization(authorization string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) TypeCodes(typeCodes []string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.typeCodes = &typeCodes
	return r
}

// Wildcard search on the code.
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) WildCard(wildCard string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.wildCard = &wildCard
	return r
}

// Profile Name to be Searched.
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) Name(name string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.name = &name
	return r
}

// External system code.
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetProfileNameValidationsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetProfileNameValidationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetProfileNameValidationsRequest) Execute() (*ProfileNameValidations, *http.Response, error) {
	return r.ApiService.GetProfileNameValidationsExecute(r)
}

/*
GetProfileNameValidations Get Profile Name Validations

You can use this API to get Profile Name Validations. <p><strong>OperationId:</strong>getProfileNameValidations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetProfileNameValidationsRequest
*/
func (a *ProfileConfigurationApiService) GetProfileNameValidations(ctx context.Context) ProfileConfigurationApiGetProfileNameValidationsRequest {
	return ProfileConfigurationApiGetProfileNameValidationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileNameValidations
func (a *ProfileConfigurationApiService) GetProfileNameValidationsExecute(r ProfileConfigurationApiGetProfileNameValidationsRequest) (*ProfileNameValidations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileNameValidations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetProfileNameValidations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileNameValidations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.typeCodes != nil {
		t := *r.typeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetProfileRelationshipsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fromType *string
	toType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) Authorization(authorization string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.xHotelid = &xHotelid
	return r
}

// From type to process
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) FromType(fromType string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.fromType = &fromType
	return r
}

// To type to process
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) ToType(toType string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.toType = &toType
	return r
}

// External system code.
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetProfileRelationshipsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetProfileRelationshipsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetProfileRelationshipsRequest) Execute() (*ProfileLinks, *http.Response, error) {
	return r.ApiService.GetProfileRelationshipsExecute(r)
}

/*
GetProfileRelationships Get profile relationships

You can use this API to get profile relationships. <p><strong>OperationId:</strong>getProfileRelationships</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetProfileRelationshipsRequest
*/
func (a *ProfileConfigurationApiService) GetProfileRelationships(ctx context.Context) ProfileConfigurationApiGetProfileRelationshipsRequest {
	return ProfileConfigurationApiGetProfileRelationshipsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileLinks
func (a *ProfileConfigurationApiService) GetProfileRelationshipsExecute(r ProfileConfigurationApiGetProfileRelationshipsRequest) (*ProfileLinks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileLinks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetProfileRelationships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relationships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromType", r.fromType, "")
	}
	if r.toType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toType", r.toType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetTemplateExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exclusivePreferenceCodes *[]string
	preferenceGroupsCodes *[]string
	preferenceCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) ExclusivePreferenceCodes(exclusivePreferenceCodes []string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.exclusivePreferenceCodes = &exclusivePreferenceCodes
	return r
}

func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) PreferenceGroupsCodes(preferenceGroupsCodes []string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.preferenceGroupsCodes = &preferenceGroupsCodes
	return r
}

func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) PreferenceCodes(preferenceCodes []string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.preferenceCodes = &preferenceCodes
	return r
}

// External system code.
func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) Execute() (*TemplateExclusivePreferences, *http.Response, error) {
	return r.ApiService.GetTemplateExclusivePreferencesExecute(r)
}

/*
GetTemplateExclusivePreferences Get template Exclusive Preferences

You can use this API to get template Exclusive Preferences. <p><strong>OperationId:</strong>getTemplateExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetTemplateExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) GetTemplateExclusivePreferences(ctx context.Context) ProfileConfigurationApiGetTemplateExclusivePreferencesRequest {
	return ProfileConfigurationApiGetTemplateExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateExclusivePreferences
func (a *ProfileConfigurationApiService) GetTemplateExclusivePreferencesExecute(r ProfileConfigurationApiGetTemplateExclusivePreferencesRequest) (*TemplateExclusivePreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateExclusivePreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetTemplateExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exclusivePreferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exclusivePreferenceCodes != nil {
		t := *r.exclusivePreferenceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclusivePreferenceCodes", t, "multi")
		}
	}
	if r.preferenceGroupsCodes != nil {
		t := *r.preferenceGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", t, "multi")
		}
	}
	if r.preferenceCodes != nil {
		t := *r.preferenceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiGetTemplatePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceCodes *[]string
	preferenceGroupsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiGetTemplatePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiGetTemplatePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiGetTemplatePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileConfigurationApiGetTemplatePreferencesRequest) PreferenceCodes(preferenceCodes []string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.preferenceCodes = &preferenceCodes
	return r
}

func (r ProfileConfigurationApiGetTemplatePreferencesRequest) PreferenceGroupsCodes(preferenceGroupsCodes []string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.preferenceGroupsCodes = &preferenceGroupsCodes
	return r
}

// External system code.
func (r ProfileConfigurationApiGetTemplatePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiGetTemplatePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiGetTemplatePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiGetTemplatePreferencesRequest) Execute() (*TemplatePreferences, *http.Response, error) {
	return r.ApiService.GetTemplatePreferencesExecute(r)
}

/*
GetTemplatePreferences Get template Preferences

You can use this API to get template Preferences. <p><strong>OperationId:</strong>getTemplatePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiGetTemplatePreferencesRequest
*/
func (a *ProfileConfigurationApiService) GetTemplatePreferences(ctx context.Context) ProfileConfigurationApiGetTemplatePreferencesRequest {
	return ProfileConfigurationApiGetTemplatePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplatePreferences
func (a *ProfileConfigurationApiService) GetTemplatePreferencesExecute(r ProfileConfigurationApiGetTemplatePreferencesRequest) (*TemplatePreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplatePreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.GetTemplatePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preferenceCodes != nil {
		t := *r.preferenceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceCodes", t, "multi")
		}
	}
	if r.preferenceGroupsCodes != nil {
		t := *r.preferenceGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "preferenceGroupsCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostAddressFormatsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	addressFormats *PutAddressFormatsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostAddressFormatsRequest) Authorization(authorization string) ProfileConfigurationApiPostAddressFormatsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostAddressFormatsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostAddressFormatsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostAddressFormatsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostAddressFormatsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating address formats.
func (r ProfileConfigurationApiPostAddressFormatsRequest) AddressFormats(addressFormats PutAddressFormatsRequest) ProfileConfigurationApiPostAddressFormatsRequest {
	r.addressFormats = &addressFormats
	return r
}

// External system code.
func (r ProfileConfigurationApiPostAddressFormatsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostAddressFormatsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostAddressFormatsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostAddressFormatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostAddressFormatsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAddressFormatsExecute(r)
}

/*
PostAddressFormats Create address formats

You can use this API to create address formats. <p><strong>OperationId:</strong>postAddressFormats</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostAddressFormatsRequest
*/
func (a *ProfileConfigurationApiService) PostAddressFormats(ctx context.Context) ProfileConfigurationApiPostAddressFormatsRequest {
	return ProfileConfigurationApiPostAddressFormatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostAddressFormatsExecute(r ProfileConfigurationApiPostAddressFormatsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostAddressFormats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addressFormats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.addressFormats
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostCreditRatingsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	creditRatings *PutCreditRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostCreditRatingsRequest) Authorization(authorization string) ProfileConfigurationApiPostCreditRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostCreditRatingsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostCreditRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostCreditRatingsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostCreditRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating credit ratings.
func (r ProfileConfigurationApiPostCreditRatingsRequest) CreditRatings(creditRatings PutCreditRatingsRequest) ProfileConfigurationApiPostCreditRatingsRequest {
	r.creditRatings = &creditRatings
	return r
}

// External system code.
func (r ProfileConfigurationApiPostCreditRatingsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostCreditRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostCreditRatingsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostCreditRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostCreditRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCreditRatingsExecute(r)
}

/*
PostCreditRatings Create credit ratings

You can use this API to create credit ratings. <p><strong>OperationId:</strong>postCreditRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostCreditRatingsRequest
*/
func (a *ProfileConfigurationApiService) PostCreditRatings(ctx context.Context) ProfileConfigurationApiPostCreditRatingsRequest {
	return ProfileConfigurationApiPostCreditRatingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostCreditRatingsExecute(r ProfileConfigurationApiPostCreditRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostCreditRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creditRatings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditRatings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exclusivePreferences *PutExclusivePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPostExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Exclusive preferences at the property level.
func (r ProfileConfigurationApiPostExclusivePreferencesRequest) ExclusivePreferences(exclusivePreferences PutExclusivePreferencesRequest) ProfileConfigurationApiPostExclusivePreferencesRequest {
	r.exclusivePreferences = &exclusivePreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPostExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostExclusivePreferencesExecute(r)
}

/*
PostExclusivePreferences Create Exclusive Preferences

You can use this API to create Exclusive Preferences at hotel Level. <p><strong>OperationId:</strong>postExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiPostExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) PostExclusivePreferences(ctx context.Context, hotelId string) ProfileConfigurationApiPostExclusivePreferencesRequest {
	return ProfileConfigurationApiPostExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostExclusivePreferencesExecute(r ProfileConfigurationApiPostExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exclusivePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exclusivePreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostPreferenceGroupsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceGroups *PutPreferenceGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostPreferenceGroupsRequest) Authorization(authorization string) ProfileConfigurationApiPostPreferenceGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostPreferenceGroupsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostPreferenceGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostPreferenceGroupsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostPreferenceGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new preference groups.
func (r ProfileConfigurationApiPostPreferenceGroupsRequest) PreferenceGroups(preferenceGroups PutPreferenceGroupsRequest) ProfileConfigurationApiPostPreferenceGroupsRequest {
	r.preferenceGroups = &preferenceGroups
	return r
}

// External system code.
func (r ProfileConfigurationApiPostPreferenceGroupsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostPreferenceGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostPreferenceGroupsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostPreferenceGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostPreferenceGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPreferenceGroupsExecute(r)
}

/*
PostPreferenceGroups Create new preference groups 

Use this API to create a new Preference group. <p><strong>OperationId:</strong>postPreferenceGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostPreferenceGroupsRequest
*/
func (a *ProfileConfigurationApiService) PostPreferenceGroups(ctx context.Context) ProfileConfigurationApiPostPreferenceGroupsRequest {
	return ProfileConfigurationApiPostPreferenceGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostPreferenceGroupsExecute(r ProfileConfigurationApiPostPreferenceGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostPreferenceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferenceGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preferenceGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelPreferences *PutPreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostPreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPostPreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostPreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostPreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostPreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostPreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating preferences at the property level.
func (r ProfileConfigurationApiPostPreferencesRequest) HotelPreferences(hotelPreferences PutPreferencesRequest) ProfileConfigurationApiPostPreferencesRequest {
	r.hotelPreferences = &hotelPreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPostPreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostPreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostPreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostPreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostPreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPreferencesExecute(r)
}

/*
PostPreferences Create preferences

This will allow you to create new preferences. <p><strong>OperationId:</strong>postPreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiPostPreferencesRequest
*/
func (a *ProfileConfigurationApiService) PostPreferences(ctx context.Context, hotelId string) ProfileConfigurationApiPostPreferencesRequest {
	return ProfileConfigurationApiPostPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostPreferencesExecute(r ProfileConfigurationApiPostPreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelPreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostProfileNameValidationsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileNameValidations *PostProfileNameValidationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostProfileNameValidationsRequest) Authorization(authorization string) ProfileConfigurationApiPostProfileNameValidationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostProfileNameValidationsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostProfileNameValidationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostProfileNameValidationsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostProfileNameValidationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create Profile names.
func (r ProfileConfigurationApiPostProfileNameValidationsRequest) ProfileNameValidations(profileNameValidations PostProfileNameValidationsRequest) ProfileConfigurationApiPostProfileNameValidationsRequest {
	r.profileNameValidations = &profileNameValidations
	return r
}

// External system code.
func (r ProfileConfigurationApiPostProfileNameValidationsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostProfileNameValidationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostProfileNameValidationsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostProfileNameValidationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostProfileNameValidationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileNameValidationsExecute(r)
}

/*
PostProfileNameValidations Create Profile Name Validations

You can use this API to create Profile Name Validations. <p><strong>OperationId:</strong>postProfileNameValidations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostProfileNameValidationsRequest
*/
func (a *ProfileConfigurationApiService) PostProfileNameValidations(ctx context.Context) ProfileConfigurationApiPostProfileNameValidationsRequest {
	return ProfileConfigurationApiPostProfileNameValidationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostProfileNameValidationsExecute(r ProfileConfigurationApiPostProfileNameValidationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostProfileNameValidations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileNameValidations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileNameValidations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostProfileRelationshipsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileLinks *PutProfileRelationshipsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostProfileRelationshipsRequest) Authorization(authorization string) ProfileConfigurationApiPostProfileRelationshipsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostProfileRelationshipsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostProfileRelationshipsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostProfileRelationshipsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostProfileRelationshipsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request Object to create Profile Links
func (r ProfileConfigurationApiPostProfileRelationshipsRequest) ProfileLinks(profileLinks PutProfileRelationshipsRequest) ProfileConfigurationApiPostProfileRelationshipsRequest {
	r.profileLinks = &profileLinks
	return r
}

// External system code.
func (r ProfileConfigurationApiPostProfileRelationshipsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostProfileRelationshipsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostProfileRelationshipsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostProfileRelationshipsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostProfileRelationshipsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileRelationshipsExecute(r)
}

/*
PostProfileRelationships Create profile relationships

You can use this API to create profile relationships. <p><strong>OperationId:</strong>postProfileRelationships</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostProfileRelationshipsRequest
*/
func (a *ProfileConfigurationApiService) PostProfileRelationships(ctx context.Context) ProfileConfigurationApiPostProfileRelationshipsRequest {
	return ProfileConfigurationApiPostProfileRelationshipsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostProfileRelationshipsExecute(r ProfileConfigurationApiPostProfileRelationshipsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostProfileRelationships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relationships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileLinks
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostTemplateExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateExclusivePreferences *PutTemplateExclusivePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating exclusive preferences at the template level.
func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) TemplateExclusivePreferences(templateExclusivePreferences PutTemplateExclusivePreferencesRequest) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	r.templateExclusivePreferences = &templateExclusivePreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateExclusivePreferencesExecute(r)
}

/*
PostTemplateExclusivePreferences Create template Exclusive Preferences

You can use this API to create template Exclusive Preferences. <p><strong>OperationId:</strong>postTemplateExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostTemplateExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) PostTemplateExclusivePreferences(ctx context.Context) ProfileConfigurationApiPostTemplateExclusivePreferencesRequest {
	return ProfileConfigurationApiPostTemplateExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostTemplateExclusivePreferencesExecute(r ProfileConfigurationApiPostTemplateExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostTemplateExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exclusivePreferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateExclusivePreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPostTemplatePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templatePreferences *PutTemplatePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPostTemplatePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPostTemplatePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPostTemplatePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPostTemplatePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPostTemplatePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPostTemplatePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating preferences at the template level.
func (r ProfileConfigurationApiPostTemplatePreferencesRequest) TemplatePreferences(templatePreferences PutTemplatePreferencesRequest) ProfileConfigurationApiPostTemplatePreferencesRequest {
	r.templatePreferences = &templatePreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPostTemplatePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPostTemplatePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPostTemplatePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPostTemplatePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPostTemplatePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplatePreferencesExecute(r)
}

/*
PostTemplatePreferences Create template preferences

You can use this API to create template preferences. <p><strong>OperationId:</strong>postTemplatePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPostTemplatePreferencesRequest
*/
func (a *ProfileConfigurationApiService) PostTemplatePreferences(ctx context.Context) ProfileConfigurationApiPostTemplatePreferencesRequest {
	return ProfileConfigurationApiPostTemplatePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PostTemplatePreferencesExecute(r ProfileConfigurationApiPostTemplatePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PostTemplatePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templatePreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutAddressFormatsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	addressFormats *PutAddressFormatsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutAddressFormatsRequest) Authorization(authorization string) ProfileConfigurationApiPutAddressFormatsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutAddressFormatsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutAddressFormatsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutAddressFormatsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutAddressFormatsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change address formats.
func (r ProfileConfigurationApiPutAddressFormatsRequest) AddressFormats(addressFormats PutAddressFormatsRequest) ProfileConfigurationApiPutAddressFormatsRequest {
	r.addressFormats = &addressFormats
	return r
}

// External system code.
func (r ProfileConfigurationApiPutAddressFormatsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutAddressFormatsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutAddressFormatsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutAddressFormatsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutAddressFormatsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAddressFormatsExecute(r)
}

/*
PutAddressFormats Change address formats

You can use this API to change address formats. <p><strong>OperationId:</strong>putAddressFormats</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutAddressFormatsRequest
*/
func (a *ProfileConfigurationApiService) PutAddressFormats(ctx context.Context) ProfileConfigurationApiPutAddressFormatsRequest {
	return ProfileConfigurationApiPutAddressFormatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutAddressFormatsExecute(r ProfileConfigurationApiPutAddressFormatsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutAddressFormats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addressFormats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.addressFormats
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutCreditRatingsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	creditRatings *PutCreditRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutCreditRatingsRequest) Authorization(authorization string) ProfileConfigurationApiPutCreditRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutCreditRatingsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutCreditRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutCreditRatingsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutCreditRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing credit ratings.
func (r ProfileConfigurationApiPutCreditRatingsRequest) CreditRatings(creditRatings PutCreditRatingsRequest) ProfileConfigurationApiPutCreditRatingsRequest {
	r.creditRatings = &creditRatings
	return r
}

// External system code.
func (r ProfileConfigurationApiPutCreditRatingsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutCreditRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutCreditRatingsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutCreditRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutCreditRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCreditRatingsExecute(r)
}

/*
PutCreditRatings Change credit ratings

You can use this API to change credit ratings. <p><strong>OperationId:</strong>putCreditRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutCreditRatingsRequest
*/
func (a *ProfileConfigurationApiService) PutCreditRatings(ctx context.Context) ProfileConfigurationApiPutCreditRatingsRequest {
	return ProfileConfigurationApiPutCreditRatingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutCreditRatingsExecute(r ProfileConfigurationApiPutCreditRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutCreditRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creditRatings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditRatings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	exclusivePreferences *PutExclusivePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPutExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Exclusive preferences at the property level.
func (r ProfileConfigurationApiPutExclusivePreferencesRequest) ExclusivePreferences(exclusivePreferences PutExclusivePreferencesRequest) ProfileConfigurationApiPutExclusivePreferencesRequest {
	r.exclusivePreferences = &exclusivePreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPutExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutExclusivePreferencesExecute(r)
}

/*
PutExclusivePreferences Change Exclusive Preferences

You can use this API to change Exclusive Preferences at hotel Level. <p><strong>OperationId:</strong>putExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiPutExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) PutExclusivePreferences(ctx context.Context, hotelId string) ProfileConfigurationApiPutExclusivePreferencesRequest {
	return ProfileConfigurationApiPutExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutExclusivePreferencesExecute(r ProfileConfigurationApiPutExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/exclusivePreferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.exclusivePreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutPreferenceGroupsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	preferenceGroups *PutPreferenceGroupsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutPreferenceGroupsRequest) Authorization(authorization string) ProfileConfigurationApiPutPreferenceGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutPreferenceGroupsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutPreferenceGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutPreferenceGroupsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutPreferenceGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing preference groups.
func (r ProfileConfigurationApiPutPreferenceGroupsRequest) PreferenceGroups(preferenceGroups PutPreferenceGroupsRequest) ProfileConfigurationApiPutPreferenceGroupsRequest {
	r.preferenceGroups = &preferenceGroups
	return r
}

// External system code.
func (r ProfileConfigurationApiPutPreferenceGroupsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutPreferenceGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutPreferenceGroupsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutPreferenceGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutPreferenceGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPreferenceGroupsExecute(r)
}

/*
PutPreferenceGroups Change Preference Groups

This API can be used to modify the preference groups. Changes can be made concurrently to multiple groups. <p><strong>OperationId:</strong>putPreferenceGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutPreferenceGroupsRequest
*/
func (a *ProfileConfigurationApiService) PutPreferenceGroups(ctx context.Context) ProfileConfigurationApiPutPreferenceGroupsRequest {
	return ProfileConfigurationApiPutPreferenceGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutPreferenceGroupsExecute(r ProfileConfigurationApiPutPreferenceGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutPreferenceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferenceGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preferenceGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelPreferences *PutPreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutPreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPutPreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutPreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutPreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutPreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutPreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing preferences at the property level.
func (r ProfileConfigurationApiPutPreferencesRequest) HotelPreferences(hotelPreferences PutPreferencesRequest) ProfileConfigurationApiPutPreferencesRequest {
	r.hotelPreferences = &hotelPreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPutPreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutPreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutPreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutPreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutPreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPreferencesExecute(r)
}

/*
PutPreferences Change preferences

Use this API to update and change existing preferences. <p><strong>OperationId:</strong>putPreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ProfileConfigurationApiPutPreferencesRequest
*/
func (a *ProfileConfigurationApiService) PutPreferences(ctx context.Context, hotelId string) ProfileConfigurationApiPutPreferencesRequest {
	return ProfileConfigurationApiPutPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutPreferencesExecute(r ProfileConfigurationApiPutPreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelPreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutProfileNameValidationsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileNameValidationsToChange *PutProfileNameValidationsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutProfileNameValidationsRequest) Authorization(authorization string) ProfileConfigurationApiPutProfileNameValidationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutProfileNameValidationsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutProfileNameValidationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutProfileNameValidationsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutProfileNameValidationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to edit Profile names.
func (r ProfileConfigurationApiPutProfileNameValidationsRequest) ProfileNameValidationsToChange(profileNameValidationsToChange PutProfileNameValidationsRequest) ProfileConfigurationApiPutProfileNameValidationsRequest {
	r.profileNameValidationsToChange = &profileNameValidationsToChange
	return r
}

// External system code.
func (r ProfileConfigurationApiPutProfileNameValidationsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutProfileNameValidationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutProfileNameValidationsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutProfileNameValidationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutProfileNameValidationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutProfileNameValidationsExecute(r)
}

/*
PutProfileNameValidations Change Profile Name Validations

You can use this API to change Profile Name Validations. <p><strong>OperationId:</strong>putProfileNameValidations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutProfileNameValidationsRequest
*/
func (a *ProfileConfigurationApiService) PutProfileNameValidations(ctx context.Context) ProfileConfigurationApiPutProfileNameValidationsRequest {
	return ProfileConfigurationApiPutProfileNameValidationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutProfileNameValidationsExecute(r ProfileConfigurationApiPutProfileNameValidationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutProfileNameValidations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profileNameValidations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileNameValidationsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutProfileRelationshipsRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileLinks *PutProfileRelationshipsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutProfileRelationshipsRequest) Authorization(authorization string) ProfileConfigurationApiPutProfileRelationshipsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutProfileRelationshipsRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutProfileRelationshipsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutProfileRelationshipsRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutProfileRelationshipsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request Object for change profile links
func (r ProfileConfigurationApiPutProfileRelationshipsRequest) ProfileLinks(profileLinks PutProfileRelationshipsRequest) ProfileConfigurationApiPutProfileRelationshipsRequest {
	r.profileLinks = &profileLinks
	return r
}

// External system code.
func (r ProfileConfigurationApiPutProfileRelationshipsRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutProfileRelationshipsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutProfileRelationshipsRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutProfileRelationshipsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutProfileRelationshipsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutProfileRelationshipsExecute(r)
}

/*
PutProfileRelationships Change profile relationships

You can use this API to change profile relationships. <p><strong>OperationId:</strong>putProfileRelationships</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutProfileRelationshipsRequest
*/
func (a *ProfileConfigurationApiService) PutProfileRelationships(ctx context.Context) ProfileConfigurationApiPutProfileRelationshipsRequest {
	return ProfileConfigurationApiPutProfileRelationshipsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutProfileRelationshipsExecute(r ProfileConfigurationApiPutProfileRelationshipsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutProfileRelationships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/relationships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileLinks
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutTemplateExclusivePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateExclusivePreferences *PutTemplateExclusivePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Exclusive preferences at the template level.
func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) TemplateExclusivePreferences(templateExclusivePreferences PutTemplateExclusivePreferencesRequest) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	r.templateExclusivePreferences = &templateExclusivePreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateExclusivePreferencesExecute(r)
}

/*
PutTemplateExclusivePreferences Change template Exclusive Preferences

You can use this API to change template Exclusive Preferences. <p><strong>OperationId:</strong>putTemplateExclusivePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutTemplateExclusivePreferencesRequest
*/
func (a *ProfileConfigurationApiService) PutTemplateExclusivePreferences(ctx context.Context) ProfileConfigurationApiPutTemplateExclusivePreferencesRequest {
	return ProfileConfigurationApiPutTemplateExclusivePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutTemplateExclusivePreferencesExecute(r ProfileConfigurationApiPutTemplateExclusivePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutTemplateExclusivePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exclusivePreferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateExclusivePreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileConfigurationApiPutTemplatePreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileConfigurationApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templatePreferences *PutTemplatePreferencesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileConfigurationApiPutTemplatePreferencesRequest) Authorization(authorization string) ProfileConfigurationApiPutTemplatePreferencesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ProfileConfigurationApiPutTemplatePreferencesRequest) XAppKey(xAppKey string) ProfileConfigurationApiPutTemplatePreferencesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileConfigurationApiPutTemplatePreferencesRequest) XHotelid(xHotelid string) ProfileConfigurationApiPutTemplatePreferencesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing preferences at the template level.
func (r ProfileConfigurationApiPutTemplatePreferencesRequest) TemplatePreferences(templatePreferences PutTemplatePreferencesRequest) ProfileConfigurationApiPutTemplatePreferencesRequest {
	r.templatePreferences = &templatePreferences
	return r
}

// External system code.
func (r ProfileConfigurationApiPutTemplatePreferencesRequest) XExternalsystem(xExternalsystem string) ProfileConfigurationApiPutTemplatePreferencesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileConfigurationApiPutTemplatePreferencesRequest) AcceptLanguage(acceptLanguage string) ProfileConfigurationApiPutTemplatePreferencesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileConfigurationApiPutTemplatePreferencesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplatePreferencesExecute(r)
}

/*
PutTemplatePreferences Change template preferences

You can use this API to change template preferences. <p><strong>OperationId:</strong>putTemplatePreferences</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileConfigurationApiPutTemplatePreferencesRequest
*/
func (a *ProfileConfigurationApiService) PutTemplatePreferences(ctx context.Context) ProfileConfigurationApiPutTemplatePreferencesRequest {
	return ProfileConfigurationApiPutTemplatePreferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileConfigurationApiService) PutTemplatePreferencesExecute(r ProfileConfigurationApiPutTemplatePreferencesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileConfigurationApiService.PutTemplatePreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/preferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templatePreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
