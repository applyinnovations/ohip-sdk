/*
OPERA Cloud CRM Configuration API

APIs for Customer Relationship Management (profile) configuration, such as creating preferences, or address types.  It also includes Membership Configuration, where you can retrieve membership levels that are configured for a property, or create new membership enrollment codes.<br /><br /> Compatible with OPERA Cloud release 23.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.4
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crmcfg

import (
	"encoding/json"
	"fmt"
)

// IdentificationRoleType Simple type for storing identification roles.
type IdentificationRoleType string

// List of identificationRoleType
const (
	IDENTIFICATIONROLETYPE_PASSPORT IdentificationRoleType = "Passport"
	IDENTIFICATIONROLETYPE_DRIVER_LICENSE IdentificationRoleType = "DriverLicense"
	IDENTIFICATIONROLETYPE_VISA IdentificationRoleType = "Visa"
	IDENTIFICATIONROLETYPE_ID IdentificationRoleType = "Id"
	IDENTIFICATIONROLETYPE_UNKNOWN IdentificationRoleType = "Unknown"
)

// All allowed values of IdentificationRoleType enum
var AllowedIdentificationRoleTypeEnumValues = []IdentificationRoleType{
	"Passport",
	"DriverLicense",
	"Visa",
	"Id",
	"Unknown",
}

func (v *IdentificationRoleType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := IdentificationRoleType(value)
	for _, existing := range AllowedIdentificationRoleTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid IdentificationRoleType", value)
}

// NewIdentificationRoleTypeFromValue returns a pointer to a valid IdentificationRoleType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewIdentificationRoleTypeFromValue(v string) (*IdentificationRoleType, error) {
	ev := IdentificationRoleType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for IdentificationRoleType: valid values are %v", v, AllowedIdentificationRoleTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v IdentificationRoleType) IsValid() bool {
	for _, existing := range AllowedIdentificationRoleTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to identificationRoleType value
func (v IdentificationRoleType) Ptr() *IdentificationRoleType {
	return &v
}

type NullableIdentificationRoleType struct {
	value *IdentificationRoleType
	isSet bool
}

func (v NullableIdentificationRoleType) Get() *IdentificationRoleType {
	return v.value
}

func (v *NullableIdentificationRoleType) Set(val *IdentificationRoleType) {
	v.value = val
	v.isSet = true
}

func (v NullableIdentificationRoleType) IsSet() bool {
	return v.isSet
}

func (v *NullableIdentificationRoleType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableIdentificationRoleType(val *IdentificationRoleType) *NullableIdentificationRoleType {
	return &NullableIdentificationRoleType{value: val, isSet: true}
}

func (v NullableIdentificationRoleType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableIdentificationRoleType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

