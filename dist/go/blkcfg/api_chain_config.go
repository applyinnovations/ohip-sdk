/*
OPERA Cloud Block Configuration API

APIs for Block configuration, such as creating, updating, fetching and removing codes related to blocks. <br />< This might include fetching the block cancellation reasons, or creating new block refused reasons.  Wash schedules can be create, or new reservation methods could be added for a property.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blkcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChainConfigApiService ChainConfigApi service
type ChainConfigApiService service

type ChainConfigApiDeleteBlockCancellationReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockCancellationReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockCancellationReasonsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) Authorization(authorization string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) XAppKey(xAppKey string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) XHotelid(xHotelid string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) BlockCancellationReasonsCodes(blockCancellationReasonsCodes []string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	r.blockCancellationReasonsCodes = &blockCancellationReasonsCodes
	return r
}

// External system code.
func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteBlockCancellationReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockCancellationReasonsExecute(r)
}

/*
DeleteBlockCancellationReasons Delete Block Cancellation Reason

Use this API to delete Block Cancellation Reason. <p><strong>OperationId:</strong>deleteBlockCancellationReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockCancellationReasonsId Unique ID of Block Cancellation Reasons.
 @return ChainConfigApiDeleteBlockCancellationReasonsRequest
*/
func (a *ChainConfigApiService) DeleteBlockCancellationReasons(ctx context.Context, blockCancellationReasonsId string) ChainConfigApiDeleteBlockCancellationReasonsRequest {
	return ChainConfigApiDeleteBlockCancellationReasonsRequest{
		ApiService: a,
		ctx: ctx,
		blockCancellationReasonsId: blockCancellationReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteBlockCancellationReasonsExecute(r ChainConfigApiDeleteBlockCancellationReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteBlockCancellationReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockCancellationReasons/{blockCancellationReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockCancellationReasonsId"+"}", url.PathEscape(parameterValueToString(r.blockCancellationReasonsId, "blockCancellationReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockCancellationReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("blockCancellationReasonsId must have at least 1 elements")
	}
	if strlen(r.blockCancellationReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("blockCancellationReasonsId must have less than 2000 elements")
	}

	if r.blockCancellationReasonsCodes != nil {
		t := *r.blockCancellationReasonsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockCancellationReasonsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockCancellationReasonsCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiDeleteBlockLostBookingCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockLostBookingCodesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockLostBookingCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) Authorization(authorization string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) XAppKey(xAppKey string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) XHotelid(xHotelid string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) BlockLostBookingCodes(blockLostBookingCodes []string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	r.blockLostBookingCodes = &blockLostBookingCodes
	return r
}

// External system code.
func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteBlockLostBookingCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockLostBookingCodesExecute(r)
}

/*
DeleteBlockLostBookingCodes Delete Block Lost Booking Code

Use this API to delete Block Lost Booking Code. <p><strong>OperationId:</strong>deleteBlockLostBookingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockLostBookingCodesId Unique ID of Block Lost Booking Codes.
 @return ChainConfigApiDeleteBlockLostBookingCodesRequest
*/
func (a *ChainConfigApiService) DeleteBlockLostBookingCodes(ctx context.Context, blockLostBookingCodesId string) ChainConfigApiDeleteBlockLostBookingCodesRequest {
	return ChainConfigApiDeleteBlockLostBookingCodesRequest{
		ApiService: a,
		ctx: ctx,
		blockLostBookingCodesId: blockLostBookingCodesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteBlockLostBookingCodesExecute(r ChainConfigApiDeleteBlockLostBookingCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteBlockLostBookingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockLostBookingCodes/{blockLostBookingCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockLostBookingCodesId"+"}", url.PathEscape(parameterValueToString(r.blockLostBookingCodesId, "blockLostBookingCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockLostBookingCodesId) < 1 {
		return localVarReturnValue, nil, reportError("blockLostBookingCodesId must have at least 1 elements")
	}
	if strlen(r.blockLostBookingCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("blockLostBookingCodesId must have less than 2000 elements")
	}

	if r.blockLostBookingCodes != nil {
		t := *r.blockLostBookingCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockLostBookingCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockLostBookingCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiDeleteBlockRateOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockRateOverrideReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRateOverrideReasonsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) Authorization(authorization string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) XAppKey(xAppKey string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) XHotelid(xHotelid string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) BlockRateOverrideReasonsCodes(blockRateOverrideReasonsCodes []string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	r.blockRateOverrideReasonsCodes = &blockRateOverrideReasonsCodes
	return r
}

// External system code.
func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockRateOverrideReasonsExecute(r)
}

/*
DeleteBlockRateOverrideReasons Delete Block Rate Override Reason

Use this API to delete Block Rate Override Reason. <p><strong>OperationId:</strong>deleteBlockRateOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockRateOverrideReasonsId Unique ID of Block Rate Override Reasons.
 @return ChainConfigApiDeleteBlockRateOverrideReasonsRequest
*/
func (a *ChainConfigApiService) DeleteBlockRateOverrideReasons(ctx context.Context, blockRateOverrideReasonsId string) ChainConfigApiDeleteBlockRateOverrideReasonsRequest {
	return ChainConfigApiDeleteBlockRateOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
		blockRateOverrideReasonsId: blockRateOverrideReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteBlockRateOverrideReasonsExecute(r ChainConfigApiDeleteBlockRateOverrideReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteBlockRateOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRateOverrideReasons/{blockRateOverrideReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockRateOverrideReasonsId"+"}", url.PathEscape(parameterValueToString(r.blockRateOverrideReasonsId, "blockRateOverrideReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockRateOverrideReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("blockRateOverrideReasonsId must have at least 1 elements")
	}
	if strlen(r.blockRateOverrideReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("blockRateOverrideReasonsId must have less than 2000 elements")
	}

	if r.blockRateOverrideReasonsCodes != nil {
		t := *r.blockRateOverrideReasonsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockRateOverrideReasonsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockRateOverrideReasonsCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiDeleteBlockRefusedReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockRefusedReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRefusedReasonsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) Authorization(authorization string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) XAppKey(xAppKey string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) XHotelid(xHotelid string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) BlockRefusedReasonsCodes(blockRefusedReasonsCodes []string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	r.blockRefusedReasonsCodes = &blockRefusedReasonsCodes
	return r
}

// External system code.
func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteBlockRefusedReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockRefusedReasonsExecute(r)
}

/*
DeleteBlockRefusedReasons Delete Block Refused Reason

Use this API to delete Block Refused Reason. <p><strong>OperationId:</strong>deleteBlockRefusedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockRefusedReasonsId Unique ID of Block Refused Reasons.
 @return ChainConfigApiDeleteBlockRefusedReasonsRequest
*/
func (a *ChainConfigApiService) DeleteBlockRefusedReasons(ctx context.Context, blockRefusedReasonsId string) ChainConfigApiDeleteBlockRefusedReasonsRequest {
	return ChainConfigApiDeleteBlockRefusedReasonsRequest{
		ApiService: a,
		ctx: ctx,
		blockRefusedReasonsId: blockRefusedReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteBlockRefusedReasonsExecute(r ChainConfigApiDeleteBlockRefusedReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteBlockRefusedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRefusedReasons/{blockRefusedReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockRefusedReasonsId"+"}", url.PathEscape(parameterValueToString(r.blockRefusedReasonsId, "blockRefusedReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockRefusedReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("blockRefusedReasonsId must have at least 1 elements")
	}
	if strlen(r.blockRefusedReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("blockRefusedReasonsId must have less than 2000 elements")
	}

	if r.blockRefusedReasonsCodes != nil {
		t := *r.blockRefusedReasonsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockRefusedReasonsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockRefusedReasonsCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiDeleteDestinationCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	destinationCodesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	destinationCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteDestinationCodesRequest) Authorization(authorization string) ChainConfigApiDeleteDestinationCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiDeleteDestinationCodesRequest) XAppKey(xAppKey string) ChainConfigApiDeleteDestinationCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteDestinationCodesRequest) XHotelid(xHotelid string) ChainConfigApiDeleteDestinationCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigApiDeleteDestinationCodesRequest) DestinationCodes(destinationCodes []string) ChainConfigApiDeleteDestinationCodesRequest {
	r.destinationCodes = &destinationCodes
	return r
}

// External system code.
func (r ChainConfigApiDeleteDestinationCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteDestinationCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteDestinationCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteDestinationCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteDestinationCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDestinationCodesExecute(r)
}

/*
DeleteDestinationCodes Delete Destination Codes

Use this API to delete Destination Codes. <p><strong>OperationId:</strong>deleteDestinationCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param destinationCodesId Unique ID of Destination Codes.
 @return ChainConfigApiDeleteDestinationCodesRequest
*/
func (a *ChainConfigApiService) DeleteDestinationCodes(ctx context.Context, destinationCodesId string) ChainConfigApiDeleteDestinationCodesRequest {
	return ChainConfigApiDeleteDestinationCodesRequest{
		ApiService: a,
		ctx: ctx,
		destinationCodesId: destinationCodesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteDestinationCodesExecute(r ChainConfigApiDeleteDestinationCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteDestinationCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/destinationCodes/{destinationCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"destinationCodesId"+"}", url.PathEscape(parameterValueToString(r.destinationCodesId, "destinationCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.destinationCodesId) < 1 {
		return localVarReturnValue, nil, reportError("destinationCodesId must have at least 1 elements")
	}
	if strlen(r.destinationCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("destinationCodesId must have less than 2000 elements")
	}

	if r.destinationCodes != nil {
		t := *r.destinationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiDeleteReservationMethodsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	reservationMethodsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationMethodsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiDeleteReservationMethodsRequest) Authorization(authorization string) ChainConfigApiDeleteReservationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiDeleteReservationMethodsRequest) XAppKey(xAppKey string) ChainConfigApiDeleteReservationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiDeleteReservationMethodsRequest) XHotelid(xHotelid string) ChainConfigApiDeleteReservationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigApiDeleteReservationMethodsRequest) ReservationMethodsCodes(reservationMethodsCodes []string) ChainConfigApiDeleteReservationMethodsRequest {
	r.reservationMethodsCodes = &reservationMethodsCodes
	return r
}

// External system code.
func (r ChainConfigApiDeleteReservationMethodsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiDeleteReservationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiDeleteReservationMethodsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiDeleteReservationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiDeleteReservationMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationMethodsExecute(r)
}

/*
DeleteReservationMethods Delete Reservation Methods

Use this API to delete Reservation Methods. <p><strong>OperationId:</strong>deleteReservationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationMethodsId Unique ID of Reservation Methods.
 @return ChainConfigApiDeleteReservationMethodsRequest
*/
func (a *ChainConfigApiService) DeleteReservationMethods(ctx context.Context, reservationMethodsId string) ChainConfigApiDeleteReservationMethodsRequest {
	return ChainConfigApiDeleteReservationMethodsRequest{
		ApiService: a,
		ctx: ctx,
		reservationMethodsId: reservationMethodsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) DeleteReservationMethodsExecute(r ChainConfigApiDeleteReservationMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.DeleteReservationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservationMethods/{reservationMethodsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationMethodsId"+"}", url.PathEscape(parameterValueToString(r.reservationMethodsId, "reservationMethodsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationMethodsId) < 1 {
		return localVarReturnValue, nil, reportError("reservationMethodsId must have at least 1 elements")
	}
	if strlen(r.reservationMethodsId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationMethodsId must have less than 2000 elements")
	}

	if r.reservationMethodsCodes != nil {
		t := *r.reservationMethodsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationMethodsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationMethodsCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetBlockCancellationReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetBlockCancellationReasonsRequest) Authorization(authorization string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiGetBlockCancellationReasonsRequest) XAppKey(xAppKey string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetBlockCancellationReasonsRequest) XHotelid(xHotelid string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetBlockCancellationReasonsRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetBlockCancellationReasonsRequest) Codes(codes []string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetBlockCancellationReasonsRequest) WildCard(wildCard string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetBlockCancellationReasonsRequest) Description(description string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetBlockCancellationReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetBlockCancellationReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetBlockCancellationReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetBlockCancellationReasonsRequest) Execute() (*BlockCancellationReasonsDetails, *http.Response, error) {
	return r.ApiService.GetBlockCancellationReasonsExecute(r)
}

/*
GetBlockCancellationReasons Get Block Cancellation Reasons

Use this API to get Block Cancellation Reasons. <p><strong>OperationId:</strong>getBlockCancellationReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetBlockCancellationReasonsRequest
*/
func (a *ChainConfigApiService) GetBlockCancellationReasons(ctx context.Context) ChainConfigApiGetBlockCancellationReasonsRequest {
	return ChainConfigApiGetBlockCancellationReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockCancellationReasonsDetails
func (a *ChainConfigApiService) GetBlockCancellationReasonsExecute(r ChainConfigApiGetBlockCancellationReasonsRequest) (*BlockCancellationReasonsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockCancellationReasonsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetBlockCancellationReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockCancellationReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetBlockLostBookingCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetBlockLostBookingCodesRequest) Authorization(authorization string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiGetBlockLostBookingCodesRequest) XAppKey(xAppKey string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetBlockLostBookingCodesRequest) XHotelid(xHotelid string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetBlockLostBookingCodesRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetBlockLostBookingCodesRequest) Codes(codes []string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetBlockLostBookingCodesRequest) WildCard(wildCard string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetBlockLostBookingCodesRequest) Description(description string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetBlockLostBookingCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetBlockLostBookingCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetBlockLostBookingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetBlockLostBookingCodesRequest) Execute() (*BlockLostBookingCodesDetails, *http.Response, error) {
	return r.ApiService.GetBlockLostBookingCodesExecute(r)
}

/*
GetBlockLostBookingCodes Get Block Lost Booking Codes

Use this API to get Block Lost Booking Codes. <p><strong>OperationId:</strong>getBlockLostBookingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetBlockLostBookingCodesRequest
*/
func (a *ChainConfigApiService) GetBlockLostBookingCodes(ctx context.Context) ChainConfigApiGetBlockLostBookingCodesRequest {
	return ChainConfigApiGetBlockLostBookingCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockLostBookingCodesDetails
func (a *ChainConfigApiService) GetBlockLostBookingCodesExecute(r ChainConfigApiGetBlockLostBookingCodesRequest) (*BlockLostBookingCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockLostBookingCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetBlockLostBookingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockLostBookingCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetBlockRateOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) Authorization(authorization string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) XAppKey(xAppKey string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) XHotelid(xHotelid string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) Codes(codes []string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) WildCard(wildCard string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) Description(description string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetBlockRateOverrideReasonsRequest) Execute() (*BlockRateOverrideReasonsDetails, *http.Response, error) {
	return r.ApiService.GetBlockRateOverrideReasonsExecute(r)
}

/*
GetBlockRateOverrideReasons Get Block Rate Override Reasons

Use this API to get Block Rate Override Reasons. <p><strong>OperationId:</strong>getBlockRateOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetBlockRateOverrideReasonsRequest
*/
func (a *ChainConfigApiService) GetBlockRateOverrideReasons(ctx context.Context) ChainConfigApiGetBlockRateOverrideReasonsRequest {
	return ChainConfigApiGetBlockRateOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockRateOverrideReasonsDetails
func (a *ChainConfigApiService) GetBlockRateOverrideReasonsExecute(r ChainConfigApiGetBlockRateOverrideReasonsRequest) (*BlockRateOverrideReasonsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRateOverrideReasonsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetBlockRateOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRateOverrideReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetBlockRefusedReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetBlockRefusedReasonsRequest) Authorization(authorization string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiGetBlockRefusedReasonsRequest) XAppKey(xAppKey string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetBlockRefusedReasonsRequest) XHotelid(xHotelid string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetBlockRefusedReasonsRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetBlockRefusedReasonsRequest) Codes(codes []string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetBlockRefusedReasonsRequest) WildCard(wildCard string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetBlockRefusedReasonsRequest) Description(description string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetBlockRefusedReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetBlockRefusedReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetBlockRefusedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetBlockRefusedReasonsRequest) Execute() (*BlockRefusedReasonsDetails, *http.Response, error) {
	return r.ApiService.GetBlockRefusedReasonsExecute(r)
}

/*
GetBlockRefusedReasons Get Block Refused Reasons

Use this API to get Block Refused Reasons. <p><strong>OperationId:</strong>getBlockRefusedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetBlockRefusedReasonsRequest
*/
func (a *ChainConfigApiService) GetBlockRefusedReasons(ctx context.Context) ChainConfigApiGetBlockRefusedReasonsRequest {
	return ChainConfigApiGetBlockRefusedReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockRefusedReasonsDetails
func (a *ChainConfigApiService) GetBlockRefusedReasonsExecute(r ChainConfigApiGetBlockRefusedReasonsRequest) (*BlockRefusedReasonsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRefusedReasonsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetBlockRefusedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRefusedReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetDestinationCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetDestinationCodesRequest) Authorization(authorization string) ChainConfigApiGetDestinationCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiGetDestinationCodesRequest) XAppKey(xAppKey string) ChainConfigApiGetDestinationCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetDestinationCodesRequest) XHotelid(xHotelid string) ChainConfigApiGetDestinationCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetDestinationCodesRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetDestinationCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetDestinationCodesRequest) Codes(codes []string) ChainConfigApiGetDestinationCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetDestinationCodesRequest) WildCard(wildCard string) ChainConfigApiGetDestinationCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetDestinationCodesRequest) Description(description string) ChainConfigApiGetDestinationCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetDestinationCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetDestinationCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetDestinationCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetDestinationCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetDestinationCodesRequest) Execute() (*DestinationCodesDetails, *http.Response, error) {
	return r.ApiService.GetDestinationCodesExecute(r)
}

/*
GetDestinationCodes Get Destination Codes

Use this API to get Destination Codes. <p><strong>OperationId:</strong>getDestinationCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetDestinationCodesRequest
*/
func (a *ChainConfigApiService) GetDestinationCodes(ctx context.Context) ChainConfigApiGetDestinationCodesRequest {
	return ChainConfigApiGetDestinationCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DestinationCodesDetails
func (a *ChainConfigApiService) GetDestinationCodesExecute(r ChainConfigApiGetDestinationCodesRequest) (*DestinationCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DestinationCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetDestinationCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/destinationCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiGetReservationMethodsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiGetReservationMethodsRequest) Authorization(authorization string) ChainConfigApiGetReservationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiGetReservationMethodsRequest) XAppKey(xAppKey string) ChainConfigApiGetReservationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiGetReservationMethodsRequest) XHotelid(xHotelid string) ChainConfigApiGetReservationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigApiGetReservationMethodsRequest) FetchInactive(fetchInactive bool) ChainConfigApiGetReservationMethodsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigApiGetReservationMethodsRequest) Codes(codes []string) ChainConfigApiGetReservationMethodsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigApiGetReservationMethodsRequest) WildCard(wildCard string) ChainConfigApiGetReservationMethodsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigApiGetReservationMethodsRequest) Description(description string) ChainConfigApiGetReservationMethodsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigApiGetReservationMethodsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiGetReservationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiGetReservationMethodsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiGetReservationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiGetReservationMethodsRequest) Execute() (*ReservationMethodsDetails, *http.Response, error) {
	return r.ApiService.GetReservationMethodsExecute(r)
}

/*
GetReservationMethods Get Reservation Methods

Use this API to get Reservation Methods. <p><strong>OperationId:</strong>getReservationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiGetReservationMethodsRequest
*/
func (a *ChainConfigApiService) GetReservationMethods(ctx context.Context) ChainConfigApiGetReservationMethodsRequest {
	return ChainConfigApiGetReservationMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReservationMethodsDetails
func (a *ChainConfigApiService) GetReservationMethodsExecute(r ChainConfigApiGetReservationMethodsRequest) (*ReservationMethodsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationMethodsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.GetReservationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservationMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostBlockCancellationReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockCancellationReasonsCriteria *PostBlockCancellationReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostBlockCancellationReasonsRequest) Authorization(authorization string) ChainConfigApiPostBlockCancellationReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPostBlockCancellationReasonsRequest) XAppKey(xAppKey string) ChainConfigApiPostBlockCancellationReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostBlockCancellationReasonsRequest) XHotelid(xHotelid string) ChainConfigApiPostBlockCancellationReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Block Cancellation Reasons.
func (r ChainConfigApiPostBlockCancellationReasonsRequest) BlockCancellationReasonsCriteria(blockCancellationReasonsCriteria PostBlockCancellationReasonsRequest) ChainConfigApiPostBlockCancellationReasonsRequest {
	r.blockCancellationReasonsCriteria = &blockCancellationReasonsCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostBlockCancellationReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostBlockCancellationReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostBlockCancellationReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostBlockCancellationReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostBlockCancellationReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockCancellationReasonsExecute(r)
}

/*
PostBlockCancellationReasons Create Block Cancellation Reasons

Use this API to create Block Cancellation Reasons. <p><strong>OperationId:</strong>postBlockCancellationReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostBlockCancellationReasonsRequest
*/
func (a *ChainConfigApiService) PostBlockCancellationReasons(ctx context.Context) ChainConfigApiPostBlockCancellationReasonsRequest {
	return ChainConfigApiPostBlockCancellationReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostBlockCancellationReasonsExecute(r ChainConfigApiPostBlockCancellationReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostBlockCancellationReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockCancellationReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockCancellationReasonsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostBlockLostBookingCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockLostBookingCodesCriteria *PostBlockLostBookingCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostBlockLostBookingCodesRequest) Authorization(authorization string) ChainConfigApiPostBlockLostBookingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPostBlockLostBookingCodesRequest) XAppKey(xAppKey string) ChainConfigApiPostBlockLostBookingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostBlockLostBookingCodesRequest) XHotelid(xHotelid string) ChainConfigApiPostBlockLostBookingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Block Lost Booking Codes.
func (r ChainConfigApiPostBlockLostBookingCodesRequest) BlockLostBookingCodesCriteria(blockLostBookingCodesCriteria PostBlockLostBookingCodesRequest) ChainConfigApiPostBlockLostBookingCodesRequest {
	r.blockLostBookingCodesCriteria = &blockLostBookingCodesCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostBlockLostBookingCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostBlockLostBookingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostBlockLostBookingCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostBlockLostBookingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostBlockLostBookingCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockLostBookingCodesExecute(r)
}

/*
PostBlockLostBookingCodes Create Block Lost Booking Codes

Use this API to create Block Lost Booking Codes. <p><strong>OperationId:</strong>postBlockLostBookingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostBlockLostBookingCodesRequest
*/
func (a *ChainConfigApiService) PostBlockLostBookingCodes(ctx context.Context) ChainConfigApiPostBlockLostBookingCodesRequest {
	return ChainConfigApiPostBlockLostBookingCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostBlockLostBookingCodesExecute(r ChainConfigApiPostBlockLostBookingCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostBlockLostBookingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockLostBookingCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockLostBookingCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostBlockRateOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRateOverrideReasonsCriteria *PostBlockRateOverrideReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) Authorization(authorization string) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) XAppKey(xAppKey string) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) XHotelid(xHotelid string) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Block Rate Override Reasons.
func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) BlockRateOverrideReasonsCriteria(blockRateOverrideReasonsCriteria PostBlockRateOverrideReasonsRequest) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	r.blockRateOverrideReasonsCriteria = &blockRateOverrideReasonsCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostBlockRateOverrideReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockRateOverrideReasonsExecute(r)
}

/*
PostBlockRateOverrideReasons Create Block Rate Override Reasons

Use this API to create Block Rate Override Reasons. <p><strong>OperationId:</strong>postBlockRateOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostBlockRateOverrideReasonsRequest
*/
func (a *ChainConfigApiService) PostBlockRateOverrideReasons(ctx context.Context) ChainConfigApiPostBlockRateOverrideReasonsRequest {
	return ChainConfigApiPostBlockRateOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostBlockRateOverrideReasonsExecute(r ChainConfigApiPostBlockRateOverrideReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostBlockRateOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRateOverrideReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockRateOverrideReasonsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostBlockRefusedReasonspostBloRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRefusedReasonsCriteria *PostBlockRefusedReasonspostBloRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) Authorization(authorization string) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) XAppKey(xAppKey string) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) XHotelid(xHotelid string) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Block Refused Reasons.
func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) BlockRefusedReasonsCriteria(blockRefusedReasonsCriteria PostBlockRefusedReasonspostBloRequest) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	r.blockRefusedReasonsCriteria = &blockRefusedReasonsCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostBlockRefusedReasonspostBloRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockRefusedReasonspostBloExecute(r)
}

/*
PostBlockRefusedReasonspostBlo Create Block Refused Reasons

Use this API to create Block Refused Reasons. <p><strong>OperationId:</strong>postBlockRefusedReasonspostBlo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostBlockRefusedReasonspostBloRequest
*/
func (a *ChainConfigApiService) PostBlockRefusedReasonspostBlo(ctx context.Context) ChainConfigApiPostBlockRefusedReasonspostBloRequest {
	return ChainConfigApiPostBlockRefusedReasonspostBloRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostBlockRefusedReasonspostBloExecute(r ChainConfigApiPostBlockRefusedReasonspostBloRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostBlockRefusedReasonspostBlo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRefusedReasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockRefusedReasonsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostDestinationCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	destinationCodesCriteria *PostDestinationCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostDestinationCodesRequest) Authorization(authorization string) ChainConfigApiPostDestinationCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPostDestinationCodesRequest) XAppKey(xAppKey string) ChainConfigApiPostDestinationCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostDestinationCodesRequest) XHotelid(xHotelid string) ChainConfigApiPostDestinationCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Destination Codes.
func (r ChainConfigApiPostDestinationCodesRequest) DestinationCodesCriteria(destinationCodesCriteria PostDestinationCodesRequest) ChainConfigApiPostDestinationCodesRequest {
	r.destinationCodesCriteria = &destinationCodesCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostDestinationCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostDestinationCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostDestinationCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostDestinationCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostDestinationCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDestinationCodesExecute(r)
}

/*
PostDestinationCodes Create Destination Codes

This API allows creation on Destination Codes. Destination Codes are used in OPERA Cloud during the block cancellation process, and they usually represent either a competitor hotel / chain, or a geographic destination that a specific block has been lost to.  <p><strong>OperationId:</strong>postDestinationCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostDestinationCodesRequest
*/
func (a *ChainConfigApiService) PostDestinationCodes(ctx context.Context) ChainConfigApiPostDestinationCodesRequest {
	return ChainConfigApiPostDestinationCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostDestinationCodesExecute(r ChainConfigApiPostDestinationCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostDestinationCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/destinationCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.destinationCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPostReservationMethodsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationMethodsCriteria *PostReservationMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPostReservationMethodsRequest) Authorization(authorization string) ChainConfigApiPostReservationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPostReservationMethodsRequest) XAppKey(xAppKey string) ChainConfigApiPostReservationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPostReservationMethodsRequest) XHotelid(xHotelid string) ChainConfigApiPostReservationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Reservation Methods.
func (r ChainConfigApiPostReservationMethodsRequest) ReservationMethodsCriteria(reservationMethodsCriteria PostReservationMethodsRequest) ChainConfigApiPostReservationMethodsRequest {
	r.reservationMethodsCriteria = &reservationMethodsCriteria
	return r
}

// External system code.
func (r ChainConfigApiPostReservationMethodsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPostReservationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPostReservationMethodsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPostReservationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPostReservationMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationMethodsExecute(r)
}

/*
PostReservationMethods Create Reservation Methods

Use this API to create Reservation Methods. <p><strong>OperationId:</strong>postReservationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigApiPostReservationMethodsRequest
*/
func (a *ChainConfigApiService) PostReservationMethods(ctx context.Context) ChainConfigApiPostReservationMethodsRequest {
	return ChainConfigApiPostReservationMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PostReservationMethodsExecute(r ChainConfigApiPostReservationMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PostReservationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservationMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationMethodsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutBlockCancellationReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockCancellationReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockCancellationReasonsToBeChanged *PutBlockCancellationReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutBlockCancellationReasonsRequest) Authorization(authorization string) ChainConfigApiPutBlockCancellationReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPutBlockCancellationReasonsRequest) XAppKey(xAppKey string) ChainConfigApiPutBlockCancellationReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutBlockCancellationReasonsRequest) XHotelid(xHotelid string) ChainConfigApiPutBlockCancellationReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Block Cancellation Reasons.
func (r ChainConfigApiPutBlockCancellationReasonsRequest) BlockCancellationReasonsToBeChanged(blockCancellationReasonsToBeChanged PutBlockCancellationReasonsRequest) ChainConfigApiPutBlockCancellationReasonsRequest {
	r.blockCancellationReasonsToBeChanged = &blockCancellationReasonsToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutBlockCancellationReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutBlockCancellationReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutBlockCancellationReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutBlockCancellationReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutBlockCancellationReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockCancellationReasonsExecute(r)
}

/*
PutBlockCancellationReasons Change Block Cancellation Reason

Use this API to update Block Cancellation Reason. <p><strong>OperationId:</strong>putBlockCancellationReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockCancellationReasonsId Unique ID of Block Cancellation Reasons.
 @return ChainConfigApiPutBlockCancellationReasonsRequest
*/
func (a *ChainConfigApiService) PutBlockCancellationReasons(ctx context.Context, blockCancellationReasonsId string) ChainConfigApiPutBlockCancellationReasonsRequest {
	return ChainConfigApiPutBlockCancellationReasonsRequest{
		ApiService: a,
		ctx: ctx,
		blockCancellationReasonsId: blockCancellationReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutBlockCancellationReasonsExecute(r ChainConfigApiPutBlockCancellationReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutBlockCancellationReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockCancellationReasons/{blockCancellationReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockCancellationReasonsId"+"}", url.PathEscape(parameterValueToString(r.blockCancellationReasonsId, "blockCancellationReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockCancellationReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("blockCancellationReasonsId must have at least 1 elements")
	}
	if strlen(r.blockCancellationReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("blockCancellationReasonsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockCancellationReasonsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutBlockLostBookingCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockLostBookingCodesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockLostBookingCodesToBeChanged *PutBlockLostBookingCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutBlockLostBookingCodesRequest) Authorization(authorization string) ChainConfigApiPutBlockLostBookingCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPutBlockLostBookingCodesRequest) XAppKey(xAppKey string) ChainConfigApiPutBlockLostBookingCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutBlockLostBookingCodesRequest) XHotelid(xHotelid string) ChainConfigApiPutBlockLostBookingCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Block Lost Booking Codes.
func (r ChainConfigApiPutBlockLostBookingCodesRequest) BlockLostBookingCodesToBeChanged(blockLostBookingCodesToBeChanged PutBlockLostBookingCodesRequest) ChainConfigApiPutBlockLostBookingCodesRequest {
	r.blockLostBookingCodesToBeChanged = &blockLostBookingCodesToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutBlockLostBookingCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutBlockLostBookingCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutBlockLostBookingCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutBlockLostBookingCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutBlockLostBookingCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockLostBookingCodesExecute(r)
}

/*
PutBlockLostBookingCodes Change Block Lost Booking Code

Use this API to update Block Lost Booking Code. <p><strong>OperationId:</strong>putBlockLostBookingCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockLostBookingCodesId Unique ID of Block Lost Booking Codes.
 @return ChainConfigApiPutBlockLostBookingCodesRequest
*/
func (a *ChainConfigApiService) PutBlockLostBookingCodes(ctx context.Context, blockLostBookingCodesId string) ChainConfigApiPutBlockLostBookingCodesRequest {
	return ChainConfigApiPutBlockLostBookingCodesRequest{
		ApiService: a,
		ctx: ctx,
		blockLostBookingCodesId: blockLostBookingCodesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutBlockLostBookingCodesExecute(r ChainConfigApiPutBlockLostBookingCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutBlockLostBookingCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockLostBookingCodes/{blockLostBookingCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockLostBookingCodesId"+"}", url.PathEscape(parameterValueToString(r.blockLostBookingCodesId, "blockLostBookingCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockLostBookingCodesId) < 1 {
		return localVarReturnValue, nil, reportError("blockLostBookingCodesId must have at least 1 elements")
	}
	if strlen(r.blockLostBookingCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("blockLostBookingCodesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockLostBookingCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutBlockRateOverrideReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockRateOverrideReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRateOverrideReasonsToBeChanged *PutBlockRateOverrideReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) Authorization(authorization string) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) XAppKey(xAppKey string) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) XHotelid(xHotelid string) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Block Rate Override Reasons.
func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) BlockRateOverrideReasonsToBeChanged(blockRateOverrideReasonsToBeChanged PutBlockRateOverrideReasonsRequest) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	r.blockRateOverrideReasonsToBeChanged = &blockRateOverrideReasonsToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutBlockRateOverrideReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockRateOverrideReasonsExecute(r)
}

/*
PutBlockRateOverrideReasons Change Block Rate Override Reason

Use this API to update Block Rate Override Reason. <p><strong>OperationId:</strong>putBlockRateOverrideReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockRateOverrideReasonsId Unique ID of Block Rate Override Reasons.
 @return ChainConfigApiPutBlockRateOverrideReasonsRequest
*/
func (a *ChainConfigApiService) PutBlockRateOverrideReasons(ctx context.Context, blockRateOverrideReasonsId string) ChainConfigApiPutBlockRateOverrideReasonsRequest {
	return ChainConfigApiPutBlockRateOverrideReasonsRequest{
		ApiService: a,
		ctx: ctx,
		blockRateOverrideReasonsId: blockRateOverrideReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutBlockRateOverrideReasonsExecute(r ChainConfigApiPutBlockRateOverrideReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutBlockRateOverrideReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRateOverrideReasons/{blockRateOverrideReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockRateOverrideReasonsId"+"}", url.PathEscape(parameterValueToString(r.blockRateOverrideReasonsId, "blockRateOverrideReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockRateOverrideReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("blockRateOverrideReasonsId must have at least 1 elements")
	}
	if strlen(r.blockRateOverrideReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("blockRateOverrideReasonsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockRateOverrideReasonsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutBlockRefusedReasonsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	blockRefusedReasonsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockRefusedReasonsToBeChanged *PutBlockRefusedReasonsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutBlockRefusedReasonsRequest) Authorization(authorization string) ChainConfigApiPutBlockRefusedReasonsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPutBlockRefusedReasonsRequest) XAppKey(xAppKey string) ChainConfigApiPutBlockRefusedReasonsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutBlockRefusedReasonsRequest) XHotelid(xHotelid string) ChainConfigApiPutBlockRefusedReasonsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Block Refused Reasons.
func (r ChainConfigApiPutBlockRefusedReasonsRequest) BlockRefusedReasonsToBeChanged(blockRefusedReasonsToBeChanged PutBlockRefusedReasonsRequest) ChainConfigApiPutBlockRefusedReasonsRequest {
	r.blockRefusedReasonsToBeChanged = &blockRefusedReasonsToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutBlockRefusedReasonsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutBlockRefusedReasonsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutBlockRefusedReasonsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutBlockRefusedReasonsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutBlockRefusedReasonsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockRefusedReasonsExecute(r)
}

/*
PutBlockRefusedReasons Change Block Refused Reason

Use this API to update Block Refused Reason. <p><strong>OperationId:</strong>putBlockRefusedReasons</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockRefusedReasonsId Unique ID of Block Refused Reasons.
 @return ChainConfigApiPutBlockRefusedReasonsRequest
*/
func (a *ChainConfigApiService) PutBlockRefusedReasons(ctx context.Context, blockRefusedReasonsId string) ChainConfigApiPutBlockRefusedReasonsRequest {
	return ChainConfigApiPutBlockRefusedReasonsRequest{
		ApiService: a,
		ctx: ctx,
		blockRefusedReasonsId: blockRefusedReasonsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutBlockRefusedReasonsExecute(r ChainConfigApiPutBlockRefusedReasonsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutBlockRefusedReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockRefusedReasons/{blockRefusedReasonsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockRefusedReasonsId"+"}", url.PathEscape(parameterValueToString(r.blockRefusedReasonsId, "blockRefusedReasonsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockRefusedReasonsId) < 1 {
		return localVarReturnValue, nil, reportError("blockRefusedReasonsId must have at least 1 elements")
	}
	if strlen(r.blockRefusedReasonsId) > 2000 {
		return localVarReturnValue, nil, reportError("blockRefusedReasonsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockRefusedReasonsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutDestinationCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	destinationCodesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	destinationCodesToBeChanged *PutDestinationCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutDestinationCodesRequest) Authorization(authorization string) ChainConfigApiPutDestinationCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPutDestinationCodesRequest) XAppKey(xAppKey string) ChainConfigApiPutDestinationCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutDestinationCodesRequest) XHotelid(xHotelid string) ChainConfigApiPutDestinationCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Destination Codes.
func (r ChainConfigApiPutDestinationCodesRequest) DestinationCodesToBeChanged(destinationCodesToBeChanged PutDestinationCodesRequest) ChainConfigApiPutDestinationCodesRequest {
	r.destinationCodesToBeChanged = &destinationCodesToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutDestinationCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutDestinationCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutDestinationCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutDestinationCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutDestinationCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutDestinationCodesExecute(r)
}

/*
PutDestinationCodes Change Destination Codes

Use this API to update Destination Codes. <p><strong>OperationId:</strong>putDestinationCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param destinationCodesId Unique ID of Destination Codes.
 @return ChainConfigApiPutDestinationCodesRequest
*/
func (a *ChainConfigApiService) PutDestinationCodes(ctx context.Context, destinationCodesId string) ChainConfigApiPutDestinationCodesRequest {
	return ChainConfigApiPutDestinationCodesRequest{
		ApiService: a,
		ctx: ctx,
		destinationCodesId: destinationCodesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutDestinationCodesExecute(r ChainConfigApiPutDestinationCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutDestinationCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/destinationCodes/{destinationCodesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"destinationCodesId"+"}", url.PathEscape(parameterValueToString(r.destinationCodesId, "destinationCodesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.destinationCodesId) < 1 {
		return localVarReturnValue, nil, reportError("destinationCodesId must have at least 1 elements")
	}
	if strlen(r.destinationCodesId) > 2000 {
		return localVarReturnValue, nil, reportError("destinationCodesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.destinationCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigApiPutReservationMethodsRequest struct {
	ctx context.Context
	ApiService *ChainConfigApiService
	reservationMethodsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationMethodsToBeChanged *PutReservationMethodsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigApiPutReservationMethodsRequest) Authorization(authorization string) ChainConfigApiPutReservationMethodsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigApiPutReservationMethodsRequest) XAppKey(xAppKey string) ChainConfigApiPutReservationMethodsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigApiPutReservationMethodsRequest) XHotelid(xHotelid string) ChainConfigApiPutReservationMethodsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Reservation Methods.
func (r ChainConfigApiPutReservationMethodsRequest) ReservationMethodsToBeChanged(reservationMethodsToBeChanged PutReservationMethodsRequest) ChainConfigApiPutReservationMethodsRequest {
	r.reservationMethodsToBeChanged = &reservationMethodsToBeChanged
	return r
}

// External system code.
func (r ChainConfigApiPutReservationMethodsRequest) XExternalsystem(xExternalsystem string) ChainConfigApiPutReservationMethodsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigApiPutReservationMethodsRequest) AcceptLanguage(acceptLanguage string) ChainConfigApiPutReservationMethodsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigApiPutReservationMethodsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutReservationMethodsExecute(r)
}

/*
PutReservationMethods Change Reservation Methods

Use this API to update Reservation Methods. <p><strong>OperationId:</strong>putReservationMethods</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationMethodsId Unique ID of Reservation Methods.
 @return ChainConfigApiPutReservationMethodsRequest
*/
func (a *ChainConfigApiService) PutReservationMethods(ctx context.Context, reservationMethodsId string) ChainConfigApiPutReservationMethodsRequest {
	return ChainConfigApiPutReservationMethodsRequest{
		ApiService: a,
		ctx: ctx,
		reservationMethodsId: reservationMethodsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigApiService) PutReservationMethodsExecute(r ChainConfigApiPutReservationMethodsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigApiService.PutReservationMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservationMethods/{reservationMethodsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationMethodsId"+"}", url.PathEscape(parameterValueToString(r.reservationMethodsId, "reservationMethodsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationMethodsId) < 1 {
		return localVarReturnValue, nil, reportError("reservationMethodsId must have at least 1 elements")
	}
	if strlen(r.reservationMethodsId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationMethodsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationMethodsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
