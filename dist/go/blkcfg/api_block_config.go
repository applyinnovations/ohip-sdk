/*
OPERA Cloud Block Configuration API

APIs for Block configuration, such as creating, updating, fetching and removing codes related to blocks. <br />< This might include fetching the block cancellation reasons, or creating new block refused reasons.  Wash schedules can be create, or new reservation methods could be added for a property.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blkcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BlockConfigApiService BlockConfigApi service
type BlockConfigApiService service

type BlockConfigApiDeleteBlockSalesAllowanceRangeRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	hotelId string
	endDate *string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	xExternalsystem *string
	acceptLanguage *string
}

// The ending value of the date range.
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) EndDate(endDate string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) StartDate(startDate string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Authorization(authorization string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) XAppKey(xAppKey string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) XHotelid(xHotelid string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Friday(friday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.friday = &friday
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Monday(monday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.monday = &monday
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Saturday(saturday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.saturday = &saturday
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Sunday(sunday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.sunday = &sunday
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Thursday(thursday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.thursday = &thursday
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Tuesday(tuesday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.tuesday = &tuesday
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Wednesday(wednesday bool) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.wednesday = &wednesday
	return r
}

// External system code.
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) XExternalsystem(xExternalsystem string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockSalesAllowanceRangeExecute(r)
}

/*
DeleteBlockSalesAllowanceRange Delete block sales allowance range

You can use this API to delete block sales allowance range. <p><strong>OperationId:</strong>deleteBlockSalesAllowanceRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return BlockConfigApiDeleteBlockSalesAllowanceRangeRequest
*/
func (a *BlockConfigApiService) DeleteBlockSalesAllowanceRange(ctx context.Context, hotelId string) BlockConfigApiDeleteBlockSalesAllowanceRangeRequest {
	return BlockConfigApiDeleteBlockSalesAllowanceRangeRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) DeleteBlockSalesAllowanceRangeExecute(r BlockConfigApiDeleteBlockSalesAllowanceRangeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.DeleteBlockSalesAllowanceRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blockSalesAllowanceRange"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiDeleteBlockStatusCodeRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	blockStatusCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiDeleteBlockStatusCodeRequest) Authorization(authorization string) BlockConfigApiDeleteBlockStatusCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiDeleteBlockStatusCodeRequest) XAppKey(xAppKey string) BlockConfigApiDeleteBlockStatusCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiDeleteBlockStatusCodeRequest) XHotelid(xHotelid string) BlockConfigApiDeleteBlockStatusCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockConfigApiDeleteBlockStatusCodeRequest) XExternalsystem(xExternalsystem string) BlockConfigApiDeleteBlockStatusCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiDeleteBlockStatusCodeRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiDeleteBlockStatusCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiDeleteBlockStatusCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBlockStatusCodeExecute(r)
}

/*
DeleteBlockStatusCode Delete block status code

You can use this API to delete block status code. <p><strong>OperationId:</strong>deleteBlockStatusCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockStatusCode OPERA Block status code
 @return BlockConfigApiDeleteBlockStatusCodeRequest
*/
func (a *BlockConfigApiService) DeleteBlockStatusCode(ctx context.Context, blockStatusCode string) BlockConfigApiDeleteBlockStatusCodeRequest {
	return BlockConfigApiDeleteBlockStatusCodeRequest{
		ApiService: a,
		ctx: ctx,
		blockStatusCode: blockStatusCode,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) DeleteBlockStatusCodeExecute(r BlockConfigApiDeleteBlockStatusCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.DeleteBlockStatusCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockStatusCodes/{blockStatusCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockStatusCode"+"}", url.PathEscape(parameterValueToString(r.blockStatusCode, "blockStatusCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockStatusCode) < 1 {
		return localVarReturnValue, nil, reportError("blockStatusCode must have at least 1 elements")
	}
	if strlen(r.blockStatusCode) > 2000 {
		return localVarReturnValue, nil, reportError("blockStatusCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiDeleteWashScheduleRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	washScheduleCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiDeleteWashScheduleRequest) Authorization(authorization string) BlockConfigApiDeleteWashScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiDeleteWashScheduleRequest) XAppKey(xAppKey string) BlockConfigApiDeleteWashScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiDeleteWashScheduleRequest) XHotelid(xHotelid string) BlockConfigApiDeleteWashScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockConfigApiDeleteWashScheduleRequest) XExternalsystem(xExternalsystem string) BlockConfigApiDeleteWashScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiDeleteWashScheduleRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiDeleteWashScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiDeleteWashScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteWashScheduleExecute(r)
}

/*
DeleteWashSchedule Delete block wash schedule

Delete a block wash schedule. <p><strong>OperationId:</strong>deleteWashSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param washScheduleCode Unique Block Wash Code
 @param hotelId Unique OPERA Hotel code
 @return BlockConfigApiDeleteWashScheduleRequest
*/
func (a *BlockConfigApiService) DeleteWashSchedule(ctx context.Context, washScheduleCode string, hotelId string) BlockConfigApiDeleteWashScheduleRequest {
	return BlockConfigApiDeleteWashScheduleRequest{
		ApiService: a,
		ctx: ctx,
		washScheduleCode: washScheduleCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) DeleteWashScheduleExecute(r BlockConfigApiDeleteWashScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.DeleteWashSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/washSchedules/{washScheduleCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"washScheduleCode"+"}", url.PathEscape(parameterValueToString(r.washScheduleCode, "washScheduleCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.washScheduleCode) < 1 {
		return localVarReturnValue, nil, reportError("washScheduleCode must have at least 1 elements")
	}
	if strlen(r.washScheduleCode) > 2000 {
		return localVarReturnValue, nil, reportError("washScheduleCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetBlockSalesAllowanceRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	endDateRange *string
	startDateRange *string
	includeRestricted *bool
	roomTypesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetBlockSalesAllowanceRequest) Authorization(authorization string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetBlockSalesAllowanceRequest) XAppKey(xAppKey string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetBlockSalesAllowanceRequest) XHotelid(xHotelid string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r BlockConfigApiGetBlockSalesAllowanceRequest) EndDateRange(endDateRange string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.endDateRange = &endDateRange
	return r
}

// The starting value of the date range.
func (r BlockConfigApiGetBlockSalesAllowanceRequest) StartDateRange(startDateRange string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.startDateRange = &startDateRange
	return r
}

// Indicate to include restricted room types.
func (r BlockConfigApiGetBlockSalesAllowanceRequest) IncludeRestricted(includeRestricted bool) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.includeRestricted = &includeRestricted
	return r
}

func (r BlockConfigApiGetBlockSalesAllowanceRequest) RoomTypesCodes(roomTypesCodes []string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.roomTypesCodes = &roomTypesCodes
	return r
}

// External system code.
func (r BlockConfigApiGetBlockSalesAllowanceRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetBlockSalesAllowanceRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetBlockSalesAllowanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetBlockSalesAllowanceRequest) Execute() (*BlockSalesAllowance, *http.Response, error) {
	return r.ApiService.GetBlockSalesAllowanceExecute(r)
}

/*
GetBlockSalesAllowance Get Block Sales Allowance

You can use this API to get Block Sales Allowance. <p><strong>OperationId:</strong>getBlockSalesAllowance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return BlockConfigApiGetBlockSalesAllowanceRequest
*/
func (a *BlockConfigApiService) GetBlockSalesAllowance(ctx context.Context, hotelId string) BlockConfigApiGetBlockSalesAllowanceRequest {
	return BlockConfigApiGetBlockSalesAllowanceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockSalesAllowance
func (a *BlockConfigApiService) GetBlockSalesAllowanceExecute(r BlockConfigApiGetBlockSalesAllowanceRequest) (*BlockSalesAllowance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockSalesAllowance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetBlockSalesAllowance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blockSalesAllowance"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.endDateRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateRange", r.endDateRange, "")
	}
	if r.startDateRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateRange", r.startDateRange, "")
	}
	if r.includeRestricted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRestricted", r.includeRestricted, "")
	}
	if r.roomTypesCodes != nil {
		t := *r.roomTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypesCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetBlockStatusCodesRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatusCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetBlockStatusCodesRequest) Authorization(authorization string) BlockConfigApiGetBlockStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetBlockStatusCodesRequest) XAppKey(xAppKey string) BlockConfigApiGetBlockStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetBlockStatusCodesRequest) XHotelid(xHotelid string) BlockConfigApiGetBlockStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockConfigApiGetBlockStatusCodesRequest) BlockStatusCodes(blockStatusCodes []string) BlockConfigApiGetBlockStatusCodesRequest {
	r.blockStatusCodes = &blockStatusCodes
	return r
}

// External system code.
func (r BlockConfigApiGetBlockStatusCodesRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetBlockStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetBlockStatusCodesRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetBlockStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetBlockStatusCodesRequest) Execute() (*StatusCodeDetails, *http.Response, error) {
	return r.ApiService.GetBlockStatusCodesExecute(r)
}

/*
GetBlockStatusCodes Get block status codes

This API fetches a list of configured status codes for the chain. It returns status code, description, and status type such as non-deduct, deduct, cancel, waitlist, inquiry, and actual. Status attributes, such as starting status, function diary visibility, allows pickup, and log catering changes are also returned in the response. Please note, that status codes are configured in a strict sequence that must be followed. In order to find available next statuses for the current block status, please use operation getNextBlockStatusCodes.Â <p><strong>OperationId:</strong>getBlockStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockConfigApiGetBlockStatusCodesRequest
*/
func (a *BlockConfigApiService) GetBlockStatusCodes(ctx context.Context) BlockConfigApiGetBlockStatusCodesRequest {
	return BlockConfigApiGetBlockStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StatusCodeDetails
func (a *BlockConfigApiService) GetBlockStatusCodesExecute(r BlockConfigApiGetBlockStatusCodesRequest) (*StatusCodeDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusCodeDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetBlockStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blockStatusCodes != nil {
		t := *r.blockStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetNextBlockStatusCodesRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	configuredOnly *bool
	blockStatusCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetNextBlockStatusCodesRequest) Authorization(authorization string) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetNextBlockStatusCodesRequest) XAppKey(xAppKey string) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetNextBlockStatusCodesRequest) XHotelid(xHotelid string) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// When set to true, only configured next status codes will be included (available status list will not be included).
func (r BlockConfigApiGetNextBlockStatusCodesRequest) ConfiguredOnly(configuredOnly bool) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.configuredOnly = &configuredOnly
	return r
}

func (r BlockConfigApiGetNextBlockStatusCodesRequest) BlockStatusCodes(blockStatusCodes []string) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.blockStatusCodes = &blockStatusCodes
	return r
}

// External system code.
func (r BlockConfigApiGetNextBlockStatusCodesRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetNextBlockStatusCodesRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetNextBlockStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetNextBlockStatusCodesRequest) Execute() (*NextBlockStatusCodeDetails, *http.Response, error) {
	return r.ApiService.GetNextBlockStatusCodesExecute(r)
}

/*
GetNextBlockStatusCodes Get next block status codes

Retrieve the next block Status Codes for a property. <p><strong>OperationId:</strong>getNextBlockStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockConfigApiGetNextBlockStatusCodesRequest
*/
func (a *BlockConfigApiService) GetNextBlockStatusCodes(ctx context.Context) BlockConfigApiGetNextBlockStatusCodesRequest {
	return BlockConfigApiGetNextBlockStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NextBlockStatusCodeDetails
func (a *BlockConfigApiService) GetNextBlockStatusCodesExecute(r BlockConfigApiGetNextBlockStatusCodesRequest) (*NextBlockStatusCodeDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NextBlockStatusCodeDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetNextBlockStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockStatusCodes/nextStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configuredOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configuredOnly", r.configuredOnly, "")
	}
	if r.blockStatusCodes != nil {
		t := *r.blockStatusCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blockStatusCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetSalesManagerGoalsRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	salesManagerId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	future *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetSalesManagerGoalsRequest) Authorization(authorization string) BlockConfigApiGetSalesManagerGoalsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetSalesManagerGoalsRequest) XAppKey(xAppKey string) BlockConfigApiGetSalesManagerGoalsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetSalesManagerGoalsRequest) XHotelid(xHotelid string) BlockConfigApiGetSalesManagerGoalsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockConfigApiGetSalesManagerGoalsRequest) Limit(limit int32) BlockConfigApiGetSalesManagerGoalsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockConfigApiGetSalesManagerGoalsRequest) Offset(offset int32) BlockConfigApiGetSalesManagerGoalsRequest {
	r.offset = &offset
	return r
}

// Use this indicator to fetch goal&#39;s having Production From or Arrival From dates later than the current business date or quarter
func (r BlockConfigApiGetSalesManagerGoalsRequest) Future(future bool) BlockConfigApiGetSalesManagerGoalsRequest {
	r.future = &future
	return r
}

// Fetch instructions that can be used to fetch details of particular Sales Manager type,ex: Group Room, Transient Room, Catering, Activity.
func (r BlockConfigApiGetSalesManagerGoalsRequest) FetchInstructions(fetchInstructions []string) BlockConfigApiGetSalesManagerGoalsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r BlockConfigApiGetSalesManagerGoalsRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetSalesManagerGoalsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetSalesManagerGoalsRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetSalesManagerGoalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetSalesManagerGoalsRequest) Execute() (*SalesManagerGoalsInfo, *http.Response, error) {
	return r.ApiService.GetSalesManagerGoalsExecute(r)
}

/*
GetSalesManagerGoals Get Sales Manager Goals by Hotel

You can use this API to retrieve individual Sales Manager Goals for a hotel, you can narrow the results using different search criteria. <p><strong>OperationId:</strong>getSalesManagerGoals</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesManagerId Sales Manager Id required to fetch Sales Manager goals information
 @param hotelId Unique OPERA Hotel Id
 @return BlockConfigApiGetSalesManagerGoalsRequest
*/
func (a *BlockConfigApiService) GetSalesManagerGoals(ctx context.Context, salesManagerId string, hotelId string) BlockConfigApiGetSalesManagerGoalsRequest {
	return BlockConfigApiGetSalesManagerGoalsRequest{
		ApiService: a,
		ctx: ctx,
		salesManagerId: salesManagerId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SalesManagerGoalsInfo
func (a *BlockConfigApiService) GetSalesManagerGoalsExecute(r BlockConfigApiGetSalesManagerGoalsRequest) (*SalesManagerGoalsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalesManagerGoalsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetSalesManagerGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/salesManagers/{salesManagerId}/salesManagerGoals"
	localVarPath = strings.Replace(localVarPath, "{"+"salesManagerId"+"}", url.PathEscape(parameterValueToString(r.salesManagerId, "salesManagerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesManagerId) < 1 {
		return localVarReturnValue, nil, reportError("salesManagerId must have at least 1 elements")
	}
	if strlen(r.salesManagerId) > 2000 {
		return localVarReturnValue, nil, reportError("salesManagerId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.future != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "future", r.future, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	salesManagerId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	future *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) Authorization(authorization string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) XAppKey(xAppKey string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) XHotelid(xHotelid string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) Limit(limit int32) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) Offset(offset int32) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.offset = &offset
	return r
}

func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) HotelIds(hotelIds []string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Use this indicator to fetch goal&#39;s having Production From or Arrival From dates later than the current business date or quarter
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) Future(future bool) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.future = &future
	return r
}

// Fetch instructions that can be used to fetch details of particular Sales Manager type,ex: Group Room, Transient Room, Catering, Activity.
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) FetchInstructions(fetchInstructions []string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) Execute() (*SalesManagerGoalsInfo, *http.Response, error) {
	return r.ApiService.GetSalesManagerGoalsMultipleHotelIdsExecute(r)
}

/*
GetSalesManagerGoalsMultipleHotelIds Get Sales Manager Goals

You can use this API to retrieve individual Sales Manager Goals, you can narrow the results using different search criteria. <p><strong>OperationId:</strong>getSalesManagerGoalsMultipleHotelIds</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesManagerId Sales Manager Id required to fetch Sales Manager goals information
 @return BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest
*/
func (a *BlockConfigApiService) GetSalesManagerGoalsMultipleHotelIds(ctx context.Context, salesManagerId string) BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest {
	return BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest{
		ApiService: a,
		ctx: ctx,
		salesManagerId: salesManagerId,
	}
}

// Execute executes the request
//  @return SalesManagerGoalsInfo
func (a *BlockConfigApiService) GetSalesManagerGoalsMultipleHotelIdsExecute(r BlockConfigApiGetSalesManagerGoalsMultipleHotelIdsRequest) (*SalesManagerGoalsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalesManagerGoalsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetSalesManagerGoalsMultipleHotelIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salesManagers/{salesManagerId}/salesManagerGoals"
	localVarPath = strings.Replace(localVarPath, "{"+"salesManagerId"+"}", url.PathEscape(parameterValueToString(r.salesManagerId, "salesManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesManagerId) < 1 {
		return localVarReturnValue, nil, reportError("salesManagerId must have at least 1 elements")
	}
	if strlen(r.salesManagerId) > 2000 {
		return localVarReturnValue, nil, reportError("salesManagerId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.future != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "future", r.future, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetSalesManagersRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	ownerCodes *[]string
	firstName *string
	lastName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetSalesManagersRequest) Authorization(authorization string) BlockConfigApiGetSalesManagersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetSalesManagersRequest) XAppKey(xAppKey string) BlockConfigApiGetSalesManagersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetSalesManagersRequest) XHotelid(xHotelid string) BlockConfigApiGetSalesManagersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockConfigApiGetSalesManagersRequest) Limit(limit int32) BlockConfigApiGetSalesManagersRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockConfigApiGetSalesManagersRequest) Offset(offset int32) BlockConfigApiGetSalesManagersRequest {
	r.offset = &offset
	return r
}

func (r BlockConfigApiGetSalesManagersRequest) OwnerCodes(ownerCodes []string) BlockConfigApiGetSalesManagersRequest {
	r.ownerCodes = &ownerCodes
	return r
}

// First name required to fetch Sales Manager information.
func (r BlockConfigApiGetSalesManagersRequest) FirstName(firstName string) BlockConfigApiGetSalesManagersRequest {
	r.firstName = &firstName
	return r
}

// Last name required to fetch Sales Manager information.
func (r BlockConfigApiGetSalesManagersRequest) LastName(lastName string) BlockConfigApiGetSalesManagersRequest {
	r.lastName = &lastName
	return r
}

// External system code.
func (r BlockConfigApiGetSalesManagersRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetSalesManagersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetSalesManagersRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetSalesManagersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetSalesManagersRequest) Execute() (*SalesManagersInfo, *http.Response, error) {
	return r.ApiService.GetSalesManagersExecute(r)
}

/*
GetSalesManagers Get Sales Managers by Hotel.

You can use this API to retrieve multiple Sales Managers for a hotel, you can narrow the results using different search criteria. <p><strong>OperationId:</strong>getSalesManagers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel Id
 @return BlockConfigApiGetSalesManagersRequest
*/
func (a *BlockConfigApiService) GetSalesManagers(ctx context.Context, hotelId string) BlockConfigApiGetSalesManagersRequest {
	return BlockConfigApiGetSalesManagersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SalesManagersInfo
func (a *BlockConfigApiService) GetSalesManagersExecute(r BlockConfigApiGetSalesManagersRequest) (*SalesManagersInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalesManagersInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetSalesManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/salesManagers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ownerCodes != nil {
		t := *r.ownerCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodes", t, "multi")
		}
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetSalesManagersMultipleHotelIdsRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	ownerCodes *[]string
	firstName *string
	lastName *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) HotelIds(hotelIds []string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) Authorization(authorization string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) XAppKey(xAppKey string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) XHotelid(xHotelid string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) Limit(limit int32) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) Offset(offset int32) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.offset = &offset
	return r
}

func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) OwnerCodes(ownerCodes []string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.ownerCodes = &ownerCodes
	return r
}

// First name required to fetch Sales Manager information.
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) FirstName(firstName string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.firstName = &firstName
	return r
}

// Last name required to fetch Sales Manager information.
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) LastName(lastName string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.lastName = &lastName
	return r
}

// External system code.
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) Execute() (*SalesManagersInfo, *http.Response, error) {
	return r.ApiService.GetSalesManagersMultipleHotelIdsExecute(r)
}

/*
GetSalesManagersMultipleHotelIds Get Sales Managers.

You can use this API to retrieve multiple Sales Managers, you can narrow the results using different search criteria. <p><strong>OperationId:</strong>getSalesManagersMultipleHotelIds</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockConfigApiGetSalesManagersMultipleHotelIdsRequest
*/
func (a *BlockConfigApiService) GetSalesManagersMultipleHotelIds(ctx context.Context) BlockConfigApiGetSalesManagersMultipleHotelIdsRequest {
	return BlockConfigApiGetSalesManagersMultipleHotelIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SalesManagersInfo
func (a *BlockConfigApiService) GetSalesManagersMultipleHotelIdsExecute(r BlockConfigApiGetSalesManagersMultipleHotelIdsRequest) (*SalesManagersInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalesManagersInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetSalesManagersMultipleHotelIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salesManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ownerCodes != nil {
		t := *r.ownerCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodes", t, "multi")
		}
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiGetWashScheduleRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	washCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiGetWashScheduleRequest) Authorization(authorization string) BlockConfigApiGetWashScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiGetWashScheduleRequest) XAppKey(xAppKey string) BlockConfigApiGetWashScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiGetWashScheduleRequest) XHotelid(xHotelid string) BlockConfigApiGetWashScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r BlockConfigApiGetWashScheduleRequest) HotelIds(hotelIds []string) BlockConfigApiGetWashScheduleRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r BlockConfigApiGetWashScheduleRequest) WashCodes(washCodes []string) BlockConfigApiGetWashScheduleRequest {
	r.washCodes = &washCodes
	return r
}

// Wildcard search on the code.
func (r BlockConfigApiGetWashScheduleRequest) WildCard(wildCard string) BlockConfigApiGetWashScheduleRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r BlockConfigApiGetWashScheduleRequest) XExternalsystem(xExternalsystem string) BlockConfigApiGetWashScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiGetWashScheduleRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiGetWashScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiGetWashScheduleRequest) Execute() (*WashScheduleDetails, *http.Response, error) {
	return r.ApiService.GetWashScheduleExecute(r)
}

/*
GetWashSchedule Get block wash schedule

Get block wash schedules. <p><strong>OperationId:</strong>getWashSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockConfigApiGetWashScheduleRequest
*/
func (a *BlockConfigApiService) GetWashSchedule(ctx context.Context) BlockConfigApiGetWashScheduleRequest {
	return BlockConfigApiGetWashScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WashScheduleDetails
func (a *BlockConfigApiService) GetWashScheduleExecute(r BlockConfigApiGetWashScheduleRequest) (*WashScheduleDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WashScheduleDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.GetWashSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/washSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.washCodes != nil {
		t := *r.washCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "washCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "washCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPostBlockStatusCodeRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatusCodeDetails *PostBlockStatusCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPostBlockStatusCodeRequest) Authorization(authorization string) BlockConfigApiPostBlockStatusCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPostBlockStatusCodeRequest) XAppKey(xAppKey string) BlockConfigApiPostBlockStatusCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPostBlockStatusCodeRequest) XHotelid(xHotelid string) BlockConfigApiPostBlockStatusCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a block status code.
func (r BlockConfigApiPostBlockStatusCodeRequest) BlockStatusCodeDetails(blockStatusCodeDetails PostBlockStatusCodeRequest) BlockConfigApiPostBlockStatusCodeRequest {
	r.blockStatusCodeDetails = &blockStatusCodeDetails
	return r
}

// External system code.
func (r BlockConfigApiPostBlockStatusCodeRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPostBlockStatusCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPostBlockStatusCodeRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPostBlockStatusCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPostBlockStatusCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBlockStatusCodeExecute(r)
}

/*
PostBlockStatusCode Create a block status code

You can use this API to create a new block status code. <p><strong>OperationId:</strong>postBlockStatusCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return BlockConfigApiPostBlockStatusCodeRequest
*/
func (a *BlockConfigApiService) PostBlockStatusCode(ctx context.Context) BlockConfigApiPostBlockStatusCodeRequest {
	return BlockConfigApiPostBlockStatusCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PostBlockStatusCodeExecute(r BlockConfigApiPostBlockStatusCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PostBlockStatusCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockStatusCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatusCodeDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPostSalesManagerGoalsRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	salesManagerId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createSalesManagerGoals *PostSalesManagerGoalsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPostSalesManagerGoalsRequest) Authorization(authorization string) BlockConfigApiPostSalesManagerGoalsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPostSalesManagerGoalsRequest) XAppKey(xAppKey string) BlockConfigApiPostSalesManagerGoalsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPostSalesManagerGoalsRequest) XHotelid(xHotelid string) BlockConfigApiPostSalesManagerGoalsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Creating Sales Manager Goal(s).
func (r BlockConfigApiPostSalesManagerGoalsRequest) CreateSalesManagerGoals(createSalesManagerGoals PostSalesManagerGoalsRequest) BlockConfigApiPostSalesManagerGoalsRequest {
	r.createSalesManagerGoals = &createSalesManagerGoals
	return r
}

// External system code.
func (r BlockConfigApiPostSalesManagerGoalsRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPostSalesManagerGoalsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPostSalesManagerGoalsRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPostSalesManagerGoalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPostSalesManagerGoalsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSalesManagerGoalsExecute(r)
}

/*
PostSalesManagerGoals Create Sales Manager Goals

Use this API to Create Sales Manager Goals for a Sales Manager ID.You must know the OPERA Sales Manager ID for this API. <p><strong>OperationId:</strong>postSalesManagerGoals</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesManagerId Sales Manager Id required to fetch Sales Manager goals information
 @param hotelId Unique OPERA Hotel Id
 @return BlockConfigApiPostSalesManagerGoalsRequest
*/
func (a *BlockConfigApiService) PostSalesManagerGoals(ctx context.Context, salesManagerId string, hotelId string) BlockConfigApiPostSalesManagerGoalsRequest {
	return BlockConfigApiPostSalesManagerGoalsRequest{
		ApiService: a,
		ctx: ctx,
		salesManagerId: salesManagerId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PostSalesManagerGoalsExecute(r BlockConfigApiPostSalesManagerGoalsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PostSalesManagerGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/salesManagers/{salesManagerId}/salesManagerGoals"
	localVarPath = strings.Replace(localVarPath, "{"+"salesManagerId"+"}", url.PathEscape(parameterValueToString(r.salesManagerId, "salesManagerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesManagerId) < 1 {
		return localVarReturnValue, nil, reportError("salesManagerId must have at least 1 elements")
	}
	if strlen(r.salesManagerId) > 2000 {
		return localVarReturnValue, nil, reportError("salesManagerId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createSalesManagerGoals
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPostWashScheduleRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	washScheduleCriteria *PostWashScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPostWashScheduleRequest) Authorization(authorization string) BlockConfigApiPostWashScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPostWashScheduleRequest) XAppKey(xAppKey string) BlockConfigApiPostWashScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPostWashScheduleRequest) XHotelid(xHotelid string) BlockConfigApiPostWashScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to create new Wash Schedule Configuration under the selected property.
func (r BlockConfigApiPostWashScheduleRequest) WashScheduleCriteria(washScheduleCriteria PostWashScheduleRequest) BlockConfigApiPostWashScheduleRequest {
	r.washScheduleCriteria = &washScheduleCriteria
	return r
}

// External system code.
func (r BlockConfigApiPostWashScheduleRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPostWashScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPostWashScheduleRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPostWashScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPostWashScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostWashScheduleExecute(r)
}

/*
PostWashSchedule Create block wash schedule

Create a block wash schedule. <p><strong>OperationId:</strong>postWashSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return BlockConfigApiPostWashScheduleRequest
*/
func (a *BlockConfigApiService) PostWashSchedule(ctx context.Context, hotelId string) BlockConfigApiPostWashScheduleRequest {
	return BlockConfigApiPostWashScheduleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PostWashScheduleExecute(r BlockConfigApiPostWashScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PostWashSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/washSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.washScheduleCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPutBlockStatusCodeRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	blockStatusCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockStatusCodeDetails *PostBlockStatusCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPutBlockStatusCodeRequest) Authorization(authorization string) BlockConfigApiPutBlockStatusCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPutBlockStatusCodeRequest) XAppKey(xAppKey string) BlockConfigApiPutBlockStatusCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPutBlockStatusCodeRequest) XHotelid(xHotelid string) BlockConfigApiPutBlockStatusCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating block status code.
func (r BlockConfigApiPutBlockStatusCodeRequest) BlockStatusCodeDetails(blockStatusCodeDetails PostBlockStatusCodeRequest) BlockConfigApiPutBlockStatusCodeRequest {
	r.blockStatusCodeDetails = &blockStatusCodeDetails
	return r
}

// External system code.
func (r BlockConfigApiPutBlockStatusCodeRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPutBlockStatusCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPutBlockStatusCodeRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPutBlockStatusCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPutBlockStatusCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBlockStatusCodeExecute(r)
}

/*
PutBlockStatusCode Change block status code

You can use this API to change block status code. <p><strong>OperationId:</strong>putBlockStatusCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockStatusCode OPERA Block status code
 @return BlockConfigApiPutBlockStatusCodeRequest
*/
func (a *BlockConfigApiService) PutBlockStatusCode(ctx context.Context, blockStatusCode string) BlockConfigApiPutBlockStatusCodeRequest {
	return BlockConfigApiPutBlockStatusCodeRequest{
		ApiService: a,
		ctx: ctx,
		blockStatusCode: blockStatusCode,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PutBlockStatusCodeExecute(r BlockConfigApiPutBlockStatusCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PutBlockStatusCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockStatusCodes/{blockStatusCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"blockStatusCode"+"}", url.PathEscape(parameterValueToString(r.blockStatusCode, "blockStatusCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.blockStatusCode) < 1 {
		return localVarReturnValue, nil, reportError("blockStatusCode must have at least 1 elements")
	}
	if strlen(r.blockStatusCode) > 2000 {
		return localVarReturnValue, nil, reportError("blockStatusCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockStatusCodeDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPutNextBlockStatusCodesRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	srcBlockStatusCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	nextBlockStatusCode *PutNextBlockStatusCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPutNextBlockStatusCodesRequest) Authorization(authorization string) BlockConfigApiPutNextBlockStatusCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPutNextBlockStatusCodesRequest) XAppKey(xAppKey string) BlockConfigApiPutNextBlockStatusCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPutNextBlockStatusCodesRequest) XHotelid(xHotelid string) BlockConfigApiPutNextBlockStatusCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change block status code flow. Batch insert/update/delete of next status code list of a particular status code.
func (r BlockConfigApiPutNextBlockStatusCodesRequest) NextBlockStatusCode(nextBlockStatusCode PutNextBlockStatusCodesRequest) BlockConfigApiPutNextBlockStatusCodesRequest {
	r.nextBlockStatusCode = &nextBlockStatusCode
	return r
}

// External system code.
func (r BlockConfigApiPutNextBlockStatusCodesRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPutNextBlockStatusCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPutNextBlockStatusCodesRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPutNextBlockStatusCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPutNextBlockStatusCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutNextBlockStatusCodesExecute(r)
}

/*
PutNextBlockStatusCodes Change next block status codes

Update the next Block status. <p><strong>OperationId:</strong>putNextBlockStatusCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param srcBlockStatusCode OPERA Block status code
 @return BlockConfigApiPutNextBlockStatusCodesRequest
*/
func (a *BlockConfigApiService) PutNextBlockStatusCodes(ctx context.Context, srcBlockStatusCode string) BlockConfigApiPutNextBlockStatusCodesRequest {
	return BlockConfigApiPutNextBlockStatusCodesRequest{
		ApiService: a,
		ctx: ctx,
		srcBlockStatusCode: srcBlockStatusCode,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PutNextBlockStatusCodesExecute(r BlockConfigApiPutNextBlockStatusCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PutNextBlockStatusCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blockStatusCodes/{srcBlockStatusCode}/nextStatusCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"srcBlockStatusCode"+"}", url.PathEscape(parameterValueToString(r.srcBlockStatusCode, "srcBlockStatusCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.srcBlockStatusCode) < 1 {
		return localVarReturnValue, nil, reportError("srcBlockStatusCode must have at least 1 elements")
	}
	if strlen(r.srcBlockStatusCode) > 2000 {
		return localVarReturnValue, nil, reportError("srcBlockStatusCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.nextBlockStatusCode
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPutSalesManagerGoalsRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	salesGoalId string
	salesManagerId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	salesManagerGoalsInfo *PutSalesManagerGoalsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPutSalesManagerGoalsRequest) Authorization(authorization string) BlockConfigApiPutSalesManagerGoalsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPutSalesManagerGoalsRequest) XAppKey(xAppKey string) BlockConfigApiPutSalesManagerGoalsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPutSalesManagerGoalsRequest) XHotelid(xHotelid string) BlockConfigApiPutSalesManagerGoalsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying Sales Manager&#39;s goal.
func (r BlockConfigApiPutSalesManagerGoalsRequest) SalesManagerGoalsInfo(salesManagerGoalsInfo PutSalesManagerGoalsRequest) BlockConfigApiPutSalesManagerGoalsRequest {
	r.salesManagerGoalsInfo = &salesManagerGoalsInfo
	return r
}

// External system code.
func (r BlockConfigApiPutSalesManagerGoalsRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPutSalesManagerGoalsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPutSalesManagerGoalsRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPutSalesManagerGoalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPutSalesManagerGoalsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutSalesManagerGoalsExecute(r)
}

/*
PutSalesManagerGoals Update Sales Manager Goal in a hotel by ID

Use this API to update Sales Manager Goal.You must know the OPERA Sales Manager ID and Goal ID for this API. <p><strong>OperationId:</strong>putSalesManagerGoals</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesGoalId Unique Sales Goal Id assigned to a Sales Manager.
 @param salesManagerId Sales Manager Id required to put Sales Manager goals information
 @param hotelId Unique OPERA Hotel Id
 @return BlockConfigApiPutSalesManagerGoalsRequest
*/
func (a *BlockConfigApiService) PutSalesManagerGoals(ctx context.Context, salesGoalId string, salesManagerId string, hotelId string) BlockConfigApiPutSalesManagerGoalsRequest {
	return BlockConfigApiPutSalesManagerGoalsRequest{
		ApiService: a,
		ctx: ctx,
		salesGoalId: salesGoalId,
		salesManagerId: salesManagerId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PutSalesManagerGoalsExecute(r BlockConfigApiPutSalesManagerGoalsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PutSalesManagerGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/salesManagers/{salesManagerId}/salesManagerGoals/{salesGoalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"salesGoalId"+"}", url.PathEscape(parameterValueToString(r.salesGoalId, "salesGoalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"salesManagerId"+"}", url.PathEscape(parameterValueToString(r.salesManagerId, "salesManagerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesGoalId) < 1 {
		return localVarReturnValue, nil, reportError("salesGoalId must have at least 1 elements")
	}
	if strlen(r.salesGoalId) > 2000 {
		return localVarReturnValue, nil, reportError("salesGoalId must have less than 2000 elements")
	}
	if strlen(r.salesManagerId) < 1 {
		return localVarReturnValue, nil, reportError("salesManagerId must have at least 1 elements")
	}
	if strlen(r.salesManagerId) > 2000 {
		return localVarReturnValue, nil, reportError("salesManagerId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.salesManagerGoalsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiPutWashScheduleRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	washScheduleCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	washScheduleCriteria *PostWashScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiPutWashScheduleRequest) Authorization(authorization string) BlockConfigApiPutWashScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiPutWashScheduleRequest) XAppKey(xAppKey string) BlockConfigApiPutWashScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiPutWashScheduleRequest) XHotelid(xHotelid string) BlockConfigApiPutWashScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to change existing Wash Schedule Configuration.
func (r BlockConfigApiPutWashScheduleRequest) WashScheduleCriteria(washScheduleCriteria PostWashScheduleRequest) BlockConfigApiPutWashScheduleRequest {
	r.washScheduleCriteria = &washScheduleCriteria
	return r
}

// External system code.
func (r BlockConfigApiPutWashScheduleRequest) XExternalsystem(xExternalsystem string) BlockConfigApiPutWashScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiPutWashScheduleRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiPutWashScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiPutWashScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutWashScheduleExecute(r)
}

/*
PutWashSchedule Change block wash schedule

Change a block wash schedule. <p><strong>OperationId:</strong>putWashSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param washScheduleCode Unique Block Wash Code
 @param hotelId Unique OPERA Hotel code
 @return BlockConfigApiPutWashScheduleRequest
*/
func (a *BlockConfigApiService) PutWashSchedule(ctx context.Context, washScheduleCode string, hotelId string) BlockConfigApiPutWashScheduleRequest {
	return BlockConfigApiPutWashScheduleRequest{
		ApiService: a,
		ctx: ctx,
		washScheduleCode: washScheduleCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) PutWashScheduleExecute(r BlockConfigApiPutWashScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.PutWashSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/washSchedules/{washScheduleCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"washScheduleCode"+"}", url.PathEscape(parameterValueToString(r.washScheduleCode, "washScheduleCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.washScheduleCode) < 1 {
		return localVarReturnValue, nil, reportError("washScheduleCode must have at least 1 elements")
	}
	if strlen(r.washScheduleCode) > 2000 {
		return localVarReturnValue, nil, reportError("washScheduleCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.washScheduleCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiRemoveSalesManagerGoalRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	salesGoalId string
	salesManagerId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiRemoveSalesManagerGoalRequest) Authorization(authorization string) BlockConfigApiRemoveSalesManagerGoalRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiRemoveSalesManagerGoalRequest) XAppKey(xAppKey string) BlockConfigApiRemoveSalesManagerGoalRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiRemoveSalesManagerGoalRequest) XHotelid(xHotelid string) BlockConfigApiRemoveSalesManagerGoalRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r BlockConfigApiRemoveSalesManagerGoalRequest) XExternalsystem(xExternalsystem string) BlockConfigApiRemoveSalesManagerGoalRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiRemoveSalesManagerGoalRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiRemoveSalesManagerGoalRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiRemoveSalesManagerGoalRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveSalesManagerGoalExecute(r)
}

/*
RemoveSalesManagerGoal Delete Sale Manager Goal

Use this API to delete Sales Manager Goal. <p><strong>OperationId:</strong>removeSalesManagerGoal</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesGoalId Unique Sales Goal Id assigned to a Sales Manager.
 @param salesManagerId Unique Sales Managers Id
 @return BlockConfigApiRemoveSalesManagerGoalRequest
*/
func (a *BlockConfigApiService) RemoveSalesManagerGoal(ctx context.Context, salesGoalId string, salesManagerId string) BlockConfigApiRemoveSalesManagerGoalRequest {
	return BlockConfigApiRemoveSalesManagerGoalRequest{
		ApiService: a,
		ctx: ctx,
		salesGoalId: salesGoalId,
		salesManagerId: salesManagerId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) RemoveSalesManagerGoalExecute(r BlockConfigApiRemoveSalesManagerGoalRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.RemoveSalesManagerGoal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salesManagers/{salesManagerId}/salesManagerGoals/{salesGoalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"salesGoalId"+"}", url.PathEscape(parameterValueToString(r.salesGoalId, "salesGoalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"salesManagerId"+"}", url.PathEscape(parameterValueToString(r.salesManagerId, "salesManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesGoalId) < 1 {
		return localVarReturnValue, nil, reportError("salesGoalId must have at least 1 elements")
	}
	if strlen(r.salesGoalId) > 2000 {
		return localVarReturnValue, nil, reportError("salesGoalId must have less than 2000 elements")
	}
	if strlen(r.salesManagerId) < 1 {
		return localVarReturnValue, nil, reportError("salesManagerId must have at least 1 elements")
	}
	if strlen(r.salesManagerId) > 2000 {
		return localVarReturnValue, nil, reportError("salesManagerId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiRemoveSalesManagerGoalsRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	salesManagerId string
	authorization *string
	xAppKey *string
	xHotelid *string
	salesGoalId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiRemoveSalesManagerGoalsRequest) Authorization(authorization string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiRemoveSalesManagerGoalsRequest) XAppKey(xAppKey string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiRemoveSalesManagerGoalsRequest) XHotelid(xHotelid string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r BlockConfigApiRemoveSalesManagerGoalsRequest) SalesGoalId(salesGoalId []string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	r.salesGoalId = &salesGoalId
	return r
}

// External system code.
func (r BlockConfigApiRemoveSalesManagerGoalsRequest) XExternalsystem(xExternalsystem string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiRemoveSalesManagerGoalsRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiRemoveSalesManagerGoalsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveSalesManagerGoalsExecute(r)
}

/*
RemoveSalesManagerGoals Delete Sale Manager Goals

Use this API to delete Sales Manager Goals. <p><strong>OperationId:</strong>removeSalesManagerGoals</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param salesManagerId Unique Sales Managers Id
 @return BlockConfigApiRemoveSalesManagerGoalsRequest
*/
func (a *BlockConfigApiService) RemoveSalesManagerGoals(ctx context.Context, salesManagerId string) BlockConfigApiRemoveSalesManagerGoalsRequest {
	return BlockConfigApiRemoveSalesManagerGoalsRequest{
		ApiService: a,
		ctx: ctx,
		salesManagerId: salesManagerId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) RemoveSalesManagerGoalsExecute(r BlockConfigApiRemoveSalesManagerGoalsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.RemoveSalesManagerGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salesManagers/{salesManagerId}/salesManagerGoals"
	localVarPath = strings.Replace(localVarPath, "{"+"salesManagerId"+"}", url.PathEscape(parameterValueToString(r.salesManagerId, "salesManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.salesManagerId) < 1 {
		return localVarReturnValue, nil, reportError("salesManagerId must have at least 1 elements")
	}
	if strlen(r.salesManagerId) > 2000 {
		return localVarReturnValue, nil, reportError("salesManagerId must have less than 2000 elements")
	}

	if r.salesGoalId != nil {
		t := *r.salesGoalId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "salesGoalId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "salesGoalId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type BlockConfigApiSetBlockSalesAllowanceRangeRequest struct {
	ctx context.Context
	ApiService *BlockConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	blockSalesAllowanceRange *SetBlockSalesAllowanceRangeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) Authorization(authorization string) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) XAppKey(xAppKey string) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) XHotelid(xHotelid string) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to a create block sales allowance with date range.
func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) BlockSalesAllowanceRange(blockSalesAllowanceRange SetBlockSalesAllowanceRangeRequest) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	r.blockSalesAllowanceRange = &blockSalesAllowanceRange
	return r
}

// External system code.
func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) XExternalsystem(xExternalsystem string) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) AcceptLanguage(acceptLanguage string) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r BlockConfigApiSetBlockSalesAllowanceRangeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetBlockSalesAllowanceRangeExecute(r)
}

/*
SetBlockSalesAllowanceRange Set block sales allowance range

You can use this API to set block sales allowance range. <p><strong>OperationId:</strong>setBlockSalesAllowanceRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return BlockConfigApiSetBlockSalesAllowanceRangeRequest
*/
func (a *BlockConfigApiService) SetBlockSalesAllowanceRange(ctx context.Context, hotelId string) BlockConfigApiSetBlockSalesAllowanceRangeRequest {
	return BlockConfigApiSetBlockSalesAllowanceRangeRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *BlockConfigApiService) SetBlockSalesAllowanceRangeExecute(r BlockConfigApiSetBlockSalesAllowanceRangeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockConfigApiService.SetBlockSalesAllowanceRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blockSalesAllowanceRange"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.blockSalesAllowanceRange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
