/*
OPERA Cloud Enterprise Configuration API

APIs to cater for Enterprise Configuration functionality in OPERA Cloud. <br /><br In this module, you can configure a variety of options related to your properties such as their locations, facilities, and local attractions. The available options are dependant on the active controls at your property.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package entcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigApiService HotelConfigApi service
type HotelConfigApiService service

type HotelConfigApiChangeAttractionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	attractionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attractionsToBeChanged *ChangeAttractionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeAttractionsRequest) Authorization(authorization string) HotelConfigApiChangeAttractionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeAttractionsRequest) XAppKey(xAppKey string) HotelConfigApiChangeAttractionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeAttractionsRequest) XHotelid(xHotelid string) HotelConfigApiChangeAttractionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing attraction.
func (r HotelConfigApiChangeAttractionsRequest) AttractionsToBeChanged(attractionsToBeChanged ChangeAttractionsRequest) HotelConfigApiChangeAttractionsRequest {
	r.attractionsToBeChanged = &attractionsToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeAttractionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeAttractionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeAttractionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeAttractionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeAttractionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeAttractionsExecute(r)
}

/*
ChangeAttractions Update an Attraction

This API is used to Use this API to update an existing attraction. . <p><strong>OperationId:</strong>changeAttractions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attractionCode Unique Code of attraction.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeAttractionsRequest
*/
func (a *HotelConfigApiService) ChangeAttractions(ctx context.Context, attractionCode string, hotelId string) HotelConfigApiChangeAttractionsRequest {
	return HotelConfigApiChangeAttractionsRequest{
		ApiService: a,
		ctx: ctx,
		attractionCode: attractionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeAttractionsExecute(r HotelConfigApiChangeAttractionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeAttractions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/attractions/{attractionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"attractionCode"+"}", url.PathEscape(parameterValueToString(r.attractionCode, "attractionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attractionCode) < 1 {
		return localVarReturnValue, nil, reportError("attractionCode must have at least 1 elements")
	}
	if strlen(r.attractionCode) > 2000 {
		return localVarReturnValue, nil, reportError("attractionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attractionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeCreditCardTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCardTypesToBeChanged *ChangeCreditCardTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeCreditCardTypesRequest) Authorization(authorization string) HotelConfigApiChangeCreditCardTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeCreditCardTypesRequest) XAppKey(xAppKey string) HotelConfigApiChangeCreditCardTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeCreditCardTypesRequest) XHotelid(xHotelid string) HotelConfigApiChangeCreditCardTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Credit Card Types.
func (r HotelConfigApiChangeCreditCardTypesRequest) CreditCardTypesToBeChanged(creditCardTypesToBeChanged ChangeCreditCardTypesRequest) HotelConfigApiChangeCreditCardTypesRequest {
	r.creditCardTypesToBeChanged = &creditCardTypesToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeCreditCardTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeCreditCardTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeCreditCardTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeCreditCardTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeCreditCardTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCreditCardTypesExecute(r)
}

/*
ChangeCreditCardTypes Change Credit Card Types

Use this API to update Credit Card Types. <p><strong>OperationId:</strong>changeCreditCardTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeCreditCardTypesRequest
*/
func (a *HotelConfigApiService) ChangeCreditCardTypes(ctx context.Context, hotelId string) HotelConfigApiChangeCreditCardTypesRequest {
	return HotelConfigApiChangeCreditCardTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeCreditCardTypesExecute(r HotelConfigApiChangeCreditCardTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeCreditCardTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditCardTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeDepartmentsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	departmentCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	departmentsToBeChanged *ChangeDepartmentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeDepartmentsRequest) Authorization(authorization string) HotelConfigApiChangeDepartmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeDepartmentsRequest) XAppKey(xAppKey string) HotelConfigApiChangeDepartmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeDepartmentsRequest) XHotelid(xHotelid string) HotelConfigApiChangeDepartmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating departments.
func (r HotelConfigApiChangeDepartmentsRequest) DepartmentsToBeChanged(departmentsToBeChanged ChangeDepartmentsRequest) HotelConfigApiChangeDepartmentsRequest {
	r.departmentsToBeChanged = &departmentsToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeDepartmentsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeDepartmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeDepartmentsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeDepartmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeDepartmentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeDepartmentsExecute(r)
}

/*
ChangeDepartments Change Departments

Use this API to update Departments. <p><strong>OperationId:</strong>changeDepartments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentCode Unique Code of department.
 @return HotelConfigApiChangeDepartmentsRequest
*/
func (a *HotelConfigApiService) ChangeDepartments(ctx context.Context, departmentCode string) HotelConfigApiChangeDepartmentsRequest {
	return HotelConfigApiChangeDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
		departmentCode: departmentCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeDepartmentsExecute(r HotelConfigApiChangeDepartmentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/departments/{departmentCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentCode"+"}", url.PathEscape(parameterValueToString(r.departmentCode, "departmentCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentCode) < 1 {
		return localVarReturnValue, nil, reportError("departmentCode must have at least 1 elements")
	}
	if strlen(r.departmentCode) > 2000 {
		return localVarReturnValue, nil, reportError("departmentCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.departmentsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeHotelContactsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	contactId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelContactsToBeChanged *ChangeHotelContactsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeHotelContactsRequest) Authorization(authorization string) HotelConfigApiChangeHotelContactsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeHotelContactsRequest) XAppKey(xAppKey string) HotelConfigApiChangeHotelContactsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeHotelContactsRequest) XHotelid(xHotelid string) HotelConfigApiChangeHotelContactsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing hotel Contacts for hotels.
func (r HotelConfigApiChangeHotelContactsRequest) HotelContactsToBeChanged(hotelContactsToBeChanged ChangeHotelContactsRequest) HotelConfigApiChangeHotelContactsRequest {
	r.hotelContactsToBeChanged = &hotelContactsToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeHotelContactsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeHotelContactsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeHotelContactsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeHotelContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeHotelContactsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeHotelContactsExecute(r)
}

/*
ChangeHotelContacts Change Hotel Contact

Use this API to update Hotel Contact. <p><strong>OperationId:</strong>changeHotelContacts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId Unique ID of contact.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeHotelContactsRequest
*/
func (a *HotelConfigApiService) ChangeHotelContacts(ctx context.Context, contactId string, hotelId string) HotelConfigApiChangeHotelContactsRequest {
	return HotelConfigApiChangeHotelContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeHotelContactsExecute(r HotelConfigApiChangeHotelContactsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeHotelContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/contacts/{contactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contactId"+"}", url.PathEscape(parameterValueToString(r.contactId, "contactId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contactId) < 1 {
		return localVarReturnValue, nil, reportError("contactId must have at least 1 elements")
	}
	if strlen(r.contactId) > 2000 {
		return localVarReturnValue, nil, reportError("contactId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelContactsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiChangeHotelNotesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	noteCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelNotesToBeChanged *ChangeHotelNotesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiChangeHotelNotesRequest) Authorization(authorization string) HotelConfigApiChangeHotelNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiChangeHotelNotesRequest) XAppKey(xAppKey string) HotelConfigApiChangeHotelNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiChangeHotelNotesRequest) XHotelid(xHotelid string) HotelConfigApiChangeHotelNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing hotel Notes for hotels.
func (r HotelConfigApiChangeHotelNotesRequest) HotelNotesToBeChanged(hotelNotesToBeChanged ChangeHotelNotesRequest) HotelConfigApiChangeHotelNotesRequest {
	r.hotelNotesToBeChanged = &hotelNotesToBeChanged
	return r
}

// External system code.
func (r HotelConfigApiChangeHotelNotesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiChangeHotelNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiChangeHotelNotesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiChangeHotelNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiChangeHotelNotesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeHotelNotesExecute(r)
}

/*
ChangeHotelNotes Update Note information

Update Note information. <p><strong>OperationId:</strong>changeHotelNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param noteCode Unique Code of note.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiChangeHotelNotesRequest
*/
func (a *HotelConfigApiService) ChangeHotelNotes(ctx context.Context, noteCode string, hotelId string) HotelConfigApiChangeHotelNotesRequest {
	return HotelConfigApiChangeHotelNotesRequest{
		ApiService: a,
		ctx: ctx,
		noteCode: noteCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) ChangeHotelNotesExecute(r HotelConfigApiChangeHotelNotesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.ChangeHotelNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/notes/{noteCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"noteCode"+"}", url.PathEscape(parameterValueToString(r.noteCode, "noteCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.noteCode) < 1 {
		return localVarReturnValue, nil, reportError("noteCode must have at least 1 elements")
	}
	if strlen(r.noteCode) > 2000 {
		return localVarReturnValue, nil, reportError("noteCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelNotesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiCopyDepartmentsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyDepartments *CopyDepartmentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiCopyDepartmentsRequest) Authorization(authorization string) HotelConfigApiCopyDepartmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiCopyDepartmentsRequest) XAppKey(xAppKey string) HotelConfigApiCopyDepartmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiCopyDepartmentsRequest) XHotelid(xHotelid string) HotelConfigApiCopyDepartmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the departments to be copied.
func (r HotelConfigApiCopyDepartmentsRequest) CopyDepartments(copyDepartments CopyDepartmentsRequest) HotelConfigApiCopyDepartmentsRequest {
	r.copyDepartments = &copyDepartments
	return r
}

// External system code.
func (r HotelConfigApiCopyDepartmentsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiCopyDepartmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiCopyDepartmentsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiCopyDepartmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiCopyDepartmentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyDepartmentsExecute(r)
}

/*
CopyDepartments  copy Departments

Copy Departments. <p><strong>OperationId:</strong>copyDepartments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return HotelConfigApiCopyDepartmentsRequest
*/
func (a *HotelConfigApiService) CopyDepartments(ctx context.Context, sourceHotelId string) HotelConfigApiCopyDepartmentsRequest {
	return HotelConfigApiCopyDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) CopyDepartmentsExecute(r HotelConfigApiCopyDepartmentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.CopyDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/departments/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyDepartments
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetAirportsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	airportCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetAirportsRequest) Authorization(authorization string) HotelConfigApiGetAirportsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetAirportsRequest) XAppKey(xAppKey string) HotelConfigApiGetAirportsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetAirportsRequest) XHotelid(xHotelid string) HotelConfigApiGetAirportsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetAirportsRequest) Limit(limit int32) HotelConfigApiGetAirportsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetAirportsRequest) PageNumber(pageNumber int32) HotelConfigApiGetAirportsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Airport code identifying the airport.
func (r HotelConfigApiGetAirportsRequest) AirportCodes(airportCodes []string) HotelConfigApiGetAirportsRequest {
	r.airportCodes = &airportCodes
	return r
}

// External system code.
func (r HotelConfigApiGetAirportsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetAirportsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetAirportsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetAirportsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetAirportsRequest) Execute() (*AirportsDetails, *http.Response, error) {
	return r.ApiService.GetAirportsExecute(r)
}

/*
GetAirports Get resort airports

Use this API to get resort airports. <p><strong>OperationId:</strong>getAirports</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetAirportsRequest
*/
func (a *HotelConfigApiService) GetAirports(ctx context.Context, hotelId string) HotelConfigApiGetAirportsRequest {
	return HotelConfigApiGetAirportsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AirportsDetails
func (a *HotelConfigApiService) GetAirportsExecute(r HotelConfigApiGetAirportsRequest) (*AirportsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AirportsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetAirports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/airports"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	if r.airportCodes != nil {
		t := *r.airportCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "airportCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "airportCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetAmenitiesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	general *bool
	meeting *bool
	amenityCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetAmenitiesRequest) Authorization(authorization string) HotelConfigApiGetAmenitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetAmenitiesRequest) XAppKey(xAppKey string) HotelConfigApiGetAmenitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetAmenitiesRequest) XHotelid(xHotelid string) HotelConfigApiGetAmenitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Is it a General amenity type.
func (r HotelConfigApiGetAmenitiesRequest) General(general bool) HotelConfigApiGetAmenitiesRequest {
	r.general = &general
	return r
}

// Is it a Meeting amenity type.
func (r HotelConfigApiGetAmenitiesRequest) Meeting(meeting bool) HotelConfigApiGetAmenitiesRequest {
	r.meeting = &meeting
	return r
}

func (r HotelConfigApiGetAmenitiesRequest) AmenityCodes(amenityCodes []string) HotelConfigApiGetAmenitiesRequest {
	r.amenityCodes = &amenityCodes
	return r
}

// External system code.
func (r HotelConfigApiGetAmenitiesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetAmenitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetAmenitiesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetAmenitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetAmenitiesRequest) Execute() (*AmenitiesDetails, *http.Response, error) {
	return r.ApiService.GetAmenitiesExecute(r)
}

/*
GetAmenities Get amenities

Use this API to get amenities. <p><strong>OperationId:</strong>getAmenities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetAmenitiesRequest
*/
func (a *HotelConfigApiService) GetAmenities(ctx context.Context, hotelId string) HotelConfigApiGetAmenitiesRequest {
	return HotelConfigApiGetAmenitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AmenitiesDetails
func (a *HotelConfigApiService) GetAmenitiesExecute(r HotelConfigApiGetAmenitiesRequest) (*AmenitiesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AmenitiesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetAmenities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/amenities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.general != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "general", r.general, "")
	}
	if r.meeting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meeting", r.meeting, "")
	}
	if r.amenityCodes != nil {
		t := *r.amenityCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amenityCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amenityCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetAttractionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attractionCodes *[]string
	wildCard *string
	classCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetAttractionsRequest) Authorization(authorization string) HotelConfigApiGetAttractionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetAttractionsRequest) XAppKey(xAppKey string) HotelConfigApiGetAttractionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetAttractionsRequest) XHotelid(xHotelid string) HotelConfigApiGetAttractionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetAttractionsRequest) AttractionCodes(attractionCodes []string) HotelConfigApiGetAttractionsRequest {
	r.attractionCodes = &attractionCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetAttractionsRequest) WildCard(wildCard string) HotelConfigApiGetAttractionsRequest {
	r.wildCard = &wildCard
	return r
}

func (r HotelConfigApiGetAttractionsRequest) ClassCodes(classCodes []string) HotelConfigApiGetAttractionsRequest {
	r.classCodes = &classCodes
	return r
}

// External system code.
func (r HotelConfigApiGetAttractionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetAttractionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetAttractionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetAttractionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetAttractionsRequest) Execute() (*AttractionsDetails, *http.Response, error) {
	return r.ApiService.GetAttractionsExecute(r)
}

/*
GetAttractions Get Attractions

Use this API to get Attractions. <p><strong>OperationId:</strong>getAttractions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetAttractionsRequest
*/
func (a *HotelConfigApiService) GetAttractions(ctx context.Context, hotelId string) HotelConfigApiGetAttractionsRequest {
	return HotelConfigApiGetAttractionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AttractionsDetails
func (a *HotelConfigApiService) GetAttractionsExecute(r HotelConfigApiGetAttractionsRequest) (*AttractionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttractionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetAttractions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/attractions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.attractionCodes != nil {
		t := *r.attractionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attractionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attractionCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.classCodes != nil {
		t := *r.classCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetCountriesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	countriesCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetCountriesRequest) Authorization(authorization string) HotelConfigApiGetCountriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetCountriesRequest) XAppKey(xAppKey string) HotelConfigApiGetCountriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetCountriesRequest) XHotelid(xHotelid string) HotelConfigApiGetCountriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetCountriesRequest) Limit(limit int32) HotelConfigApiGetCountriesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetCountriesRequest) PageNumber(pageNumber int32) HotelConfigApiGetCountriesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetCountriesRequest) CountriesCodes(countriesCodes []string) HotelConfigApiGetCountriesRequest {
	r.countriesCodes = &countriesCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetCountriesRequest) WildCard(wildCard string) HotelConfigApiGetCountriesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r HotelConfigApiGetCountriesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetCountriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetCountriesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetCountriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetCountriesRequest) Execute() (*CountriesDetails, *http.Response, error) {
	return r.ApiService.GetCountriesExecute(r)
}

/*
GetCountries Get Countries

Use this API to get Countries. <p><strong>OperationId:</strong>getCountries</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetCountriesRequest
*/
func (a *HotelConfigApiService) GetCountries(ctx context.Context, hotelId string) HotelConfigApiGetCountriesRequest {
	return HotelConfigApiGetCountriesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CountriesDetails
func (a *HotelConfigApiService) GetCountriesExecute(r HotelConfigApiGetCountriesRequest) (*CountriesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountriesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/countries"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	if r.countriesCodes != nil {
		t := *r.countriesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countriesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countriesCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetCreditCardTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetCreditCardTypesRequest) Authorization(authorization string) HotelConfigApiGetCreditCardTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetCreditCardTypesRequest) XAppKey(xAppKey string) HotelConfigApiGetCreditCardTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetCreditCardTypesRequest) XHotelid(xHotelid string) HotelConfigApiGetCreditCardTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r HotelConfigApiGetCreditCardTypesRequest) FetchInactive(fetchInactive bool) HotelConfigApiGetCreditCardTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetCreditCardTypesRequest) Codes(codes []string) HotelConfigApiGetCreditCardTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetCreditCardTypesRequest) WildCard(wildCard string) HotelConfigApiGetCreditCardTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r HotelConfigApiGetCreditCardTypesRequest) Description(description string) HotelConfigApiGetCreditCardTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r HotelConfigApiGetCreditCardTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetCreditCardTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetCreditCardTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetCreditCardTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetCreditCardTypesRequest) Execute() (*CreditCardTypesDetails, *http.Response, error) {
	return r.ApiService.GetCreditCardTypesExecute(r)
}

/*
GetCreditCardTypes Get Credit Card Types

Use this API to get Credit Card Types. <p><strong>OperationId:</strong>getCreditCardTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetCreditCardTypesRequest
*/
func (a *HotelConfigApiService) GetCreditCardTypes(ctx context.Context, hotelId string) HotelConfigApiGetCreditCardTypesRequest {
	return HotelConfigApiGetCreditCardTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreditCardTypesDetails
func (a *HotelConfigApiService) GetCreditCardTypesExecute(r HotelConfigApiGetCreditCardTypesRequest) (*CreditCardTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditCardTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetCreditCardTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetCurrencyExchangeRatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	exchangeType *string
	hotelIds *[]string
	currencyCode *string
	currencyCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) Authorization(authorization string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) XAppKey(xAppKey string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) XHotelid(xHotelid string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Exchange Rate Types
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) ExchangeType(exchangeType string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.exchangeType = &exchangeType
	return r
}

// List of Hotels for which the currency exchange rate information is required.
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) HotelIds(hotelIds []string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Currency Code for which the exchange rate is requested. Sending no currency code will return values for all available currency codes.
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) CurrencyCode(currencyCode string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.currencyCode = &currencyCode
	return r
}

func (r HotelConfigApiGetCurrencyExchangeRatesRequest) CurrencyCodes(currencyCodes []string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.currencyCodes = &currencyCodes
	return r
}

// External system code.
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetCurrencyExchangeRatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetCurrencyExchangeRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetCurrencyExchangeRatesRequest) Execute() (*CurrencyExchangeRatesDetails, *http.Response, error) {
	return r.ApiService.GetCurrencyExchangeRatesExecute(r)
}

/*
GetCurrencyExchangeRates Get Currency Exchange Rates

Fetch the currency exchange rates when using this API. <p><strong>OperationId:</strong>getCurrencyExchangeRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetCurrencyExchangeRatesRequest
*/
func (a *HotelConfigApiService) GetCurrencyExchangeRates(ctx context.Context) HotelConfigApiGetCurrencyExchangeRatesRequest {
	return HotelConfigApiGetCurrencyExchangeRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrencyExchangeRatesDetails
func (a *HotelConfigApiService) GetCurrencyExchangeRatesExecute(r HotelConfigApiGetCurrencyExchangeRatesRequest) (*CurrencyExchangeRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrencyExchangeRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetCurrencyExchangeRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencyExchangeRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exchangeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeType", r.exchangeType, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
	}
	if r.currencyCodes != nil {
		t := *r.currencyCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetDepartmentsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	departmentCodes *[]string
	departmentWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetDepartmentsRequest) Authorization(authorization string) HotelConfigApiGetDepartmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetDepartmentsRequest) XAppKey(xAppKey string) HotelConfigApiGetDepartmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetDepartmentsRequest) XHotelid(xHotelid string) HotelConfigApiGetDepartmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetDepartmentsRequest) HotelIds(hotelIds []string) HotelConfigApiGetDepartmentsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetDepartmentsRequest) DepartmentCodes(departmentCodes []string) HotelConfigApiGetDepartmentsRequest {
	r.departmentCodes = &departmentCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetDepartmentsRequest) DepartmentWildCard(departmentWildCard string) HotelConfigApiGetDepartmentsRequest {
	r.departmentWildCard = &departmentWildCard
	return r
}

// External system code.
func (r HotelConfigApiGetDepartmentsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetDepartmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetDepartmentsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetDepartmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetDepartmentsRequest) Execute() (*DepartmentsDetails, *http.Response, error) {
	return r.ApiService.GetDepartmentsExecute(r)
}

/*
GetDepartments Get Departments

Use this API to get Departments. <p><strong>OperationId:</strong>getDepartments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetDepartmentsRequest
*/
func (a *HotelConfigApiService) GetDepartments(ctx context.Context) HotelConfigApiGetDepartmentsRequest {
	return HotelConfigApiGetDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DepartmentsDetails
func (a *HotelConfigApiService) GetDepartmentsExecute(r HotelConfigApiGetDepartmentsRequest) (*DepartmentsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepartmentsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/departments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.departmentCodes != nil {
		t := *r.departmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCodes", t, "multi")
		}
	}
	if r.departmentWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departmentWildCard", r.departmentWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetHotelRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetHotelRequest) Authorization(authorization string) HotelConfigApiGetHotelRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetHotelRequest) XAppKey(xAppKey string) HotelConfigApiGetHotelRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetHotelRequest) XHotelid(xHotelid string) HotelConfigApiGetHotelRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for hotel fetch instruction.
func (r HotelConfigApiGetHotelRequest) FetchInstructions(fetchInstructions []string) HotelConfigApiGetHotelRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r HotelConfigApiGetHotelRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetHotelRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetHotelRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetHotelRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetHotelRequest) Execute() (*HotelDetails, *http.Response, error) {
	return r.ApiService.GetHotelExecute(r)
}

/*
GetHotel Get hotel property configuration details

Use this API to return hotel configuration information details for a specific property.  Specific areas of configuration can be returned based on the fetchInstructions query parameter such as General, Attraction, Airports, Alternatehotels, Raterange, etc.<p><strong>OperationId:</strong>getHotel</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetHotelRequest
*/
func (a *HotelConfigApiService) GetHotel(ctx context.Context, hotelId string) HotelConfigApiGetHotelRequest {
	return HotelConfigApiGetHotelRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelDetails
func (a *HotelConfigApiService) GetHotelExecute(r HotelConfigApiGetHotelRequest) (*HotelDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetHotel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetHotelDetailsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelDetailCodes *[]string
	hotelDetailCategoriesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetHotelDetailsRequest) Authorization(authorization string) HotelConfigApiGetHotelDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetHotelDetailsRequest) XAppKey(xAppKey string) HotelConfigApiGetHotelDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetHotelDetailsRequest) XHotelid(xHotelid string) HotelConfigApiGetHotelDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetHotelDetailsRequest) HotelDetailCodes(hotelDetailCodes []string) HotelConfigApiGetHotelDetailsRequest {
	r.hotelDetailCodes = &hotelDetailCodes
	return r
}

func (r HotelConfigApiGetHotelDetailsRequest) HotelDetailCategoriesCodes(hotelDetailCategoriesCodes []string) HotelConfigApiGetHotelDetailsRequest {
	r.hotelDetailCategoriesCodes = &hotelDetailCategoriesCodes
	return r
}

// External system code.
func (r HotelConfigApiGetHotelDetailsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetHotelDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetHotelDetailsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetHotelDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetHotelDetailsRequest) Execute() (*HotelDetailsDetails, *http.Response, error) {
	return r.ApiService.GetHotelDetailsExecute(r)
}

/*
GetHotelDetails Get hotel details 

Use this API to get hotel details. <p><strong>OperationId:</strong>getHotelDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetHotelDetailsRequest
*/
func (a *HotelConfigApiService) GetHotelDetails(ctx context.Context, hotelId string) HotelConfigApiGetHotelDetailsRequest {
	return HotelConfigApiGetHotelDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelDetailsDetails
func (a *HotelConfigApiService) GetHotelDetailsExecute(r HotelConfigApiGetHotelDetailsRequest) (*HotelDetailsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelDetailsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetHotelDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/hotelDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelDetailCodes != nil {
		t := *r.hotelDetailCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelDetailCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelDetailCodes", t, "multi")
		}
	}
	if r.hotelDetailCategoriesCodes != nil {
		t := *r.hotelDetailCategoriesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelDetailCategoriesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelDetailCategoriesCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetLanguagesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	languageCodes *[]string
	description *string
	useAsAlternateLanguage *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetLanguagesRequest) Authorization(authorization string) HotelConfigApiGetLanguagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetLanguagesRequest) XAppKey(xAppKey string) HotelConfigApiGetLanguagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetLanguagesRequest) XHotelid(xHotelid string) HotelConfigApiGetLanguagesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetLanguagesRequest) LanguageCodes(languageCodes []string) HotelConfigApiGetLanguagesRequest {
	r.languageCodes = &languageCodes
	return r
}

// Language description to be searched.
func (r HotelConfigApiGetLanguagesRequest) Description(description string) HotelConfigApiGetLanguagesRequest {
	r.description = &description
	return r
}

// This is a placeholder element for future use. Functionality may not be available for the current implementation.
func (r HotelConfigApiGetLanguagesRequest) UseAsAlternateLanguage(useAsAlternateLanguage bool) HotelConfigApiGetLanguagesRequest {
	r.useAsAlternateLanguage = &useAsAlternateLanguage
	return r
}

// External system code.
func (r HotelConfigApiGetLanguagesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetLanguagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetLanguagesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetLanguagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetLanguagesRequest) Execute() (*LanguagesDetails, *http.Response, error) {
	return r.ApiService.GetLanguagesExecute(r)
}

/*
GetLanguages Get Languages

Use this API to get Languages. <p><strong>OperationId:</strong>getLanguages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetLanguagesRequest
*/
func (a *HotelConfigApiService) GetLanguages(ctx context.Context) HotelConfigApiGetLanguagesRequest {
	return HotelConfigApiGetLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LanguagesDetails
func (a *HotelConfigApiService) GetLanguagesExecute(r HotelConfigApiGetLanguagesRequest) (*LanguagesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LanguagesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.languageCodes != nil {
		t := *r.languageCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "languageCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "languageCodes", t, "multi")
		}
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.useAsAlternateLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useAsAlternateLanguage", r.useAsAlternateLanguage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetOperaSettingsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	cROCode *string
	parameterNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetOperaSettingsRequest) Authorization(authorization string) HotelConfigApiGetOperaSettingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetOperaSettingsRequest) XAppKey(xAppKey string) HotelConfigApiGetOperaSettingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetOperaSettingsRequest) XHotelid(xHotelid string) HotelConfigApiGetOperaSettingsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetOperaSettingsRequest) HotelId(hotelId string) HotelConfigApiGetOperaSettingsRequest {
	r.hotelId = &hotelId
	return r
}

func (r HotelConfigApiGetOperaSettingsRequest) CROCode(cROCode string) HotelConfigApiGetOperaSettingsRequest {
	r.cROCode = &cROCode
	return r
}

func (r HotelConfigApiGetOperaSettingsRequest) ParameterNameWildCard(parameterNameWildCard string) HotelConfigApiGetOperaSettingsRequest {
	r.parameterNameWildCard = &parameterNameWildCard
	return r
}

// External system code.
func (r HotelConfigApiGetOperaSettingsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetOperaSettingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetOperaSettingsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetOperaSettingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetOperaSettingsRequest) Execute() (*OperaSettingsDetails, *http.Response, error) {
	return r.ApiService.GetOperaSettingsExecute(r)
}

/*
GetOperaSettings Get OPERA controls

Use this API to return OPERA controls based on search criteria such as hotelId, cROCode, parameterNameWildCard.<p><strong>OperationId:</strong>getOperaSettings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetOperaSettingsRequest
*/
func (a *HotelConfigApiService) GetOperaSettings(ctx context.Context) HotelConfigApiGetOperaSettingsRequest {
	return HotelConfigApiGetOperaSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaSettingsDetails
func (a *HotelConfigApiService) GetOperaSettingsExecute(r HotelConfigApiGetOperaSettingsRequest) (*OperaSettingsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaSettingsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetOperaSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.cROCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cROCode", r.cROCode, "")
	}
	if r.parameterNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parameterNameWildCard", r.parameterNameWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetTemplateJobTitlesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	jobTitleCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetTemplateJobTitlesRequest) Authorization(authorization string) HotelConfigApiGetTemplateJobTitlesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetTemplateJobTitlesRequest) XAppKey(xAppKey string) HotelConfigApiGetTemplateJobTitlesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetTemplateJobTitlesRequest) XHotelid(xHotelid string) HotelConfigApiGetTemplateJobTitlesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigApiGetTemplateJobTitlesRequest) JobTitleCodes(jobTitleCodes []string) HotelConfigApiGetTemplateJobTitlesRequest {
	r.jobTitleCodes = &jobTitleCodes
	return r
}

// External system code.
func (r HotelConfigApiGetTemplateJobTitlesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetTemplateJobTitlesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetTemplateJobTitlesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetTemplateJobTitlesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetTemplateJobTitlesRequest) Execute() (*TemplateJobTitlesDetails, *http.Response, error) {
	return r.ApiService.GetTemplateJobTitlesExecute(r)
}

/*
GetTemplateJobTitles Get template job titles

Use this API to get template job titles. <p><strong>OperationId:</strong>getTemplateJobTitles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetTemplateJobTitlesRequest
*/
func (a *HotelConfigApiService) GetTemplateJobTitles(ctx context.Context) HotelConfigApiGetTemplateJobTitlesRequest {
	return HotelConfigApiGetTemplateJobTitlesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateJobTitlesDetails
func (a *HotelConfigApiService) GetTemplateJobTitlesExecute(r HotelConfigApiGetTemplateJobTitlesRequest) (*TemplateJobTitlesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateJobTitlesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetTemplateJobTitles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobTitles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobTitleCodes != nil {
		t := *r.jobTitleCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "jobTitleCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "jobTitleCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetTransportationRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transportationCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetTransportationRequest) Authorization(authorization string) HotelConfigApiGetTransportationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetTransportationRequest) XAppKey(xAppKey string) HotelConfigApiGetTransportationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetTransportationRequest) XHotelid(xHotelid string) HotelConfigApiGetTransportationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetTransportationRequest) TransportationCodes(transportationCodes []string) HotelConfigApiGetTransportationRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetTransportationRequest) WildCard(wildCard string) HotelConfigApiGetTransportationRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r HotelConfigApiGetTransportationRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetTransportationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetTransportationRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetTransportationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetTransportationRequest) Execute() (*TransportationDetails, *http.Response, error) {
	return r.ApiService.GetTransportationExecute(r)
}

/*
GetTransportation Get transportation

Use this API to get transportation. <p><strong>OperationId:</strong>getTransportation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetTransportationRequest
*/
func (a *HotelConfigApiService) GetTransportation(ctx context.Context, hotelId string) HotelConfigApiGetTransportationRequest {
	return HotelConfigApiGetTransportationRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransportationDetails
func (a *HotelConfigApiService) GetTransportationExecute(r HotelConfigApiGetTransportationRequest) (*TransportationDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransportationDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetTransportation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transportations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetTransportationTemplatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	transportationCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetTransportationTemplatesRequest) Authorization(authorization string) HotelConfigApiGetTransportationTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetTransportationTemplatesRequest) XAppKey(xAppKey string) HotelConfigApiGetTransportationTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetTransportationTemplatesRequest) XHotelid(xHotelid string) HotelConfigApiGetTransportationTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetTransportationTemplatesRequest) TransportationCodes(transportationCodes []string) HotelConfigApiGetTransportationTemplatesRequest {
	r.transportationCodes = &transportationCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetTransportationTemplatesRequest) WildCard(wildCard string) HotelConfigApiGetTransportationTemplatesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r HotelConfigApiGetTransportationTemplatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetTransportationTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetTransportationTemplatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetTransportationTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetTransportationTemplatesRequest) Execute() (*TransportationTemplatesDetails, *http.Response, error) {
	return r.ApiService.GetTransportationTemplatesExecute(r)
}

/*
GetTransportationTemplates Get transportation templates

Use this API to get transportation templates. <p><strong>OperationId:</strong>getTransportationTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetTransportationTemplatesRequest
*/
func (a *HotelConfigApiService) GetTransportationTemplates(ctx context.Context) HotelConfigApiGetTransportationTemplatesRequest {
	return HotelConfigApiGetTransportationTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransportationTemplatesDetails
func (a *HotelConfigApiService) GetTransportationTemplatesExecute(r HotelConfigApiGetTransportationTemplatesRequest) (*TransportationTemplatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransportationTemplatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetTransportationTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transportations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transportationCodes != nil {
		t := *r.transportationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportationCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostAmenitiesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	amenitiesCriteria *PostAmenitiesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostAmenitiesRequest) Authorization(authorization string) HotelConfigApiPostAmenitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostAmenitiesRequest) XAppKey(xAppKey string) HotelConfigApiPostAmenitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostAmenitiesRequest) XHotelid(xHotelid string) HotelConfigApiPostAmenitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating amenities at the property level.
func (r HotelConfigApiPostAmenitiesRequest) AmenitiesCriteria(amenitiesCriteria PostAmenitiesRequest) HotelConfigApiPostAmenitiesRequest {
	r.amenitiesCriteria = &amenitiesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostAmenitiesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostAmenitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostAmenitiesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostAmenitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostAmenitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAmenitiesExecute(r)
}

/*
PostAmenities Create amenities

Use this API to create amenities. <p><strong>OperationId:</strong>postAmenities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostAmenitiesRequest
*/
func (a *HotelConfigApiService) PostAmenities(ctx context.Context, hotelId string) HotelConfigApiPostAmenitiesRequest {
	return HotelConfigApiPostAmenitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostAmenitiesExecute(r HotelConfigApiPostAmenitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostAmenities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/amenities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.amenitiesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostAttractionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attractionsCriteria *PostAttractionsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostAttractionsRequest) Authorization(authorization string) HotelConfigApiPostAttractionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostAttractionsRequest) XAppKey(xAppKey string) HotelConfigApiPostAttractionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostAttractionsRequest) XHotelid(xHotelid string) HotelConfigApiPostAttractionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new group of attractions.
func (r HotelConfigApiPostAttractionsRequest) AttractionsCriteria(attractionsCriteria PostAttractionsRequest) HotelConfigApiPostAttractionsRequest {
	r.attractionsCriteria = &attractionsCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostAttractionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostAttractionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostAttractionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostAttractionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostAttractionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAttractionsExecute(r)
}

/*
PostAttractions Create Attractions

This API can be used to Use this API to create a new attraction for a property. . <p><strong>OperationId:</strong>postAttractions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostAttractionsRequest
*/
func (a *HotelConfigApiService) PostAttractions(ctx context.Context, hotelId string) HotelConfigApiPostAttractionsRequest {
	return HotelConfigApiPostAttractionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostAttractionsExecute(r HotelConfigApiPostAttractionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostAttractions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/attractions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attractionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostCreditCardTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCardTypesCriteria *PostCreditCardTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostCreditCardTypesRequest) Authorization(authorization string) HotelConfigApiPostCreditCardTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostCreditCardTypesRequest) XAppKey(xAppKey string) HotelConfigApiPostCreditCardTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostCreditCardTypesRequest) XHotelid(xHotelid string) HotelConfigApiPostCreditCardTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Credit Card Types.
func (r HotelConfigApiPostCreditCardTypesRequest) CreditCardTypesCriteria(creditCardTypesCriteria PostCreditCardTypesRequest) HotelConfigApiPostCreditCardTypesRequest {
	r.creditCardTypesCriteria = &creditCardTypesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostCreditCardTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostCreditCardTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostCreditCardTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostCreditCardTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostCreditCardTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCreditCardTypesExecute(r)
}

/*
PostCreditCardTypes Create Credit Card Types

Use this API to create Credit Card Types. <p><strong>OperationId:</strong>postCreditCardTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostCreditCardTypesRequest
*/
func (a *HotelConfigApiService) PostCreditCardTypes(ctx context.Context, hotelId string) HotelConfigApiPostCreditCardTypesRequest {
	return HotelConfigApiPostCreditCardTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostCreditCardTypesExecute(r HotelConfigApiPostCreditCardTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostCreditCardTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditCardTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostDepartmentsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	departmentsCriteria *PostDepartmentsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostDepartmentsRequest) Authorization(authorization string) HotelConfigApiPostDepartmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostDepartmentsRequest) XAppKey(xAppKey string) HotelConfigApiPostDepartmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostDepartmentsRequest) XHotelid(xHotelid string) HotelConfigApiPostDepartmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new departments.
func (r HotelConfigApiPostDepartmentsRequest) DepartmentsCriteria(departmentsCriteria PostDepartmentsRequest) HotelConfigApiPostDepartmentsRequest {
	r.departmentsCriteria = &departmentsCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostDepartmentsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostDepartmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostDepartmentsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostDepartmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostDepartmentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostDepartmentsExecute(r)
}

/*
PostDepartments Create Departments

Use this API to create Departments. <p><strong>OperationId:</strong>postDepartments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostDepartmentsRequest
*/
func (a *HotelConfigApiService) PostDepartments(ctx context.Context) HotelConfigApiPostDepartmentsRequest {
	return HotelConfigApiPostDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostDepartmentsExecute(r HotelConfigApiPostDepartmentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/departments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.departmentsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostHotelContactsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelContactsCriteria *PostHotelContactsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostHotelContactsRequest) Authorization(authorization string) HotelConfigApiPostHotelContactsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostHotelContactsRequest) XAppKey(xAppKey string) HotelConfigApiPostHotelContactsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostHotelContactsRequest) XHotelid(xHotelid string) HotelConfigApiPostHotelContactsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Contacts for hotels.
func (r HotelConfigApiPostHotelContactsRequest) HotelContactsCriteria(hotelContactsCriteria PostHotelContactsRequest) HotelConfigApiPostHotelContactsRequest {
	r.hotelContactsCriteria = &hotelContactsCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostHotelContactsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostHotelContactsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostHotelContactsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostHotelContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostHotelContactsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelContactsExecute(r)
}

/*
PostHotelContacts Create Hotel Contacts

Use this API to create Hotel Contacts. <p><strong>OperationId:</strong>postHotelContacts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostHotelContactsRequest
*/
func (a *HotelConfigApiService) PostHotelContacts(ctx context.Context, hotelId string) HotelConfigApiPostHotelContactsRequest {
	return HotelConfigApiPostHotelContactsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostHotelContactsExecute(r HotelConfigApiPostHotelContactsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostHotelContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelContactsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostHotelNotesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelNotesCriteria *PostHotelNotesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostHotelNotesRequest) Authorization(authorization string) HotelConfigApiPostHotelNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostHotelNotesRequest) XAppKey(xAppKey string) HotelConfigApiPostHotelNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostHotelNotesRequest) XHotelid(xHotelid string) HotelConfigApiPostHotelNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Notes for the hotels
func (r HotelConfigApiPostHotelNotesRequest) HotelNotesCriteria(hotelNotesCriteria PostHotelNotesRequest) HotelConfigApiPostHotelNotesRequest {
	r.hotelNotesCriteria = &hotelNotesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostHotelNotesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostHotelNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostHotelNotesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostHotelNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostHotelNotesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelNotesExecute(r)
}

/*
PostHotelNotes Create Note information

Use this API to create Note information. <p><strong>OperationId:</strong>postHotelNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostHotelNotesRequest
*/
func (a *HotelConfigApiService) PostHotelNotes(ctx context.Context, hotelId string) HotelConfigApiPostHotelNotesRequest {
	return HotelConfigApiPostHotelNotesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostHotelNotesExecute(r HotelConfigApiPostHotelNotesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostHotelNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/notes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelNotesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostTransportationRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transportationCriteria *PostTransportationRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostTransportationRequest) Authorization(authorization string) HotelConfigApiPostTransportationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostTransportationRequest) XAppKey(xAppKey string) HotelConfigApiPostTransportationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostTransportationRequest) XHotelid(xHotelid string) HotelConfigApiPostTransportationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating transportation.
func (r HotelConfigApiPostTransportationRequest) TransportationCriteria(transportationCriteria PostTransportationRequest) HotelConfigApiPostTransportationRequest {
	r.transportationCriteria = &transportationCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostTransportationRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostTransportationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostTransportationRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostTransportationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostTransportationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTransportationExecute(r)
}

/*
PostTransportation Create transportation

Use this API to create transportation. <p><strong>OperationId:</strong>postTransportation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostTransportationRequest
*/
func (a *HotelConfigApiService) PostTransportation(ctx context.Context, hotelId string) HotelConfigApiPostTransportationRequest {
	return HotelConfigApiPostTransportationRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostTransportationExecute(r HotelConfigApiPostTransportationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostTransportation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transportations"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transportationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveAttractionsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	attractionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attractionCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveAttractionsRequest) Authorization(authorization string) HotelConfigApiRemoveAttractionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveAttractionsRequest) XAppKey(xAppKey string) HotelConfigApiRemoveAttractionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveAttractionsRequest) XHotelid(xHotelid string) HotelConfigApiRemoveAttractionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r HotelConfigApiRemoveAttractionsRequest) AttractionCodes(attractionCodes []string) HotelConfigApiRemoveAttractionsRequest {
	r.attractionCodes = &attractionCodes
	return r
}

// External system code.
func (r HotelConfigApiRemoveAttractionsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveAttractionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveAttractionsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveAttractionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveAttractionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveAttractionsExecute(r)
}

/*
RemoveAttractions Delete Attractions

 Use this API to remove an existing attraction. <p><strong>OperationId:</strong>removeAttractions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attractionCode Unique Code of attraction.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiRemoveAttractionsRequest
*/
func (a *HotelConfigApiService) RemoveAttractions(ctx context.Context, attractionCode string, hotelId string) HotelConfigApiRemoveAttractionsRequest {
	return HotelConfigApiRemoveAttractionsRequest{
		ApiService: a,
		ctx: ctx,
		attractionCode: attractionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveAttractionsExecute(r HotelConfigApiRemoveAttractionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveAttractions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/attractions/{attractionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"attractionCode"+"}", url.PathEscape(parameterValueToString(r.attractionCode, "attractionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attractionCode) < 1 {
		return localVarReturnValue, nil, reportError("attractionCode must have at least 1 elements")
	}
	if strlen(r.attractionCode) > 2000 {
		return localVarReturnValue, nil, reportError("attractionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.attractionCodes != nil {
		t := *r.attractionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attractionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attractionCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveCreditCardTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditCardTypesCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveCreditCardTypesRequest) Authorization(authorization string) HotelConfigApiRemoveCreditCardTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveCreditCardTypesRequest) XAppKey(xAppKey string) HotelConfigApiRemoveCreditCardTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveCreditCardTypesRequest) XHotelid(xHotelid string) HotelConfigApiRemoveCreditCardTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r HotelConfigApiRemoveCreditCardTypesRequest) CreditCardTypesCode(creditCardTypesCode []string) HotelConfigApiRemoveCreditCardTypesRequest {
	r.creditCardTypesCode = &creditCardTypesCode
	return r
}

// External system code.
func (r HotelConfigApiRemoveCreditCardTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveCreditCardTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveCreditCardTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveCreditCardTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveCreditCardTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCreditCardTypesExecute(r)
}

/*
RemoveCreditCardTypes Delete Credit Card Types

Use this API to delete Credit Card Types. <p><strong>OperationId:</strong>removeCreditCardTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiRemoveCreditCardTypesRequest
*/
func (a *HotelConfigApiService) RemoveCreditCardTypes(ctx context.Context, hotelId string) HotelConfigApiRemoveCreditCardTypesRequest {
	return HotelConfigApiRemoveCreditCardTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveCreditCardTypesExecute(r HotelConfigApiRemoveCreditCardTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveCreditCardTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.creditCardTypesCode != nil {
		t := *r.creditCardTypesCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardTypesCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardTypesCode", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveDepartmentsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	departmentCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveDepartmentsRequest) Authorization(authorization string) HotelConfigApiRemoveDepartmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveDepartmentsRequest) XAppKey(xAppKey string) HotelConfigApiRemoveDepartmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveDepartmentsRequest) XHotelid(xHotelid string) HotelConfigApiRemoveDepartmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel where the code is configured.
func (r HotelConfigApiRemoveDepartmentsRequest) HotelId(hotelId string) HotelConfigApiRemoveDepartmentsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r HotelConfigApiRemoveDepartmentsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveDepartmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveDepartmentsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveDepartmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveDepartmentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveDepartmentsExecute(r)
}

/*
RemoveDepartments Delete Departments

Use this API to delete Departments. <p><strong>OperationId:</strong>removeDepartments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentCode Unique Code of department.
 @return HotelConfigApiRemoveDepartmentsRequest
*/
func (a *HotelConfigApiService) RemoveDepartments(ctx context.Context, departmentCode string) HotelConfigApiRemoveDepartmentsRequest {
	return HotelConfigApiRemoveDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
		departmentCode: departmentCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveDepartmentsExecute(r HotelConfigApiRemoveDepartmentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/departments/{departmentCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentCode"+"}", url.PathEscape(parameterValueToString(r.departmentCode, "departmentCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentCode) < 1 {
		return localVarReturnValue, nil, reportError("departmentCode must have at least 1 elements")
	}
	if strlen(r.departmentCode) > 2000 {
		return localVarReturnValue, nil, reportError("departmentCode must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveHotelContactsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	contactId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idExtension *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveHotelContactsRequest) Authorization(authorization string) HotelConfigApiRemoveHotelContactsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveHotelContactsRequest) XAppKey(xAppKey string) HotelConfigApiRemoveHotelContactsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveHotelContactsRequest) XHotelid(xHotelid string) HotelConfigApiRemoveHotelContactsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r HotelConfigApiRemoveHotelContactsRequest) IdExtension(idExtension int32) HotelConfigApiRemoveHotelContactsRequest {
	r.idExtension = &idExtension
	return r
}

// External system code.
func (r HotelConfigApiRemoveHotelContactsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveHotelContactsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveHotelContactsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveHotelContactsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveHotelContactsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveHotelContactsExecute(r)
}

/*
RemoveHotelContacts Delete Hotel contact

Use this API to delete Hotel contact. <p><strong>OperationId:</strong>removeHotelContacts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactId Unique ID of contact.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiRemoveHotelContactsRequest
*/
func (a *HotelConfigApiService) RemoveHotelContacts(ctx context.Context, contactId string, hotelId string) HotelConfigApiRemoveHotelContactsRequest {
	return HotelConfigApiRemoveHotelContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveHotelContactsExecute(r HotelConfigApiRemoveHotelContactsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveHotelContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/contacts/{contactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contactId"+"}", url.PathEscape(parameterValueToString(r.contactId, "contactId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.contactId) < 1 {
		return localVarReturnValue, nil, reportError("contactId must have at least 1 elements")
	}
	if strlen(r.contactId) > 2000 {
		return localVarReturnValue, nil, reportError("contactId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiRemoveHotelNotesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	noteCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiRemoveHotelNotesRequest) Authorization(authorization string) HotelConfigApiRemoveHotelNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiRemoveHotelNotesRequest) XAppKey(xAppKey string) HotelConfigApiRemoveHotelNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiRemoveHotelNotesRequest) XHotelid(xHotelid string) HotelConfigApiRemoveHotelNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiRemoveHotelNotesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiRemoveHotelNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiRemoveHotelNotesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiRemoveHotelNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiRemoveHotelNotesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveHotelNotesExecute(r)
}

/*
RemoveHotelNotes Delete Note information

Use this API to delete Note information. <p><strong>OperationId:</strong>removeHotelNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param noteCode Unique Code of note.
 @return HotelConfigApiRemoveHotelNotesRequest
*/
func (a *HotelConfigApiService) RemoveHotelNotes(ctx context.Context, noteCode string) HotelConfigApiRemoveHotelNotesRequest {
	return HotelConfigApiRemoveHotelNotesRequest{
		ApiService: a,
		ctx: ctx,
		noteCode: noteCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) RemoveHotelNotesExecute(r HotelConfigApiRemoveHotelNotesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.RemoveHotelNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notes/{noteCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"noteCode"+"}", url.PathEscape(parameterValueToString(r.noteCode, "noteCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.noteCode) < 1 {
		return localVarReturnValue, nil, reportError("noteCode must have at least 1 elements")
	}
	if strlen(r.noteCode) > 2000 {
		return localVarReturnValue, nil, reportError("noteCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
