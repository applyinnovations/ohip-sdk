/*
OPERA Cloud Enterprise Configuration API

APIs to cater for Enterprise Configuration functionality in OPERA Cloud. <br /><br In this module, you can configure a variety of options related to your properties such as their locations, facilities, and local attractions. The available options are dependant on the active controls at your property.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package entcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChainConfigAPIService ChainConfigAPI service
type ChainConfigAPIService service

type ChainConfigAPIChangeBrandCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	brandCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	brandCodesToBeChanged *BrandCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeBrandCodesRequest) Authorization(authorization string) ChainConfigAPIChangeBrandCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeBrandCodesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeBrandCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeBrandCodesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeBrandCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Brand Codes.
func (r ChainConfigAPIChangeBrandCodesRequest) BrandCodesToBeChanged(brandCodesToBeChanged BrandCodesToBeChanged) ChainConfigAPIChangeBrandCodesRequest {
	r.brandCodesToBeChanged = &brandCodesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeBrandCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeBrandCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeBrandCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeBrandCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeBrandCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeBrandCodesExecute(r)
}

/*
ChangeBrandCodes Change Brand Code

Use this API to update Brand Code. <p><strong>OperationId:</strong>changeBrandCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param brandCode Unique Code of Brand.
 @return ChainConfigAPIChangeBrandCodesRequest
*/
func (a *ChainConfigAPIService) ChangeBrandCodes(ctx context.Context, brandCode string) ChainConfigAPIChangeBrandCodesRequest {
	return ChainConfigAPIChangeBrandCodesRequest{
		ApiService: a,
		ctx: ctx,
		brandCode: brandCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeBrandCodesExecute(r ChainConfigAPIChangeBrandCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeBrandCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brandCodes/{brandCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"brandCode"+"}", url.PathEscape(parameterValueToString(r.brandCode, "brandCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.brandCode) < 1 {
		return localVarReturnValue, nil, reportError("brandCode must have at least 1 elements")
	}
	if strlen(r.brandCode) > 2000 {
		return localVarReturnValue, nil, reportError("brandCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.brandCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCorporateBusinessUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	businessUnitCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateBusinessUnitsToBeChanged *CorporateBusinessUnitsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) Authorization(authorization string) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Corporate Business Units.
func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) CorporateBusinessUnitsToBeChanged(corporateBusinessUnitsToBeChanged CorporateBusinessUnitsToBeChanged) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	r.corporateBusinessUnitsToBeChanged = &corporateBusinessUnitsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCorporateBusinessUnitsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCorporateBusinessUnitsExecute(r)
}

/*
ChangeCorporateBusinessUnits Change Corporate Business Units

Use this API to update Corporate Business Units. <p><strong>OperationId:</strong>changeCorporateBusinessUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessUnitCode Unique Code of Business Units.
 @return ChainConfigAPIChangeCorporateBusinessUnitsRequest
*/
func (a *ChainConfigAPIService) ChangeCorporateBusinessUnits(ctx context.Context, businessUnitCode string) ChainConfigAPIChangeCorporateBusinessUnitsRequest {
	return ChainConfigAPIChangeCorporateBusinessUnitsRequest{
		ApiService: a,
		ctx: ctx,
		businessUnitCode: businessUnitCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCorporateBusinessUnitsExecute(r ChainConfigAPIChangeCorporateBusinessUnitsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCorporateBusinessUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateBusinessUnits/{businessUnitCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"businessUnitCode"+"}", url.PathEscape(parameterValueToString(r.businessUnitCode, "businessUnitCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessUnitCode) < 1 {
		return localVarReturnValue, nil, reportError("businessUnitCode must have at least 1 elements")
	}
	if strlen(r.businessUnitCode) > 2000 {
		return localVarReturnValue, nil, reportError("businessUnitCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateBusinessUnitsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCorporateDepartmentCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	departmentCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateDepartmentCodesToBeChanged *CorporateDepartmentCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) Authorization(authorization string) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Corporate Department Codes.
func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) CorporateDepartmentCodesToBeChanged(corporateDepartmentCodesToBeChanged CorporateDepartmentCodesToBeChanged) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	r.corporateDepartmentCodesToBeChanged = &corporateDepartmentCodesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCorporateDepartmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCorporateDepartmentCodesExecute(r)
}

/*
ChangeCorporateDepartmentCodes Change Corporate Department Codes

Use this API to update Corporate Department Codes. <p><strong>OperationId:</strong>changeCorporateDepartmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentCode Unique Code of Department.
 @return ChainConfigAPIChangeCorporateDepartmentCodesRequest
*/
func (a *ChainConfigAPIService) ChangeCorporateDepartmentCodes(ctx context.Context, departmentCode string) ChainConfigAPIChangeCorporateDepartmentCodesRequest {
	return ChainConfigAPIChangeCorporateDepartmentCodesRequest{
		ApiService: a,
		ctx: ctx,
		departmentCode: departmentCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCorporateDepartmentCodesExecute(r ChainConfigAPIChangeCorporateDepartmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCorporateDepartmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDepartmentCodes/{departmentCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentCode"+"}", url.PathEscape(parameterValueToString(r.departmentCode, "departmentCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentCode) < 1 {
		return localVarReturnValue, nil, reportError("departmentCode must have at least 1 elements")
	}
	if strlen(r.departmentCode) > 2000 {
		return localVarReturnValue, nil, reportError("departmentCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateDepartmentCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCorporateDivisionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	divisionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateDivisionsToBeChanged *CorporateDivisionsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCorporateDivisionsRequest) Authorization(authorization string) ChainConfigAPIChangeCorporateDivisionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCorporateDivisionsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCorporateDivisionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCorporateDivisionsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCorporateDivisionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Corporate Divisions.
func (r ChainConfigAPIChangeCorporateDivisionsRequest) CorporateDivisionsToBeChanged(corporateDivisionsToBeChanged CorporateDivisionsToBeChanged) ChainConfigAPIChangeCorporateDivisionsRequest {
	r.corporateDivisionsToBeChanged = &corporateDivisionsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCorporateDivisionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCorporateDivisionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCorporateDivisionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCorporateDivisionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCorporateDivisionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCorporateDivisionsExecute(r)
}

/*
ChangeCorporateDivisions Change Corporate Divisions

Use this API to update Corporate Divisions. <p><strong>OperationId:</strong>changeCorporateDivisions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param divisionCode Unique Code of Corporate Divisions.
 @return ChainConfigAPIChangeCorporateDivisionsRequest
*/
func (a *ChainConfigAPIService) ChangeCorporateDivisions(ctx context.Context, divisionCode string) ChainConfigAPIChangeCorporateDivisionsRequest {
	return ChainConfigAPIChangeCorporateDivisionsRequest{
		ApiService: a,
		ctx: ctx,
		divisionCode: divisionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCorporateDivisionsExecute(r ChainConfigAPIChangeCorporateDivisionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCorporateDivisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDivisions/{divisionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"divisionCode"+"}", url.PathEscape(parameterValueToString(r.divisionCode, "divisionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.divisionCode) < 1 {
		return localVarReturnValue, nil, reportError("divisionCode must have at least 1 elements")
	}
	if strlen(r.divisionCode) > 2000 {
		return localVarReturnValue, nil, reportError("divisionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateDivisionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCorporateOperatingUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	operatingUnitCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateOperatingUnitsToBeChanged *CorporateOperatingUnitsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) Authorization(authorization string) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Corporate Operating Units.
func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) CorporateOperatingUnitsToBeChanged(corporateOperatingUnitsToBeChanged CorporateOperatingUnitsToBeChanged) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	r.corporateOperatingUnitsToBeChanged = &corporateOperatingUnitsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCorporateOperatingUnitsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCorporateOperatingUnitsExecute(r)
}

/*
ChangeCorporateOperatingUnits Change Corporate Operating Units

Use this API to update Corporate Operating Units. <p><strong>OperationId:</strong>changeCorporateOperatingUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatingUnitCode Unique Code of Corporate Operating Units.
 @return ChainConfigAPIChangeCorporateOperatingUnitsRequest
*/
func (a *ChainConfigAPIService) ChangeCorporateOperatingUnits(ctx context.Context, operatingUnitCode string) ChainConfigAPIChangeCorporateOperatingUnitsRequest {
	return ChainConfigAPIChangeCorporateOperatingUnitsRequest{
		ApiService: a,
		ctx: ctx,
		operatingUnitCode: operatingUnitCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCorporateOperatingUnitsExecute(r ChainConfigAPIChangeCorporateOperatingUnitsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCorporateOperatingUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateOperatingUnits/{operatingUnitCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatingUnitCode"+"}", url.PathEscape(parameterValueToString(r.operatingUnitCode, "operatingUnitCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.operatingUnitCode) < 1 {
		return localVarReturnValue, nil, reportError("operatingUnitCode must have at least 1 elements")
	}
	if strlen(r.operatingUnitCode) > 2000 {
		return localVarReturnValue, nil, reportError("operatingUnitCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateOperatingUnitsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCountryGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	guestTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	countryGuestTypesToBeChanged *CountryGuestTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCountryGuestTypesRequest) Authorization(authorization string) ChainConfigAPIChangeCountryGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCountryGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCountryGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCountryGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCountryGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Philippines Country Guest Types.
func (r ChainConfigAPIChangeCountryGuestTypesRequest) CountryGuestTypesToBeChanged(countryGuestTypesToBeChanged CountryGuestTypesToBeChanged) ChainConfigAPIChangeCountryGuestTypesRequest {
	r.countryGuestTypesToBeChanged = &countryGuestTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCountryGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCountryGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCountryGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCountryGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCountryGuestTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCountryGuestTypesExecute(r)
}

/*
ChangeCountryGuestTypes Change Country Guest Types

Use this API to update Country Guest Types. <p><strong>OperationId:</strong>changeCountryGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guestTypeCode Unique Code of guest type.
 @return ChainConfigAPIChangeCountryGuestTypesRequest
*/
func (a *ChainConfigAPIService) ChangeCountryGuestTypes(ctx context.Context, guestTypeCode string) ChainConfigAPIChangeCountryGuestTypesRequest {
	return ChainConfigAPIChangeCountryGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
		guestTypeCode: guestTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCountryGuestTypesExecute(r ChainConfigAPIChangeCountryGuestTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCountryGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countries/guestTypes/{guestTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guestTypeCode"+"}", url.PathEscape(parameterValueToString(r.guestTypeCode, "guestTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guestTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("guestTypeCode must have at least 1 elements")
	}
	if strlen(r.guestTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guestTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.countryGuestTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeCountryMainGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	groupCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	countryMainGroupsToBeChanged *CountryMainGroupsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeCountryMainGroupsRequest) Authorization(authorization string) ChainConfigAPIChangeCountryMainGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeCountryMainGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeCountryMainGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeCountryMainGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeCountryMainGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Country Main Groups.
func (r ChainConfigAPIChangeCountryMainGroupsRequest) CountryMainGroupsToBeChanged(countryMainGroupsToBeChanged CountryMainGroupsToBeChanged) ChainConfigAPIChangeCountryMainGroupsRequest {
	r.countryMainGroupsToBeChanged = &countryMainGroupsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeCountryMainGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeCountryMainGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeCountryMainGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeCountryMainGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeCountryMainGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCountryMainGroupsExecute(r)
}

/*
ChangeCountryMainGroups Change Country Main Groups

Use this API to update Country Main Groups. <p><strong>OperationId:</strong>changeCountryMainGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupCode Unique Code of Groups.
 @return ChainConfigAPIChangeCountryMainGroupsRequest
*/
func (a *ChainConfigAPIService) ChangeCountryMainGroups(ctx context.Context, groupCode string) ChainConfigAPIChangeCountryMainGroupsRequest {
	return ChainConfigAPIChangeCountryMainGroupsRequest{
		ApiService: a,
		ctx: ctx,
		groupCode: groupCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeCountryMainGroupsExecute(r ChainConfigAPIChangeCountryMainGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeCountryMainGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countryMainGroups/{groupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupCode"+"}", url.PathEscape(parameterValueToString(r.groupCode, "groupCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupCode) < 1 {
		return localVarReturnValue, nil, reportError("groupCode must have at least 1 elements")
	}
	if strlen(r.groupCode) > 2000 {
		return localVarReturnValue, nil, reportError("groupCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.countryMainGroupsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeHotelCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	categoryCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelCategoriesToBeChanged *HotelCategoriesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeHotelCategoriesRequest) Authorization(authorization string) ChainConfigAPIChangeHotelCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeHotelCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeHotelCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeHotelCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeHotelCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Hotel Categories.
func (r ChainConfigAPIChangeHotelCategoriesRequest) HotelCategoriesToBeChanged(hotelCategoriesToBeChanged HotelCategoriesToBeChanged) ChainConfigAPIChangeHotelCategoriesRequest {
	r.hotelCategoriesToBeChanged = &hotelCategoriesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeHotelCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeHotelCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeHotelCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeHotelCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeHotelCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeHotelCategoriesExecute(r)
}

/*
ChangeHotelCategories Change Hotel Categories

. <p><strong>OperationId:</strong>changeHotelCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryCode Unique Code of Categories.
 @return ChainConfigAPIChangeHotelCategoriesRequest
*/
func (a *ChainConfigAPIService) ChangeHotelCategories(ctx context.Context, categoryCode string) ChainConfigAPIChangeHotelCategoriesRequest {
	return ChainConfigAPIChangeHotelCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		categoryCode: categoryCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeHotelCategoriesExecute(r ChainConfigAPIChangeHotelCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeHotelCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelCategories/{categoryCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryCode"+"}", url.PathEscape(parameterValueToString(r.categoryCode, "categoryCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.categoryCode) < 1 {
		return localVarReturnValue, nil, reportError("categoryCode must have at least 1 elements")
	}
	if strlen(r.categoryCode) > 2000 {
		return localVarReturnValue, nil, reportError("categoryCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelCategoriesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeNoteTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	noteTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	noteTypesToBeChanged *NoteTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeNoteTypesRequest) Authorization(authorization string) ChainConfigAPIChangeNoteTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeNoteTypesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeNoteTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeNoteTypesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeNoteTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing Note Types.
func (r ChainConfigAPIChangeNoteTypesRequest) NoteTypesToBeChanged(noteTypesToBeChanged NoteTypesToBeChanged) ChainConfigAPIChangeNoteTypesRequest {
	r.noteTypesToBeChanged = &noteTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeNoteTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeNoteTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeNoteTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeNoteTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeNoteTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeNoteTypesExecute(r)
}

/*
ChangeNoteTypes Change Note Types

Use this API to update Note Types. <p><strong>OperationId:</strong>changeNoteTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param noteTypeCode Unique Code of Note Types.
 @return ChainConfigAPIChangeNoteTypesRequest
*/
func (a *ChainConfigAPIService) ChangeNoteTypes(ctx context.Context, noteTypeCode string) ChainConfigAPIChangeNoteTypesRequest {
	return ChainConfigAPIChangeNoteTypesRequest{
		ApiService: a,
		ctx: ctx,
		noteTypeCode: noteTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeNoteTypesExecute(r ChainConfigAPIChangeNoteTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeNoteTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noteTypes/{noteTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"noteTypeCode"+"}", url.PathEscape(parameterValueToString(r.noteTypeCode, "noteTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.noteTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("noteTypeCode must have at least 1 elements")
	}
	if strlen(r.noteTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("noteTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.noteTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangePropertyDetailCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	categoryCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyDetailCategoriesToBeChanged *PropertyDetailCategoriesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) Authorization(authorization string) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Property Detail Categories.
func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) PropertyDetailCategoriesToBeChanged(propertyDetailCategoriesToBeChanged PropertyDetailCategoriesToBeChanged) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	r.propertyDetailCategoriesToBeChanged = &propertyDetailCategoriesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangePropertyDetailCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangePropertyDetailCategoriesExecute(r)
}

/*
ChangePropertyDetailCategories Change Property Detail Categories

Use this API to update Property Detail Categories. <p><strong>OperationId:</strong>changePropertyDetailCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryCode Unique Code of Categories.
 @return ChainConfigAPIChangePropertyDetailCategoriesRequest
*/
func (a *ChainConfigAPIService) ChangePropertyDetailCategories(ctx context.Context, categoryCode string) ChainConfigAPIChangePropertyDetailCategoriesRequest {
	return ChainConfigAPIChangePropertyDetailCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		categoryCode: categoryCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangePropertyDetailCategoriesExecute(r ChainConfigAPIChangePropertyDetailCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangePropertyDetailCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyDetailsCategories/{categoryCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryCode"+"}", url.PathEscape(parameterValueToString(r.categoryCode, "categoryCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.categoryCode) < 1 {
		return localVarReturnValue, nil, reportError("categoryCode must have at least 1 elements")
	}
	if strlen(r.categoryCode) > 2000 {
		return localVarReturnValue, nil, reportError("categoryCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.propertyDetailCategoriesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeRegionsCodeRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	regionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	regionsCodeToBeChanged *RegionsCodeToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeRegionsCodeRequest) Authorization(authorization string) ChainConfigAPIChangeRegionsCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeRegionsCodeRequest) XAppKey(xAppKey string) ChainConfigAPIChangeRegionsCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeRegionsCodeRequest) XHotelid(xHotelid string) ChainConfigAPIChangeRegionsCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Regions Code.
func (r ChainConfigAPIChangeRegionsCodeRequest) RegionsCodeToBeChanged(regionsCodeToBeChanged RegionsCodeToBeChanged) ChainConfigAPIChangeRegionsCodeRequest {
	r.regionsCodeToBeChanged = &regionsCodeToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeRegionsCodeRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeRegionsCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeRegionsCodeRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeRegionsCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeRegionsCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeRegionsCodeExecute(r)
}

/*
ChangeRegionsCode Change Regions Code

Use this API to update Regions Code. <p><strong>OperationId:</strong>changeRegionsCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionCode Unique Code of Regions.
 @return ChainConfigAPIChangeRegionsCodeRequest
*/
func (a *ChainConfigAPIService) ChangeRegionsCode(ctx context.Context, regionCode string) ChainConfigAPIChangeRegionsCodeRequest {
	return ChainConfigAPIChangeRegionsCodeRequest{
		ApiService: a,
		ctx: ctx,
		regionCode: regionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeRegionsCodeExecute(r ChainConfigAPIChangeRegionsCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeRegionsCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/regionCode/{regionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"regionCode"+"}", url.PathEscape(parameterValueToString(r.regionCode, "regionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.regionCode) < 1 {
		return localVarReturnValue, nil, reportError("regionCode must have at least 1 elements")
	}
	if strlen(r.regionCode) > 2000 {
		return localVarReturnValue, nil, reportError("regionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.regionsCodeToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeTemplateCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	code string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCodesToBeChanged *TemplateCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeTemplateCodesRequest) Authorization(authorization string) ChainConfigAPIChangeTemplateCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeTemplateCodesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeTemplateCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeTemplateCodesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeTemplateCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Template Codes.
func (r ChainConfigAPIChangeTemplateCodesRequest) TemplateCodesToBeChanged(templateCodesToBeChanged TemplateCodesToBeChanged) ChainConfigAPIChangeTemplateCodesRequest {
	r.templateCodesToBeChanged = &templateCodesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeTemplateCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeTemplateCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeTemplateCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeTemplateCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeTemplateCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTemplateCodesExecute(r)
}

/*
ChangeTemplateCodes Change Template Codes

Use this API to update Template Codes. <p><strong>OperationId:</strong>changeTemplateCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique Code of Template.
 @return ChainConfigAPIChangeTemplateCodesRequest
*/
func (a *ChainConfigAPIService) ChangeTemplateCodes(ctx context.Context, code string) ChainConfigAPIChangeTemplateCodesRequest {
	return ChainConfigAPIChangeTemplateCodesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeTemplateCodesExecute(r ChainConfigAPIChangeTemplateCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeTemplateCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateCodes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeUserDefinedFieldGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	udfGroupCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	userDefinedFieldGroupsToBeChanged *UserDefinedFieldGroupsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) Authorization(authorization string) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing User Defined Field Groups.
func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) UserDefinedFieldGroupsToBeChanged(userDefinedFieldGroupsToBeChanged UserDefinedFieldGroupsToBeChanged) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	r.userDefinedFieldGroupsToBeChanged = &userDefinedFieldGroupsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeUserDefinedFieldGroupsExecute(r)
}

/*
ChangeUserDefinedFieldGroups Change User Defined Field Groups

Use this API to update User Defined Field Groups. <p><strong>OperationId:</strong>changeUserDefinedFieldGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param udfGroupCode Unique Code of User Defined Field Groups.
 @return ChainConfigAPIChangeUserDefinedFieldGroupsRequest
*/
func (a *ChainConfigAPIService) ChangeUserDefinedFieldGroups(ctx context.Context, udfGroupCode string) ChainConfigAPIChangeUserDefinedFieldGroupsRequest {
	return ChainConfigAPIChangeUserDefinedFieldGroupsRequest{
		ApiService: a,
		ctx: ctx,
		udfGroupCode: udfGroupCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeUserDefinedFieldGroupsExecute(r ChainConfigAPIChangeUserDefinedFieldGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeUserDefinedFieldGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldGroups/{udfGroupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"udfGroupCode"+"}", url.PathEscape(parameterValueToString(r.udfGroupCode, "udfGroupCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.udfGroupCode) < 1 {
		return localVarReturnValue, nil, reportError("udfGroupCode must have at least 1 elements")
	}
	if strlen(r.udfGroupCode) > 2000 {
		return localVarReturnValue, nil, reportError("udfGroupCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.userDefinedFieldGroupsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIChangeUserDefinedFieldValuesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	udfValue string
	authorization *string
	xAppKey *string
	xHotelid *string
	userDefinedFieldValuesToBeChanged *UserDefinedFieldValuesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) Authorization(authorization string) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) XAppKey(xAppKey string) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) XHotelid(xHotelid string) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing User Defined Field Values.
func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) UserDefinedFieldValuesToBeChanged(userDefinedFieldValuesToBeChanged UserDefinedFieldValuesToBeChanged) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	r.userDefinedFieldValuesToBeChanged = &userDefinedFieldValuesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIChangeUserDefinedFieldValuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeUserDefinedFieldValuesExecute(r)
}

/*
ChangeUserDefinedFieldValues Change a User Defined Field Value 

Use this API to modify a User Defined Field Value. <p><strong>OperationId:</strong>changeUserDefinedFieldValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param udfValue Unique Value of User Defined Field.
 @return ChainConfigAPIChangeUserDefinedFieldValuesRequest
*/
func (a *ChainConfigAPIService) ChangeUserDefinedFieldValues(ctx context.Context, udfValue string) ChainConfigAPIChangeUserDefinedFieldValuesRequest {
	return ChainConfigAPIChangeUserDefinedFieldValuesRequest{
		ApiService: a,
		ctx: ctx,
		udfValue: udfValue,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) ChangeUserDefinedFieldValuesExecute(r ChainConfigAPIChangeUserDefinedFieldValuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.ChangeUserDefinedFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldValues/{udfValue}"
	localVarPath = strings.Replace(localVarPath, "{"+"udfValue"+"}", url.PathEscape(parameterValueToString(r.udfValue, "udfValue")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.udfValue) < 1 {
		return localVarReturnValue, nil, reportError("udfValue must have at least 1 elements")
	}
	if strlen(r.udfValue) > 2000 {
		return localVarReturnValue, nil, reportError("udfValue must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.userDefinedFieldValuesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteAttractionClassesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	attractionClassCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteAttractionClassesRequest) Authorization(authorization string) ChainConfigAPIDeleteAttractionClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteAttractionClassesRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteAttractionClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteAttractionClassesRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteAttractionClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIDeleteAttractionClassesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteAttractionClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteAttractionClassesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteAttractionClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteAttractionClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAttractionClassesExecute(r)
}

/*
DeleteAttractionClasses Delete Attraction Classes

Use this API to delete Attraction Classes. <p><strong>OperationId:</strong>deleteAttractionClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attractionClassCode Unique ID of Attraction Classes.
 @return ChainConfigAPIDeleteAttractionClassesRequest
*/
func (a *ChainConfigAPIService) DeleteAttractionClasses(ctx context.Context, attractionClassCode string) ChainConfigAPIDeleteAttractionClassesRequest {
	return ChainConfigAPIDeleteAttractionClassesRequest{
		ApiService: a,
		ctx: ctx,
		attractionClassCode: attractionClassCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteAttractionClassesExecute(r ChainConfigAPIDeleteAttractionClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteAttractionClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attractionClasses/{attractionClassCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"attractionClassCode"+"}", url.PathEscape(parameterValueToString(r.attractionClassCode, "attractionClassCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attractionClassCode) < 1 {
		return localVarReturnValue, nil, reportError("attractionClassCode must have at least 1 elements")
	}
	if strlen(r.attractionClassCode) > 2000 {
		return localVarReturnValue, nil, reportError("attractionClassCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	communicationMethodsEntDetailsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationMethodsEntDetailsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) Authorization(authorization string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) CommunicationMethodsEntDetailsCodes(communicationMethodsEntDetailsCodes []string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	r.communicationMethodsEntDetailsCodes = &communicationMethodsEntDetailsCodes
	return r
}

// External system code.
func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCommunicationMethodsEntDetailsExecute(r)
}

/*
DeleteCommunicationMethodsEntDetails Delete Communication Methods Ent Details

Use this API to delete Communication Methods Ent Details. <p><strong>OperationId:</strong>deleteCommunicationMethodsEntDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param communicationMethodsEntDetailsId Unique ID of Communication Methods Ent Details.
 @return ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest
*/
func (a *ChainConfigAPIService) DeleteCommunicationMethodsEntDetails(ctx context.Context, communicationMethodsEntDetailsId string) ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest {
	return ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest{
		ApiService: a,
		ctx: ctx,
		communicationMethodsEntDetailsId: communicationMethodsEntDetailsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteCommunicationMethodsEntDetailsExecute(r ChainConfigAPIDeleteCommunicationMethodsEntDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteCommunicationMethodsEntDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationMethodsEntDetails/{communicationMethodsEntDetailsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"communicationMethodsEntDetailsId"+"}", url.PathEscape(parameterValueToString(r.communicationMethodsEntDetailsId, "communicationMethodsEntDetailsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.communicationMethodsEntDetailsId) < 1 {
		return localVarReturnValue, nil, reportError("communicationMethodsEntDetailsId must have at least 1 elements")
	}
	if strlen(r.communicationMethodsEntDetailsId) > 2000 {
		return localVarReturnValue, nil, reportError("communicationMethodsEntDetailsId must have less than 2000 elements")
	}

	if r.communicationMethodsEntDetailsCodes != nil {
		t := *r.communicationMethodsEntDetailsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "communicationMethodsEntDetailsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "communicationMethodsEntDetailsCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteFlexFieldRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	flexFieldId float32
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteFlexFieldRequest) Authorization(authorization string) ChainConfigAPIDeleteFlexFieldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteFlexFieldRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteFlexFieldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteFlexFieldRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteFlexFieldRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIDeleteFlexFieldRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteFlexFieldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteFlexFieldRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteFlexFieldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteFlexFieldRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteFlexFieldExecute(r)
}

/*
DeleteFlexField Operation to delete a flex field.

Operation to delete a flex field. <p><strong>OperationId:</strong>deleteFlexField</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flexFieldId Flex Field ID
 @param hotelId Unique ID of the hotel in OPERA
 @return ChainConfigAPIDeleteFlexFieldRequest
*/
func (a *ChainConfigAPIService) DeleteFlexField(ctx context.Context, flexFieldId float32, hotelId string) ChainConfigAPIDeleteFlexFieldRequest {
	return ChainConfigAPIDeleteFlexFieldRequest{
		ApiService: a,
		ctx: ctx,
		flexFieldId: flexFieldId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteFlexFieldExecute(r ChainConfigAPIDeleteFlexFieldRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteFlexField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/flexFields/{flexFieldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"flexFieldId"+"}", url.PathEscape(parameterValueToString(r.flexFieldId, "flexFieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteMarketingRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	marketingRegionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	marketingRegionsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteMarketingRegionsRequest) Authorization(authorization string) ChainConfigAPIDeleteMarketingRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteMarketingRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteMarketingRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteMarketingRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteMarketingRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIDeleteMarketingRegionsRequest) MarketingRegionsCodes(marketingRegionsCodes []string) ChainConfigAPIDeleteMarketingRegionsRequest {
	r.marketingRegionsCodes = &marketingRegionsCodes
	return r
}

// External system code.
func (r ChainConfigAPIDeleteMarketingRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteMarketingRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteMarketingRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteMarketingRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteMarketingRegionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMarketingRegionsExecute(r)
}

/*
DeleteMarketingRegions Delete Marketing Regions

Use this API to delete Marketing Regions. <p><strong>OperationId:</strong>deleteMarketingRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketingRegionCode Unique ID of Marketing Regions.
 @return ChainConfigAPIDeleteMarketingRegionsRequest
*/
func (a *ChainConfigAPIService) DeleteMarketingRegions(ctx context.Context, marketingRegionCode string) ChainConfigAPIDeleteMarketingRegionsRequest {
	return ChainConfigAPIDeleteMarketingRegionsRequest{
		ApiService: a,
		ctx: ctx,
		marketingRegionCode: marketingRegionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteMarketingRegionsExecute(r ChainConfigAPIDeleteMarketingRegionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteMarketingRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketingRegions/{marketingRegionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"marketingRegionCode"+"}", url.PathEscape(parameterValueToString(r.marketingRegionCode, "marketingRegionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.marketingRegionCode) < 1 {
		return localVarReturnValue, nil, reportError("marketingRegionCode must have at least 1 elements")
	}
	if strlen(r.marketingRegionCode) > 2000 {
		return localVarReturnValue, nil, reportError("marketingRegionCode must have less than 2000 elements")
	}

	if r.marketingRegionsCodes != nil {
		t := *r.marketingRegionsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketingRegionsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketingRegionsCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeletePropertyTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	propertyTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyTypesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeletePropertyTypesRequest) Authorization(authorization string) ChainConfigAPIDeletePropertyTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeletePropertyTypesRequest) XAppKey(xAppKey string) ChainConfigAPIDeletePropertyTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeletePropertyTypesRequest) XHotelid(xHotelid string) ChainConfigAPIDeletePropertyTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIDeletePropertyTypesRequest) PropertyTypesCodes(propertyTypesCodes []string) ChainConfigAPIDeletePropertyTypesRequest {
	r.propertyTypesCodes = &propertyTypesCodes
	return r
}

// External system code.
func (r ChainConfigAPIDeletePropertyTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeletePropertyTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeletePropertyTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeletePropertyTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeletePropertyTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePropertyTypesExecute(r)
}

/*
DeletePropertyTypes Delete Property Types

Use this API to delete Property Types. <p><strong>OperationId:</strong>deletePropertyTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param propertyTypeCode Unique ID of Property Types.
 @return ChainConfigAPIDeletePropertyTypesRequest
*/
func (a *ChainConfigAPIService) DeletePropertyTypes(ctx context.Context, propertyTypeCode string) ChainConfigAPIDeletePropertyTypesRequest {
	return ChainConfigAPIDeletePropertyTypesRequest{
		ApiService: a,
		ctx: ctx,
		propertyTypeCode: propertyTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeletePropertyTypesExecute(r ChainConfigAPIDeletePropertyTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeletePropertyTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyTypes/{propertyTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"propertyTypeCode"+"}", url.PathEscape(parameterValueToString(r.propertyTypeCode, "propertyTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.propertyTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("propertyTypeCode must have at least 1 elements")
	}
	if strlen(r.propertyTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("propertyTypeCode must have less than 2000 elements")
	}

	if r.propertyTypesCodes != nil {
		t := *r.propertyTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "propertyTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "propertyTypesCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIDeleteRoomAmenitiesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	roomAmenitiesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomAmenitiesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIDeleteRoomAmenitiesRequest) Authorization(authorization string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIDeleteRoomAmenitiesRequest) XAppKey(xAppKey string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIDeleteRoomAmenitiesRequest) XHotelid(xHotelid string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIDeleteRoomAmenitiesRequest) RoomAmenitiesCodes(roomAmenitiesCodes []string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	r.roomAmenitiesCodes = &roomAmenitiesCodes
	return r
}

// External system code.
func (r ChainConfigAPIDeleteRoomAmenitiesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIDeleteRoomAmenitiesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIDeleteRoomAmenitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomAmenitiesExecute(r)
}

/*
DeleteRoomAmenities Delete Room Amenities

Use this API to delete Room Amenities. <p><strong>OperationId:</strong>deleteRoomAmenities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomAmenitiesId Unique ID of Room Amenities.
 @return ChainConfigAPIDeleteRoomAmenitiesRequest
*/
func (a *ChainConfigAPIService) DeleteRoomAmenities(ctx context.Context, roomAmenitiesId string) ChainConfigAPIDeleteRoomAmenitiesRequest {
	return ChainConfigAPIDeleteRoomAmenitiesRequest{
		ApiService: a,
		ctx: ctx,
		roomAmenitiesId: roomAmenitiesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) DeleteRoomAmenitiesExecute(r ChainConfigAPIDeleteRoomAmenitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.DeleteRoomAmenities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomAmenities/{roomAmenitiesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomAmenitiesId"+"}", url.PathEscape(parameterValueToString(r.roomAmenitiesId, "roomAmenitiesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomAmenitiesId) < 1 {
		return localVarReturnValue, nil, reportError("roomAmenitiesId must have at least 1 elements")
	}
	if strlen(r.roomAmenitiesId) > 2000 {
		return localVarReturnValue, nil, reportError("roomAmenitiesId must have less than 2000 elements")
	}

	if r.roomAmenitiesCodes != nil {
		t := *r.roomAmenitiesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAmenitiesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAmenitiesCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetAttractionClassesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetAttractionClassesRequest) Authorization(authorization string) ChainConfigAPIGetAttractionClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetAttractionClassesRequest) XAppKey(xAppKey string) ChainConfigAPIGetAttractionClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetAttractionClassesRequest) XHotelid(xHotelid string) ChainConfigAPIGetAttractionClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetAttractionClassesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetAttractionClassesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetAttractionClassesRequest) Codes(codes []string) ChainConfigAPIGetAttractionClassesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetAttractionClassesRequest) WildCard(wildCard string) ChainConfigAPIGetAttractionClassesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetAttractionClassesRequest) Description(description string) ChainConfigAPIGetAttractionClassesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetAttractionClassesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetAttractionClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetAttractionClassesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetAttractionClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetAttractionClassesRequest) Execute() (*AttractionClassesDetails, *http.Response, error) {
	return r.ApiService.GetAttractionClassesExecute(r)
}

/*
GetAttractionClasses Get Attraction Classes

Use this API to get Attraction Classes. <p><strong>OperationId:</strong>getAttractionClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetAttractionClassesRequest
*/
func (a *ChainConfigAPIService) GetAttractionClasses(ctx context.Context) ChainConfigAPIGetAttractionClassesRequest {
	return ChainConfigAPIGetAttractionClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttractionClassesDetails
func (a *ChainConfigAPIService) GetAttractionClassesExecute(r ChainConfigAPIGetAttractionClassesRequest) (*AttractionClassesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttractionClassesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetAttractionClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attractionClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetBrandCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetBrandCodesRequest) Authorization(authorization string) ChainConfigAPIGetBrandCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetBrandCodesRequest) XAppKey(xAppKey string) ChainConfigAPIGetBrandCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetBrandCodesRequest) XHotelid(xHotelid string) ChainConfigAPIGetBrandCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetBrandCodesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetBrandCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetBrandCodesRequest) Codes(codes []string) ChainConfigAPIGetBrandCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetBrandCodesRequest) WildCard(wildCard string) ChainConfigAPIGetBrandCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetBrandCodesRequest) Description(description string) ChainConfigAPIGetBrandCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetBrandCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetBrandCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetBrandCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetBrandCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetBrandCodesRequest) Execute() (*BrandCodesDetails, *http.Response, error) {
	return r.ApiService.GetBrandCodesExecute(r)
}

/*
GetBrandCodes Get brand codes

Use this API to return brand codes based on search criteria such as codes, wildCard, description. Brand codes are used for different hotel brands within a hotel corporation.<p><strong>OperationId:</strong>getBrandCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetBrandCodesRequest
*/
func (a *ChainConfigAPIService) GetBrandCodes(ctx context.Context) ChainConfigAPIGetBrandCodesRequest {
	return ChainConfigAPIGetBrandCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BrandCodesDetails
func (a *ChainConfigAPIService) GetBrandCodesExecute(r ChainConfigAPIGetBrandCodesRequest) (*BrandCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BrandCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetBrandCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brandCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetChainRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	enforceSecurity *bool
	includeActive *bool
	includeInactive *bool
	limit *int32
	chainCodes *[]string
	chainName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetChainRequest) Authorization(authorization string) ChainConfigAPIGetChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetChainRequest) XAppKey(xAppKey string) ChainConfigAPIGetChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetChainRequest) XHotelid(xHotelid string) ChainConfigAPIGetChainRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIGetChainRequest) EnforceSecurity(enforceSecurity bool) ChainConfigAPIGetChainRequest {
	r.enforceSecurity = &enforceSecurity
	return r
}

func (r ChainConfigAPIGetChainRequest) IncludeActive(includeActive bool) ChainConfigAPIGetChainRequest {
	r.includeActive = &includeActive
	return r
}

func (r ChainConfigAPIGetChainRequest) IncludeInactive(includeInactive bool) ChainConfigAPIGetChainRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ChainConfigAPIGetChainRequest) Limit(limit int32) ChainConfigAPIGetChainRequest {
	r.limit = &limit
	return r
}

func (r ChainConfigAPIGetChainRequest) ChainCodes(chainCodes []string) ChainConfigAPIGetChainRequest {
	r.chainCodes = &chainCodes
	return r
}

func (r ChainConfigAPIGetChainRequest) ChainName(chainName string) ChainConfigAPIGetChainRequest {
	r.chainName = &chainName
	return r
}

// External system code.
func (r ChainConfigAPIGetChainRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetChainRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetChainRequest) Execute() (*ChainDetails, *http.Response, error) {
	return r.ApiService.GetChainExecute(r)
}

/*
GetChain Get Chains

Use this API to get Chains. <p><strong>OperationId:</strong>getChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetChainRequest
*/
func (a *ChainConfigAPIService) GetChain(ctx context.Context) ChainConfigAPIGetChainRequest {
	return ChainConfigAPIGetChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChainDetails
func (a *ChainConfigAPIService) GetChainExecute(r ChainConfigAPIGetChainRequest) (*ChainDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChainDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enforceSecurity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enforceSecurity", r.enforceSecurity, "")
  }
	if r.includeActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeActive", r.includeActive, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.chainCodes != nil {
		t := *r.chainCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chainCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chainCodes", t, "multi")
		}
  }
	if r.chainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainName", r.chainName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCommunicationMethodsEntDetailsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) Authorization(authorization string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) XAppKey(xAppKey string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) XHotelid(xHotelid string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) Codes(codes []string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) WildCard(wildCard string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) Description(description string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) Execute() (*CommunicationMethodsEntDetailsDetails, *http.Response, error) {
	return r.ApiService.GetCommunicationMethodsEntDetailsExecute(r)
}

/*
GetCommunicationMethodsEntDetails Get Communication Methods Ent Details

Use this API to get Communication Methods Ent Details. <p><strong>OperationId:</strong>getCommunicationMethodsEntDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCommunicationMethodsEntDetailsRequest
*/
func (a *ChainConfigAPIService) GetCommunicationMethodsEntDetails(ctx context.Context) ChainConfigAPIGetCommunicationMethodsEntDetailsRequest {
	return ChainConfigAPIGetCommunicationMethodsEntDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CommunicationMethodsEntDetailsDetails
func (a *ChainConfigAPIService) GetCommunicationMethodsEntDetailsExecute(r ChainConfigAPIGetCommunicationMethodsEntDetailsRequest) (*CommunicationMethodsEntDetailsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommunicationMethodsEntDetailsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCommunicationMethodsEntDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationMethodsEntDetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCorporateBusinessUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) Authorization(authorization string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) Codes(codes []string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) WildCard(wildCard string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) Description(description string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCorporateBusinessUnitsRequest) Execute() (*CorporateBusinessUnitsDetails, *http.Response, error) {
	return r.ApiService.GetCorporateBusinessUnitsExecute(r)
}

/*
GetCorporateBusinessUnits Get Corporate Business Units

Use this API to get Corporate Business Units. <p><strong>OperationId:</strong>getCorporateBusinessUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCorporateBusinessUnitsRequest
*/
func (a *ChainConfigAPIService) GetCorporateBusinessUnits(ctx context.Context) ChainConfigAPIGetCorporateBusinessUnitsRequest {
	return ChainConfigAPIGetCorporateBusinessUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CorporateBusinessUnitsDetails
func (a *ChainConfigAPIService) GetCorporateBusinessUnitsExecute(r ChainConfigAPIGetCorporateBusinessUnitsRequest) (*CorporateBusinessUnitsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporateBusinessUnitsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCorporateBusinessUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateBusinessUnits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCorporateDepartmentCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) Authorization(authorization string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) XAppKey(xAppKey string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) XHotelid(xHotelid string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) Codes(codes []string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) WildCard(wildCard string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) Description(description string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCorporateDepartmentCodesRequest) Execute() (*CorporateDepartmentCodesDetails, *http.Response, error) {
	return r.ApiService.GetCorporateDepartmentCodesExecute(r)
}

/*
GetCorporateDepartmentCodes Get Corporate Department Codes

Use this API to get Corporate Department Codes. <p><strong>OperationId:</strong>getCorporateDepartmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCorporateDepartmentCodesRequest
*/
func (a *ChainConfigAPIService) GetCorporateDepartmentCodes(ctx context.Context) ChainConfigAPIGetCorporateDepartmentCodesRequest {
	return ChainConfigAPIGetCorporateDepartmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CorporateDepartmentCodesDetails
func (a *ChainConfigAPIService) GetCorporateDepartmentCodesExecute(r ChainConfigAPIGetCorporateDepartmentCodesRequest) (*CorporateDepartmentCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporateDepartmentCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCorporateDepartmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDepartmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCorporateDivisionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCorporateDivisionsRequest) Authorization(authorization string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCorporateDivisionsRequest) XAppKey(xAppKey string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCorporateDivisionsRequest) XHotelid(xHotelid string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCorporateDivisionsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCorporateDivisionsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCorporateDivisionsRequest) Codes(codes []string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCorporateDivisionsRequest) WildCard(wildCard string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCorporateDivisionsRequest) Description(description string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCorporateDivisionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCorporateDivisionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCorporateDivisionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCorporateDivisionsRequest) Execute() (*CorporateDivisionsDetails, *http.Response, error) {
	return r.ApiService.GetCorporateDivisionsExecute(r)
}

/*
GetCorporateDivisions Get Corporate Divisions

Use this API to get Corporate Divisions. <p><strong>OperationId:</strong>getCorporateDivisions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCorporateDivisionsRequest
*/
func (a *ChainConfigAPIService) GetCorporateDivisions(ctx context.Context) ChainConfigAPIGetCorporateDivisionsRequest {
	return ChainConfigAPIGetCorporateDivisionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CorporateDivisionsDetails
func (a *ChainConfigAPIService) GetCorporateDivisionsExecute(r ChainConfigAPIGetCorporateDivisionsRequest) (*CorporateDivisionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporateDivisionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCorporateDivisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDivisions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCorporateOperatingUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) Authorization(authorization string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) Codes(codes []string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) WildCard(wildCard string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) Description(description string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCorporateOperatingUnitsRequest) Execute() (*CorporateOperatingUnitsDetails, *http.Response, error) {
	return r.ApiService.GetCorporateOperatingUnitsExecute(r)
}

/*
GetCorporateOperatingUnits Get Corporate Operating Units

Use this API to get Corporate Operating Units. <p><strong>OperationId:</strong>getCorporateOperatingUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCorporateOperatingUnitsRequest
*/
func (a *ChainConfigAPIService) GetCorporateOperatingUnits(ctx context.Context) ChainConfigAPIGetCorporateOperatingUnitsRequest {
	return ChainConfigAPIGetCorporateOperatingUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CorporateOperatingUnitsDetails
func (a *ChainConfigAPIService) GetCorporateOperatingUnitsExecute(r ChainConfigAPIGetCorporateOperatingUnitsRequest) (*CorporateOperatingUnitsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CorporateOperatingUnitsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCorporateOperatingUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateOperatingUnits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCountryGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCountryGuestTypesRequest) Authorization(authorization string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCountryGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCountryGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCountryGuestTypesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCountryGuestTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCountryGuestTypesRequest) Codes(codes []string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCountryGuestTypesRequest) WildCard(wildCard string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCountryGuestTypesRequest) Description(description string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCountryGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCountryGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCountryGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCountryGuestTypesRequest) Execute() (*CountryGuestTypesDetails, *http.Response, error) {
	return r.ApiService.GetCountryGuestTypesExecute(r)
}

/*
GetCountryGuestTypes Get Country Guest Types

Use this API to get Country Guest Types. <p><strong>OperationId:</strong>getCountryGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCountryGuestTypesRequest
*/
func (a *ChainConfigAPIService) GetCountryGuestTypes(ctx context.Context) ChainConfigAPIGetCountryGuestTypesRequest {
	return ChainConfigAPIGetCountryGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountryGuestTypesDetails
func (a *ChainConfigAPIService) GetCountryGuestTypesExecute(r ChainConfigAPIGetCountryGuestTypesRequest) (*CountryGuestTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryGuestTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCountryGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countries/guestTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetCountryMainGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetCountryMainGroupsRequest) Authorization(authorization string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetCountryMainGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetCountryMainGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetCountryMainGroupsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetCountryMainGroupsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetCountryMainGroupsRequest) Codes(codes []string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetCountryMainGroupsRequest) WildCard(wildCard string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetCountryMainGroupsRequest) Description(description string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetCountryMainGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetCountryMainGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetCountryMainGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetCountryMainGroupsRequest) Execute() (*CountryMainGroupsDetails, *http.Response, error) {
	return r.ApiService.GetCountryMainGroupsExecute(r)
}

/*
GetCountryMainGroups Get Country Main Groups

Use this API to get Country Main Groups. <p><strong>OperationId:</strong>getCountryMainGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetCountryMainGroupsRequest
*/
func (a *ChainConfigAPIService) GetCountryMainGroups(ctx context.Context) ChainConfigAPIGetCountryMainGroupsRequest {
	return ChainConfigAPIGetCountryMainGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountryMainGroupsDetails
func (a *ChainConfigAPIService) GetCountryMainGroupsExecute(r ChainConfigAPIGetCountryMainGroupsRequest) (*CountryMainGroupsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryMainGroupsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetCountryMainGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countryMainGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetDefaultNoteRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	noteType *string
	noteCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetDefaultNoteRequest) Authorization(authorization string) ChainConfigAPIGetDefaultNoteRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetDefaultNoteRequest) XAppKey(xAppKey string) ChainConfigAPIGetDefaultNoteRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetDefaultNoteRequest) XHotelid(xHotelid string) ChainConfigAPIGetDefaultNoteRequest {
	r.xHotelid = &xHotelid
	return r
}

// Default Hotel Code for users
func (r ChainConfigAPIGetDefaultNoteRequest) HotelId(hotelId string) ChainConfigAPIGetDefaultNoteRequest {
	r.hotelId = &hotelId
	return r
}

// Notes Group added to Search criteria
func (r ChainConfigAPIGetDefaultNoteRequest) NoteType(noteType string) ChainConfigAPIGetDefaultNoteRequest {
	r.noteType = &noteType
	return r
}

// Code of the Note Type added to the Search criteria
func (r ChainConfigAPIGetDefaultNoteRequest) NoteCode(noteCode string) ChainConfigAPIGetDefaultNoteRequest {
	r.noteCode = &noteCode
	return r
}

// External system code.
func (r ChainConfigAPIGetDefaultNoteRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetDefaultNoteRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetDefaultNoteRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetDefaultNoteRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetDefaultNoteRequest) Execute() (*DefaultNoteDetails, *http.Response, error) {
	return r.ApiService.GetDefaultNoteExecute(r)
}

/*
GetDefaultNote Get Default Note text

Use this API to get Default Note text. <p><strong>OperationId:</strong>getDefaultNote</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetDefaultNoteRequest
*/
func (a *ChainConfigAPIService) GetDefaultNote(ctx context.Context) ChainConfigAPIGetDefaultNoteRequest {
	return ChainConfigAPIGetDefaultNoteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefaultNoteDetails
func (a *ChainConfigAPIService) GetDefaultNoteExecute(r ChainConfigAPIGetDefaultNoteRequest) (*DefaultNoteDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefaultNoteDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetDefaultNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/defaultNote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.noteType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteType", r.noteType, "")
  }
	if r.noteCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteCode", r.noteCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetFlexFieldRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	flexFieldId float32
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetFlexFieldRequest) Authorization(authorization string) ChainConfigAPIGetFlexFieldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetFlexFieldRequest) XAppKey(xAppKey string) ChainConfigAPIGetFlexFieldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetFlexFieldRequest) XHotelid(xHotelid string) ChainConfigAPIGetFlexFieldRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIGetFlexFieldRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetFlexFieldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetFlexFieldRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetFlexFieldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetFlexFieldRequest) Execute() (*FlexFieldCriteria, *http.Response, error) {
	return r.ApiService.GetFlexFieldExecute(r)
}

/*
GetFlexField Operation to fetch the flex field details.

API to fetch the flex field details.<br><p><strong></strong></p> <p><strong>OperationId:</strong>getFlexField</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flexFieldId Flex Field ID
 @param hotelId Unique ID of the hotel in OPERA
 @return ChainConfigAPIGetFlexFieldRequest
*/
func (a *ChainConfigAPIService) GetFlexField(ctx context.Context, flexFieldId float32, hotelId string) ChainConfigAPIGetFlexFieldRequest {
	return ChainConfigAPIGetFlexFieldRequest{
		ApiService: a,
		ctx: ctx,
		flexFieldId: flexFieldId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FlexFieldCriteria
func (a *ChainConfigAPIService) GetFlexFieldExecute(r ChainConfigAPIGetFlexFieldRequest) (*FlexFieldCriteria, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlexFieldCriteria
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetFlexField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/flexFields/{flexFieldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"flexFieldId"+"}", url.PathEscape(parameterValueToString(r.flexFieldId, "flexFieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetFlexFieldsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	flexFieldId *float32
	code *string
	module *string
	fetchInactive *bool
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetFlexFieldsRequest) Authorization(authorization string) ChainConfigAPIGetFlexFieldsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetFlexFieldsRequest) XAppKey(xAppKey string) ChainConfigAPIGetFlexFieldsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetFlexFieldsRequest) XHotelid(xHotelid string) ChainConfigAPIGetFlexFieldsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code
func (r ChainConfigAPIGetFlexFieldsRequest) HotelIds(hotelIds []string) ChainConfigAPIGetFlexFieldsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Flex field ID
func (r ChainConfigAPIGetFlexFieldsRequest) FlexFieldId(flexFieldId float32) ChainConfigAPIGetFlexFieldsRequest {
	r.flexFieldId = &flexFieldId
	return r
}

// Flex field code
func (r ChainConfigAPIGetFlexFieldsRequest) Code(code string) ChainConfigAPIGetFlexFieldsRequest {
	r.code = &code
	return r
}

// Flex field module
func (r ChainConfigAPIGetFlexFieldsRequest) Module(module string) ChainConfigAPIGetFlexFieldsRequest {
	r.module = &module
	return r
}

// Determines whether to fetch inactive records or not
func (r ChainConfigAPIGetFlexFieldsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetFlexFieldsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Indicates maximum number of records a Web Service should return. Default is 50
func (r ChainConfigAPIGetFlexFieldsRequest) Limit(limit int32) ChainConfigAPIGetFlexFieldsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ChainConfigAPIGetFlexFieldsRequest) Offset(offset int32) ChainConfigAPIGetFlexFieldsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r ChainConfigAPIGetFlexFieldsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetFlexFieldsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetFlexFieldsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetFlexFieldsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetFlexFieldsRequest) Execute() (*FlexFieldsResponse, *http.Response, error) {
	return r.ApiService.GetFlexFieldsExecute(r)
}

/*
GetFlexFields Operation to fetch flex fields.

API to fetch flex fields. <p><strong>OperationId:</strong>getFlexFields</p> <p>The maximum allowable limit for this API is <strong>50</strong>.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetFlexFieldsRequest
*/
func (a *ChainConfigAPIService) GetFlexFields(ctx context.Context) ChainConfigAPIGetFlexFieldsRequest {
	return ChainConfigAPIGetFlexFieldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlexFieldsResponse
func (a *ChainConfigAPIService) GetFlexFieldsExecute(r ChainConfigAPIGetFlexFieldsRequest) (*FlexFieldsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlexFieldsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetFlexFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flexFields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.flexFieldId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flexFieldId", r.flexFieldId, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
  }
	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetHotelCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetHotelCategoriesRequest) Authorization(authorization string) ChainConfigAPIGetHotelCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetHotelCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIGetHotelCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetHotelCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIGetHotelCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetHotelCategoriesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetHotelCategoriesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetHotelCategoriesRequest) Codes(codes []string) ChainConfigAPIGetHotelCategoriesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetHotelCategoriesRequest) WildCard(wildCard string) ChainConfigAPIGetHotelCategoriesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetHotelCategoriesRequest) Description(description string) ChainConfigAPIGetHotelCategoriesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetHotelCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetHotelCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetHotelCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetHotelCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetHotelCategoriesRequest) Execute() (*HotelCategoriesDetails, *http.Response, error) {
	return r.ApiService.GetHotelCategoriesExecute(r)
}

/*
GetHotelCategories Get Hotel Categories

. <p><strong>OperationId:</strong>getHotelCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetHotelCategoriesRequest
*/
func (a *ChainConfigAPIService) GetHotelCategories(ctx context.Context) ChainConfigAPIGetHotelCategoriesRequest {
	return ChainConfigAPIGetHotelCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HotelCategoriesDetails
func (a *ChainConfigAPIService) GetHotelCategoriesExecute(r ChainConfigAPIGetHotelCategoriesRequest) (*HotelCategoriesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelCategoriesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetHotelCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetMarketingCitiesByRegionRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	regionCode *string
	marketingCity *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) Authorization(authorization string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) XAppKey(xAppKey string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) XHotelid(xHotelid string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Region Code
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) RegionCode(regionCode string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.regionCode = &regionCode
	return r
}

// Marketing City
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) MarketingCity(marketingCity string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.marketingCity = &marketingCity
	return r
}

// External system code.
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetMarketingCitiesByRegionRequest) Execute() (*MarketingCitiesByRegionDetails, *http.Response, error) {
	return r.ApiService.GetMarketingCitiesByRegionExecute(r)
}

/*
GetMarketingCitiesByRegion Get marketing cities by region

Use this API to get marketing cities by region. <p><strong>OperationId:</strong>getMarketingCitiesByRegion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetMarketingCitiesByRegionRequest
*/
func (a *ChainConfigAPIService) GetMarketingCitiesByRegion(ctx context.Context) ChainConfigAPIGetMarketingCitiesByRegionRequest {
	return ChainConfigAPIGetMarketingCitiesByRegionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarketingCitiesByRegionDetails
func (a *ChainConfigAPIService) GetMarketingCitiesByRegionExecute(r ChainConfigAPIGetMarketingCitiesByRegionRequest) (*MarketingCitiesByRegionDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarketingCitiesByRegionDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetMarketingCitiesByRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketingCitiesByRegion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.regionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionCode", r.regionCode, "")
  }
	if r.marketingCity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketingCity", r.marketingCity, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetMarketingRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetMarketingRegionsRequest) Authorization(authorization string) ChainConfigAPIGetMarketingRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetMarketingRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIGetMarketingRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetMarketingRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIGetMarketingRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetMarketingRegionsRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetMarketingRegionsRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetMarketingRegionsRequest) Codes(codes []string) ChainConfigAPIGetMarketingRegionsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetMarketingRegionsRequest) WildCard(wildCard string) ChainConfigAPIGetMarketingRegionsRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetMarketingRegionsRequest) Description(description string) ChainConfigAPIGetMarketingRegionsRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetMarketingRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetMarketingRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetMarketingRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetMarketingRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetMarketingRegionsRequest) Execute() (*MarketingRegionsDetails, *http.Response, error) {
	return r.ApiService.GetMarketingRegionsExecute(r)
}

/*
GetMarketingRegions Get Marketing Regions

Use this API to get Marketing Regions. <p><strong>OperationId:</strong>getMarketingRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetMarketingRegionsRequest
*/
func (a *ChainConfigAPIService) GetMarketingRegions(ctx context.Context) ChainConfigAPIGetMarketingRegionsRequest {
	return ChainConfigAPIGetMarketingRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarketingRegionsDetails
func (a *ChainConfigAPIService) GetMarketingRegionsExecute(r ChainConfigAPIGetMarketingRegionsRequest) (*MarketingRegionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarketingRegionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetMarketingRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketingRegions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetNoteTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	noteGroup *string
	includeInactive *bool
	includeDepartmentDetails *bool
	noteCode *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetNoteTypesRequest) Authorization(authorization string) ChainConfigAPIGetNoteTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetNoteTypesRequest) XAppKey(xAppKey string) ChainConfigAPIGetNoteTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetNoteTypesRequest) XHotelid(xHotelid string) ChainConfigAPIGetNoteTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Notes Group added to the search criteria.
func (r ChainConfigAPIGetNoteTypesRequest) NoteGroup(noteGroup string) ChainConfigAPIGetNoteTypesRequest {
	r.noteGroup = &noteGroup
	return r
}

// If true this boolean will set the criteria to only return Inactive records.
func (r ChainConfigAPIGetNoteTypesRequest) IncludeInactive(includeInactive bool) ChainConfigAPIGetNoteTypesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Boolean flag to fetch note types with/without departments. &#39;True&#39; indicates including departments information for corresponding note types.
func (r ChainConfigAPIGetNoteTypesRequest) IncludeDepartmentDetails(includeDepartmentDetails bool) ChainConfigAPIGetNoteTypesRequest {
	r.includeDepartmentDetails = &includeDepartmentDetails
	return r
}

// Code of the Note Type.
func (r ChainConfigAPIGetNoteTypesRequest) NoteCode(noteCode string) ChainConfigAPIGetNoteTypesRequest {
	r.noteCode = &noteCode
	return r
}

func (r ChainConfigAPIGetNoteTypesRequest) Codes(codes []string) ChainConfigAPIGetNoteTypesRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r ChainConfigAPIGetNoteTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetNoteTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetNoteTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetNoteTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetNoteTypesRequest) Execute() (*NoteTypesDetails, *http.Response, error) {
	return r.ApiService.GetNoteTypesExecute(r)
}

/*
GetNoteTypes Get Note Types

Use this API to get Note Types. <p><strong>OperationId:</strong>getNoteTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetNoteTypesRequest
*/
func (a *ChainConfigAPIService) GetNoteTypes(ctx context.Context) ChainConfigAPIGetNoteTypesRequest {
	return ChainConfigAPIGetNoteTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NoteTypesDetails
func (a *ChainConfigAPIService) GetNoteTypesExecute(r ChainConfigAPIGetNoteTypesRequest) (*NoteTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NoteTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetNoteTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noteTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.noteGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteGroup", r.noteGroup, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.includeDepartmentDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDepartmentDetails", r.includeDepartmentDetails, "")
  }
	if r.noteCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteCode", r.noteCode, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetPropertyDetailCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) Authorization(authorization string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) Codes(codes []string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) WildCard(wildCard string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) Description(description string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetPropertyDetailCategoriesRequest) Execute() (*PropertyDetailCategoriesDetails, *http.Response, error) {
	return r.ApiService.GetPropertyDetailCategoriesExecute(r)
}

/*
GetPropertyDetailCategories Get Property Detail Categories

Use this API to get Property Detail Categories. <p><strong>OperationId:</strong>getPropertyDetailCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetPropertyDetailCategoriesRequest
*/
func (a *ChainConfigAPIService) GetPropertyDetailCategories(ctx context.Context) ChainConfigAPIGetPropertyDetailCategoriesRequest {
	return ChainConfigAPIGetPropertyDetailCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PropertyDetailCategoriesDetails
func (a *ChainConfigAPIService) GetPropertyDetailCategoriesExecute(r ChainConfigAPIGetPropertyDetailCategoriesRequest) (*PropertyDetailCategoriesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PropertyDetailCategoriesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetPropertyDetailCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyDetailsCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetPropertyTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetPropertyTypesRequest) Authorization(authorization string) ChainConfigAPIGetPropertyTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetPropertyTypesRequest) XAppKey(xAppKey string) ChainConfigAPIGetPropertyTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetPropertyTypesRequest) XHotelid(xHotelid string) ChainConfigAPIGetPropertyTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetPropertyTypesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetPropertyTypesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetPropertyTypesRequest) Codes(codes []string) ChainConfigAPIGetPropertyTypesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetPropertyTypesRequest) WildCard(wildCard string) ChainConfigAPIGetPropertyTypesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetPropertyTypesRequest) Description(description string) ChainConfigAPIGetPropertyTypesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetPropertyTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetPropertyTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetPropertyTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetPropertyTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetPropertyTypesRequest) Execute() (*PropertyTypesDetails, *http.Response, error) {
	return r.ApiService.GetPropertyTypesExecute(r)
}

/*
GetPropertyTypes Get property types

Use this API to get Property Types based on search criteria such as codes, wildCard, description.  Property types are used for different hotel types i.e. Resort, Business, CityCenter, Motel, BedAndBreakfast.<p><strong>OperationId:</strong>getPropertyTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetPropertyTypesRequest
*/
func (a *ChainConfigAPIService) GetPropertyTypes(ctx context.Context) ChainConfigAPIGetPropertyTypesRequest {
	return ChainConfigAPIGetPropertyTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PropertyTypesDetails
func (a *ChainConfigAPIService) GetPropertyTypesExecute(r ChainConfigAPIGetPropertyTypesRequest) (*PropertyTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PropertyTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetPropertyTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetRegionsCodeRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetRegionsCodeRequest) Authorization(authorization string) ChainConfigAPIGetRegionsCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetRegionsCodeRequest) XAppKey(xAppKey string) ChainConfigAPIGetRegionsCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetRegionsCodeRequest) XHotelid(xHotelid string) ChainConfigAPIGetRegionsCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetRegionsCodeRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetRegionsCodeRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetRegionsCodeRequest) Codes(codes []string) ChainConfigAPIGetRegionsCodeRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetRegionsCodeRequest) WildCard(wildCard string) ChainConfigAPIGetRegionsCodeRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetRegionsCodeRequest) Description(description string) ChainConfigAPIGetRegionsCodeRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetRegionsCodeRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetRegionsCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetRegionsCodeRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetRegionsCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetRegionsCodeRequest) Execute() (*RegionsCodeDetails, *http.Response, error) {
	return r.ApiService.GetRegionsCodeExecute(r)
}

/*
GetRegionsCode Get Regions Code

Use this API to get Regions Code. <p><strong>OperationId:</strong>getRegionsCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetRegionsCodeRequest
*/
func (a *ChainConfigAPIService) GetRegionsCode(ctx context.Context) ChainConfigAPIGetRegionsCodeRequest {
	return ChainConfigAPIGetRegionsCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegionsCodeDetails
func (a *ChainConfigAPIService) GetRegionsCodeExecute(r ChainConfigAPIGetRegionsCodeRequest) (*RegionsCodeDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegionsCodeDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetRegionsCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/regionCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetRoomAmenitiesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetRoomAmenitiesRequest) Authorization(authorization string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetRoomAmenitiesRequest) XAppKey(xAppKey string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetRoomAmenitiesRequest) XHotelid(xHotelid string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetRoomAmenitiesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetRoomAmenitiesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetRoomAmenitiesRequest) Codes(codes []string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetRoomAmenitiesRequest) WildCard(wildCard string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetRoomAmenitiesRequest) Description(description string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetRoomAmenitiesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetRoomAmenitiesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetRoomAmenitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetRoomAmenitiesRequest) Execute() (*RoomAmenitiesDetails, *http.Response, error) {
	return r.ApiService.GetRoomAmenitiesExecute(r)
}

/*
GetRoomAmenities Get Room Amenities

Use this API to get Room Amenities. <p><strong>OperationId:</strong>getRoomAmenities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetRoomAmenitiesRequest
*/
func (a *ChainConfigAPIService) GetRoomAmenities(ctx context.Context) ChainConfigAPIGetRoomAmenitiesRequest {
	return ChainConfigAPIGetRoomAmenitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoomAmenitiesDetails
func (a *ChainConfigAPIService) GetRoomAmenitiesExecute(r ChainConfigAPIGetRoomAmenitiesRequest) (*RoomAmenitiesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomAmenitiesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetRoomAmenities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomAmenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetTemplateCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetTemplateCodesRequest) Authorization(authorization string) ChainConfigAPIGetTemplateCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetTemplateCodesRequest) XAppKey(xAppKey string) ChainConfigAPIGetTemplateCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetTemplateCodesRequest) XHotelid(xHotelid string) ChainConfigAPIGetTemplateCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r ChainConfigAPIGetTemplateCodesRequest) FetchInactive(fetchInactive bool) ChainConfigAPIGetTemplateCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r ChainConfigAPIGetTemplateCodesRequest) Codes(codes []string) ChainConfigAPIGetTemplateCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ChainConfigAPIGetTemplateCodesRequest) WildCard(wildCard string) ChainConfigAPIGetTemplateCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r ChainConfigAPIGetTemplateCodesRequest) Description(description string) ChainConfigAPIGetTemplateCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r ChainConfigAPIGetTemplateCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetTemplateCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetTemplateCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetTemplateCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetTemplateCodesRequest) Execute() (*TemplateCodesDetails, *http.Response, error) {
	return r.ApiService.GetTemplateCodesExecute(r)
}

/*
GetTemplateCodes  Get Template Codes

 Use this API to get Template Codes. <p><strong>OperationId:</strong>getTemplateCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetTemplateCodesRequest
*/
func (a *ChainConfigAPIService) GetTemplateCodes(ctx context.Context) ChainConfigAPIGetTemplateCodesRequest {
	return ChainConfigAPIGetTemplateCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateCodesDetails
func (a *ChainConfigAPIService) GetTemplateCodesExecute(r ChainConfigAPIGetTemplateCodesRequest) (*TemplateCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetTemplateCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetUserDefinedFieldGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	groupCodes *[]string
	descriptionWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) Authorization(authorization string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Identifier for the User Defined Field Group
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) GroupCodes(groupCodes []string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.groupCodes = &groupCodes
	return r
}

// Specifies the user defined field description to search.
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) DescriptionWildCard(descriptionWildCard string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// External system code.
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetUserDefinedFieldGroupsRequest) Execute() (*UserDefinedFieldGroupsDetails, *http.Response, error) {
	return r.ApiService.GetUserDefinedFieldGroupsExecute(r)
}

/*
GetUserDefinedFieldGroups Get User Defined Field Groups

Use this API to get User Defined Field Groups. <p><strong>OperationId:</strong>getUserDefinedFieldGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetUserDefinedFieldGroupsRequest
*/
func (a *ChainConfigAPIService) GetUserDefinedFieldGroups(ctx context.Context) ChainConfigAPIGetUserDefinedFieldGroupsRequest {
	return ChainConfigAPIGetUserDefinedFieldGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserDefinedFieldGroupsDetails
func (a *ChainConfigAPIService) GetUserDefinedFieldGroupsExecute(r ChainConfigAPIGetUserDefinedFieldGroupsRequest) (*UserDefinedFieldGroupsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDefinedFieldGroupsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetUserDefinedFieldGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupCodes != nil {
		t := *r.groupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "groupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "groupCodes", t, "multi")
		}
  }
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIGetUserDefinedFieldValuesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	groupCode *string
	valueCodes *[]string
	descriptionWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) Authorization(authorization string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) XAppKey(xAppKey string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) XHotelid(xHotelid string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Group Code which the User Defined Field Value belongs to.
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) GroupCode(groupCode string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.groupCode = &groupCode
	return r
}

func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) ValueCodes(valueCodes []string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.valueCodes = &valueCodes
	return r
}

// Specifies the User Defined Field Value description to search.
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) DescriptionWildCard(descriptionWildCard string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// External system code.
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIGetUserDefinedFieldValuesRequest) Execute() (*UserDefinedFieldValuesDetails, *http.Response, error) {
	return r.ApiService.GetUserDefinedFieldValuesExecute(r)
}

/*
GetUserDefinedFieldValues Get user defined field (UDF) values

Use this API to return User Defined Field (UDF) Values based on search criteria such as groupCode, valueCode, descriptionWildCard.  The LOV Group and LOV Values functionality allows a property to create a custom group of values to be used in a specified user defined field (UDF). This functionality provides added flexibility in allowing a site to track information or details that are specific to their business and outside of the standard fields offered in OPERA Cloud.<p><strong>OperationId:</strong>getUserDefinedFieldValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIGetUserDefinedFieldValuesRequest
*/
func (a *ChainConfigAPIService) GetUserDefinedFieldValues(ctx context.Context) ChainConfigAPIGetUserDefinedFieldValuesRequest {
	return ChainConfigAPIGetUserDefinedFieldValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserDefinedFieldValuesDetails
func (a *ChainConfigAPIService) GetUserDefinedFieldValuesExecute(r ChainConfigAPIGetUserDefinedFieldValuesRequest) (*UserDefinedFieldValuesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDefinedFieldValuesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.GetUserDefinedFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupCode", r.groupCode, "")
  }
	if r.valueCodes != nil {
		t := *r.valueCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "valueCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "valueCodes", t, "multi")
		}
  }
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostAttractionClassesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	attractionClassesCriteria *AttractionClassesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostAttractionClassesRequest) Authorization(authorization string) ChainConfigAPIPostAttractionClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostAttractionClassesRequest) XAppKey(xAppKey string) ChainConfigAPIPostAttractionClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostAttractionClassesRequest) XHotelid(xHotelid string) ChainConfigAPIPostAttractionClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Attraction Classes.
func (r ChainConfigAPIPostAttractionClassesRequest) AttractionClassesCriteria(attractionClassesCriteria AttractionClassesCriteria) ChainConfigAPIPostAttractionClassesRequest {
	r.attractionClassesCriteria = &attractionClassesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostAttractionClassesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostAttractionClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostAttractionClassesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostAttractionClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostAttractionClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAttractionClassesExecute(r)
}

/*
PostAttractionClasses Create Attraction Classes

Use this API to create Attraction Classes. <p><strong>OperationId:</strong>postAttractionClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostAttractionClassesRequest
*/
func (a *ChainConfigAPIService) PostAttractionClasses(ctx context.Context) ChainConfigAPIPostAttractionClassesRequest {
	return ChainConfigAPIPostAttractionClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostAttractionClassesExecute(r ChainConfigAPIPostAttractionClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostAttractionClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attractionClasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attractionClassesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostBrandCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	brandCodesCriteria *BrandCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostBrandCodesRequest) Authorization(authorization string) ChainConfigAPIPostBrandCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostBrandCodesRequest) XAppKey(xAppKey string) ChainConfigAPIPostBrandCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostBrandCodesRequest) XHotelid(xHotelid string) ChainConfigAPIPostBrandCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Brand Codes.
func (r ChainConfigAPIPostBrandCodesRequest) BrandCodesCriteria(brandCodesCriteria BrandCodesCriteria) ChainConfigAPIPostBrandCodesRequest {
	r.brandCodesCriteria = &brandCodesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostBrandCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostBrandCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostBrandCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostBrandCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostBrandCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBrandCodesExecute(r)
}

/*
PostBrandCodes Create Brand Codes

Use this API to create Brand Codes. <p><strong>OperationId:</strong>postBrandCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostBrandCodesRequest
*/
func (a *ChainConfigAPIService) PostBrandCodes(ctx context.Context) ChainConfigAPIPostBrandCodesRequest {
	return ChainConfigAPIPostBrandCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostBrandCodesExecute(r ChainConfigAPIPostBrandCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostBrandCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brandCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.brandCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCommunicationMethodsEntDetailsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationMethodsEntDetailsCriteria *CommunicationMethodsEntDetailsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) Authorization(authorization string) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) XAppKey(xAppKey string) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) XHotelid(xHotelid string) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Communication Methods Ent Details.
func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) CommunicationMethodsEntDetailsCriteria(communicationMethodsEntDetailsCriteria CommunicationMethodsEntDetailsCriteria) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	r.communicationMethodsEntDetailsCriteria = &communicationMethodsEntDetailsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCommunicationMethodsEntDetailsExecute(r)
}

/*
PostCommunicationMethodsEntDetails Create Communication Methods Ent Details

Use this API to create Communication Methods Ent Details. <p><strong>OperationId:</strong>postCommunicationMethodsEntDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCommunicationMethodsEntDetailsRequest
*/
func (a *ChainConfigAPIService) PostCommunicationMethodsEntDetails(ctx context.Context) ChainConfigAPIPostCommunicationMethodsEntDetailsRequest {
	return ChainConfigAPIPostCommunicationMethodsEntDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCommunicationMethodsEntDetailsExecute(r ChainConfigAPIPostCommunicationMethodsEntDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCommunicationMethodsEntDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationMethodsEntDetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.communicationMethodsEntDetailsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCorporateBusinessUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateBusinessUnitsCriteria *CorporateBusinessUnitsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) Authorization(authorization string) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Corporate Business Units.
func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) CorporateBusinessUnitsCriteria(corporateBusinessUnitsCriteria CorporateBusinessUnitsCriteria) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	r.corporateBusinessUnitsCriteria = &corporateBusinessUnitsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCorporateBusinessUnitsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCorporateBusinessUnitsExecute(r)
}

/*
PostCorporateBusinessUnits Create Corporate Business Units

Use this API to create Corporate Business Units. <p><strong>OperationId:</strong>postCorporateBusinessUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCorporateBusinessUnitsRequest
*/
func (a *ChainConfigAPIService) PostCorporateBusinessUnits(ctx context.Context) ChainConfigAPIPostCorporateBusinessUnitsRequest {
	return ChainConfigAPIPostCorporateBusinessUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCorporateBusinessUnitsExecute(r ChainConfigAPIPostCorporateBusinessUnitsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCorporateBusinessUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateBusinessUnits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateBusinessUnitsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCorporateDepartmentCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateDepartmentCodesCriteria *CorporateDepartmentCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) Authorization(authorization string) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) XAppKey(xAppKey string) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) XHotelid(xHotelid string) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Corporate Department Codes.
func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) CorporateDepartmentCodesCriteria(corporateDepartmentCodesCriteria CorporateDepartmentCodesCriteria) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	r.corporateDepartmentCodesCriteria = &corporateDepartmentCodesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCorporateDepartmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCorporateDepartmentCodesExecute(r)
}

/*
PostCorporateDepartmentCodes Create Corporate Department Codes

Use this API to create Corporate Department Codes. <p><strong>OperationId:</strong>postCorporateDepartmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCorporateDepartmentCodesRequest
*/
func (a *ChainConfigAPIService) PostCorporateDepartmentCodes(ctx context.Context) ChainConfigAPIPostCorporateDepartmentCodesRequest {
	return ChainConfigAPIPostCorporateDepartmentCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCorporateDepartmentCodesExecute(r ChainConfigAPIPostCorporateDepartmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCorporateDepartmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDepartmentCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateDepartmentCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCorporateDivisionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateDivisionsCriteria *CorporateDivisionsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCorporateDivisionsRequest) Authorization(authorization string) ChainConfigAPIPostCorporateDivisionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCorporateDivisionsRequest) XAppKey(xAppKey string) ChainConfigAPIPostCorporateDivisionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCorporateDivisionsRequest) XHotelid(xHotelid string) ChainConfigAPIPostCorporateDivisionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Corporate Divisions.
func (r ChainConfigAPIPostCorporateDivisionsRequest) CorporateDivisionsCriteria(corporateDivisionsCriteria CorporateDivisionsCriteria) ChainConfigAPIPostCorporateDivisionsRequest {
	r.corporateDivisionsCriteria = &corporateDivisionsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCorporateDivisionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCorporateDivisionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCorporateDivisionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCorporateDivisionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCorporateDivisionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCorporateDivisionsExecute(r)
}

/*
PostCorporateDivisions Create Corporate Divisions

Use this API to create Corporate Divisions. <p><strong>OperationId:</strong>postCorporateDivisions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCorporateDivisionsRequest
*/
func (a *ChainConfigAPIService) PostCorporateDivisions(ctx context.Context) ChainConfigAPIPostCorporateDivisionsRequest {
	return ChainConfigAPIPostCorporateDivisionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCorporateDivisionsExecute(r ChainConfigAPIPostCorporateDivisionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCorporateDivisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDivisions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateDivisionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCorporateOperatingUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateOperatingUnitsCriteria *CorporateOperatingUnitsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) Authorization(authorization string) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Corporate Operating Units.
func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) CorporateOperatingUnitsCriteria(corporateOperatingUnitsCriteria CorporateOperatingUnitsCriteria) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	r.corporateOperatingUnitsCriteria = &corporateOperatingUnitsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCorporateOperatingUnitsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCorporateOperatingUnitsExecute(r)
}

/*
PostCorporateOperatingUnits Create Corporate Operating Units

Use this API to create Corporate Operating Units. <p><strong>OperationId:</strong>postCorporateOperatingUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCorporateOperatingUnitsRequest
*/
func (a *ChainConfigAPIService) PostCorporateOperatingUnits(ctx context.Context) ChainConfigAPIPostCorporateOperatingUnitsRequest {
	return ChainConfigAPIPostCorporateOperatingUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCorporateOperatingUnitsExecute(r ChainConfigAPIPostCorporateOperatingUnitsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCorporateOperatingUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateOperatingUnits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.corporateOperatingUnitsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCountryGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	countryGuestTypesCriteria *CountryGuestTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCountryGuestTypesRequest) Authorization(authorization string) ChainConfigAPIPostCountryGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCountryGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPostCountryGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCountryGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPostCountryGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Country Guest Types.
func (r ChainConfigAPIPostCountryGuestTypesRequest) CountryGuestTypesCriteria(countryGuestTypesCriteria CountryGuestTypesCriteria) ChainConfigAPIPostCountryGuestTypesRequest {
	r.countryGuestTypesCriteria = &countryGuestTypesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCountryGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCountryGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCountryGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCountryGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCountryGuestTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCountryGuestTypesExecute(r)
}

/*
PostCountryGuestTypes Create Country Guest Types

Use this API to create Country Guest Types. <p><strong>OperationId:</strong>postCountryGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCountryGuestTypesRequest
*/
func (a *ChainConfigAPIService) PostCountryGuestTypes(ctx context.Context) ChainConfigAPIPostCountryGuestTypesRequest {
	return ChainConfigAPIPostCountryGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCountryGuestTypesExecute(r ChainConfigAPIPostCountryGuestTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCountryGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countries/guestTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.countryGuestTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostCountryMainGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	countryMainGroupsCriteria *CountryMainGroupsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostCountryMainGroupsRequest) Authorization(authorization string) ChainConfigAPIPostCountryMainGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostCountryMainGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIPostCountryMainGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostCountryMainGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIPostCountryMainGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Country Main Groups.
func (r ChainConfigAPIPostCountryMainGroupsRequest) CountryMainGroupsCriteria(countryMainGroupsCriteria CountryMainGroupsCriteria) ChainConfigAPIPostCountryMainGroupsRequest {
	r.countryMainGroupsCriteria = &countryMainGroupsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostCountryMainGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostCountryMainGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostCountryMainGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostCountryMainGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostCountryMainGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCountryMainGroupsExecute(r)
}

/*
PostCountryMainGroups Create Country Main Groups

Use this API to create Country Main Groups. <p><strong>OperationId:</strong>postCountryMainGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostCountryMainGroupsRequest
*/
func (a *ChainConfigAPIService) PostCountryMainGroups(ctx context.Context) ChainConfigAPIPostCountryMainGroupsRequest {
	return ChainConfigAPIPostCountryMainGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostCountryMainGroupsExecute(r ChainConfigAPIPostCountryMainGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostCountryMainGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countryMainGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.countryMainGroupsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostFlexFieldRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	flexFieldDetail *FlexFieldCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostFlexFieldRequest) Authorization(authorization string) ChainConfigAPIPostFlexFieldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostFlexFieldRequest) XAppKey(xAppKey string) ChainConfigAPIPostFlexFieldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostFlexFieldRequest) XHotelid(xHotelid string) ChainConfigAPIPostFlexFieldRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create a new flex field
func (r ChainConfigAPIPostFlexFieldRequest) FlexFieldDetail(flexFieldDetail FlexFieldCriteria) ChainConfigAPIPostFlexFieldRequest {
	r.flexFieldDetail = &flexFieldDetail
	return r
}

// External system code.
func (r ChainConfigAPIPostFlexFieldRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostFlexFieldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostFlexFieldRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostFlexFieldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostFlexFieldRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFlexFieldExecute(r)
}

/*
PostFlexField Operation to create a flex field.

Operation to create a flex field. <p><strong>OperationId:</strong>postFlexField</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostFlexFieldRequest
*/
func (a *ChainConfigAPIService) PostFlexField(ctx context.Context) ChainConfigAPIPostFlexFieldRequest {
	return ChainConfigAPIPostFlexFieldRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostFlexFieldExecute(r ChainConfigAPIPostFlexFieldRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostFlexField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flexFields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.flexFieldDetail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostHotelCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelCategoriesCriteria *HotelCategoriesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostHotelCategoriesRequest) Authorization(authorization string) ChainConfigAPIPostHotelCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostHotelCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIPostHotelCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostHotelCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIPostHotelCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Hotel Categories.
func (r ChainConfigAPIPostHotelCategoriesRequest) HotelCategoriesCriteria(hotelCategoriesCriteria HotelCategoriesCriteria) ChainConfigAPIPostHotelCategoriesRequest {
	r.hotelCategoriesCriteria = &hotelCategoriesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostHotelCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostHotelCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostHotelCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostHotelCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostHotelCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelCategoriesExecute(r)
}

/*
PostHotelCategories Create Hotel Categories

. <p><strong>OperationId:</strong>postHotelCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostHotelCategoriesRequest
*/
func (a *ChainConfigAPIService) PostHotelCategories(ctx context.Context) ChainConfigAPIPostHotelCategoriesRequest {
	return ChainConfigAPIPostHotelCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostHotelCategoriesExecute(r ChainConfigAPIPostHotelCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostHotelCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelCategoriesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostMarketingRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	marketingRegionsCriteria *MarketingRegionsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostMarketingRegionsRequest) Authorization(authorization string) ChainConfigAPIPostMarketingRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostMarketingRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIPostMarketingRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostMarketingRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIPostMarketingRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Marketing Regions.
func (r ChainConfigAPIPostMarketingRegionsRequest) MarketingRegionsCriteria(marketingRegionsCriteria MarketingRegionsCriteria) ChainConfigAPIPostMarketingRegionsRequest {
	r.marketingRegionsCriteria = &marketingRegionsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostMarketingRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostMarketingRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostMarketingRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostMarketingRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostMarketingRegionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMarketingRegionsExecute(r)
}

/*
PostMarketingRegions Create Marketing Regions

Use this API to create Marketing Regions. <p><strong>OperationId:</strong>postMarketingRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostMarketingRegionsRequest
*/
func (a *ChainConfigAPIService) PostMarketingRegions(ctx context.Context) ChainConfigAPIPostMarketingRegionsRequest {
	return ChainConfigAPIPostMarketingRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostMarketingRegionsExecute(r ChainConfigAPIPostMarketingRegionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostMarketingRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketingRegions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.marketingRegionsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostNoteTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	noteTypesCriteria *NoteTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostNoteTypesRequest) Authorization(authorization string) ChainConfigAPIPostNoteTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostNoteTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPostNoteTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostNoteTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPostNoteTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Note Types.
func (r ChainConfigAPIPostNoteTypesRequest) NoteTypesCriteria(noteTypesCriteria NoteTypesCriteria) ChainConfigAPIPostNoteTypesRequest {
	r.noteTypesCriteria = &noteTypesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostNoteTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostNoteTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostNoteTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostNoteTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostNoteTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostNoteTypesExecute(r)
}

/*
PostNoteTypes Create Note Types

Use this API to create Note Types. <p><strong>OperationId:</strong>postNoteTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostNoteTypesRequest
*/
func (a *ChainConfigAPIService) PostNoteTypes(ctx context.Context) ChainConfigAPIPostNoteTypesRequest {
	return ChainConfigAPIPostNoteTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostNoteTypesExecute(r ChainConfigAPIPostNoteTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostNoteTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noteTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.noteTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostPropertyDetailCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyDetailCategoriesCriteria *PropertyDetailCategoriesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) Authorization(authorization string) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Property Detail Categories.
func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) PropertyDetailCategoriesCriteria(propertyDetailCategoriesCriteria PropertyDetailCategoriesCriteria) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	r.propertyDetailCategoriesCriteria = &propertyDetailCategoriesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostPropertyDetailCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPropertyDetailCategoriesExecute(r)
}

/*
PostPropertyDetailCategories Create Property Detail Categories

Use this API to create Property Detail Categories. <p><strong>OperationId:</strong>postPropertyDetailCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostPropertyDetailCategoriesRequest
*/
func (a *ChainConfigAPIService) PostPropertyDetailCategories(ctx context.Context) ChainConfigAPIPostPropertyDetailCategoriesRequest {
	return ChainConfigAPIPostPropertyDetailCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostPropertyDetailCategoriesExecute(r ChainConfigAPIPostPropertyDetailCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostPropertyDetailCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyDetailsCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.propertyDetailCategoriesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostPropertyTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyTypesCriteria *PropertyTypesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostPropertyTypesRequest) Authorization(authorization string) ChainConfigAPIPostPropertyTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostPropertyTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPostPropertyTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostPropertyTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPostPropertyTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Property Types.
func (r ChainConfigAPIPostPropertyTypesRequest) PropertyTypesCriteria(propertyTypesCriteria PropertyTypesCriteria) ChainConfigAPIPostPropertyTypesRequest {
	r.propertyTypesCriteria = &propertyTypesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostPropertyTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostPropertyTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostPropertyTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostPropertyTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostPropertyTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPropertyTypesExecute(r)
}

/*
PostPropertyTypes Create Property Types

Use this API to create Property Types. <p><strong>OperationId:</strong>postPropertyTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostPropertyTypesRequest
*/
func (a *ChainConfigAPIService) PostPropertyTypes(ctx context.Context) ChainConfigAPIPostPropertyTypesRequest {
	return ChainConfigAPIPostPropertyTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostPropertyTypesExecute(r ChainConfigAPIPostPropertyTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostPropertyTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.propertyTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostRegionsCodeRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	regionsCodeCriteria *RegionsCodeCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostRegionsCodeRequest) Authorization(authorization string) ChainConfigAPIPostRegionsCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostRegionsCodeRequest) XAppKey(xAppKey string) ChainConfigAPIPostRegionsCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostRegionsCodeRequest) XHotelid(xHotelid string) ChainConfigAPIPostRegionsCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Regions Code.
func (r ChainConfigAPIPostRegionsCodeRequest) RegionsCodeCriteria(regionsCodeCriteria RegionsCodeCriteria) ChainConfigAPIPostRegionsCodeRequest {
	r.regionsCodeCriteria = &regionsCodeCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostRegionsCodeRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostRegionsCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostRegionsCodeRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostRegionsCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostRegionsCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRegionsCodeExecute(r)
}

/*
PostRegionsCode Create Regions Code

Use this API to create Regions Code. <p><strong>OperationId:</strong>postRegionsCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostRegionsCodeRequest
*/
func (a *ChainConfigAPIService) PostRegionsCode(ctx context.Context) ChainConfigAPIPostRegionsCodeRequest {
	return ChainConfigAPIPostRegionsCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostRegionsCodeExecute(r ChainConfigAPIPostRegionsCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostRegionsCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/regionCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.regionsCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostRoomAmenitiesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	roomAmenitiesCriteria *RoomAmenitiesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostRoomAmenitiesRequest) Authorization(authorization string) ChainConfigAPIPostRoomAmenitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostRoomAmenitiesRequest) XAppKey(xAppKey string) ChainConfigAPIPostRoomAmenitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostRoomAmenitiesRequest) XHotelid(xHotelid string) ChainConfigAPIPostRoomAmenitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Room Amenities.
func (r ChainConfigAPIPostRoomAmenitiesRequest) RoomAmenitiesCriteria(roomAmenitiesCriteria RoomAmenitiesCriteria) ChainConfigAPIPostRoomAmenitiesRequest {
	r.roomAmenitiesCriteria = &roomAmenitiesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostRoomAmenitiesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostRoomAmenitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostRoomAmenitiesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostRoomAmenitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostRoomAmenitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomAmenitiesExecute(r)
}

/*
PostRoomAmenities Create Room Amenities

Use this API to create Room Amenities. <p><strong>OperationId:</strong>postRoomAmenities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostRoomAmenitiesRequest
*/
func (a *ChainConfigAPIService) PostRoomAmenities(ctx context.Context) ChainConfigAPIPostRoomAmenitiesRequest {
	return ChainConfigAPIPostRoomAmenitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostRoomAmenitiesExecute(r ChainConfigAPIPostRoomAmenitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostRoomAmenities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomAmenities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomAmenitiesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostTemplateCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCodesCriteria *TemplateCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostTemplateCodesRequest) Authorization(authorization string) ChainConfigAPIPostTemplateCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostTemplateCodesRequest) XAppKey(xAppKey string) ChainConfigAPIPostTemplateCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostTemplateCodesRequest) XHotelid(xHotelid string) ChainConfigAPIPostTemplateCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Template Codes.
func (r ChainConfigAPIPostTemplateCodesRequest) TemplateCodesCriteria(templateCodesCriteria TemplateCodesCriteria) ChainConfigAPIPostTemplateCodesRequest {
	r.templateCodesCriteria = &templateCodesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostTemplateCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostTemplateCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostTemplateCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostTemplateCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostTemplateCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateCodesExecute(r)
}

/*
PostTemplateCodes Create Template Codes

Use this API to create Template Codes. <p><strong>OperationId:</strong>postTemplateCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostTemplateCodesRequest
*/
func (a *ChainConfigAPIService) PostTemplateCodes(ctx context.Context) ChainConfigAPIPostTemplateCodesRequest {
	return ChainConfigAPIPostTemplateCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostTemplateCodesExecute(r ChainConfigAPIPostTemplateCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostTemplateCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostUserDefinedFieldGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	userDefinedFieldGroupsCriteria *UserDefinedFieldGroupsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) Authorization(authorization string) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating User Defined Field Groups.
func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) UserDefinedFieldGroupsCriteria(userDefinedFieldGroupsCriteria UserDefinedFieldGroupsCriteria) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	r.userDefinedFieldGroupsCriteria = &userDefinedFieldGroupsCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostUserDefinedFieldGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostUserDefinedFieldGroupsExecute(r)
}

/*
PostUserDefinedFieldGroups Create User Defined Field Groups

Use this API to create User Defined Field Groups. <p><strong>OperationId:</strong>postUserDefinedFieldGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostUserDefinedFieldGroupsRequest
*/
func (a *ChainConfigAPIService) PostUserDefinedFieldGroups(ctx context.Context) ChainConfigAPIPostUserDefinedFieldGroupsRequest {
	return ChainConfigAPIPostUserDefinedFieldGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostUserDefinedFieldGroupsExecute(r ChainConfigAPIPostUserDefinedFieldGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostUserDefinedFieldGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.userDefinedFieldGroupsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPostUserDefinedFieldValuesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	userDefinedFieldValuesCriteria *UserDefinedFieldValuesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) Authorization(authorization string) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) XAppKey(xAppKey string) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) XHotelid(xHotelid string) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating User Defined Field Values.
func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) UserDefinedFieldValuesCriteria(userDefinedFieldValuesCriteria UserDefinedFieldValuesCriteria) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	r.userDefinedFieldValuesCriteria = &userDefinedFieldValuesCriteria
	return r
}

// External system code.
func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPostUserDefinedFieldValuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostUserDefinedFieldValuesExecute(r)
}

/*
PostUserDefinedFieldValues Create User Defined Field (UDF) Values

Use this API to create a new User Defined Field (UDF) Value. The LOV Group and LOV Values functionality allows a property create a custom group of values to be used in a specified user defined field (UDF).  This functionality provides added flexibility in allowing a site to track information or details that are specific to their business and outside of the standard fields offered in the OPERA Cloud. <p><strong>OperationId:</strong>postUserDefinedFieldValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChainConfigAPIPostUserDefinedFieldValuesRequest
*/
func (a *ChainConfigAPIService) PostUserDefinedFieldValues(ctx context.Context) ChainConfigAPIPostUserDefinedFieldValuesRequest {
	return ChainConfigAPIPostUserDefinedFieldValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PostUserDefinedFieldValuesExecute(r ChainConfigAPIPostUserDefinedFieldValuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PostUserDefinedFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.userDefinedFieldValuesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutAttractionClassesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	attractionClassCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	attractionClassesToBeChanged *AttractionClassesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutAttractionClassesRequest) Authorization(authorization string) ChainConfigAPIPutAttractionClassesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutAttractionClassesRequest) XAppKey(xAppKey string) ChainConfigAPIPutAttractionClassesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutAttractionClassesRequest) XHotelid(xHotelid string) ChainConfigAPIPutAttractionClassesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Attraction Classes.
func (r ChainConfigAPIPutAttractionClassesRequest) AttractionClassesToBeChanged(attractionClassesToBeChanged AttractionClassesToBeChanged) ChainConfigAPIPutAttractionClassesRequest {
	r.attractionClassesToBeChanged = &attractionClassesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutAttractionClassesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutAttractionClassesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutAttractionClassesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutAttractionClassesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutAttractionClassesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAttractionClassesExecute(r)
}

/*
PutAttractionClasses Change Attraction Classes

Use this API to update Attraction Classes. <p><strong>OperationId:</strong>putAttractionClasses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attractionClassCode Unique ID of Attraction Classes.
 @return ChainConfigAPIPutAttractionClassesRequest
*/
func (a *ChainConfigAPIService) PutAttractionClasses(ctx context.Context, attractionClassCode string) ChainConfigAPIPutAttractionClassesRequest {
	return ChainConfigAPIPutAttractionClassesRequest{
		ApiService: a,
		ctx: ctx,
		attractionClassCode: attractionClassCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutAttractionClassesExecute(r ChainConfigAPIPutAttractionClassesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutAttractionClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attractionClasses/{attractionClassCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"attractionClassCode"+"}", url.PathEscape(parameterValueToString(r.attractionClassCode, "attractionClassCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attractionClassCode) < 1 {
		return localVarReturnValue, nil, reportError("attractionClassCode must have at least 1 elements")
	}
	if strlen(r.attractionClassCode) > 2000 {
		return localVarReturnValue, nil, reportError("attractionClassCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attractionClassesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutChainRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	chainCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	chainToBeChanged *ChainToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutChainRequest) Authorization(authorization string) ChainConfigAPIPutChainRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutChainRequest) XAppKey(xAppKey string) ChainConfigAPIPutChainRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutChainRequest) XHotelid(xHotelid string) ChainConfigAPIPutChainRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Chain.
func (r ChainConfigAPIPutChainRequest) ChainToBeChanged(chainToBeChanged ChainToBeChanged) ChainConfigAPIPutChainRequest {
	r.chainToBeChanged = &chainToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutChainRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutChainRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutChainRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutChainRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutChainRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutChainExecute(r)
}

/*
PutChain Change Chain

Use this API to update Chain. <p><strong>OperationId:</strong>putChain</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chainCode Unique Code of Chain.
 @return ChainConfigAPIPutChainRequest
*/
func (a *ChainConfigAPIService) PutChain(ctx context.Context, chainCode string) ChainConfigAPIPutChainRequest {
	return ChainConfigAPIPutChainRequest{
		ApiService: a,
		ctx: ctx,
		chainCode: chainCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutChainExecute(r ChainConfigAPIPutChainRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chain/{chainCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"chainCode"+"}", url.PathEscape(parameterValueToString(r.chainCode, "chainCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.chainCode) < 1 {
		return localVarReturnValue, nil, reportError("chainCode must have at least 1 elements")
	}
	if strlen(r.chainCode) > 2000 {
		return localVarReturnValue, nil, reportError("chainCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.chainToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutCommunicationMethodsEntDetailsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	communicationMethodsEntDetailsId string
	authorization *string
	xAppKey *string
	xHotelid *string
	communicationMethodsEntDetailsToBeChanged *CommunicationMethodsEntDetailsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) Authorization(authorization string) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) XAppKey(xAppKey string) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) XHotelid(xHotelid string) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Communication Methods Ent Details.
func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) CommunicationMethodsEntDetailsToBeChanged(communicationMethodsEntDetailsToBeChanged CommunicationMethodsEntDetailsToBeChanged) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	r.communicationMethodsEntDetailsToBeChanged = &communicationMethodsEntDetailsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCommunicationMethodsEntDetailsExecute(r)
}

/*
PutCommunicationMethodsEntDetails Change Communication Methods Ent Details

Use this API to update Communication Methods Ent Details. <p><strong>OperationId:</strong>putCommunicationMethodsEntDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param communicationMethodsEntDetailsId Unique ID of Communication Methods Ent Details.
 @return ChainConfigAPIPutCommunicationMethodsEntDetailsRequest
*/
func (a *ChainConfigAPIService) PutCommunicationMethodsEntDetails(ctx context.Context, communicationMethodsEntDetailsId string) ChainConfigAPIPutCommunicationMethodsEntDetailsRequest {
	return ChainConfigAPIPutCommunicationMethodsEntDetailsRequest{
		ApiService: a,
		ctx: ctx,
		communicationMethodsEntDetailsId: communicationMethodsEntDetailsId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutCommunicationMethodsEntDetailsExecute(r ChainConfigAPIPutCommunicationMethodsEntDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutCommunicationMethodsEntDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communicationMethodsEntDetails/{communicationMethodsEntDetailsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"communicationMethodsEntDetailsId"+"}", url.PathEscape(parameterValueToString(r.communicationMethodsEntDetailsId, "communicationMethodsEntDetailsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.communicationMethodsEntDetailsId) < 1 {
		return localVarReturnValue, nil, reportError("communicationMethodsEntDetailsId must have at least 1 elements")
	}
	if strlen(r.communicationMethodsEntDetailsId) > 2000 {
		return localVarReturnValue, nil, reportError("communicationMethodsEntDetailsId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.communicationMethodsEntDetailsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutMarketingRegionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	marketingRegionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	marketingRegionsToBeChanged *MarketingRegionsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutMarketingRegionsRequest) Authorization(authorization string) ChainConfigAPIPutMarketingRegionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutMarketingRegionsRequest) XAppKey(xAppKey string) ChainConfigAPIPutMarketingRegionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutMarketingRegionsRequest) XHotelid(xHotelid string) ChainConfigAPIPutMarketingRegionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Marketing Regions.
func (r ChainConfigAPIPutMarketingRegionsRequest) MarketingRegionsToBeChanged(marketingRegionsToBeChanged MarketingRegionsToBeChanged) ChainConfigAPIPutMarketingRegionsRequest {
	r.marketingRegionsToBeChanged = &marketingRegionsToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutMarketingRegionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutMarketingRegionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutMarketingRegionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutMarketingRegionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutMarketingRegionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMarketingRegionsExecute(r)
}

/*
PutMarketingRegions Change Marketing Regions

Use this API to update Marketing Regions. <p><strong>OperationId:</strong>putMarketingRegions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param marketingRegionCode Unique ID of Marketing Regions.
 @return ChainConfigAPIPutMarketingRegionsRequest
*/
func (a *ChainConfigAPIService) PutMarketingRegions(ctx context.Context, marketingRegionCode string) ChainConfigAPIPutMarketingRegionsRequest {
	return ChainConfigAPIPutMarketingRegionsRequest{
		ApiService: a,
		ctx: ctx,
		marketingRegionCode: marketingRegionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutMarketingRegionsExecute(r ChainConfigAPIPutMarketingRegionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutMarketingRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketingRegions/{marketingRegionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"marketingRegionCode"+"}", url.PathEscape(parameterValueToString(r.marketingRegionCode, "marketingRegionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.marketingRegionCode) < 1 {
		return localVarReturnValue, nil, reportError("marketingRegionCode must have at least 1 elements")
	}
	if strlen(r.marketingRegionCode) > 2000 {
		return localVarReturnValue, nil, reportError("marketingRegionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.marketingRegionsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutPropertyTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	propertyTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyTypesToBeChanged *PropertyTypesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutPropertyTypesRequest) Authorization(authorization string) ChainConfigAPIPutPropertyTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutPropertyTypesRequest) XAppKey(xAppKey string) ChainConfigAPIPutPropertyTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutPropertyTypesRequest) XHotelid(xHotelid string) ChainConfigAPIPutPropertyTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Property Types.
func (r ChainConfigAPIPutPropertyTypesRequest) PropertyTypesToBeChanged(propertyTypesToBeChanged PropertyTypesToBeChanged) ChainConfigAPIPutPropertyTypesRequest {
	r.propertyTypesToBeChanged = &propertyTypesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutPropertyTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutPropertyTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutPropertyTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutPropertyTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutPropertyTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPropertyTypesExecute(r)
}

/*
PutPropertyTypes Change Property Types

Use this API to update Property Types. <p><strong>OperationId:</strong>putPropertyTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param propertyTypeCode Unique ID of Property Types.
 @return ChainConfigAPIPutPropertyTypesRequest
*/
func (a *ChainConfigAPIService) PutPropertyTypes(ctx context.Context, propertyTypeCode string) ChainConfigAPIPutPropertyTypesRequest {
	return ChainConfigAPIPutPropertyTypesRequest{
		ApiService: a,
		ctx: ctx,
		propertyTypeCode: propertyTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutPropertyTypesExecute(r ChainConfigAPIPutPropertyTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutPropertyTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyTypes/{propertyTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"propertyTypeCode"+"}", url.PathEscape(parameterValueToString(r.propertyTypeCode, "propertyTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.propertyTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("propertyTypeCode must have at least 1 elements")
	}
	if strlen(r.propertyTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("propertyTypeCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.propertyTypesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIPutRoomAmenitiesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	roomAmenitiesId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomAmenitiesToBeChanged *RoomAmenitiesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIPutRoomAmenitiesRequest) Authorization(authorization string) ChainConfigAPIPutRoomAmenitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIPutRoomAmenitiesRequest) XAppKey(xAppKey string) ChainConfigAPIPutRoomAmenitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIPutRoomAmenitiesRequest) XHotelid(xHotelid string) ChainConfigAPIPutRoomAmenitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Room Amenities.
func (r ChainConfigAPIPutRoomAmenitiesRequest) RoomAmenitiesToBeChanged(roomAmenitiesToBeChanged RoomAmenitiesToBeChanged) ChainConfigAPIPutRoomAmenitiesRequest {
	r.roomAmenitiesToBeChanged = &roomAmenitiesToBeChanged
	return r
}

// External system code.
func (r ChainConfigAPIPutRoomAmenitiesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIPutRoomAmenitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIPutRoomAmenitiesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIPutRoomAmenitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIPutRoomAmenitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomAmenitiesExecute(r)
}

/*
PutRoomAmenities Change Room Amenities

Use this API to update Room Amenities. <p><strong>OperationId:</strong>putRoomAmenities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomAmenitiesId Unique ID of Room Amenities.
 @return ChainConfigAPIPutRoomAmenitiesRequest
*/
func (a *ChainConfigAPIService) PutRoomAmenities(ctx context.Context, roomAmenitiesId string) ChainConfigAPIPutRoomAmenitiesRequest {
	return ChainConfigAPIPutRoomAmenitiesRequest{
		ApiService: a,
		ctx: ctx,
		roomAmenitiesId: roomAmenitiesId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) PutRoomAmenitiesExecute(r ChainConfigAPIPutRoomAmenitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.PutRoomAmenities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomAmenities/{roomAmenitiesId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomAmenitiesId"+"}", url.PathEscape(parameterValueToString(r.roomAmenitiesId, "roomAmenitiesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomAmenitiesId) < 1 {
		return localVarReturnValue, nil, reportError("roomAmenitiesId must have at least 1 elements")
	}
	if strlen(r.roomAmenitiesId) > 2000 {
		return localVarReturnValue, nil, reportError("roomAmenitiesId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomAmenitiesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveBrandCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	brandCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	brandCodesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveBrandCodesRequest) Authorization(authorization string) ChainConfigAPIRemoveBrandCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveBrandCodesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveBrandCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveBrandCodesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveBrandCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveBrandCodesRequest) BrandCodesCodes(brandCodesCodes []string) ChainConfigAPIRemoveBrandCodesRequest {
	r.brandCodesCodes = &brandCodesCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveBrandCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveBrandCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveBrandCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveBrandCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveBrandCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveBrandCodesExecute(r)
}

/*
RemoveBrandCodes Delete Brand Code

Use this API to delete Brand Code. <p><strong>OperationId:</strong>removeBrandCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param brandCode Unique Code of Brand.
 @return ChainConfigAPIRemoveBrandCodesRequest
*/
func (a *ChainConfigAPIService) RemoveBrandCodes(ctx context.Context, brandCode string) ChainConfigAPIRemoveBrandCodesRequest {
	return ChainConfigAPIRemoveBrandCodesRequest{
		ApiService: a,
		ctx: ctx,
		brandCode: brandCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveBrandCodesExecute(r ChainConfigAPIRemoveBrandCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveBrandCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/brandCodes/{brandCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"brandCode"+"}", url.PathEscape(parameterValueToString(r.brandCode, "brandCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.brandCode) < 1 {
		return localVarReturnValue, nil, reportError("brandCode must have at least 1 elements")
	}
	if strlen(r.brandCode) > 2000 {
		return localVarReturnValue, nil, reportError("brandCode must have less than 2000 elements")
	}

	if r.brandCodesCodes != nil {
		t := *r.brandCodesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "brandCodesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "brandCodesCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCorporateBusinessUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	businessUnitCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateBusinessUnitsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) Authorization(authorization string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) CorporateBusinessUnitsCodes(corporateBusinessUnitsCodes []string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	r.corporateBusinessUnitsCodes = &corporateBusinessUnitsCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCorporateBusinessUnitsExecute(r)
}

/*
RemoveCorporateBusinessUnits Delete Corporate Business Units

Use this API to delete Corporate Business Units. <p><strong>OperationId:</strong>removeCorporateBusinessUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessUnitCode Unique Code of Business Units.
 @return ChainConfigAPIRemoveCorporateBusinessUnitsRequest
*/
func (a *ChainConfigAPIService) RemoveCorporateBusinessUnits(ctx context.Context, businessUnitCode string) ChainConfigAPIRemoveCorporateBusinessUnitsRequest {
	return ChainConfigAPIRemoveCorporateBusinessUnitsRequest{
		ApiService: a,
		ctx: ctx,
		businessUnitCode: businessUnitCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCorporateBusinessUnitsExecute(r ChainConfigAPIRemoveCorporateBusinessUnitsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCorporateBusinessUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateBusinessUnits/{businessUnitCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"businessUnitCode"+"}", url.PathEscape(parameterValueToString(r.businessUnitCode, "businessUnitCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessUnitCode) < 1 {
		return localVarReturnValue, nil, reportError("businessUnitCode must have at least 1 elements")
	}
	if strlen(r.businessUnitCode) > 2000 {
		return localVarReturnValue, nil, reportError("businessUnitCode must have less than 2000 elements")
	}

	if r.corporateBusinessUnitsCodes != nil {
		t := *r.corporateBusinessUnitsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "corporateBusinessUnitsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "corporateBusinessUnitsCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCorporateDepartmentCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	departmentCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) Authorization(authorization string) ChainConfigAPIRemoveCorporateDepartmentCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCorporateDepartmentCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCorporateDepartmentCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCorporateDepartmentCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCorporateDepartmentCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCorporateDepartmentCodesExecute(r)
}

/*
RemoveCorporateDepartmentCodes Delete Corporate Department Codes

Use this API to delete Corporate Department Codes. <p><strong>OperationId:</strong>removeCorporateDepartmentCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param departmentCode Unique Code of Department.
 @return ChainConfigAPIRemoveCorporateDepartmentCodesRequest
*/
func (a *ChainConfigAPIService) RemoveCorporateDepartmentCodes(ctx context.Context, departmentCode string) ChainConfigAPIRemoveCorporateDepartmentCodesRequest {
	return ChainConfigAPIRemoveCorporateDepartmentCodesRequest{
		ApiService: a,
		ctx: ctx,
		departmentCode: departmentCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCorporateDepartmentCodesExecute(r ChainConfigAPIRemoveCorporateDepartmentCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCorporateDepartmentCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDepartmentCodes/{departmentCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"departmentCode"+"}", url.PathEscape(parameterValueToString(r.departmentCode, "departmentCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.departmentCode) < 1 {
		return localVarReturnValue, nil, reportError("departmentCode must have at least 1 elements")
	}
	if strlen(r.departmentCode) > 2000 {
		return localVarReturnValue, nil, reportError("departmentCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCorporateDivisionsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	divisionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateDivisionsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCorporateDivisionsRequest) Authorization(authorization string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCorporateDivisionsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCorporateDivisionsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveCorporateDivisionsRequest) CorporateDivisionsCodes(corporateDivisionsCodes []string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	r.corporateDivisionsCodes = &corporateDivisionsCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCorporateDivisionsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCorporateDivisionsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCorporateDivisionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCorporateDivisionsExecute(r)
}

/*
RemoveCorporateDivisions Delete Corporate Divisions

Use this API to delete Corporate Divisions. <p><strong>OperationId:</strong>removeCorporateDivisions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param divisionCode Unique Code of Corporate Divisions.
 @return ChainConfigAPIRemoveCorporateDivisionsRequest
*/
func (a *ChainConfigAPIService) RemoveCorporateDivisions(ctx context.Context, divisionCode string) ChainConfigAPIRemoveCorporateDivisionsRequest {
	return ChainConfigAPIRemoveCorporateDivisionsRequest{
		ApiService: a,
		ctx: ctx,
		divisionCode: divisionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCorporateDivisionsExecute(r ChainConfigAPIRemoveCorporateDivisionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCorporateDivisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateDivisions/{divisionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"divisionCode"+"}", url.PathEscape(parameterValueToString(r.divisionCode, "divisionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.divisionCode) < 1 {
		return localVarReturnValue, nil, reportError("divisionCode must have at least 1 elements")
	}
	if strlen(r.divisionCode) > 2000 {
		return localVarReturnValue, nil, reportError("divisionCode must have less than 2000 elements")
	}

	if r.corporateDivisionsCodes != nil {
		t := *r.corporateDivisionsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "corporateDivisionsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "corporateDivisionsCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCorporateOperatingUnitsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	operatingUnitCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	corporateOperatingUnitsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) Authorization(authorization string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) CorporateOperatingUnitsCodes(corporateOperatingUnitsCodes []string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	r.corporateOperatingUnitsCodes = &corporateOperatingUnitsCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCorporateOperatingUnitsExecute(r)
}

/*
RemoveCorporateOperatingUnits Delete Corporate Operating Units

Use this API to delete Corporate Operating Units. <p><strong>OperationId:</strong>removeCorporateOperatingUnits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatingUnitCode Unique Code of Corporate Operating Units.
 @return ChainConfigAPIRemoveCorporateOperatingUnitsRequest
*/
func (a *ChainConfigAPIService) RemoveCorporateOperatingUnits(ctx context.Context, operatingUnitCode string) ChainConfigAPIRemoveCorporateOperatingUnitsRequest {
	return ChainConfigAPIRemoveCorporateOperatingUnitsRequest{
		ApiService: a,
		ctx: ctx,
		operatingUnitCode: operatingUnitCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCorporateOperatingUnitsExecute(r ChainConfigAPIRemoveCorporateOperatingUnitsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCorporateOperatingUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/corporateOperatingUnits/{operatingUnitCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatingUnitCode"+"}", url.PathEscape(parameterValueToString(r.operatingUnitCode, "operatingUnitCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.operatingUnitCode) < 1 {
		return localVarReturnValue, nil, reportError("operatingUnitCode must have at least 1 elements")
	}
	if strlen(r.operatingUnitCode) > 2000 {
		return localVarReturnValue, nil, reportError("operatingUnitCode must have less than 2000 elements")
	}

	if r.corporateOperatingUnitsCodes != nil {
		t := *r.corporateOperatingUnitsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "corporateOperatingUnitsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "corporateOperatingUnitsCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCountryGuestTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	guestTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	countryGuestTypesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCountryGuestTypesRequest) Authorization(authorization string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCountryGuestTypesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCountryGuestTypesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveCountryGuestTypesRequest) CountryGuestTypesCodes(countryGuestTypesCodes []string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	r.countryGuestTypesCodes = &countryGuestTypesCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCountryGuestTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCountryGuestTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCountryGuestTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCountryGuestTypesExecute(r)
}

/*
RemoveCountryGuestTypes Delete Country Guest Types

Use this API to delete Country Guest Types. <p><strong>OperationId:</strong>removeCountryGuestTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guestTypeCode Unique Code of guest type.
 @return ChainConfigAPIRemoveCountryGuestTypesRequest
*/
func (a *ChainConfigAPIService) RemoveCountryGuestTypes(ctx context.Context, guestTypeCode string) ChainConfigAPIRemoveCountryGuestTypesRequest {
	return ChainConfigAPIRemoveCountryGuestTypesRequest{
		ApiService: a,
		ctx: ctx,
		guestTypeCode: guestTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCountryGuestTypesExecute(r ChainConfigAPIRemoveCountryGuestTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCountryGuestTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countries/guestTypes/{guestTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"guestTypeCode"+"}", url.PathEscape(parameterValueToString(r.guestTypeCode, "guestTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guestTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("guestTypeCode must have at least 1 elements")
	}
	if strlen(r.guestTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("guestTypeCode must have less than 2000 elements")
	}

	if r.countryGuestTypesCodes != nil {
		t := *r.countryGuestTypesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countryGuestTypesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countryGuestTypesCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveCountryMainGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	groupCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	countryMainGroupsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveCountryMainGroupsRequest) Authorization(authorization string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveCountryMainGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveCountryMainGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveCountryMainGroupsRequest) CountryMainGroupsCodes(countryMainGroupsCodes []string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	r.countryMainGroupsCodes = &countryMainGroupsCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveCountryMainGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveCountryMainGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveCountryMainGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCountryMainGroupsExecute(r)
}

/*
RemoveCountryMainGroups Delete Country Main Groups

Use this API to delete Country Main Groups. <p><strong>OperationId:</strong>removeCountryMainGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupCode Unique Code of Groups.
 @return ChainConfigAPIRemoveCountryMainGroupsRequest
*/
func (a *ChainConfigAPIService) RemoveCountryMainGroups(ctx context.Context, groupCode string) ChainConfigAPIRemoveCountryMainGroupsRequest {
	return ChainConfigAPIRemoveCountryMainGroupsRequest{
		ApiService: a,
		ctx: ctx,
		groupCode: groupCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveCountryMainGroupsExecute(r ChainConfigAPIRemoveCountryMainGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveCountryMainGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/countryMainGroups/{groupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupCode"+"}", url.PathEscape(parameterValueToString(r.groupCode, "groupCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupCode) < 1 {
		return localVarReturnValue, nil, reportError("groupCode must have at least 1 elements")
	}
	if strlen(r.groupCode) > 2000 {
		return localVarReturnValue, nil, reportError("groupCode must have less than 2000 elements")
	}

	if r.countryMainGroupsCodes != nil {
		t := *r.countryMainGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "countryMainGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "countryMainGroupsCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveHotelCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	categoryCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveHotelCategoriesRequest) Authorization(authorization string) ChainConfigAPIRemoveHotelCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveHotelCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveHotelCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveHotelCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveHotelCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveHotelCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveHotelCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveHotelCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveHotelCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveHotelCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveHotelCategoriesExecute(r)
}

/*
RemoveHotelCategories Delete Hotel Categories

. <p><strong>OperationId:</strong>removeHotelCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryCode Unique Code of Categories.
 @return ChainConfigAPIRemoveHotelCategoriesRequest
*/
func (a *ChainConfigAPIService) RemoveHotelCategories(ctx context.Context, categoryCode string) ChainConfigAPIRemoveHotelCategoriesRequest {
	return ChainConfigAPIRemoveHotelCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		categoryCode: categoryCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveHotelCategoriesExecute(r ChainConfigAPIRemoveHotelCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveHotelCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotelCategories/{categoryCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryCode"+"}", url.PathEscape(parameterValueToString(r.categoryCode, "categoryCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.categoryCode) < 1 {
		return localVarReturnValue, nil, reportError("categoryCode must have at least 1 elements")
	}
	if strlen(r.categoryCode) > 2000 {
		return localVarReturnValue, nil, reportError("categoryCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveNoteTypesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	noteTypeCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	noteGroup *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveNoteTypesRequest) Authorization(authorization string) ChainConfigAPIRemoveNoteTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveNoteTypesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveNoteTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveNoteTypesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveNoteTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Notes Group of the Note Types code.
func (r ChainConfigAPIRemoveNoteTypesRequest) NoteGroup(noteGroup string) ChainConfigAPIRemoveNoteTypesRequest {
	r.noteGroup = &noteGroup
	return r
}

// External system code.
func (r ChainConfigAPIRemoveNoteTypesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveNoteTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveNoteTypesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveNoteTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveNoteTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveNoteTypesExecute(r)
}

/*
RemoveNoteTypes Delete Note Types

Use this API to delete Note Types. <p><strong>OperationId:</strong>removeNoteTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param noteTypeCode Unique Code of Note Types.
 @return ChainConfigAPIRemoveNoteTypesRequest
*/
func (a *ChainConfigAPIService) RemoveNoteTypes(ctx context.Context, noteTypeCode string) ChainConfigAPIRemoveNoteTypesRequest {
	return ChainConfigAPIRemoveNoteTypesRequest{
		ApiService: a,
		ctx: ctx,
		noteTypeCode: noteTypeCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveNoteTypesExecute(r ChainConfigAPIRemoveNoteTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveNoteTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/noteTypes/{noteTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"noteTypeCode"+"}", url.PathEscape(parameterValueToString(r.noteTypeCode, "noteTypeCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.noteTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("noteTypeCode must have at least 1 elements")
	}
	if strlen(r.noteTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("noteTypeCode must have less than 2000 elements")
	}

	if r.noteGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteGroup", r.noteGroup, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemovePropertyDetailCategoriesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	categoryCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyDetailCategoriesCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) Authorization(authorization string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) XAppKey(xAppKey string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) XHotelid(xHotelid string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) PropertyDetailCategoriesCodes(propertyDetailCategoriesCodes []string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	r.propertyDetailCategoriesCodes = &propertyDetailCategoriesCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemovePropertyDetailCategoriesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemovePropertyDetailCategoriesExecute(r)
}

/*
RemovePropertyDetailCategories Delete Property Detail Categories

Use this API to delete Property Detail Categories. <p><strong>OperationId:</strong>removePropertyDetailCategories</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryCode Unique Code of Categories.
 @return ChainConfigAPIRemovePropertyDetailCategoriesRequest
*/
func (a *ChainConfigAPIService) RemovePropertyDetailCategories(ctx context.Context, categoryCode string) ChainConfigAPIRemovePropertyDetailCategoriesRequest {
	return ChainConfigAPIRemovePropertyDetailCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		categoryCode: categoryCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemovePropertyDetailCategoriesExecute(r ChainConfigAPIRemovePropertyDetailCategoriesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemovePropertyDetailCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertyDetailsCategories/{categoryCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryCode"+"}", url.PathEscape(parameterValueToString(r.categoryCode, "categoryCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.categoryCode) < 1 {
		return localVarReturnValue, nil, reportError("categoryCode must have at least 1 elements")
	}
	if strlen(r.categoryCode) > 2000 {
		return localVarReturnValue, nil, reportError("categoryCode must have less than 2000 elements")
	}

	if r.propertyDetailCategoriesCodes != nil {
		t := *r.propertyDetailCategoriesCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "propertyDetailCategoriesCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "propertyDetailCategoriesCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveRegionsCodeRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	regionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveRegionsCodeRequest) Authorization(authorization string) ChainConfigAPIRemoveRegionsCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveRegionsCodeRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveRegionsCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveRegionsCodeRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveRegionsCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveRegionsCodeRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveRegionsCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveRegionsCodeRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveRegionsCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveRegionsCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveRegionsCodeExecute(r)
}

/*
RemoveRegionsCode Delete Regions Code

Use this API to delete Regions Code. <p><strong>OperationId:</strong>removeRegionsCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionCode Unique Code of Regions.
 @return ChainConfigAPIRemoveRegionsCodeRequest
*/
func (a *ChainConfigAPIService) RemoveRegionsCode(ctx context.Context, regionCode string) ChainConfigAPIRemoveRegionsCodeRequest {
	return ChainConfigAPIRemoveRegionsCodeRequest{
		ApiService: a,
		ctx: ctx,
		regionCode: regionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveRegionsCodeExecute(r ChainConfigAPIRemoveRegionsCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveRegionsCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/regionCode/{regionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"regionCode"+"}", url.PathEscape(parameterValueToString(r.regionCode, "regionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.regionCode) < 1 {
		return localVarReturnValue, nil, reportError("regionCode must have at least 1 elements")
	}
	if strlen(r.regionCode) > 2000 {
		return localVarReturnValue, nil, reportError("regionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveTemplateCodesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	code string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveTemplateCodesRequest) Authorization(authorization string) ChainConfigAPIRemoveTemplateCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveTemplateCodesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveTemplateCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveTemplateCodesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveTemplateCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ChainConfigAPIRemoveTemplateCodesRequest) TemplateCodes(templateCodes []string) ChainConfigAPIRemoveTemplateCodesRequest {
	r.templateCodes = &templateCodes
	return r
}

// External system code.
func (r ChainConfigAPIRemoveTemplateCodesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveTemplateCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveTemplateCodesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveTemplateCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveTemplateCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTemplateCodesExecute(r)
}

/*
RemoveTemplateCodes Delete Template Codes

Use this API to delete Template Codes. <p><strong>OperationId:</strong>removeTemplateCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Unique Code of Template.
 @return ChainConfigAPIRemoveTemplateCodesRequest
*/
func (a *ChainConfigAPIService) RemoveTemplateCodes(ctx context.Context, code string) ChainConfigAPIRemoveTemplateCodesRequest {
	return ChainConfigAPIRemoveTemplateCodesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveTemplateCodesExecute(r ChainConfigAPIRemoveTemplateCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveTemplateCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templateCodes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}

	if r.templateCodes != nil {
		t := *r.templateCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "templateCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "templateCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveUserDefinedFieldGroupsRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	udfGroupCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) Authorization(authorization string) ChainConfigAPIRemoveUserDefinedFieldGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveUserDefinedFieldGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveUserDefinedFieldGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveUserDefinedFieldGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveUserDefinedFieldGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveUserDefinedFieldGroupsExecute(r)
}

/*
RemoveUserDefinedFieldGroups Delete User Defined Field Groups

Use this API to delete User Defined Field Groups. <p><strong>OperationId:</strong>removeUserDefinedFieldGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param udfGroupCode Unique Code of User Defined Field Groups.
 @return ChainConfigAPIRemoveUserDefinedFieldGroupsRequest
*/
func (a *ChainConfigAPIService) RemoveUserDefinedFieldGroups(ctx context.Context, udfGroupCode string) ChainConfigAPIRemoveUserDefinedFieldGroupsRequest {
	return ChainConfigAPIRemoveUserDefinedFieldGroupsRequest{
		ApiService: a,
		ctx: ctx,
		udfGroupCode: udfGroupCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveUserDefinedFieldGroupsExecute(r ChainConfigAPIRemoveUserDefinedFieldGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveUserDefinedFieldGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldGroups/{udfGroupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"udfGroupCode"+"}", url.PathEscape(parameterValueToString(r.udfGroupCode, "udfGroupCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.udfGroupCode) < 1 {
		return localVarReturnValue, nil, reportError("udfGroupCode must have at least 1 elements")
	}
	if strlen(r.udfGroupCode) > 2000 {
		return localVarReturnValue, nil, reportError("udfGroupCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIRemoveUserDefinedFieldValuesRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	udfValue string
	authorization *string
	xAppKey *string
	xHotelid *string
	groupCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) Authorization(authorization string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) XAppKey(xAppKey string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) XHotelid(xHotelid string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Group Code which the User Defined Field Value belongs to.
func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) GroupCode(groupCode string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	r.groupCode = &groupCode
	return r
}

// External system code.
func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveUserDefinedFieldValuesExecute(r)
}

/*
RemoveUserDefinedFieldValues Delete a User Defined Field Value 

Use this API to delete a User Defined Field Value. <p><strong>OperationId:</strong>removeUserDefinedFieldValues</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param udfValue Unique Value of User Defined Field.
 @return ChainConfigAPIRemoveUserDefinedFieldValuesRequest
*/
func (a *ChainConfigAPIService) RemoveUserDefinedFieldValues(ctx context.Context, udfValue string) ChainConfigAPIRemoveUserDefinedFieldValuesRequest {
	return ChainConfigAPIRemoveUserDefinedFieldValuesRequest{
		ApiService: a,
		ctx: ctx,
		udfValue: udfValue,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) RemoveUserDefinedFieldValuesExecute(r ChainConfigAPIRemoveUserDefinedFieldValuesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.RemoveUserDefinedFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userDefinedFieldValues/{udfValue}"
	localVarPath = strings.Replace(localVarPath, "{"+"udfValue"+"}", url.PathEscape(parameterValueToString(r.udfValue, "udfValue")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.udfValue) < 1 {
		return localVarReturnValue, nil, reportError("udfValue must have at least 1 elements")
	}
	if strlen(r.udfValue) > 2000 {
		return localVarReturnValue, nil, reportError("udfValue must have less than 2000 elements")
	}

	if r.groupCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupCode", r.groupCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ChainConfigAPIUpdateFlexFieldRequest struct {
	ctx context.Context
	ApiService *ChainConfigAPIService
	flexFieldId float32
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	flexFieldDetail *FlexFieldCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ChainConfigAPIUpdateFlexFieldRequest) Authorization(authorization string) ChainConfigAPIUpdateFlexFieldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ChainConfigAPIUpdateFlexFieldRequest) XAppKey(xAppKey string) ChainConfigAPIUpdateFlexFieldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ChainConfigAPIUpdateFlexFieldRequest) XHotelid(xHotelid string) ChainConfigAPIUpdateFlexFieldRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating the configuration of flex fields.
func (r ChainConfigAPIUpdateFlexFieldRequest) FlexFieldDetail(flexFieldDetail FlexFieldCriteria) ChainConfigAPIUpdateFlexFieldRequest {
	r.flexFieldDetail = &flexFieldDetail
	return r
}

// External system code.
func (r ChainConfigAPIUpdateFlexFieldRequest) XExternalsystem(xExternalsystem string) ChainConfigAPIUpdateFlexFieldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ChainConfigAPIUpdateFlexFieldRequest) AcceptLanguage(acceptLanguage string) ChainConfigAPIUpdateFlexFieldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ChainConfigAPIUpdateFlexFieldRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UpdateFlexFieldExecute(r)
}

/*
UpdateFlexField Operation to update flex field.

Operation to update flex field. <p><strong>OperationId:</strong>updateFlexField</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flexFieldId Flex Field ID
 @param hotelId Unique ID of the hotel in OPERA
 @return ChainConfigAPIUpdateFlexFieldRequest
*/
func (a *ChainConfigAPIService) UpdateFlexField(ctx context.Context, flexFieldId float32, hotelId string) ChainConfigAPIUpdateFlexFieldRequest {
	return ChainConfigAPIUpdateFlexFieldRequest{
		ApiService: a,
		ctx: ctx,
		flexFieldId: flexFieldId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ChainConfigAPIService) UpdateFlexFieldExecute(r ChainConfigAPIUpdateFlexFieldRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainConfigAPIService.UpdateFlexField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/flexFields/{flexFieldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"flexFieldId"+"}", url.PathEscape(parameterValueToString(r.flexFieldId, "flexFieldId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.flexFieldDetail
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
