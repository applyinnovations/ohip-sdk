/*
OPERA Cloud Room Rotation Service API

APIs to facilitate Room Rotation functionality in OPERA Cloud. Api provides capability to handle Room Rotation in OPERA Cloud. Room Rotation provides room ownership options for automatic inventory rotation and prioritization for owner rooms assignment and occupancy.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rmr

import (
	"encoding/json"
	"fmt"
)

// RotationRuleCalculationRuleType Simple type for Rotation Rule Calculation Rule.
type RotationRuleCalculationRuleType string

// List of rotationRuleCalculationRuleType
const (
	ROTATIONRULECALCULATIONRULETYPE_PER_REVENUE RotationRuleCalculationRuleType = "PerRevenue"
	ROTATIONRULECALCULATIONRULETYPE_PER_NIGHT RotationRuleCalculationRuleType = "PerNight"
	ROTATIONRULECALCULATIONRULETYPE_PER_STAY RotationRuleCalculationRuleType = "PerStay"
	ROTATIONRULECALCULATIONRULETYPE_AVG_RATE_AMOUNT RotationRuleCalculationRuleType = "AvgRateAmount"
)

// All allowed values of RotationRuleCalculationRuleType enum
var AllowedRotationRuleCalculationRuleTypeEnumValues = []RotationRuleCalculationRuleType{
	"PerRevenue",
	"PerNight",
	"PerStay",
	"AvgRateAmount",
}

func (v *RotationRuleCalculationRuleType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := RotationRuleCalculationRuleType(value)
	for _, existing := range AllowedRotationRuleCalculationRuleTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid RotationRuleCalculationRuleType", value)
}

// NewRotationRuleCalculationRuleTypeFromValue returns a pointer to a valid RotationRuleCalculationRuleType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewRotationRuleCalculationRuleTypeFromValue(v string) (*RotationRuleCalculationRuleType, error) {
	ev := RotationRuleCalculationRuleType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for RotationRuleCalculationRuleType: valid values are %v", v, AllowedRotationRuleCalculationRuleTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v RotationRuleCalculationRuleType) IsValid() bool {
	for _, existing := range AllowedRotationRuleCalculationRuleTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to rotationRuleCalculationRuleType value
func (v RotationRuleCalculationRuleType) Ptr() *RotationRuleCalculationRuleType {
	return &v
}

type NullableRotationRuleCalculationRuleType struct {
	value *RotationRuleCalculationRuleType
	isSet bool
}

func (v NullableRotationRuleCalculationRuleType) Get() *RotationRuleCalculationRuleType {
	return v.value
}

func (v *NullableRotationRuleCalculationRuleType) Set(val *RotationRuleCalculationRuleType) {
	v.value = val
	v.isSet = true
}

func (v NullableRotationRuleCalculationRuleType) IsSet() bool {
	return v.isSet
}

func (v *NullableRotationRuleCalculationRuleType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRotationRuleCalculationRuleType(val *RotationRuleCalculationRuleType) *NullableRotationRuleCalculationRuleType {
	return &NullableRotationRuleCalculationRuleType{value: val, isSet: true}
}

func (v NullableRotationRuleCalculationRuleType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRotationRuleCalculationRuleType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

