/*
OPERA Cloud Reservation Master Data Management API

APIs to cater for Reservation Configuration in OPERA Cloud. In this module you can retrieve, create, modify or delete configuration related to Reservations, Blocks and Leisure Management.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvcfg

import (
	"encoding/json"
	"fmt"
)

// RoundingRuleType Simple type for storing rounding rule type.
type RoundingRuleType string

// List of roundingRuleType
const (
	ROUNDINGRULETYPE_UP RoundingRuleType = "Up"
	ROUNDINGRULETYPE_DOWN RoundingRuleType = "Down"
	ROUNDINGRULETYPE_NONE RoundingRuleType = "None"
	ROUNDINGRULETYPE_UP_KEEP_DECIMAL RoundingRuleType = "UpKeepDecimal"
	ROUNDINGRULETYPE_DOWN_KEEP_DECIMAL RoundingRuleType = "DownKeepDecimal"
)

// All allowed values of RoundingRuleType enum
var AllowedRoundingRuleTypeEnumValues = []RoundingRuleType{
	"Up",
	"Down",
	"None",
	"UpKeepDecimal",
	"DownKeepDecimal",
}

func (v *RoundingRuleType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := RoundingRuleType(value)
	for _, existing := range AllowedRoundingRuleTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid RoundingRuleType", value)
}

// NewRoundingRuleTypeFromValue returns a pointer to a valid RoundingRuleType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewRoundingRuleTypeFromValue(v string) (*RoundingRuleType, error) {
	ev := RoundingRuleType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for RoundingRuleType: valid values are %v", v, AllowedRoundingRuleTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v RoundingRuleType) IsValid() bool {
	for _, existing := range AllowedRoundingRuleTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to roundingRuleType value
func (v RoundingRuleType) Ptr() *RoundingRuleType {
	return &v
}

type NullableRoundingRuleType struct {
	value *RoundingRuleType
	isSet bool
}

func (v NullableRoundingRuleType) Get() *RoundingRuleType {
	return v.value
}

func (v *NullableRoundingRuleType) Set(val *RoundingRuleType) {
	v.value = val
	v.isSet = true
}

func (v NullableRoundingRuleType) IsSet() bool {
	return v.isSet
}

func (v *NullableRoundingRuleType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRoundingRuleType(val *RoundingRuleType) *NullableRoundingRuleType {
	return &NullableRoundingRuleType{value: val, isSet: true}
}

func (v NullableRoundingRuleType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRoundingRuleType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

