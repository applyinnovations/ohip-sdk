/*
OPERA Cloud Reservation Master Data Management API

APIs to cater for Reservation Configuration in OPERA Cloud. In this module you can retrieve, create, modify or delete configuration related to Reservations, Blocks and Leisure Management.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ReservationConfigApiService ReservationConfigApi service
type ReservationConfigApiService service

type ReservationConfigApiCopyAutoAttachElementsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoAttachElementsCopy *CopyAutoAttachElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiCopyAutoAttachElementsRequest) Authorization(authorization string) ReservationConfigApiCopyAutoAttachElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiCopyAutoAttachElementsRequest) XAppKey(xAppKey string) ReservationConfigApiCopyAutoAttachElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiCopyAutoAttachElementsRequest) XHotelid(xHotelid string) ReservationConfigApiCopyAutoAttachElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the auto attach configuration rule(s) to be copied.
func (r ReservationConfigApiCopyAutoAttachElementsRequest) AutoAttachElementsCopy(autoAttachElementsCopy CopyAutoAttachElementsRequest) ReservationConfigApiCopyAutoAttachElementsRequest {
	r.autoAttachElementsCopy = &autoAttachElementsCopy
	return r
}

// External system code.
func (r ReservationConfigApiCopyAutoAttachElementsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiCopyAutoAttachElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiCopyAutoAttachElementsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiCopyAutoAttachElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiCopyAutoAttachElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyAutoAttachElementsExecute(r)
}

/*
CopyAutoAttachElements Copy Auto Attach Elements

You can use this API to copy Auto Attach Elements. <p><strong>OperationId:</strong>copyAutoAttachElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Source Hotel code
 @return ReservationConfigApiCopyAutoAttachElementsRequest
*/
func (a *ReservationConfigApiService) CopyAutoAttachElements(ctx context.Context, hotelId string) ReservationConfigApiCopyAutoAttachElementsRequest {
	return ReservationConfigApiCopyAutoAttachElementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) CopyAutoAttachElementsExecute(r ReservationConfigApiCopyAutoAttachElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.CopyAutoAttachElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoAttachElements/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoAttachElementsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiCopyECouponCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCouponCodesCopy *CopyECouponCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiCopyECouponCodesRequest) Authorization(authorization string) ReservationConfigApiCopyECouponCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiCopyECouponCodesRequest) XAppKey(xAppKey string) ReservationConfigApiCopyECouponCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiCopyECouponCodesRequest) XHotelid(xHotelid string) ReservationConfigApiCopyECouponCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy the existing eCoupon codes from source property to the selected target properties.
func (r ReservationConfigApiCopyECouponCodesRequest) ECouponCodesCopy(eCouponCodesCopy CopyECouponCodesRequest) ReservationConfigApiCopyECouponCodesRequest {
	r.eCouponCodesCopy = &eCouponCodesCopy
	return r
}

// External system code.
func (r ReservationConfigApiCopyECouponCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiCopyECouponCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiCopyECouponCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiCopyECouponCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiCopyECouponCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyECouponCodesExecute(r)
}

/*
CopyECouponCodes Copy eCoupon Codes

Copy an existing property eCoupon Codes to create a new one. <p><strong>OperationId:</strong>copyECouponCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiCopyECouponCodesRequest
*/
func (a *ReservationConfigApiService) CopyECouponCodes(ctx context.Context, hotelId string) ReservationConfigApiCopyECouponCodesRequest {
	return ReservationConfigApiCopyECouponCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) CopyECouponCodesExecute(r ReservationConfigApiCopyECouponCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.CopyECouponCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ecoupons/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCouponCodesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiCopyGlobalAlertsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	globalAlertsCopy *CopyGlobalAlertsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiCopyGlobalAlertsRequest) Authorization(authorization string) ReservationConfigApiCopyGlobalAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiCopyGlobalAlertsRequest) XAppKey(xAppKey string) ReservationConfigApiCopyGlobalAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiCopyGlobalAlertsRequest) XHotelid(xHotelid string) ReservationConfigApiCopyGlobalAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying Global Alerts.
func (r ReservationConfigApiCopyGlobalAlertsRequest) GlobalAlertsCopy(globalAlertsCopy CopyGlobalAlertsRequest) ReservationConfigApiCopyGlobalAlertsRequest {
	r.globalAlertsCopy = &globalAlertsCopy
	return r
}

// External system code.
func (r ReservationConfigApiCopyGlobalAlertsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiCopyGlobalAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiCopyGlobalAlertsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiCopyGlobalAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiCopyGlobalAlertsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyGlobalAlertsExecute(r)
}

/*
CopyGlobalAlerts Copy Global Alerts

Copy a Global Alert for a property. <p><strong>OperationId:</strong>copyGlobalAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiCopyGlobalAlertsRequest
*/
func (a *ReservationConfigApiService) CopyGlobalAlerts(ctx context.Context) ReservationConfigApiCopyGlobalAlertsRequest {
	return ReservationConfigApiCopyGlobalAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) CopyGlobalAlertsExecute(r ReservationConfigApiCopyGlobalAlertsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.CopyGlobalAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/globalAlerts/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.globalAlertsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiCopyTraceTextsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	traceTextsCopy *CopyTraceTextsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiCopyTraceTextsRequest) Authorization(authorization string) ReservationConfigApiCopyTraceTextsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiCopyTraceTextsRequest) XAppKey(xAppKey string) ReservationConfigApiCopyTraceTextsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiCopyTraceTextsRequest) XHotelid(xHotelid string) ReservationConfigApiCopyTraceTextsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying trace texts.
func (r ReservationConfigApiCopyTraceTextsRequest) TraceTextsCopy(traceTextsCopy CopyTraceTextsRequest) ReservationConfigApiCopyTraceTextsRequest {
	r.traceTextsCopy = &traceTextsCopy
	return r
}

// External system code.
func (r ReservationConfigApiCopyTraceTextsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiCopyTraceTextsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiCopyTraceTextsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiCopyTraceTextsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiCopyTraceTextsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTraceTextsExecute(r)
}

/*
CopyTraceTexts Copy trace text 

Copy an existing Trace Text to create a new one. <p><strong>OperationId:</strong>copyTraceTexts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Source Hotel code
 @return ReservationConfigApiCopyTraceTextsRequest
*/
func (a *ReservationConfigApiService) CopyTraceTexts(ctx context.Context, hotelId string) ReservationConfigApiCopyTraceTextsRequest {
	return ReservationConfigApiCopyTraceTextsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) CopyTraceTextsExecute(r ReservationConfigApiCopyTraceTextsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.CopyTraceTexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/traceTexts/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.traceTextsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiCopyUpsellRulesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	upsellRulesCopy *CopyUpsellRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiCopyUpsellRulesRequest) Authorization(authorization string) ReservationConfigApiCopyUpsellRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiCopyUpsellRulesRequest) XAppKey(xAppKey string) ReservationConfigApiCopyUpsellRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiCopyUpsellRulesRequest) XHotelid(xHotelid string) ReservationConfigApiCopyUpsellRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the upsell rules to be copied to hotel code(s).
func (r ReservationConfigApiCopyUpsellRulesRequest) UpsellRulesCopy(upsellRulesCopy CopyUpsellRulesRequest) ReservationConfigApiCopyUpsellRulesRequest {
	r.upsellRulesCopy = &upsellRulesCopy
	return r
}

// External system code.
func (r ReservationConfigApiCopyUpsellRulesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiCopyUpsellRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiCopyUpsellRulesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiCopyUpsellRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiCopyUpsellRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyUpsellRulesExecute(r)
}

/*
CopyUpsellRules Copy upsell rules

Copy an existing upsell rule, to create a new one. <p><strong>OperationId:</strong>copyUpsellRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Source Hotel code
 @return ReservationConfigApiCopyUpsellRulesRequest
*/
func (a *ReservationConfigApiService) CopyUpsellRules(ctx context.Context, hotelId string) ReservationConfigApiCopyUpsellRulesRequest {
	return ReservationConfigApiCopyUpsellRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) CopyUpsellRulesExecute(r ReservationConfigApiCopyUpsellRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.CopyUpsellRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upsellRules/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.upsellRulesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteAlertCodeTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	alertCodeTemplateCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) AlertCodeTemplateCodes(alertCodeTemplateCodes []string) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	r.alertCodeTemplateCodes = &alertCodeTemplateCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) Authorization(authorization string) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteAlertCodeTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAlertCodeTemplatesExecute(r)
}

/*
DeleteAlertCodeTemplates Delete Alert Code Template

Delete an existing alert code template. <p><strong>OperationId:</strong>deleteAlertCodeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiDeleteAlertCodeTemplatesRequest
*/
func (a *ReservationConfigApiService) DeleteAlertCodeTemplates(ctx context.Context) ReservationConfigApiDeleteAlertCodeTemplatesRequest {
	return ReservationConfigApiDeleteAlertCodeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteAlertCodeTemplatesExecute(r ReservationConfigApiDeleteAlertCodeTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteAlertCodeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alertCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.alertCodeTemplateCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodeTemplateCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodeTemplateCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteAlertCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteAlertCodesRequest) Authorization(authorization string) ReservationConfigApiDeleteAlertCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteAlertCodesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteAlertCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteAlertCodesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteAlertCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r ReservationConfigApiDeleteAlertCodesRequest) Codes(codes []string) ReservationConfigApiDeleteAlertCodesRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r ReservationConfigApiDeleteAlertCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteAlertCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteAlertCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteAlertCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteAlertCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAlertCodesExecute(r)
}

/*
DeleteAlertCodes Delete an Alert Code

You can use this API to delete an Alert Code. <p><strong>OperationId:</strong>deleteAlertCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiDeleteAlertCodesRequest
*/
func (a *ReservationConfigApiService) DeleteAlertCodes(ctx context.Context, hotelId string) ReservationConfigApiDeleteAlertCodesRequest {
	return ReservationConfigApiDeleteAlertCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteAlertCodesExecute(r ReservationConfigApiDeleteAlertCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteAlertCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/alertCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteAutoAttachElementsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	autoAttachElements *DeleteAutoAttachElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteAutoAttachElementsRequest) Authorization(authorization string) ReservationConfigApiDeleteAutoAttachElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteAutoAttachElementsRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteAutoAttachElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteAutoAttachElementsRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteAutoAttachElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Delete auto attach configuration rule(s) for resort.
func (r ReservationConfigApiDeleteAutoAttachElementsRequest) AutoAttachElements(autoAttachElements DeleteAutoAttachElementsRequest) ReservationConfigApiDeleteAutoAttachElementsRequest {
	r.autoAttachElements = &autoAttachElements
	return r
}

// External system code.
func (r ReservationConfigApiDeleteAutoAttachElementsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteAutoAttachElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteAutoAttachElementsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteAutoAttachElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteAutoAttachElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAutoAttachElementsExecute(r)
}

/*
DeleteAutoAttachElements Delete Auto Attach Elements

Delete an Auto Attach Element Rule on a property. <p><strong>OperationId:</strong>deleteAutoAttachElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiDeleteAutoAttachElementsRequest
*/
func (a *ReservationConfigApiService) DeleteAutoAttachElements(ctx context.Context) ReservationConfigApiDeleteAutoAttachElementsRequest {
	return ReservationConfigApiDeleteAutoAttachElementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteAutoAttachElementsExecute(r ReservationConfigApiDeleteAutoAttachElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteAutoAttachElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/autoAttachElements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoAttachElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteECouponCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	ecouponCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteECouponCodesRequest) Authorization(authorization string) ReservationConfigApiDeleteECouponCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteECouponCodesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteECouponCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteECouponCodesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteECouponCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteECouponCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteECouponCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteECouponCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteECouponCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteECouponCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteECouponCodesExecute(r)
}

/*
DeleteECouponCodes Delete an eCoupon Code

Delete an existing eCoupon Code. <p><strong>OperationId:</strong>deleteECouponCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecouponCode
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiDeleteECouponCodesRequest
*/
func (a *ReservationConfigApiService) DeleteECouponCodes(ctx context.Context, ecouponCode string, hotelId string) ReservationConfigApiDeleteECouponCodesRequest {
	return ReservationConfigApiDeleteECouponCodesRequest{
		ApiService: a,
		ctx: ctx,
		ecouponCode: ecouponCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteECouponCodesExecute(r ReservationConfigApiDeleteECouponCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteECouponCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ecouponCodes/{ecouponCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ecouponCode"+"}", url.PathEscape(parameterValueToString(r.ecouponCode, "ecouponCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ecouponCode) < 1 {
		return localVarReturnValue, nil, reportError("ecouponCode must have at least 1 elements")
	}
	if strlen(r.ecouponCode) > 2000 {
		return localVarReturnValue, nil, reportError("ecouponCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteGlobalAlertsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	globalAlerts *DeleteGlobalAlertsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteGlobalAlertsRequest) Authorization(authorization string) ReservationConfigApiDeleteGlobalAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteGlobalAlertsRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteGlobalAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteGlobalAlertsRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteGlobalAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for removing the existing Global Alerts.
func (r ReservationConfigApiDeleteGlobalAlertsRequest) GlobalAlerts(globalAlerts DeleteGlobalAlertsRequest) ReservationConfigApiDeleteGlobalAlertsRequest {
	r.globalAlerts = &globalAlerts
	return r
}

// External system code.
func (r ReservationConfigApiDeleteGlobalAlertsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteGlobalAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteGlobalAlertsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteGlobalAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteGlobalAlertsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGlobalAlertsExecute(r)
}

/*
DeleteGlobalAlerts Delete a Global Alert Code

Delete a Global Alert for a property. <p><strong>OperationId:</strong>deleteGlobalAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiDeleteGlobalAlertsRequest
*/
func (a *ReservationConfigApiService) DeleteGlobalAlerts(ctx context.Context) ReservationConfigApiDeleteGlobalAlertsRequest {
	return ReservationConfigApiDeleteGlobalAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteGlobalAlertsExecute(r ReservationConfigApiDeleteGlobalAlertsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteGlobalAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/globalAlerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.globalAlerts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteGuestMessageTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	guestMessageTemplateCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) GuestMessageTemplateCodes(guestMessageTemplateCodes []string) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	r.guestMessageTemplateCodes = &guestMessageTemplateCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) Authorization(authorization string) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteGuestMessageTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGuestMessageTemplatesExecute(r)
}

/*
DeleteGuestMessageTemplates Delete an existing guest message template

Delete an existing Guest Message Template. <p><strong>OperationId:</strong>deleteGuestMessageTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiDeleteGuestMessageTemplatesRequest
*/
func (a *ReservationConfigApiService) DeleteGuestMessageTemplates(ctx context.Context) ReservationConfigApiDeleteGuestMessageTemplatesRequest {
	return ReservationConfigApiDeleteGuestMessageTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteGuestMessageTemplatesExecute(r ReservationConfigApiDeleteGuestMessageTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteGuestMessageTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guestMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.guestMessageTemplateCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestMessageTemplateCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestMessageTemplateCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	messageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteGuestMessagesRequest) Authorization(authorization string) ReservationConfigApiDeleteGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteGuestMessagesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteGuestMessagesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteGuestMessagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGuestMessagesExecute(r)
}

/*
DeleteGuestMessages Delete a Guest messages

You can use this API to delete a Guest messages. <p><strong>OperationId:</strong>deleteGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageCode
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiDeleteGuestMessagesRequest
*/
func (a *ReservationConfigApiService) DeleteGuestMessages(ctx context.Context, messageCode string, hotelId string) ReservationConfigApiDeleteGuestMessagesRequest {
	return ReservationConfigApiDeleteGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		messageCode: messageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteGuestMessagesExecute(r ReservationConfigApiDeleteGuestMessagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guestMessages/{messageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageCode"+"}", url.PathEscape(parameterValueToString(r.messageCode, "messageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.messageCode) < 1 {
		return localVarReturnValue, nil, reportError("messageCode must have at least 1 elements")
	}
	if strlen(r.messageCode) > 2000 {
		return localVarReturnValue, nil, reportError("messageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteHotelTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	code string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiDeleteHotelTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteHotelTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteHotelTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteHotelTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteHotelTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelTurnAwayCodesExecute(r)
}

/*
DeleteHotelTurnAwayCodes Delete an existing turnaway code

Delete an existing Turnaway code for a property. <p><strong>OperationId:</strong>deleteHotelTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiDeleteHotelTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) DeleteHotelTurnAwayCodes(ctx context.Context, code string, hotelId string) ReservationConfigApiDeleteHotelTurnAwayCodesRequest {
	return ReservationConfigApiDeleteHotelTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteHotelTurnAwayCodesExecute(r ReservationConfigApiDeleteHotelTurnAwayCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteHotelTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/turnawayCodes/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteLocatorCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	locatorCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteLocatorCodesRequest) Authorization(authorization string) ReservationConfigApiDeleteLocatorCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteLocatorCodesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteLocatorCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteLocatorCodesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteLocatorCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteLocatorCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteLocatorCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteLocatorCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteLocatorCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteLocatorCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteLocatorCodesExecute(r)
}

/*
DeleteLocatorCodes Delete a Locator Code

You can use this API to delete a Locator Code. <p><strong>OperationId:</strong>deleteLocatorCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locatorCode
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiDeleteLocatorCodesRequest
*/
func (a *ReservationConfigApiService) DeleteLocatorCodes(ctx context.Context, locatorCode string, hotelId string) ReservationConfigApiDeleteLocatorCodesRequest {
	return ReservationConfigApiDeleteLocatorCodesRequest{
		ApiService: a,
		ctx: ctx,
		locatorCode: locatorCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteLocatorCodesExecute(r ReservationConfigApiDeleteLocatorCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteLocatorCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/locatorCodes/{locatorCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"locatorCode"+"}", url.PathEscape(parameterValueToString(r.locatorCode, "locatorCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.locatorCode) < 1 {
		return localVarReturnValue, nil, reportError("locatorCode must have at least 1 elements")
	}
	if strlen(r.locatorCode) > 2000 {
		return localVarReturnValue, nil, reportError("locatorCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteLocatorCodesTemplateRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	locatorCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) LocatorCodes(locatorCodes []string) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	r.locatorCodes = &locatorCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) Authorization(authorization string) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteLocatorCodesTemplateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteLocatorCodesTemplateExecute(r)
}

/*
DeleteLocatorCodesTemplate Delete a Locator Code

Delete the selected Locator Code <p><strong>OperationId:</strong>deleteLocatorCodesTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiDeleteLocatorCodesTemplateRequest
*/
func (a *ReservationConfigApiService) DeleteLocatorCodesTemplate(ctx context.Context) ReservationConfigApiDeleteLocatorCodesTemplateRequest {
	return ReservationConfigApiDeleteLocatorCodesTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteLocatorCodesTemplateExecute(r ReservationConfigApiDeleteLocatorCodesTemplateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteLocatorCodesTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templates/locatorCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.locatorCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locatorCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locatorCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteTemplateTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	turnawayCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiDeleteTemplateTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteTemplateTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteTemplateTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteTemplateTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteTemplateTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplateTurnAwayCodesExecute(r)
}

/*
DeleteTemplateTurnAwayCodes Delete a Turnaway code template

Delete an existing Turnaway Code Template. <p><strong>OperationId:</strong>deleteTemplateTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param turnawayCode
 @return ReservationConfigApiDeleteTemplateTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) DeleteTemplateTurnAwayCodes(ctx context.Context, turnawayCode string) ReservationConfigApiDeleteTemplateTurnAwayCodesRequest {
	return ReservationConfigApiDeleteTemplateTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
		turnawayCode: turnawayCode,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteTemplateTurnAwayCodesExecute(r ReservationConfigApiDeleteTemplateTurnAwayCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteTemplateTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/turnawayCodes/{turnawayCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"turnawayCode"+"}", url.PathEscape(parameterValueToString(r.turnawayCode, "turnawayCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.turnawayCode) < 1 {
		return localVarReturnValue, nil, reportError("turnawayCode must have at least 1 elements")
	}
	if strlen(r.turnawayCode) > 2000 {
		return localVarReturnValue, nil, reportError("turnawayCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteTraceTextsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	departmentCode *[]string
	traceText *[]string
	canDelete *[]bool
	displaySequence *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteTraceTextsRequest) Authorization(authorization string) ReservationConfigApiDeleteTraceTextsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteTraceTextsRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteTraceTextsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteTraceTextsRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteTraceTextsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property Code where the trace text belongs to.
func (r ReservationConfigApiDeleteTraceTextsRequest) HotelId(hotelId []string) ReservationConfigApiDeleteTraceTextsRequest {
	r.hotelId = &hotelId
	return r
}

// Department Code where the trace text belongs to.
func (r ReservationConfigApiDeleteTraceTextsRequest) DepartmentCode(departmentCode []string) ReservationConfigApiDeleteTraceTextsRequest {
	r.departmentCode = &departmentCode
	return r
}

// Trace text value.
func (r ReservationConfigApiDeleteTraceTextsRequest) TraceText(traceText []string) ReservationConfigApiDeleteTraceTextsRequest {
	r.traceText = &traceText
	return r
}

// Determines whether this trace text can be deleted.
func (r ReservationConfigApiDeleteTraceTextsRequest) CanDelete(canDelete []bool) ReservationConfigApiDeleteTraceTextsRequest {
	r.canDelete = &canDelete
	return r
}

// Display Sequence for the trace text.
func (r ReservationConfigApiDeleteTraceTextsRequest) DisplaySequence(displaySequence []float32) ReservationConfigApiDeleteTraceTextsRequest {
	r.displaySequence = &displaySequence
	return r
}

// External system code.
func (r ReservationConfigApiDeleteTraceTextsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteTraceTextsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteTraceTextsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteTraceTextsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteTraceTextsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTraceTextsExecute(r)
}

/*
DeleteTraceTexts Delete trace text 

Delete an existing Trace Text for a property. <p><strong>OperationId:</strong>deleteTraceTexts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiDeleteTraceTextsRequest
*/
func (a *ReservationConfigApiService) DeleteTraceTexts(ctx context.Context) ReservationConfigApiDeleteTraceTextsRequest {
	return ReservationConfigApiDeleteTraceTextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteTraceTextsExecute(r ReservationConfigApiDeleteTraceTextsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteTraceTexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traceTexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.departmentCode != nil {
		t := *r.departmentCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCode", t, "multi")
		}
	}
	if r.traceText != nil {
		t := *r.traceText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "traceText", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "traceText", t, "multi")
		}
	}
	if r.canDelete != nil {
		t := *r.canDelete
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "canDelete", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "canDelete", t, "multi")
		}
	}
	if r.displaySequence != nil {
		t := *r.displaySequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "displaySequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "displaySequence", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiDeleteUpsellRulesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	ruleCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiDeleteUpsellRulesRequest) Authorization(authorization string) ReservationConfigApiDeleteUpsellRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiDeleteUpsellRulesRequest) XAppKey(xAppKey string) ReservationConfigApiDeleteUpsellRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiDeleteUpsellRulesRequest) XHotelid(xHotelid string) ReservationConfigApiDeleteUpsellRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationConfigApiDeleteUpsellRulesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiDeleteUpsellRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiDeleteUpsellRulesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiDeleteUpsellRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiDeleteUpsellRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteUpsellRulesExecute(r)
}

/*
DeleteUpsellRules Delete an Upsell Rule

Use this API to delete an existing Upgrade rule for a property. <p><strong>OperationId:</strong>deleteUpsellRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleCode
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiDeleteUpsellRulesRequest
*/
func (a *ReservationConfigApiService) DeleteUpsellRules(ctx context.Context, ruleCode string, hotelId string) ReservationConfigApiDeleteUpsellRulesRequest {
	return ReservationConfigApiDeleteUpsellRulesRequest{
		ApiService: a,
		ctx: ctx,
		ruleCode: ruleCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) DeleteUpsellRulesExecute(r ReservationConfigApiDeleteUpsellRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.DeleteUpsellRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upsellRules/{ruleCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleCode"+"}", url.PathEscape(parameterValueToString(r.ruleCode, "ruleCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ruleCode) < 1 {
		return localVarReturnValue, nil, reportError("ruleCode must have at least 1 elements")
	}
	if strlen(r.ruleCode) > 2000 {
		return localVarReturnValue, nil, reportError("ruleCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetAlertCodeTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	alertCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) Authorization(authorization string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) AlertCodes(alertCodes []string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.alertCodes = &alertCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) WildCard(wildCard string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetAlertCodeTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetAlertCodeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetAlertCodeTemplatesRequest) Execute() (*AlertCodeTemplates, *http.Response, error) {
	return r.ApiService.GetAlertCodeTemplatesExecute(r)
}

/*
GetAlertCodeTemplates Get Alert Code Templates

Retrieve all configured Alert Code Templates. <p><strong>OperationId:</strong>getAlertCodeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetAlertCodeTemplatesRequest
*/
func (a *ReservationConfigApiService) GetAlertCodeTemplates(ctx context.Context) ReservationConfigApiGetAlertCodeTemplatesRequest {
	return ReservationConfigApiGetAlertCodeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertCodeTemplates
func (a *ReservationConfigApiService) GetAlertCodeTemplatesExecute(r ReservationConfigApiGetAlertCodeTemplatesRequest) (*AlertCodeTemplates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCodeTemplates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetAlertCodeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alertCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.alertCodes != nil {
		t := *r.alertCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetAlertCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	alertCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetAlertCodesRequest) Authorization(authorization string) ReservationConfigApiGetAlertCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetAlertCodesRequest) XAppKey(xAppKey string) ReservationConfigApiGetAlertCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetAlertCodesRequest) XHotelid(xHotelid string) ReservationConfigApiGetAlertCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationConfigApiGetAlertCodesRequest) Code(code []string) ReservationConfigApiGetAlertCodesRequest {
	r.code = &code
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetAlertCodesRequest) AlertCodes(alertCodes []string) ReservationConfigApiGetAlertCodesRequest {
	r.alertCodes = &alertCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetAlertCodesRequest) WildCard(wildCard string) ReservationConfigApiGetAlertCodesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ReservationConfigApiGetAlertCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetAlertCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetAlertCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetAlertCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetAlertCodesRequest) Execute() (*AlertCodes, *http.Response, error) {
	return r.ApiService.GetAlertCodesExecute(r)
}

/*
GetAlertCodes Get Alert Codes

You can use this API to get Alert Codes. <p><strong>OperationId:</strong>getAlertCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetAlertCodesRequest
*/
func (a *ReservationConfigApiService) GetAlertCodes(ctx context.Context, hotelId string) ReservationConfigApiGetAlertCodesRequest {
	return ReservationConfigApiGetAlertCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AlertCodes
func (a *ReservationConfigApiService) GetAlertCodesExecute(r ReservationConfigApiGetAlertCodesRequest) (*AlertCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetAlertCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/alertCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.alertCodes != nil {
		t := *r.alertCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetAutoAttachElementsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	code *[]string
	criteriaCode *string
	type_ *string
	basedOn *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetAutoAttachElementsRequest) Authorization(authorization string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetAutoAttachElementsRequest) XAppKey(xAppKey string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetAutoAttachElementsRequest) XHotelid(xHotelid string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of Hotels.
func (r ReservationConfigApiGetAutoAttachElementsRequest) HotelIds(hotelIds []string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ReservationConfigApiGetAutoAttachElementsRequest) Code(code []string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.code = &code
	return r
}

// The name of the rule.
func (r ReservationConfigApiGetAutoAttachElementsRequest) CriteriaCode(criteriaCode string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.criteriaCode = &criteriaCode
	return r
}

// Available only when Reservation Discounts and Advanced Discounts are active
func (r ReservationConfigApiGetAutoAttachElementsRequest) Type_(type_ string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.type_ = &type_
	return r
}

// Available only when Keyword Functionality is active.
func (r ReservationConfigApiGetAutoAttachElementsRequest) BasedOn(basedOn string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.basedOn = &basedOn
	return r
}

// Indicator that tells whether to include inactive rules in search results.
func (r ReservationConfigApiGetAutoAttachElementsRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetAutoAttachElementsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetAutoAttachElementsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetAutoAttachElementsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetAutoAttachElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetAutoAttachElementsRequest) Execute() (*AutoAttachElementsConfig, *http.Response, error) {
	return r.ApiService.GetAutoAttachElementsExecute(r)
}

/*
GetAutoAttachElements Get Auto Attach Elements

Retrieve the Auto Attach Element Rules that are configured. Auto attach elements are rules defined to auto-update various fields (elements) on a new reservation.  Rules can be associated with rate codes, memberships, room types, preferences etc.  An example could be 'If rate code is PROMO1 then update specials on the reservation to include FB (Fruit Basket). <p><strong>OperationId:</strong>getAutoAttachElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetAutoAttachElementsRequest
*/
func (a *ReservationConfigApiService) GetAutoAttachElements(ctx context.Context, hotelId string) ReservationConfigApiGetAutoAttachElementsRequest {
	return ReservationConfigApiGetAutoAttachElementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoAttachElementsConfig
func (a *ReservationConfigApiService) GetAutoAttachElementsExecute(r ReservationConfigApiGetAutoAttachElementsRequest) (*AutoAttachElementsConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoAttachElementsConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetAutoAttachElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoAttachElements"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.criteriaCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "criteriaCode", r.criteriaCode, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.basedOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "basedOn", r.basedOn, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetECouponCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	eCouponCodes *[]string
	wildCardECouponCodes *string
	ratePlansCodes *[]string
	wildCardRatePlans *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetECouponCodesRequest) Authorization(authorization string) ReservationConfigApiGetECouponCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetECouponCodesRequest) XAppKey(xAppKey string) ReservationConfigApiGetECouponCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetECouponCodesRequest) XHotelid(xHotelid string) ReservationConfigApiGetECouponCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetECouponCodesRequest) Limit(limit int32) ReservationConfigApiGetECouponCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetECouponCodesRequest) Offset(offset int32) ReservationConfigApiGetECouponCodesRequest {
	r.offset = &offset
	return r
}

func (r ReservationConfigApiGetECouponCodesRequest) HotelIds(hotelIds []string) ReservationConfigApiGetECouponCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetECouponCodesRequest) ECouponCodes(eCouponCodes []string) ReservationConfigApiGetECouponCodesRequest {
	r.eCouponCodes = &eCouponCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetECouponCodesRequest) WildCardECouponCodes(wildCardECouponCodes string) ReservationConfigApiGetECouponCodesRequest {
	r.wildCardECouponCodes = &wildCardECouponCodes
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetECouponCodesRequest) RatePlansCodes(ratePlansCodes []string) ReservationConfigApiGetECouponCodesRequest {
	r.ratePlansCodes = &ratePlansCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetECouponCodesRequest) WildCardRatePlans(wildCardRatePlans string) ReservationConfigApiGetECouponCodesRequest {
	r.wildCardRatePlans = &wildCardRatePlans
	return r
}

// Indicator that tells whether to include inactive rules in search results .
func (r ReservationConfigApiGetECouponCodesRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetECouponCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetECouponCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetECouponCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetECouponCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetECouponCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetECouponCodesRequest) Execute() (*ECouponCodes, *http.Response, error) {
	return r.ApiService.GetECouponCodesExecute(r)
}

/*
GetECouponCodes Get eCoupon Codes

Get existing property eCoupon Codes. <p><strong>OperationId:</strong>getECouponCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetECouponCodesRequest
*/
func (a *ReservationConfigApiService) GetECouponCodes(ctx context.Context) ReservationConfigApiGetECouponCodesRequest {
	return ReservationConfigApiGetECouponCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ECouponCodes
func (a *ReservationConfigApiService) GetECouponCodesExecute(r ReservationConfigApiGetECouponCodesRequest) (*ECouponCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECouponCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetECouponCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecoupons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.eCouponCodes != nil {
		t := *r.eCouponCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eCouponCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eCouponCodes", t, "multi")
		}
	}
	if r.wildCardECouponCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCardECouponCodes", r.wildCardECouponCodes, "")
	}
	if r.ratePlansCodes != nil {
		t := *r.ratePlansCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlansCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlansCodes", t, "multi")
		}
	}
	if r.wildCardRatePlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCardRatePlans", r.wildCardRatePlans, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetGlobalAlertsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	alertCodes *[]string
	wildCard *string
	welcomeOffer *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetGlobalAlertsRequest) Authorization(authorization string) ReservationConfigApiGetGlobalAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetGlobalAlertsRequest) XAppKey(xAppKey string) ReservationConfigApiGetGlobalAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetGlobalAlertsRequest) XHotelid(xHotelid string) ReservationConfigApiGetGlobalAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ReservationConfigApiGetGlobalAlertsRequest) HotelIds(hotelIds []string) ReservationConfigApiGetGlobalAlertsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetGlobalAlertsRequest) AlertCodes(alertCodes []string) ReservationConfigApiGetGlobalAlertsRequest {
	r.alertCodes = &alertCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetGlobalAlertsRequest) WildCard(wildCard string) ReservationConfigApiGetGlobalAlertsRequest {
	r.wildCard = &wildCard
	return r
}

func (r ReservationConfigApiGetGlobalAlertsRequest) WelcomeOffer(welcomeOffer bool) ReservationConfigApiGetGlobalAlertsRequest {
	r.welcomeOffer = &welcomeOffer
	return r
}

// External system code.
func (r ReservationConfigApiGetGlobalAlertsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetGlobalAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetGlobalAlertsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetGlobalAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetGlobalAlertsRequest) Execute() (*GlobalAlertsInfo, *http.Response, error) {
	return r.ApiService.GetGlobalAlertsExecute(r)
}

/*
GetGlobalAlerts Get Global Alerts

Retrieve all configured Global Alerts for a property. <p><strong>OperationId:</strong>getGlobalAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetGlobalAlertsRequest
*/
func (a *ReservationConfigApiService) GetGlobalAlerts(ctx context.Context) ReservationConfigApiGetGlobalAlertsRequest {
	return ReservationConfigApiGetGlobalAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GlobalAlertsInfo
func (a *ReservationConfigApiService) GetGlobalAlertsExecute(r ReservationConfigApiGetGlobalAlertsRequest) (*GlobalAlertsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalAlertsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetGlobalAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/globalAlerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.alertCodes != nil {
		t := *r.alertCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "alertCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.welcomeOffer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "welcomeOffer", r.welcomeOffer, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetGuestMessageTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guestMessageCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) Authorization(authorization string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) GuestMessageCodes(guestMessageCodes []string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.guestMessageCodes = &guestMessageCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) WildCard(wildCard string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetGuestMessageTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetGuestMessageTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetGuestMessageTemplatesRequest) Execute() (*GuestMessageTemplates, *http.Response, error) {
	return r.ApiService.GetGuestMessageTemplatesExecute(r)
}

/*
GetGuestMessageTemplates Get Guest Message Templates

Retrieve the configured Guest Message Templates. <p><strong>OperationId:</strong>getGuestMessageTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetGuestMessageTemplatesRequest
*/
func (a *ReservationConfigApiService) GetGuestMessageTemplates(ctx context.Context) ReservationConfigApiGetGuestMessageTemplatesRequest {
	return ReservationConfigApiGetGuestMessageTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GuestMessageTemplates
func (a *ReservationConfigApiService) GetGuestMessageTemplatesExecute(r ReservationConfigApiGetGuestMessageTemplatesRequest) (*GuestMessageTemplates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestMessageTemplates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetGuestMessageTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guestMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guestMessageCodes != nil {
		t := *r.guestMessageCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestMessageCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestMessageCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	offset *int32
	guestMessageCodes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetGuestMessagesRequest) Authorization(authorization string) ReservationConfigApiGetGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetGuestMessagesRequest) XAppKey(xAppKey string) ReservationConfigApiGetGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetGuestMessagesRequest) XHotelid(xHotelid string) ReservationConfigApiGetGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of Hotels.
func (r ReservationConfigApiGetGuestMessagesRequest) HotelIds(hotelIds []string) ReservationConfigApiGetGuestMessagesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetGuestMessagesRequest) Limit(limit int32) ReservationConfigApiGetGuestMessagesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetGuestMessagesRequest) Offset(offset int32) ReservationConfigApiGetGuestMessagesRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetGuestMessagesRequest) GuestMessageCodes(guestMessageCodes []string) ReservationConfigApiGetGuestMessagesRequest {
	r.guestMessageCodes = &guestMessageCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetGuestMessagesRequest) WildCard(wildCard string) ReservationConfigApiGetGuestMessagesRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r ReservationConfigApiGetGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetGuestMessagesRequest) Execute() (*RetrievedGuestMessages, *http.Response, error) {
	return r.ApiService.GetGuestMessagesExecute(r)
}

/*
GetGuestMessages Get Guest Messages

You can use this API to get Guest Messages. <p><strong>OperationId:</strong>getGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetGuestMessagesRequest
*/
func (a *ReservationConfigApiService) GetGuestMessages(ctx context.Context, hotelId string) ReservationConfigApiGetGuestMessagesRequest {
	return ReservationConfigApiGetGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RetrievedGuestMessages
func (a *ReservationConfigApiService) GetGuestMessagesExecute(r ReservationConfigApiGetGuestMessagesRequest) (*RetrievedGuestMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetrievedGuestMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guestMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.guestMessageCodes != nil {
		t := *r.guestMessageCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestMessageCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestMessageCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetHotelTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	code *[]string
	turnAwayCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) Limit(limit int32) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) Offset(offset int32) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.offset = &offset
	return r
}

func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) Code(code []string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.code = &code
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) TurnAwayCodes(turnAwayCodes []string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.turnAwayCodes = &turnAwayCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) WildCard(wildCard string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Inactive flag - whether or not to display inactive records
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetHotelTurnAwayCodesRequest) Execute() (*HotelTurnAwayCodes, *http.Response, error) {
	return r.ApiService.GetHotelTurnAwayCodesExecute(r)
}

/*
GetHotelTurnAwayCodes Get Turnaway codes

Turnaway Codes enable you to record the number of potential reservations that were "turned away" and could not be confirmed.  Use this API to fetch all configured Turnaway codes for a property. <p><strong>OperationId:</strong>getHotelTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetHotelTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) GetHotelTurnAwayCodes(ctx context.Context, hotelId string) ReservationConfigApiGetHotelTurnAwayCodesRequest {
	return ReservationConfigApiGetHotelTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelTurnAwayCodes
func (a *ReservationConfigApiService) GetHotelTurnAwayCodesExecute(r ReservationConfigApiGetHotelTurnAwayCodesRequest) (*HotelTurnAwayCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelTurnAwayCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetHotelTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/turnawayCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	if r.turnAwayCodes != nil {
		t := *r.turnAwayCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "turnAwayCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "turnAwayCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetLocatorCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	offset *int32
	locatorCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetLocatorCodesRequest) Authorization(authorization string) ReservationConfigApiGetLocatorCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetLocatorCodesRequest) XAppKey(xAppKey string) ReservationConfigApiGetLocatorCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetLocatorCodesRequest) XHotelid(xHotelid string) ReservationConfigApiGetLocatorCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of Hotels.
func (r ReservationConfigApiGetLocatorCodesRequest) HotelIds(hotelIds []string) ReservationConfigApiGetLocatorCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetLocatorCodesRequest) Limit(limit int32) ReservationConfigApiGetLocatorCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetLocatorCodesRequest) Offset(offset int32) ReservationConfigApiGetLocatorCodesRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetLocatorCodesRequest) LocatorCodes(locatorCodes []string) ReservationConfigApiGetLocatorCodesRequest {
	r.locatorCodes = &locatorCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetLocatorCodesRequest) WildCard(wildCard string) ReservationConfigApiGetLocatorCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Indicator that tells whether to include inactive rules in search results.
func (r ReservationConfigApiGetLocatorCodesRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetLocatorCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetLocatorCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetLocatorCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetLocatorCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetLocatorCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetLocatorCodesRequest) Execute() (*LocatorCodesInfo, *http.Response, error) {
	return r.ApiService.GetLocatorCodesExecute(r)
}

/*
GetLocatorCodes Get existing property Locator Codes

You can use this API to get existing property Locator Codes. <p><strong>OperationId:</strong>getLocatorCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetLocatorCodesRequest
*/
func (a *ReservationConfigApiService) GetLocatorCodes(ctx context.Context, hotelId string) ReservationConfigApiGetLocatorCodesRequest {
	return ReservationConfigApiGetLocatorCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return LocatorCodesInfo
func (a *ReservationConfigApiService) GetLocatorCodesExecute(r ReservationConfigApiGetLocatorCodesRequest) (*LocatorCodesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocatorCodesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetLocatorCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/locatorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.locatorCodes != nil {
		t := *r.locatorCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locatorCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locatorCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetLocatorCodesTemplateRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	locatorCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) Authorization(authorization string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) XAppKey(xAppKey string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) XHotelid(xHotelid string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) LocatorCodes(locatorCodes []string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.locatorCodes = &locatorCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) WildCard(wildCard string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.wildCard = &wildCard
	return r
}

// Indicator that tells whether to include inactive rules in search results.
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetLocatorCodesTemplateRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetLocatorCodesTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetLocatorCodesTemplateRequest) Execute() (*LocatorCodesTemplateInfo, *http.Response, error) {
	return r.ApiService.GetLocatorCodesTemplateExecute(r)
}

/*
GetLocatorCodesTemplate Get template Locator Codes

Get existing template Locator Codes <p><strong>OperationId:</strong>getLocatorCodesTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetLocatorCodesTemplateRequest
*/
func (a *ReservationConfigApiService) GetLocatorCodesTemplate(ctx context.Context) ReservationConfigApiGetLocatorCodesTemplateRequest {
	return ReservationConfigApiGetLocatorCodesTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LocatorCodesTemplateInfo
func (a *ReservationConfigApiService) GetLocatorCodesTemplateExecute(r ReservationConfigApiGetLocatorCodesTemplateRequest) (*LocatorCodesTemplateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LocatorCodesTemplateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetLocatorCodesTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templates/locatorCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.locatorCodes != nil {
		t := *r.locatorCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locatorCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locatorCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetMembershipLevelRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	membershipTypeCodes *[]string
	wildCardMembershipTypes *string
	membershipLevelCodes *[]string
	wildCardMembershipLevels *string
	descriptionWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) Authorization(authorization string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) Limit(limit int32) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) Offset(offset int32) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) MembershipTypeCodes(membershipTypeCodes []string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.membershipTypeCodes = &membershipTypeCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) WildCardMembershipTypes(wildCardMembershipTypes string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.wildCardMembershipTypes = &wildCardMembershipTypes
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) MembershipLevelCodes(membershipLevelCodes []string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.membershipLevelCodes = &membershipLevelCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) WildCardMembershipLevels(wildCardMembershipLevels string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.wildCardMembershipLevels = &wildCardMembershipLevels
	return r
}

// Criteria to specify which membership levels description would be included in the results.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) DescriptionWildCard(descriptionWildCard string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// External system code.
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetMembershipLevelRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetMembershipLevelRatingsRequest) Execute() (*MembershipLevelRatingsInfo, *http.Response, error) {
	return r.ApiService.GetMembershipLevelRatingsExecute(r)
}

/*
GetMembershipLevelRatings Get Membership Level Ratings

This API accepts the membership level ratings in the request and returns gets the membership levels. <p><strong>OperationId:</strong>getMembershipLevelRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetMembershipLevelRatingsRequest
*/
func (a *ReservationConfigApiService) GetMembershipLevelRatings(ctx context.Context, hotelId string) ReservationConfigApiGetMembershipLevelRatingsRequest {
	return ReservationConfigApiGetMembershipLevelRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MembershipLevelRatingsInfo
func (a *ReservationConfigApiService) GetMembershipLevelRatingsExecute(r ReservationConfigApiGetMembershipLevelRatingsRequest) (*MembershipLevelRatingsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipLevelRatingsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetMembershipLevelRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/membershipLevels/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.membershipTypeCodes != nil {
		t := *r.membershipTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipTypeCodes", t, "multi")
		}
	}
	if r.wildCardMembershipTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCardMembershipTypes", r.wildCardMembershipTypes, "")
	}
	if r.membershipLevelCodes != nil {
		t := *r.membershipLevelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevelCodes", t, "multi")
		}
	}
	if r.wildCardMembershipLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCardMembershipLevels", r.wildCardMembershipLevels, "")
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetRatePlanRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	ratePlanCodes *[]string
	rateCategoryCodes *[]string
	ratings *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetRatePlanRatingsRequest) Authorization(authorization string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetRatePlanRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetRatePlanRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetRatePlanRatingsRequest) Limit(limit int32) ReservationConfigApiGetRatePlanRatingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetRatePlanRatingsRequest) Offset(offset int32) ReservationConfigApiGetRatePlanRatingsRequest {
	r.offset = &offset
	return r
}

func (r ReservationConfigApiGetRatePlanRatingsRequest) RatePlanCodes(ratePlanCodes []string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.ratePlanCodes = &ratePlanCodes
	return r
}

func (r ReservationConfigApiGetRatePlanRatingsRequest) RateCategoryCodes(rateCategoryCodes []string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.rateCategoryCodes = &rateCategoryCodes
	return r
}

// Possible Rate plan rating values.
func (r ReservationConfigApiGetRatePlanRatingsRequest) Ratings(ratings []string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.ratings = &ratings
	return r
}

// External system code.
func (r ReservationConfigApiGetRatePlanRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetRatePlanRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetRatePlanRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetRatePlanRatingsRequest) Execute() (*RatePlanRatings, *http.Response, error) {
	return r.ApiService.GetRatePlanRatingsExecute(r)
}

/*
GetRatePlanRatings Get Rate Plan Ratings

You can use this API to get Rate Plan Ratings. <p><strong>OperationId:</strong>getRatePlanRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetRatePlanRatingsRequest
*/
func (a *ReservationConfigApiService) GetRatePlanRatings(ctx context.Context, hotelId string) ReservationConfigApiGetRatePlanRatingsRequest {
	return ReservationConfigApiGetRatePlanRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanRatings
func (a *ReservationConfigApiService) GetRatePlanRatingsExecute(r ReservationConfigApiGetRatePlanRatingsRequest) (*RatePlanRatings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanRatings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetRatePlanRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ratePlanCodes != nil {
		t := *r.ratePlanCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCodes", t, "multi")
		}
	}
	if r.rateCategoryCodes != nil {
		t := *r.rateCategoryCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategoryCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategoryCodes", t, "multi")
		}
	}
	if r.ratings != nil {
		t := *r.ratings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetReservationColorsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	description *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetReservationColorsRequest) Authorization(authorization string) ReservationConfigApiGetReservationColorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetReservationColorsRequest) XAppKey(xAppKey string) ReservationConfigApiGetReservationColorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetReservationColorsRequest) XHotelid(xHotelid string) ReservationConfigApiGetReservationColorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Description to filter result.
func (r ReservationConfigApiGetReservationColorsRequest) Description(description string) ReservationConfigApiGetReservationColorsRequest {
	r.description = &description
	return r
}

// Indicates whether to include inactive reservation colors or not.
func (r ReservationConfigApiGetReservationColorsRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetReservationColorsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetReservationColorsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetReservationColorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetReservationColorsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetReservationColorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetReservationColorsRequest) Execute() (*ReservationColorsResponse, *http.Response, error) {
	return r.ApiService.GetReservationColorsExecute(r)
}

/*
GetReservationColors Get Reservation Colors

Use this API to get Reservation Colors. <p><strong>OperationId:</strong>getReservationColors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return ReservationConfigApiGetReservationColorsRequest
*/
func (a *ReservationConfigApiService) GetReservationColors(ctx context.Context, hotelId string) ReservationConfigApiGetReservationColorsRequest {
	return ReservationConfigApiGetReservationColorsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationColorsResponse
func (a *ReservationConfigApiService) GetReservationColorsExecute(r ReservationConfigApiGetReservationColorsRequest) (*ReservationColorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationColorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetReservationColors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/colors"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetRoomFeatureRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	featureCodes *[]string
	wildCardRoomFeatures *string
	descriptionWildCard *string
	ratings *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) Authorization(authorization string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) Limit(limit int32) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) Offset(offset int32) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) FeatureCodes(featureCodes []string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.featureCodes = &featureCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) WildCardRoomFeatures(wildCardRoomFeatures string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.wildCardRoomFeatures = &wildCardRoomFeatures
	return r
}

// Criteria to specify which rooms features description would be included in the results.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) DescriptionWildCard(descriptionWildCard string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// Possible Room Feature rating values.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) Ratings(ratings []string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.ratings = &ratings
	return r
}

// External system code.
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetRoomFeatureRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetRoomFeatureRatingsRequest) Execute() (*RoomFeatureRatingsInfo, *http.Response, error) {
	return r.ApiService.GetRoomFeatureRatingsExecute(r)
}

/*
GetRoomFeatureRatings Get Room Feature Ratings

You can use this API to get Room Feature Ratings. <p><strong>OperationId:</strong>getRoomFeatureRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetRoomFeatureRatingsRequest
*/
func (a *ReservationConfigApiService) GetRoomFeatureRatings(ctx context.Context, hotelId string) ReservationConfigApiGetRoomFeatureRatingsRequest {
	return ReservationConfigApiGetRoomFeatureRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomFeatureRatingsInfo
func (a *ReservationConfigApiService) GetRoomFeatureRatingsExecute(r ReservationConfigApiGetRoomFeatureRatingsRequest) (*RoomFeatureRatingsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomFeatureRatingsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetRoomFeatureRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomFeatures/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.featureCodes != nil {
		t := *r.featureCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "featureCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "featureCodes", t, "multi")
		}
	}
	if r.wildCardRoomFeatures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCardRoomFeatures", r.wildCardRoomFeatures, "")
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	if r.ratings != nil {
		t := *r.ratings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetRoomRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	roomNumberCodes *[]string
	roomTypeCodes *[]string
	roomClassCodes *[]string
	ratings *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetRoomRatingsRequest) Authorization(authorization string) ReservationConfigApiGetRoomRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetRoomRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiGetRoomRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetRoomRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiGetRoomRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetRoomRatingsRequest) Limit(limit int32) ReservationConfigApiGetRoomRatingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetRoomRatingsRequest) Offset(offset int32) ReservationConfigApiGetRoomRatingsRequest {
	r.offset = &offset
	return r
}

func (r ReservationConfigApiGetRoomRatingsRequest) RoomNumberCodes(roomNumberCodes []string) ReservationConfigApiGetRoomRatingsRequest {
	r.roomNumberCodes = &roomNumberCodes
	return r
}

func (r ReservationConfigApiGetRoomRatingsRequest) RoomTypeCodes(roomTypeCodes []string) ReservationConfigApiGetRoomRatingsRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r ReservationConfigApiGetRoomRatingsRequest) RoomClassCodes(roomClassCodes []string) ReservationConfigApiGetRoomRatingsRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

// Possible room rating values.
func (r ReservationConfigApiGetRoomRatingsRequest) Ratings(ratings []string) ReservationConfigApiGetRoomRatingsRequest {
	r.ratings = &ratings
	return r
}

// External system code.
func (r ReservationConfigApiGetRoomRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetRoomRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetRoomRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetRoomRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetRoomRatingsRequest) Execute() (*RoomRatings, *http.Response, error) {
	return r.ApiService.GetRoomRatingsExecute(r)
}

/*
GetRoomRatings Get Room Ratings

You can use this API to get Room Ratings. <p><strong>OperationId:</strong>getRoomRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetRoomRatingsRequest
*/
func (a *ReservationConfigApiService) GetRoomRatings(ctx context.Context, hotelId string) ReservationConfigApiGetRoomRatingsRequest {
	return ReservationConfigApiGetRoomRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRatings
func (a *ReservationConfigApiService) GetRoomRatingsExecute(r ReservationConfigApiGetRoomRatingsRequest) (*RoomRatings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRatings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetRoomRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.roomNumberCodes != nil {
		t := *r.roomNumberCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberCodes", t, "multi")
		}
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	if r.ratings != nil {
		t := *r.ratings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetRoomSpecialRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	specialCodes *[]string
	wildCardRoomSpecials *string
	descriptionWildCard *string
	ratings *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) Authorization(authorization string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) Limit(limit int32) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) Offset(offset int32) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) SpecialCodes(specialCodes []string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.specialCodes = &specialCodes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) WildCardRoomSpecials(wildCardRoomSpecials string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.wildCardRoomSpecials = &wildCardRoomSpecials
	return r
}

// Criteria to specify which rooms specials description would be included in the results.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) DescriptionWildCard(descriptionWildCard string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// Possible Room special rating values.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) Ratings(ratings []string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.ratings = &ratings
	return r
}

// External system code.
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetRoomSpecialRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetRoomSpecialRatingsRequest) Execute() (*RoomSpecialRatingsInfo, *http.Response, error) {
	return r.ApiService.GetRoomSpecialRatingsExecute(r)
}

/*
GetRoomSpecialRatings Get Room Special Ratings

You can use this API to get Room Special Ratings. <p><strong>OperationId:</strong>getRoomSpecialRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetRoomSpecialRatingsRequest
*/
func (a *ReservationConfigApiService) GetRoomSpecialRatings(ctx context.Context, hotelId string) ReservationConfigApiGetRoomSpecialRatingsRequest {
	return ReservationConfigApiGetRoomSpecialRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomSpecialRatingsInfo
func (a *ReservationConfigApiService) GetRoomSpecialRatingsExecute(r ReservationConfigApiGetRoomSpecialRatingsRequest) (*RoomSpecialRatingsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomSpecialRatingsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetRoomSpecialRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomSpecials/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.specialCodes != nil {
		t := *r.specialCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "specialCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "specialCodes", t, "multi")
		}
	}
	if r.wildCardRoomSpecials != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCardRoomSpecials", r.wildCardRoomSpecials, "")
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	if r.ratings != nil {
		t := *r.ratings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratings", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetTemplateTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	codes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) Codes(codes []string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) WildCard(wildCard string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Inactive flag - whether or not to display inactive records.
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) IncludeInactive(includeInactive bool) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetTemplateTurnAwayCodesRequest) Execute() (*TemplateTurnAwayCodes, *http.Response, error) {
	return r.ApiService.GetTemplateTurnAwayCodesExecute(r)
}

/*
GetTemplateTurnAwayCodes Get Template TurnAway Codes

Retrieve all existing Turnaway Code Templates. <p><strong>OperationId:</strong>getTemplateTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetTemplateTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) GetTemplateTurnAwayCodes(ctx context.Context) ReservationConfigApiGetTemplateTurnAwayCodesRequest {
	return ReservationConfigApiGetTemplateTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateTurnAwayCodes
func (a *ReservationConfigApiService) GetTemplateTurnAwayCodesExecute(r ReservationConfigApiGetTemplateTurnAwayCodesRequest) (*TemplateTurnAwayCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateTurnAwayCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetTemplateTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/turnawayCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetTraceTextsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeGlobal *bool
	departmentCodes *[]string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetTraceTextsRequest) Authorization(authorization string) ReservationConfigApiGetTraceTextsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetTraceTextsRequest) XAppKey(xAppKey string) ReservationConfigApiGetTraceTextsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetTraceTextsRequest) XHotelid(xHotelid string) ReservationConfigApiGetTraceTextsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to tell whether to exclude global traces or not.
func (r ReservationConfigApiGetTraceTextsRequest) ExcludeGlobal(excludeGlobal bool) ReservationConfigApiGetTraceTextsRequest {
	r.excludeGlobal = &excludeGlobal
	return r
}

func (r ReservationConfigApiGetTraceTextsRequest) DepartmentCodes(departmentCodes []string) ReservationConfigApiGetTraceTextsRequest {
	r.departmentCodes = &departmentCodes
	return r
}

func (r ReservationConfigApiGetTraceTextsRequest) HotelIds(hotelIds []string) ReservationConfigApiGetTraceTextsRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ReservationConfigApiGetTraceTextsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetTraceTextsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetTraceTextsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetTraceTextsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetTraceTextsRequest) Execute() (*TraceTextsToBeFetched, *http.Response, error) {
	return r.ApiService.GetTraceTextsExecute(r)
}

/*
GetTraceTexts Get trace texts 

Fetch all configured Trace Texts for a property. <p><strong>OperationId:</strong>getTraceTexts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiGetTraceTextsRequest
*/
func (a *ReservationConfigApiService) GetTraceTexts(ctx context.Context) ReservationConfigApiGetTraceTextsRequest {
	return ReservationConfigApiGetTraceTextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TraceTextsToBeFetched
func (a *ReservationConfigApiService) GetTraceTextsExecute(r ReservationConfigApiGetTraceTextsRequest) (*TraceTextsToBeFetched, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TraceTextsToBeFetched
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetTraceTexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traceTexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeGlobal", r.excludeGlobal, "")
	}
	if r.departmentCodes != nil {
		t := *r.departmentCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "departmentCodes", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiGetUpsellRulesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	stayDate *string
	rule *string
	searchByRoomType *bool
	fromCodes *[]string
	toCodes *[]string
	rateCode *string
	membershipType *string
	channel *string
	reservationTypeCodes *[]string
	marketCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiGetUpsellRulesRequest) Authorization(authorization string) ReservationConfigApiGetUpsellRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiGetUpsellRulesRequest) XAppKey(xAppKey string) ReservationConfigApiGetUpsellRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiGetUpsellRulesRequest) XHotelid(xHotelid string) ReservationConfigApiGetUpsellRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The stay date to be searched.
func (r ReservationConfigApiGetUpsellRulesRequest) StayDate(stayDate string) ReservationConfigApiGetUpsellRulesRequest {
	r.stayDate = &stayDate
	return r
}

// Wildcard search for the upsell rule code or description.
func (r ReservationConfigApiGetUpsellRulesRequest) Rule(rule string) ReservationConfigApiGetUpsellRulesRequest {
	r.rule = &rule
	return r
}

// Signifies whether upsell rules are to be searched based on Room Type or Room Class.
func (r ReservationConfigApiGetUpsellRulesRequest) SearchByRoomType(searchByRoomType bool) ReservationConfigApiGetUpsellRulesRequest {
	r.searchByRoomType = &searchByRoomType
	return r
}

func (r ReservationConfigApiGetUpsellRulesRequest) FromCodes(fromCodes []string) ReservationConfigApiGetUpsellRulesRequest {
	r.fromCodes = &fromCodes
	return r
}

func (r ReservationConfigApiGetUpsellRulesRequest) ToCodes(toCodes []string) ReservationConfigApiGetUpsellRulesRequest {
	r.toCodes = &toCodes
	return r
}

// Rate code to be searched.
func (r ReservationConfigApiGetUpsellRulesRequest) RateCode(rateCode string) ReservationConfigApiGetUpsellRulesRequest {
	r.rateCode = &rateCode
	return r
}

// Membership type to be searched.
func (r ReservationConfigApiGetUpsellRulesRequest) MembershipType(membershipType string) ReservationConfigApiGetUpsellRulesRequest {
	r.membershipType = &membershipType
	return r
}

// Channel to be searched.
func (r ReservationConfigApiGetUpsellRulesRequest) Channel(channel string) ReservationConfigApiGetUpsellRulesRequest {
	r.channel = &channel
	return r
}

func (r ReservationConfigApiGetUpsellRulesRequest) ReservationTypeCodes(reservationTypeCodes []string) ReservationConfigApiGetUpsellRulesRequest {
	r.reservationTypeCodes = &reservationTypeCodes
	return r
}

func (r ReservationConfigApiGetUpsellRulesRequest) MarketCodes(marketCodes []string) ReservationConfigApiGetUpsellRulesRequest {
	r.marketCodes = &marketCodes
	return r
}

// External system code.
func (r ReservationConfigApiGetUpsellRulesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiGetUpsellRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiGetUpsellRulesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiGetUpsellRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiGetUpsellRulesRequest) Execute() (*UpsellRules, *http.Response, error) {
	return r.ApiService.GetUpsellRulesExecute(r)
}

/*
GetUpsellRules Get upsell rules

This API will retrieve all configured Upgrade Rules.  These enable you to configure the rules for calculating the reservation upsell amounts.   <p><strong>OperationId:</strong>getUpsellRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiGetUpsellRulesRequest
*/
func (a *ReservationConfigApiService) GetUpsellRules(ctx context.Context, hotelId string) ReservationConfigApiGetUpsellRulesRequest {
	return ReservationConfigApiGetUpsellRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UpsellRules
func (a *ReservationConfigApiService) GetUpsellRulesExecute(r ReservationConfigApiGetUpsellRulesRequest) (*UpsellRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpsellRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.GetUpsellRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upsellRules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.stayDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stayDate", r.stayDate, "")
	}
	if r.rule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rule", r.rule, "")
	}
	if r.searchByRoomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchByRoomType", r.searchByRoomType, "")
	}
	if r.fromCodes != nil {
		t := *r.fromCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fromCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fromCodes", t, "multi")
		}
	}
	if r.toCodes != nil {
		t := *r.toCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "toCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "toCodes", t, "multi")
		}
	}
	if r.rateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", r.rateCode, "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
	}
	if r.channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "")
	}
	if r.reservationTypeCodes != nil {
		t := *r.reservationTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ReservationTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ReservationTypeCodes", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostAlertCodeTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	alertTemplates *PutAlertCodeTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostAlertCodeTemplatesRequest) Authorization(authorization string) ReservationConfigApiPostAlertCodeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostAlertCodeTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiPostAlertCodeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostAlertCodeTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiPostAlertCodeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new alert code template.
func (r ReservationConfigApiPostAlertCodeTemplatesRequest) AlertTemplates(alertTemplates PutAlertCodeTemplatesRequest) ReservationConfigApiPostAlertCodeTemplatesRequest {
	r.alertTemplates = &alertTemplates
	return r
}

// External system code.
func (r ReservationConfigApiPostAlertCodeTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostAlertCodeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostAlertCodeTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostAlertCodeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostAlertCodeTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAlertCodeTemplatesExecute(r)
}

/*
PostAlertCodeTemplates Create Alert Code Template

Create a new Alert Code Template. <p><strong>OperationId:</strong>postAlertCodeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPostAlertCodeTemplatesRequest
*/
func (a *ReservationConfigApiService) PostAlertCodeTemplates(ctx context.Context) ReservationConfigApiPostAlertCodeTemplatesRequest {
	return ReservationConfigApiPostAlertCodeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostAlertCodeTemplatesExecute(r ReservationConfigApiPostAlertCodeTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostAlertCodeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alertCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.alertTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostAlertCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	alertCodes *PutAlertCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostAlertCodesRequest) Authorization(authorization string) ReservationConfigApiPostAlertCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostAlertCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPostAlertCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostAlertCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPostAlertCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new group of alerts.
func (r ReservationConfigApiPostAlertCodesRequest) AlertCodes(alertCodes PutAlertCodesRequest) ReservationConfigApiPostAlertCodesRequest {
	r.alertCodes = &alertCodes
	return r
}

// External system code.
func (r ReservationConfigApiPostAlertCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostAlertCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostAlertCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostAlertCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostAlertCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAlertCodesExecute(r)
}

/*
PostAlertCodes Create a new alert code

You can use this API to create a new alert code. <p><strong>OperationId:</strong>postAlertCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostAlertCodesRequest
*/
func (a *ReservationConfigApiService) PostAlertCodes(ctx context.Context, hotelId string) ReservationConfigApiPostAlertCodesRequest {
	return ReservationConfigApiPostAlertCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostAlertCodesExecute(r ReservationConfigApiPostAlertCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostAlertCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/alertCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.alertCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostAutoAttachElementsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoAttachElements *DeleteAutoAttachElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostAutoAttachElementsRequest) Authorization(authorization string) ReservationConfigApiPostAutoAttachElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostAutoAttachElementsRequest) XAppKey(xAppKey string) ReservationConfigApiPostAutoAttachElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostAutoAttachElementsRequest) XHotelid(xHotelid string) ReservationConfigApiPostAutoAttachElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Add configuration rule(s) that specify the elements to be automatically attached to the reservation.
func (r ReservationConfigApiPostAutoAttachElementsRequest) AutoAttachElements(autoAttachElements DeleteAutoAttachElementsRequest) ReservationConfigApiPostAutoAttachElementsRequest {
	r.autoAttachElements = &autoAttachElements
	return r
}

// External system code.
func (r ReservationConfigApiPostAutoAttachElementsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostAutoAttachElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostAutoAttachElementsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostAutoAttachElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostAutoAttachElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAutoAttachElementsExecute(r)
}

/*
PostAutoAttachElements Create Auto Attach Elements

Create a new Auto Attach Element Rule. Auto attach elements are rules defined to auto-update various fields (elements) on a new reservation.  Rules can be associated with rate codes, memberships, room types, preferences etc.  An example could be 'If rate code is PROMO1 then update specials on the reservation to include FB (Fruit Basket). <p><strong>OperationId:</strong>postAutoAttachElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostAutoAttachElementsRequest
*/
func (a *ReservationConfigApiService) PostAutoAttachElements(ctx context.Context, hotelId string) ReservationConfigApiPostAutoAttachElementsRequest {
	return ReservationConfigApiPostAutoAttachElementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostAutoAttachElementsExecute(r ReservationConfigApiPostAutoAttachElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostAutoAttachElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoAttachElements"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoAttachElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostECouponCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCouponCodes *PutECouponCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostECouponCodesRequest) Authorization(authorization string) ReservationConfigApiPostECouponCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostECouponCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPostECouponCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostECouponCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPostECouponCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create new eCoupon codes.
func (r ReservationConfigApiPostECouponCodesRequest) ECouponCodes(eCouponCodes PutECouponCodesRequest) ReservationConfigApiPostECouponCodesRequest {
	r.eCouponCodes = &eCouponCodes
	return r
}

// External system code.
func (r ReservationConfigApiPostECouponCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostECouponCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostECouponCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostECouponCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostECouponCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostECouponCodesExecute(r)
}

/*
PostECouponCodes Create an eCoupon Code

You can create an ecoupon for a specified property and it can be a maximum of 8 alphanumeric characters. You can enter a quantity value from 1 to 99. <p><strong>OperationId:</strong>postECouponCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostECouponCodesRequest
*/
func (a *ReservationConfigApiService) PostECouponCodes(ctx context.Context, hotelId string) ReservationConfigApiPostECouponCodesRequest {
	return ReservationConfigApiPostECouponCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostECouponCodesExecute(r ReservationConfigApiPostECouponCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostECouponCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ecoupons"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCouponCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostGlobalAlertsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	globalAlerts *DeleteGlobalAlertsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostGlobalAlertsRequest) Authorization(authorization string) ReservationConfigApiPostGlobalAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostGlobalAlertsRequest) XAppKey(xAppKey string) ReservationConfigApiPostGlobalAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostGlobalAlertsRequest) XHotelid(xHotelid string) ReservationConfigApiPostGlobalAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new Global Alert.
func (r ReservationConfigApiPostGlobalAlertsRequest) GlobalAlerts(globalAlerts DeleteGlobalAlertsRequest) ReservationConfigApiPostGlobalAlertsRequest {
	r.globalAlerts = &globalAlerts
	return r
}

// External system code.
func (r ReservationConfigApiPostGlobalAlertsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostGlobalAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostGlobalAlertsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostGlobalAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostGlobalAlertsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGlobalAlertsExecute(r)
}

/*
PostGlobalAlerts Create Global Alerts

You can create a Global Alerts to generate automatically for all reservations that meet the alert condition. <p><strong>OperationId:</strong>postGlobalAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostGlobalAlertsRequest
*/
func (a *ReservationConfigApiService) PostGlobalAlerts(ctx context.Context, hotelId string) ReservationConfigApiPostGlobalAlertsRequest {
	return ReservationConfigApiPostGlobalAlertsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostGlobalAlertsExecute(r ReservationConfigApiPostGlobalAlertsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostGlobalAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/globalAlerts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.globalAlerts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostGuestMessageTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guestMessageTemplates *PutGuestMessageTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostGuestMessageTemplatesRequest) Authorization(authorization string) ReservationConfigApiPostGuestMessageTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostGuestMessageTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiPostGuestMessageTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostGuestMessageTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiPostGuestMessageTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new guest message template.
func (r ReservationConfigApiPostGuestMessageTemplatesRequest) GuestMessageTemplates(guestMessageTemplates PutGuestMessageTemplatesRequest) ReservationConfigApiPostGuestMessageTemplatesRequest {
	r.guestMessageTemplates = &guestMessageTemplates
	return r
}

// External system code.
func (r ReservationConfigApiPostGuestMessageTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostGuestMessageTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostGuestMessageTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostGuestMessageTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostGuestMessageTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuestMessageTemplatesExecute(r)
}

/*
PostGuestMessageTemplates Create a new guest message template

Message templates enable you to define standard message texts within OPERA Cloud to ensure consistency in the format of guest messages. You can use this API to create a new Guest Message Template. <p><strong>OperationId:</strong>postGuestMessageTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPostGuestMessageTemplatesRequest
*/
func (a *ReservationConfigApiService) PostGuestMessageTemplates(ctx context.Context) ReservationConfigApiPostGuestMessageTemplatesRequest {
	return ReservationConfigApiPostGuestMessageTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostGuestMessageTemplatesExecute(r ReservationConfigApiPostGuestMessageTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostGuestMessageTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guestMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestMessageTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestMessages *PutGuestMessagesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostGuestMessagesRequest) Authorization(authorization string) ReservationConfigApiPostGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostGuestMessagesRequest) XAppKey(xAppKey string) ReservationConfigApiPostGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostGuestMessagesRequest) XHotelid(xHotelid string) ReservationConfigApiPostGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new guest message.
func (r ReservationConfigApiPostGuestMessagesRequest) GuestMessages(guestMessages PutGuestMessagesRequest) ReservationConfigApiPostGuestMessagesRequest {
	r.guestMessages = &guestMessages
	return r
}

// External system code.
func (r ReservationConfigApiPostGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostGuestMessagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuestMessagesExecute(r)
}

/*
PostGuestMessages Create Guest Messages

This API is used to create a new guest messages based on the request.  <p><strong>OperationId:</strong>postGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostGuestMessagesRequest
*/
func (a *ReservationConfigApiService) PostGuestMessages(ctx context.Context, hotelId string) ReservationConfigApiPostGuestMessagesRequest {
	return ReservationConfigApiPostGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostGuestMessagesExecute(r ReservationConfigApiPostGuestMessagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guestMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestMessages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostHotelTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTurnAwayCodes *PutHotelTurnAwayCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new hotel turnaway code.
func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) HotelTurnAwayCodes(hotelTurnAwayCodes PutHotelTurnAwayCodesRequest) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	r.hotelTurnAwayCodes = &hotelTurnAwayCodes
	return r
}

// External system code.
func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostHotelTurnAwayCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelTurnAwayCodesExecute(r)
}

/*
PostHotelTurnAwayCodes Create Turn Away Codes

Turnaway Codes enable you to record the number of potential reservations that were "turned away" and could not be confirmed.  Use this API to create a new Turnaway Code for a property. <p><strong>OperationId:</strong>postHotelTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostHotelTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) PostHotelTurnAwayCodes(ctx context.Context, hotelId string) ReservationConfigApiPostHotelTurnAwayCodesRequest {
	return ReservationConfigApiPostHotelTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostHotelTurnAwayCodesExecute(r ReservationConfigApiPostHotelTurnAwayCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostHotelTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/turnawayCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTurnAwayCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostLocatorCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	locatorCodes *PutLocatorCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostLocatorCodesRequest) Authorization(authorization string) ReservationConfigApiPostLocatorCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostLocatorCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPostLocatorCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostLocatorCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPostLocatorCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new locator code.
func (r ReservationConfigApiPostLocatorCodesRequest) LocatorCodes(locatorCodes PutLocatorCodesRequest) ReservationConfigApiPostLocatorCodesRequest {
	r.locatorCodes = &locatorCodes
	return r
}

// External system code.
func (r ReservationConfigApiPostLocatorCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostLocatorCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostLocatorCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostLocatorCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostLocatorCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostLocatorCodesExecute(r)
}

/*
PostLocatorCodes Create a new Locator Code

You can use this API to create a new Locator Code. <p><strong>OperationId:</strong>postLocatorCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostLocatorCodesRequest
*/
func (a *ReservationConfigApiService) PostLocatorCodes(ctx context.Context, hotelId string) ReservationConfigApiPostLocatorCodesRequest {
	return ReservationConfigApiPostLocatorCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostLocatorCodesExecute(r ReservationConfigApiPostLocatorCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostLocatorCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/locatorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.locatorCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostLocatorCodesTemplateRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	locatorCodesTemplate *PutLocatorCodesTemplateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostLocatorCodesTemplateRequest) Authorization(authorization string) ReservationConfigApiPostLocatorCodesTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostLocatorCodesTemplateRequest) XAppKey(xAppKey string) ReservationConfigApiPostLocatorCodesTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostLocatorCodesTemplateRequest) XHotelid(xHotelid string) ReservationConfigApiPostLocatorCodesTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating locator code template.
func (r ReservationConfigApiPostLocatorCodesTemplateRequest) LocatorCodesTemplate(locatorCodesTemplate PutLocatorCodesTemplateRequest) ReservationConfigApiPostLocatorCodesTemplateRequest {
	r.locatorCodesTemplate = &locatorCodesTemplate
	return r
}

// External system code.
func (r ReservationConfigApiPostLocatorCodesTemplateRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostLocatorCodesTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostLocatorCodesTemplateRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostLocatorCodesTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostLocatorCodesTemplateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostLocatorCodesTemplateExecute(r)
}

/*
PostLocatorCodesTemplate Create a template Locator Code

Create a new Locator Code at template level. <p><strong>OperationId:</strong>postLocatorCodesTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPostLocatorCodesTemplateRequest
*/
func (a *ReservationConfigApiService) PostLocatorCodesTemplate(ctx context.Context) ReservationConfigApiPostLocatorCodesTemplateRequest {
	return ReservationConfigApiPostLocatorCodesTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostLocatorCodesTemplateExecute(r ReservationConfigApiPostLocatorCodesTemplateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostLocatorCodesTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templates/locatorCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.locatorCodesTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostTemplateTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTurnAwayCodes *PutTemplateTurnAwayCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template turnaway code.
func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) TemplateTurnAwayCodes(templateTurnAwayCodes PutTemplateTurnAwayCodesRequest) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	r.templateTurnAwayCodes = &templateTurnAwayCodes
	return r
}

// External system code.
func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostTemplateTurnAwayCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateTurnAwayCodesExecute(r)
}

/*
PostTemplateTurnAwayCodes Create Template TurnAway Codes

Create a new Turnaway Code Template. <p><strong>OperationId:</strong>postTemplateTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPostTemplateTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) PostTemplateTurnAwayCodes(ctx context.Context) ReservationConfigApiPostTemplateTurnAwayCodesRequest {
	return ReservationConfigApiPostTemplateTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostTemplateTurnAwayCodesExecute(r ReservationConfigApiPostTemplateTurnAwayCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostTemplateTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/turnawayCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTurnAwayCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostTraceTextsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	traceTextsToBeCreated *PostTraceTextsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostTraceTextsRequest) Authorization(authorization string) ReservationConfigApiPostTraceTextsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostTraceTextsRequest) XAppKey(xAppKey string) ReservationConfigApiPostTraceTextsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostTraceTextsRequest) XHotelid(xHotelid string) ReservationConfigApiPostTraceTextsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new trace texts.
func (r ReservationConfigApiPostTraceTextsRequest) TraceTextsToBeCreated(traceTextsToBeCreated PostTraceTextsRequest) ReservationConfigApiPostTraceTextsRequest {
	r.traceTextsToBeCreated = &traceTextsToBeCreated
	return r
}

// External system code.
func (r ReservationConfigApiPostTraceTextsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostTraceTextsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostTraceTextsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostTraceTextsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostTraceTextsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTraceTextsExecute(r)
}

/*
PostTraceTexts Create new trace texts

When you create traces for reservation, blocks, or AR accounts, you must first set up the standard messages that are available. When you create a trace, these texts can be selected and used as-is, or they can be modified as necessary. When you create a trace text, it must be associated with a department, like Reservations. <p><strong>OperationId:</strong>postTraceTexts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPostTraceTextsRequest
*/
func (a *ReservationConfigApiService) PostTraceTexts(ctx context.Context) ReservationConfigApiPostTraceTextsRequest {
	return ReservationConfigApiPostTraceTextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostTraceTextsExecute(r ReservationConfigApiPostTraceTextsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostTraceTexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traceTexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.traceTextsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPostUpsellRulesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	upsellRules *PutUpsellRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPostUpsellRulesRequest) Authorization(authorization string) ReservationConfigApiPostUpsellRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPostUpsellRulesRequest) XAppKey(xAppKey string) ReservationConfigApiPostUpsellRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPostUpsellRulesRequest) XHotelid(xHotelid string) ReservationConfigApiPostUpsellRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new upsell rules.
func (r ReservationConfigApiPostUpsellRulesRequest) UpsellRules(upsellRules PutUpsellRulesRequest) ReservationConfigApiPostUpsellRulesRequest {
	r.upsellRules = &upsellRules
	return r
}

// External system code.
func (r ReservationConfigApiPostUpsellRulesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPostUpsellRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPostUpsellRulesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPostUpsellRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPostUpsellRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostUpsellRulesExecute(r)
}

/*
PostUpsellRules Create Upsell Rules

Use this API to create a new Upgrade rule for a property.  You can upgrade a reservation during the check-in process, but it must match the date ranges, the room types, and the formulas defined in the upgrade rules for the property. A message alerts you to available upgrades and prices. <p><strong>OperationId:</strong>postUpsellRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPostUpsellRulesRequest
*/
func (a *ReservationConfigApiService) PostUpsellRules(ctx context.Context, hotelId string) ReservationConfigApiPostUpsellRulesRequest {
	return ReservationConfigApiPostUpsellRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PostUpsellRulesExecute(r ReservationConfigApiPostUpsellRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PostUpsellRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upsellRules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.upsellRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutAlertCodeTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	alertTemplates *PutAlertCodeTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutAlertCodeTemplatesRequest) Authorization(authorization string) ReservationConfigApiPutAlertCodeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutAlertCodeTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiPutAlertCodeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutAlertCodeTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiPutAlertCodeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying the existing alert code templates.
func (r ReservationConfigApiPutAlertCodeTemplatesRequest) AlertTemplates(alertTemplates PutAlertCodeTemplatesRequest) ReservationConfigApiPutAlertCodeTemplatesRequest {
	r.alertTemplates = &alertTemplates
	return r
}

// External system code.
func (r ReservationConfigApiPutAlertCodeTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutAlertCodeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutAlertCodeTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutAlertCodeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutAlertCodeTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAlertCodeTemplatesExecute(r)
}

/*
PutAlertCodeTemplates Change Alert Code Template

Update an existing alert code template. <p><strong>OperationId:</strong>putAlertCodeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPutAlertCodeTemplatesRequest
*/
func (a *ReservationConfigApiService) PutAlertCodeTemplates(ctx context.Context) ReservationConfigApiPutAlertCodeTemplatesRequest {
	return ReservationConfigApiPutAlertCodeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutAlertCodeTemplatesExecute(r ReservationConfigApiPutAlertCodeTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutAlertCodeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alertCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.alertTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutAlertCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	alertCodes *PutAlertCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutAlertCodesRequest) Authorization(authorization string) ReservationConfigApiPutAlertCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutAlertCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPutAlertCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutAlertCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPutAlertCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing alert.
func (r ReservationConfigApiPutAlertCodesRequest) AlertCodes(alertCodes PutAlertCodesRequest) ReservationConfigApiPutAlertCodesRequest {
	r.alertCodes = &alertCodes
	return r
}

// External system code.
func (r ReservationConfigApiPutAlertCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutAlertCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutAlertCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutAlertCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutAlertCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAlertCodesExecute(r)
}

/*
PutAlertCodes Change Alert Codes

You can use this API to change Alert Codes. <p><strong>OperationId:</strong>putAlertCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutAlertCodesRequest
*/
func (a *ReservationConfigApiService) PutAlertCodes(ctx context.Context, hotelId string) ReservationConfigApiPutAlertCodesRequest {
	return ReservationConfigApiPutAlertCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutAlertCodesExecute(r ReservationConfigApiPutAlertCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutAlertCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/alertCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.alertCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutAutoAttachElementsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoAttachElements *DeleteAutoAttachElementsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutAutoAttachElementsRequest) Authorization(authorization string) ReservationConfigApiPutAutoAttachElementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutAutoAttachElementsRequest) XAppKey(xAppKey string) ReservationConfigApiPutAutoAttachElementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutAutoAttachElementsRequest) XHotelid(xHotelid string) ReservationConfigApiPutAutoAttachElementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Modify auto attach configuration rule(s).
func (r ReservationConfigApiPutAutoAttachElementsRequest) AutoAttachElements(autoAttachElements DeleteAutoAttachElementsRequest) ReservationConfigApiPutAutoAttachElementsRequest {
	r.autoAttachElements = &autoAttachElements
	return r
}

// External system code.
func (r ReservationConfigApiPutAutoAttachElementsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutAutoAttachElementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutAutoAttachElementsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutAutoAttachElementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutAutoAttachElementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAutoAttachElementsExecute(r)
}

/*
PutAutoAttachElements Update Auto Attach Elements

Modify the configuration of an Auto Attach Element Rule that exists on a property. <p><strong>OperationId:</strong>putAutoAttachElements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutAutoAttachElementsRequest
*/
func (a *ReservationConfigApiService) PutAutoAttachElements(ctx context.Context, hotelId string) ReservationConfigApiPutAutoAttachElementsRequest {
	return ReservationConfigApiPutAutoAttachElementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutAutoAttachElementsExecute(r ReservationConfigApiPutAutoAttachElementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutAutoAttachElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoAttachElements"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoAttachElements
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutECouponCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCouponCodes *PutECouponCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutECouponCodesRequest) Authorization(authorization string) ReservationConfigApiPutECouponCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutECouponCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPutECouponCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutECouponCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPutECouponCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the existing eCoupon codes.
func (r ReservationConfigApiPutECouponCodesRequest) ECouponCodes(eCouponCodes PutECouponCodesRequest) ReservationConfigApiPutECouponCodesRequest {
	r.eCouponCodes = &eCouponCodes
	return r
}

// External system code.
func (r ReservationConfigApiPutECouponCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutECouponCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutECouponCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutECouponCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutECouponCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutECouponCodesExecute(r)
}

/*
PutECouponCodes Change an eCoupon Code

Update an existing eCoupon Code. <p><strong>OperationId:</strong>putECouponCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutECouponCodesRequest
*/
func (a *ReservationConfigApiService) PutECouponCodes(ctx context.Context, hotelId string) ReservationConfigApiPutECouponCodesRequest {
	return ReservationConfigApiPutECouponCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutECouponCodesExecute(r ReservationConfigApiPutECouponCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutECouponCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ecoupons"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCouponCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutGlobalAlertsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	globalAlerts *DeleteGlobalAlertsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutGlobalAlertsRequest) Authorization(authorization string) ReservationConfigApiPutGlobalAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutGlobalAlertsRequest) XAppKey(xAppKey string) ReservationConfigApiPutGlobalAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutGlobalAlertsRequest) XHotelid(xHotelid string) ReservationConfigApiPutGlobalAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing Global Alert.
func (r ReservationConfigApiPutGlobalAlertsRequest) GlobalAlerts(globalAlerts DeleteGlobalAlertsRequest) ReservationConfigApiPutGlobalAlertsRequest {
	r.globalAlerts = &globalAlerts
	return r
}

// External system code.
func (r ReservationConfigApiPutGlobalAlertsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutGlobalAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutGlobalAlertsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutGlobalAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutGlobalAlertsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGlobalAlertsExecute(r)
}

/*
PutGlobalAlerts Change Global Alerts

Use this API to change Global Alerts for a property. <p><strong>OperationId:</strong>putGlobalAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutGlobalAlertsRequest
*/
func (a *ReservationConfigApiService) PutGlobalAlerts(ctx context.Context, hotelId string) ReservationConfigApiPutGlobalAlertsRequest {
	return ReservationConfigApiPutGlobalAlertsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutGlobalAlertsExecute(r ReservationConfigApiPutGlobalAlertsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutGlobalAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/globalAlerts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.globalAlerts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutGuestMessageTemplatesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guestMessageTemplates *PutGuestMessageTemplatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutGuestMessageTemplatesRequest) Authorization(authorization string) ReservationConfigApiPutGuestMessageTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutGuestMessageTemplatesRequest) XAppKey(xAppKey string) ReservationConfigApiPutGuestMessageTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutGuestMessageTemplatesRequest) XHotelid(xHotelid string) ReservationConfigApiPutGuestMessageTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing guest message template.
func (r ReservationConfigApiPutGuestMessageTemplatesRequest) GuestMessageTemplates(guestMessageTemplates PutGuestMessageTemplatesRequest) ReservationConfigApiPutGuestMessageTemplatesRequest {
	r.guestMessageTemplates = &guestMessageTemplates
	return r
}

// External system code.
func (r ReservationConfigApiPutGuestMessageTemplatesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutGuestMessageTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutGuestMessageTemplatesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutGuestMessageTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutGuestMessageTemplatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGuestMessageTemplatesExecute(r)
}

/*
PutGuestMessageTemplates Change Guest Message Templates

Update an existing Guest Message Template. <p><strong>OperationId:</strong>putGuestMessageTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPutGuestMessageTemplatesRequest
*/
func (a *ReservationConfigApiService) PutGuestMessageTemplates(ctx context.Context) ReservationConfigApiPutGuestMessageTemplatesRequest {
	return ReservationConfigApiPutGuestMessageTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutGuestMessageTemplatesExecute(r ReservationConfigApiPutGuestMessageTemplatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutGuestMessageTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guestMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestMessageTemplates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutGuestMessagesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestMessages *PutGuestMessagesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutGuestMessagesRequest) Authorization(authorization string) ReservationConfigApiPutGuestMessagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutGuestMessagesRequest) XAppKey(xAppKey string) ReservationConfigApiPutGuestMessagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutGuestMessagesRequest) XHotelid(xHotelid string) ReservationConfigApiPutGuestMessagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing guest message.
func (r ReservationConfigApiPutGuestMessagesRequest) GuestMessages(guestMessages PutGuestMessagesRequest) ReservationConfigApiPutGuestMessagesRequest {
	r.guestMessages = &guestMessages
	return r
}

// External system code.
func (r ReservationConfigApiPutGuestMessagesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutGuestMessagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutGuestMessagesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutGuestMessagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutGuestMessagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutGuestMessagesExecute(r)
}

/*
PutGuestMessages Change a Guest messages

You can use this API to change a Guest messages. <p><strong>OperationId:</strong>putGuestMessages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutGuestMessagesRequest
*/
func (a *ReservationConfigApiService) PutGuestMessages(ctx context.Context, hotelId string) ReservationConfigApiPutGuestMessagesRequest {
	return ReservationConfigApiPutGuestMessagesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutGuestMessagesExecute(r ReservationConfigApiPutGuestMessagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutGuestMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guestMessages"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestMessages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutHotelTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelTurnAwayCodes *PutHotelTurnAwayCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying hotel turnaway codes.
func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) HotelTurnAwayCodes(hotelTurnAwayCodes PutHotelTurnAwayCodesRequest) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	r.hotelTurnAwayCodes = &hotelTurnAwayCodes
	return r
}

// External system code.
func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutHotelTurnAwayCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutHotelTurnAwayCodesExecute(r)
}

/*
PutHotelTurnAwayCodes Change TurnAway Codes

Update an existing Turnaway code for a property. <p><strong>OperationId:</strong>putHotelTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutHotelTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) PutHotelTurnAwayCodes(ctx context.Context, hotelId string) ReservationConfigApiPutHotelTurnAwayCodesRequest {
	return ReservationConfigApiPutHotelTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutHotelTurnAwayCodesExecute(r ReservationConfigApiPutHotelTurnAwayCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutHotelTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/turnawayCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelTurnAwayCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutLocatorCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	locatorCodes *PutLocatorCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutLocatorCodesRequest) Authorization(authorization string) ReservationConfigApiPutLocatorCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutLocatorCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPutLocatorCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutLocatorCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPutLocatorCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing locator code.
func (r ReservationConfigApiPutLocatorCodesRequest) LocatorCodes(locatorCodes PutLocatorCodesRequest) ReservationConfigApiPutLocatorCodesRequest {
	r.locatorCodes = &locatorCodes
	return r
}

// External system code.
func (r ReservationConfigApiPutLocatorCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutLocatorCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutLocatorCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutLocatorCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutLocatorCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutLocatorCodesExecute(r)
}

/*
PutLocatorCodes Change the existing Locator Code

You can use this API to change the existing Locator Code. <p><strong>OperationId:</strong>putLocatorCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutLocatorCodesRequest
*/
func (a *ReservationConfigApiService) PutLocatorCodes(ctx context.Context, hotelId string) ReservationConfigApiPutLocatorCodesRequest {
	return ReservationConfigApiPutLocatorCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutLocatorCodesExecute(r ReservationConfigApiPutLocatorCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutLocatorCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/locatorCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.locatorCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutLocatorCodesTemplateRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	locatorCodesTemplate *PutLocatorCodesTemplateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutLocatorCodesTemplateRequest) Authorization(authorization string) ReservationConfigApiPutLocatorCodesTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutLocatorCodesTemplateRequest) XAppKey(xAppKey string) ReservationConfigApiPutLocatorCodesTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutLocatorCodesTemplateRequest) XHotelid(xHotelid string) ReservationConfigApiPutLocatorCodesTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying an existing locator code template.
func (r ReservationConfigApiPutLocatorCodesTemplateRequest) LocatorCodesTemplate(locatorCodesTemplate PutLocatorCodesTemplateRequest) ReservationConfigApiPutLocatorCodesTemplateRequest {
	r.locatorCodesTemplate = &locatorCodesTemplate
	return r
}

// External system code.
func (r ReservationConfigApiPutLocatorCodesTemplateRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutLocatorCodesTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutLocatorCodesTemplateRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutLocatorCodesTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutLocatorCodesTemplateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutLocatorCodesTemplateExecute(r)
}

/*
PutLocatorCodesTemplate Change a Locator Code

Change an existing Locator Code <p><strong>OperationId:</strong>putLocatorCodesTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPutLocatorCodesTemplateRequest
*/
func (a *ReservationConfigApiService) PutLocatorCodesTemplate(ctx context.Context) ReservationConfigApiPutLocatorCodesTemplateRequest {
	return ReservationConfigApiPutLocatorCodesTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutLocatorCodesTemplateExecute(r ReservationConfigApiPutLocatorCodesTemplateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutLocatorCodesTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templates/locatorCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.locatorCodesTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutMembershipLevelRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	membershipLevel string
	membershipType string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipLevelRatings *PutMembershipLevelRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutMembershipLevelRatingsRequest) Authorization(authorization string) ReservationConfigApiPutMembershipLevelRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutMembershipLevelRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiPutMembershipLevelRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutMembershipLevelRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiPutMembershipLevelRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying membership levels rating details.
func (r ReservationConfigApiPutMembershipLevelRatingsRequest) MembershipLevelRatings(membershipLevelRatings PutMembershipLevelRatingsRequest) ReservationConfigApiPutMembershipLevelRatingsRequest {
	r.membershipLevelRatings = &membershipLevelRatings
	return r
}

// External system code.
func (r ReservationConfigApiPutMembershipLevelRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutMembershipLevelRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutMembershipLevelRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutMembershipLevelRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutMembershipLevelRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutMembershipLevelRatingsExecute(r)
}

/*
PutMembershipLevelRatings Change Membership Level Ratings

You can use this API to change Membership Level Ratings. <p><strong>OperationId:</strong>putMembershipLevelRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipLevel OPERA Membership level
 @param membershipType OPERA Membership type
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutMembershipLevelRatingsRequest
*/
func (a *ReservationConfigApiService) PutMembershipLevelRatings(ctx context.Context, membershipLevel string, membershipType string, hotelId string) ReservationConfigApiPutMembershipLevelRatingsRequest {
	return ReservationConfigApiPutMembershipLevelRatingsRequest{
		ApiService: a,
		ctx: ctx,
		membershipLevel: membershipLevel,
		membershipType: membershipType,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutMembershipLevelRatingsExecute(r ReservationConfigApiPutMembershipLevelRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutMembershipLevelRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/membershipTypes/{membershipType}/membershipLevels/{membershipLevel}/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipLevel"+"}", url.PathEscape(parameterValueToString(r.membershipLevel, "membershipLevel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipLevel) < 1 {
		return localVarReturnValue, nil, reportError("membershipLevel must have at least 1 elements")
	}
	if strlen(r.membershipLevel) > 2000 {
		return localVarReturnValue, nil, reportError("membershipLevel must have less than 2000 elements")
	}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipLevelRatings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutRatePlanRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanRatingsInfo *PutRatePlanRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutRatePlanRatingsRequest) Authorization(authorization string) ReservationConfigApiPutRatePlanRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutRatePlanRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiPutRatePlanRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutRatePlanRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiPutRatePlanRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying rate plan codes and their rating details.
func (r ReservationConfigApiPutRatePlanRatingsRequest) RatePlanRatingsInfo(ratePlanRatingsInfo PutRatePlanRatingsRequest) ReservationConfigApiPutRatePlanRatingsRequest {
	r.ratePlanRatingsInfo = &ratePlanRatingsInfo
	return r
}

// External system code.
func (r ReservationConfigApiPutRatePlanRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutRatePlanRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutRatePlanRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutRatePlanRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutRatePlanRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRatePlanRatingsExecute(r)
}

/*
PutRatePlanRatings Change Rate Plan Ratings

You can use this API to change Rate Plan Ratings. <p><strong>OperationId:</strong>putRatePlanRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutRatePlanRatingsRequest
*/
func (a *ReservationConfigApiService) PutRatePlanRatings(ctx context.Context, hotelId string) ReservationConfigApiPutRatePlanRatingsRequest {
	return ReservationConfigApiPutRatePlanRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutRatePlanRatingsExecute(r ReservationConfigApiPutRatePlanRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutRatePlanRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanRatingsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutReservationColorsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	code string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationColorsToChange *PutReservationColorsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutReservationColorsRequest) Authorization(authorization string) ReservationConfigApiPutReservationColorsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutReservationColorsRequest) XAppKey(xAppKey string) ReservationConfigApiPutReservationColorsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutReservationColorsRequest) XHotelid(xHotelid string) ReservationConfigApiPutReservationColorsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change reservation colors.
func (r ReservationConfigApiPutReservationColorsRequest) ReservationColorsToChange(reservationColorsToChange PutReservationColorsRequest) ReservationConfigApiPutReservationColorsRequest {
	r.reservationColorsToChange = &reservationColorsToChange
	return r
}

// External system code.
func (r ReservationConfigApiPutReservationColorsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutReservationColorsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutReservationColorsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutReservationColorsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutReservationColorsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutReservationColorsExecute(r)
}

/*
PutReservationColors Change Reservation Colors

Use this API to put Reservation Colors. <p><strong>OperationId:</strong>putReservationColors</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code
 @param hotelId Unique ID of hotel.
 @return ReservationConfigApiPutReservationColorsRequest
*/
func (a *ReservationConfigApiService) PutReservationColors(ctx context.Context, code string, hotelId string) ReservationConfigApiPutReservationColorsRequest {
	return ReservationConfigApiPutReservationColorsRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutReservationColorsExecute(r ReservationConfigApiPutReservationColorsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutReservationColors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/colors/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 1 {
		return localVarReturnValue, nil, reportError("code must have at least 1 elements")
	}
	if strlen(r.code) > 2000 {
		return localVarReturnValue, nil, reportError("code must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationColorsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutRoomFeatureRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomFeatureRatings *PutRoomFeatureRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutRoomFeatureRatingsRequest) Authorization(authorization string) ReservationConfigApiPutRoomFeatureRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutRoomFeatureRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiPutRoomFeatureRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutRoomFeatureRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiPutRoomFeatureRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying room features rating details.
func (r ReservationConfigApiPutRoomFeatureRatingsRequest) RoomFeatureRatings(roomFeatureRatings PutRoomFeatureRatingsRequest) ReservationConfigApiPutRoomFeatureRatingsRequest {
	r.roomFeatureRatings = &roomFeatureRatings
	return r
}

// External system code.
func (r ReservationConfigApiPutRoomFeatureRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutRoomFeatureRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutRoomFeatureRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutRoomFeatureRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutRoomFeatureRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomFeatureRatingsExecute(r)
}

/*
PutRoomFeatureRatings Change Room Feature Ratings

You can use this API to change Room Feature Ratings. <p><strong>OperationId:</strong>putRoomFeatureRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutRoomFeatureRatingsRequest
*/
func (a *ReservationConfigApiService) PutRoomFeatureRatings(ctx context.Context, hotelId string) ReservationConfigApiPutRoomFeatureRatingsRequest {
	return ReservationConfigApiPutRoomFeatureRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutRoomFeatureRatingsExecute(r ReservationConfigApiPutRoomFeatureRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutRoomFeatureRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomFeatures/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomFeatureRatings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutRoomRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRatingsInfo *PutRoomRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutRoomRatingsRequest) Authorization(authorization string) ReservationConfigApiPutRoomRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutRoomRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiPutRoomRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutRoomRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiPutRoomRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying room rating details.
func (r ReservationConfigApiPutRoomRatingsRequest) RoomRatingsInfo(roomRatingsInfo PutRoomRatingsRequest) ReservationConfigApiPutRoomRatingsRequest {
	r.roomRatingsInfo = &roomRatingsInfo
	return r
}

// External system code.
func (r ReservationConfigApiPutRoomRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutRoomRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutRoomRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutRoomRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutRoomRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomRatingsExecute(r)
}

/*
PutRoomRatings Change Room Ratings

You can use this API to change Room Ratings. <p><strong>OperationId:</strong>putRoomRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId OPERA Room id
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutRoomRatingsRequest
*/
func (a *ReservationConfigApiService) PutRoomRatings(ctx context.Context, roomId string, hotelId string) ReservationConfigApiPutRoomRatingsRequest {
	return ReservationConfigApiPutRoomRatingsRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutRoomRatingsExecute(r ReservationConfigApiPutRoomRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutRoomRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRatingsInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutRoomSpecialRatingsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomSpecialRatings *PutRoomSpecialRatingsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutRoomSpecialRatingsRequest) Authorization(authorization string) ReservationConfigApiPutRoomSpecialRatingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutRoomSpecialRatingsRequest) XAppKey(xAppKey string) ReservationConfigApiPutRoomSpecialRatingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutRoomSpecialRatingsRequest) XHotelid(xHotelid string) ReservationConfigApiPutRoomSpecialRatingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying room specials rating details.
func (r ReservationConfigApiPutRoomSpecialRatingsRequest) RoomSpecialRatings(roomSpecialRatings PutRoomSpecialRatingsRequest) ReservationConfigApiPutRoomSpecialRatingsRequest {
	r.roomSpecialRatings = &roomSpecialRatings
	return r
}

// External system code.
func (r ReservationConfigApiPutRoomSpecialRatingsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutRoomSpecialRatingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutRoomSpecialRatingsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutRoomSpecialRatingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutRoomSpecialRatingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomSpecialRatingsExecute(r)
}

/*
PutRoomSpecialRatings Change Room Special Ratings

You can use this API to change Room Special Ratings. <p><strong>OperationId:</strong>putRoomSpecialRatings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutRoomSpecialRatingsRequest
*/
func (a *ReservationConfigApiService) PutRoomSpecialRatings(ctx context.Context, hotelId string) ReservationConfigApiPutRoomSpecialRatingsRequest {
	return ReservationConfigApiPutRoomSpecialRatingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutRoomSpecialRatingsExecute(r ReservationConfigApiPutRoomSpecialRatingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutRoomSpecialRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomSpecials/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomSpecialRatings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutTemplateTurnAwayCodesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateTurnAwayCodes *PutTemplateTurnAwayCodesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) Authorization(authorization string) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) XAppKey(xAppKey string) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) XHotelid(xHotelid string) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying template turnaway codes.
func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) TemplateTurnAwayCodes(templateTurnAwayCodes PutTemplateTurnAwayCodesRequest) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	r.templateTurnAwayCodes = &templateTurnAwayCodes
	return r
}

// External system code.
func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutTemplateTurnAwayCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplateTurnAwayCodesExecute(r)
}

/*
PutTemplateTurnAwayCodes Change a Turnaway code template

Update an existing Turnaway Code Template. <p><strong>OperationId:</strong>putTemplateTurnAwayCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPutTemplateTurnAwayCodesRequest
*/
func (a *ReservationConfigApiService) PutTemplateTurnAwayCodes(ctx context.Context) ReservationConfigApiPutTemplateTurnAwayCodesRequest {
	return ReservationConfigApiPutTemplateTurnAwayCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutTemplateTurnAwayCodesExecute(r ReservationConfigApiPutTemplateTurnAwayCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutTemplateTurnAwayCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/turnawayCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateTurnAwayCodes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutTraceTextsRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	traceTextChanges *PutTraceTextsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutTraceTextsRequest) Authorization(authorization string) ReservationConfigApiPutTraceTextsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutTraceTextsRequest) XAppKey(xAppKey string) ReservationConfigApiPutTraceTextsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutTraceTextsRequest) XHotelid(xHotelid string) ReservationConfigApiPutTraceTextsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing trace texts.
func (r ReservationConfigApiPutTraceTextsRequest) TraceTextChanges(traceTextChanges PutTraceTextsRequest) ReservationConfigApiPutTraceTextsRequest {
	r.traceTextChanges = &traceTextChanges
	return r
}

// External system code.
func (r ReservationConfigApiPutTraceTextsRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutTraceTextsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutTraceTextsRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutTraceTextsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutTraceTextsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTraceTextsExecute(r)
}

/*
PutTraceTexts Change trace text 

Update an existing Trace Text for a property. <p><strong>OperationId:</strong>putTraceTexts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ReservationConfigApiPutTraceTextsRequest
*/
func (a *ReservationConfigApiService) PutTraceTexts(ctx context.Context) ReservationConfigApiPutTraceTextsRequest {
	return ReservationConfigApiPutTraceTextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutTraceTextsExecute(r ReservationConfigApiPutTraceTextsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutTraceTexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traceTexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.traceTextChanges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiPutUpsellRulesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	upsellRules *PutUpsellRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiPutUpsellRulesRequest) Authorization(authorization string) ReservationConfigApiPutUpsellRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiPutUpsellRulesRequest) XAppKey(xAppKey string) ReservationConfigApiPutUpsellRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiPutUpsellRulesRequest) XHotelid(xHotelid string) ReservationConfigApiPutUpsellRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing upsell rules.
func (r ReservationConfigApiPutUpsellRulesRequest) UpsellRules(upsellRules PutUpsellRulesRequest) ReservationConfigApiPutUpsellRulesRequest {
	r.upsellRules = &upsellRules
	return r
}

// External system code.
func (r ReservationConfigApiPutUpsellRulesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiPutUpsellRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiPutUpsellRulesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiPutUpsellRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiPutUpsellRulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutUpsellRulesExecute(r)
}

/*
PutUpsellRules Modify Upsell Rule

Use this API to modify an existing Upgrade rule for a property. <p><strong>OperationId:</strong>putUpsellRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiPutUpsellRulesRequest
*/
func (a *ReservationConfigApiService) PutUpsellRules(ctx context.Context, hotelId string) ReservationConfigApiPutUpsellRulesRequest {
	return ReservationConfigApiPutUpsellRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ReservationConfigApiService) PutUpsellRulesExecute(r ReservationConfigApiPutUpsellRulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.PutUpsellRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upsellRules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.upsellRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationConfigApiTestUpsellRulesRequest struct {
	ctx context.Context
	ApiService *ReservationConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	upsellRulesToTest *TestUpsellRulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationConfigApiTestUpsellRulesRequest) Authorization(authorization string) ReservationConfigApiTestUpsellRulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationConfigApiTestUpsellRulesRequest) XAppKey(xAppKey string) ReservationConfigApiTestUpsellRulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationConfigApiTestUpsellRulesRequest) XHotelid(xHotelid string) ReservationConfigApiTestUpsellRulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for testing upsell rules.
func (r ReservationConfigApiTestUpsellRulesRequest) UpsellRulesToTest(upsellRulesToTest TestUpsellRulesRequest) ReservationConfigApiTestUpsellRulesRequest {
	r.upsellRulesToTest = &upsellRulesToTest
	return r
}

// External system code.
func (r ReservationConfigApiTestUpsellRulesRequest) XExternalsystem(xExternalsystem string) ReservationConfigApiTestUpsellRulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationConfigApiTestUpsellRulesRequest) AcceptLanguage(acceptLanguage string) ReservationConfigApiTestUpsellRulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationConfigApiTestUpsellRulesRequest) Execute() (*UpsellRulesToTestDetails, *http.Response, error) {
	return r.ApiService.TestUpsellRulesExecute(r)
}

/*
TestUpsellRules Test upsell rules

Use this API to test and see if the rule that you have created works.  E.g. you can test by giving a rate code and dates, and see that the rule returns the correct upsell details. <p><strong>OperationId:</strong>testUpsellRules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique OPERA Hotel code
 @return ReservationConfigApiTestUpsellRulesRequest
*/
func (a *ReservationConfigApiService) TestUpsellRules(ctx context.Context, hotelId string) ReservationConfigApiTestUpsellRulesRequest {
	return ReservationConfigApiTestUpsellRulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UpsellRulesToTestDetails
func (a *ReservationConfigApiService) TestUpsellRulesExecute(r ReservationConfigApiTestUpsellRulesRequest) (*UpsellRulesToTestDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpsellRulesToTestDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationConfigApiService.TestUpsellRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/upsellRules/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.upsellRulesToTest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
