/*
OPERA Cloud Reservation Master Data Management API

APIs to cater for Reservation Configuration in OPERA Cloud. In this module you can retrieve, create, modify or delete configuration related to Reservations, Blocks and Leisure Management.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvcfg

import (
	"encoding/json"
	"fmt"
)

// ResvAutoAttchBasedOnCode Available only when Keyword Functionality is active.
type ResvAutoAttchBasedOnCode string

// List of resvAutoAttchBasedOnCode
const (
	RESVAUTOATTCHBASEDONCODE_MEMBERSHIP ResvAutoAttchBasedOnCode = "Membership"
	RESVAUTOATTCHBASEDONCODE_PREFERENCE ResvAutoAttchBasedOnCode = "Preference"
	RESVAUTOATTCHBASEDONCODE_RATE_CODE ResvAutoAttchBasedOnCode = "RateCode"
	RESVAUTOATTCHBASEDONCODE_ROOM_TYPE ResvAutoAttchBasedOnCode = "RoomType"
	RESVAUTOATTCHBASEDONCODE_MIN_ADULTS ResvAutoAttchBasedOnCode = "MinAdults"
	RESVAUTOATTCHBASEDONCODE_MIN_CHILDREN ResvAutoAttchBasedOnCode = "MinChildren"
	RESVAUTOATTCHBASEDONCODE_KEYWORD_TYPE ResvAutoAttchBasedOnCode = "KeywordType"
	RESVAUTOATTCHBASEDONCODE_SPECIAL ResvAutoAttchBasedOnCode = "Special"
	RESVAUTOATTCHBASEDONCODE_VIP ResvAutoAttchBasedOnCode = "Vip"
	RESVAUTOATTCHBASEDONCODE_CONDITION ResvAutoAttchBasedOnCode = "Condition"
)

// All allowed values of ResvAutoAttchBasedOnCode enum
var AllowedResvAutoAttchBasedOnCodeEnumValues = []ResvAutoAttchBasedOnCode{
	"Membership",
	"Preference",
	"RateCode",
	"RoomType",
	"MinAdults",
	"MinChildren",
	"KeywordType",
	"Special",
	"Vip",
	"Condition",
}

func (v *ResvAutoAttchBasedOnCode) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ResvAutoAttchBasedOnCode(value)
	for _, existing := range AllowedResvAutoAttchBasedOnCodeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ResvAutoAttchBasedOnCode", value)
}

// NewResvAutoAttchBasedOnCodeFromValue returns a pointer to a valid ResvAutoAttchBasedOnCode
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewResvAutoAttchBasedOnCodeFromValue(v string) (*ResvAutoAttchBasedOnCode, error) {
	ev := ResvAutoAttchBasedOnCode(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ResvAutoAttchBasedOnCode: valid values are %v", v, AllowedResvAutoAttchBasedOnCodeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ResvAutoAttchBasedOnCode) IsValid() bool {
	for _, existing := range AllowedResvAutoAttchBasedOnCodeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to resvAutoAttchBasedOnCode value
func (v ResvAutoAttchBasedOnCode) Ptr() *ResvAutoAttchBasedOnCode {
	return &v
}

type NullableResvAutoAttchBasedOnCode struct {
	value *ResvAutoAttchBasedOnCode
	isSet bool
}

func (v NullableResvAutoAttchBasedOnCode) Get() *ResvAutoAttchBasedOnCode {
	return v.value
}

func (v *NullableResvAutoAttchBasedOnCode) Set(val *ResvAutoAttchBasedOnCode) {
	v.value = val
	v.isSet = true
}

func (v NullableResvAutoAttchBasedOnCode) IsSet() bool {
	return v.isSet
}

func (v *NullableResvAutoAttchBasedOnCode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableResvAutoAttchBasedOnCode(val *ResvAutoAttchBasedOnCode) *NullableResvAutoAttchBasedOnCode {
	return &NullableResvAutoAttchBasedOnCode{value: val, isSet: true}
}

func (v NullableResvAutoAttchBasedOnCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableResvAutoAttchBasedOnCode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

