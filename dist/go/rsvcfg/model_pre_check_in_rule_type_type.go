/*
OPERA Cloud Reservation Master Data Management API

APIs to cater for Reservation Configuration in OPERA Cloud. In this module you can retrieve, create, modify or delete configuration related to Reservations, Blocks and Leisure Management.<br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvcfg

import (
	"encoding/json"
	"fmt"
)

// PreCheckInRuleTypeType The rule type on which the Internet Pre Check-In Rule is based. If a reservation has any of the following code, Pre CheckIn rule gets active for that reservation
type PreCheckInRuleTypeType string

// List of preCheckInRuleTypeType
const (
	PRECHECKINRULETYPETYPE_SPECIALS PreCheckInRuleTypeType = "Specials"
	PRECHECKINRULETYPETYPE_MARKET_CODES PreCheckInRuleTypeType = "MarketCodes"
	PRECHECKINRULETYPETYPE_TIME_LIMIT PreCheckInRuleTypeType = "TimeLimit"
	PRECHECKINRULETYPETYPE_RATE_PLANS PreCheckInRuleTypeType = "RatePlans"
	PRECHECKINRULETYPETYPE_RESERVATION_TYPES PreCheckInRuleTypeType = "ReservationTypes"
	PRECHECKINRULETYPETYPE_VIP_CODES PreCheckInRuleTypeType = "VIPCodes"
	PRECHECKINRULETYPETYPE_MEMBERSHIPS PreCheckInRuleTypeType = "Memberships"
	PRECHECKINRULETYPETYPE_ORIGIN_CODES PreCheckInRuleTypeType = "OriginCodes"
)

// All allowed values of PreCheckInRuleTypeType enum
var AllowedPreCheckInRuleTypeTypeEnumValues = []PreCheckInRuleTypeType{
	"Specials",
	"MarketCodes",
	"TimeLimit",
	"RatePlans",
	"ReservationTypes",
	"VIPCodes",
	"Memberships",
	"OriginCodes",
}

func (v *PreCheckInRuleTypeType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := PreCheckInRuleTypeType(value)
	for _, existing := range AllowedPreCheckInRuleTypeTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid PreCheckInRuleTypeType", value)
}

// NewPreCheckInRuleTypeTypeFromValue returns a pointer to a valid PreCheckInRuleTypeType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewPreCheckInRuleTypeTypeFromValue(v string) (*PreCheckInRuleTypeType, error) {
	ev := PreCheckInRuleTypeType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for PreCheckInRuleTypeType: valid values are %v", v, AllowedPreCheckInRuleTypeTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v PreCheckInRuleTypeType) IsValid() bool {
	for _, existing := range AllowedPreCheckInRuleTypeTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to preCheckInRuleTypeType value
func (v PreCheckInRuleTypeType) Ptr() *PreCheckInRuleTypeType {
	return &v
}

type NullablePreCheckInRuleTypeType struct {
	value *PreCheckInRuleTypeType
	isSet bool
}

func (v NullablePreCheckInRuleTypeType) Get() *PreCheckInRuleTypeType {
	return v.value
}

func (v *NullablePreCheckInRuleTypeType) Set(val *PreCheckInRuleTypeType) {
	v.value = val
	v.isSet = true
}

func (v NullablePreCheckInRuleTypeType) IsSet() bool {
	return v.isSet
}

func (v *NullablePreCheckInRuleTypeType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePreCheckInRuleTypeType(val *PreCheckInRuleTypeType) *NullablePreCheckInRuleTypeType {
	return &NullablePreCheckInRuleTypeType{value: val, isSet: true}
}

func (v NullablePreCheckInRuleTypeType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePreCheckInRuleTypeType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

