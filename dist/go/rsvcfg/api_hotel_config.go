/*
OPERA Cloud Reservation Master Data Management API

APIs to cater for Reservation Configuration in OPERA Cloud. In this module you can retrieve, create, modify or delete configuration related to Reservations, Blocks and Leisure Management.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigApiService HotelConfigApi service
type HotelConfigApiService service

type HotelConfigApiGetDepositPolicyRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	hotelIds *[]string
	policyCodeListCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetDepositPolicyRequest) Authorization(authorization string) HotelConfigApiGetDepositPolicyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetDepositPolicyRequest) XAppKey(xAppKey string) HotelConfigApiGetDepositPolicyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetDepositPolicyRequest) XHotelid(xHotelid string) HotelConfigApiGetDepositPolicyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetDepositPolicyRequest) Limit(limit int32) HotelConfigApiGetDepositPolicyRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetDepositPolicyRequest) PageNumber(pageNumber int32) HotelConfigApiGetDepositPolicyRequest {
	r.pageNumber = &pageNumber
	return r
}

// Hotel code.
func (r HotelConfigApiGetDepositPolicyRequest) HotelIds(hotelIds []string) HotelConfigApiGetDepositPolicyRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r HotelConfigApiGetDepositPolicyRequest) PolicyCodeListCodes(policyCodeListCodes []string) HotelConfigApiGetDepositPolicyRequest {
	r.policyCodeListCodes = &policyCodeListCodes
	return r
}

// Indicator that tells whether to include inactive in search results.
func (r HotelConfigApiGetDepositPolicyRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetDepositPolicyRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r HotelConfigApiGetDepositPolicyRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetDepositPolicyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetDepositPolicyRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetDepositPolicyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetDepositPolicyRequest) Execute() (*DepositPolicyDetails, *http.Response, error) {
	return r.ApiService.GetDepositPolicyExecute(r)
}

/*
GetDepositPolicy Get deposit policies in hotel level

Use this API to get deposit policies in hotel level. <p><strong>OperationId:</strong>getDepositPolicy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetDepositPolicyRequest
*/
func (a *HotelConfigApiService) GetDepositPolicy(ctx context.Context) HotelConfigApiGetDepositPolicyRequest {
	return HotelConfigApiGetDepositPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DepositPolicyDetails
func (a *HotelConfigApiService) GetDepositPolicyExecute(r HotelConfigApiGetDepositPolicyRequest) (*DepositPolicyDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositPolicyDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetDepositPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/depositpolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.policyCodeListCodes != nil {
		t := *r.policyCodeListCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyCodeListCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyCodeListCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetGuaranteeCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	hotelIds *[]string
	guaranteeCodes *[]string
	inactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetGuaranteeCodesRequest) Authorization(authorization string) HotelConfigApiGetGuaranteeCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetGuaranteeCodesRequest) XAppKey(xAppKey string) HotelConfigApiGetGuaranteeCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetGuaranteeCodesRequest) XHotelid(xHotelid string) HotelConfigApiGetGuaranteeCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetGuaranteeCodesRequest) Limit(limit int32) HotelConfigApiGetGuaranteeCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetGuaranteeCodesRequest) PageNumber(pageNumber int32) HotelConfigApiGetGuaranteeCodesRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r HotelConfigApiGetGuaranteeCodesRequest) HotelIds(hotelIds []string) HotelConfigApiGetGuaranteeCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r HotelConfigApiGetGuaranteeCodesRequest) GuaranteeCodes(guaranteeCodes []string) HotelConfigApiGetGuaranteeCodesRequest {
	r.guaranteeCodes = &guaranteeCodes
	return r
}

// Is Guarantee Code Inactive?
func (r HotelConfigApiGetGuaranteeCodesRequest) Inactive(inactive bool) HotelConfigApiGetGuaranteeCodesRequest {
	r.inactive = &inactive
	return r
}

// External system code.
func (r HotelConfigApiGetGuaranteeCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetGuaranteeCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetGuaranteeCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetGuaranteeCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetGuaranteeCodesRequest) Execute() (*GuaranteeCodesDetails, *http.Response, error) {
	return r.ApiService.GetGuaranteeCodesExecute(r)
}

/*
GetGuaranteeCodes Get guarantee codes

Use this API to get Guarantee Codes for a hotel. Guarantee codes are required to identify if the reservation is deducted (definite), not deducted (tentative) from availability, or is guaranteed.<p><strong>OperationId:</strong>getGuaranteeCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetGuaranteeCodesRequest
*/
func (a *HotelConfigApiService) GetGuaranteeCodes(ctx context.Context) HotelConfigApiGetGuaranteeCodesRequest {
	return HotelConfigApiGetGuaranteeCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GuaranteeCodesDetails
func (a *HotelConfigApiService) GetGuaranteeCodesExecute(r HotelConfigApiGetGuaranteeCodesRequest) (*GuaranteeCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuaranteeCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetGuaranteeCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guaranteeCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.guaranteeCodes != nil {
		t := *r.guaranteeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guaranteeCodes", t, "multi")
		}
	}
	if r.inactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", r.inactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetMarketCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	hotelIds *[]string
	marketCodes *[]string
	marketGroupsCodes *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetMarketCodesRequest) Authorization(authorization string) HotelConfigApiGetMarketCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetMarketCodesRequest) XAppKey(xAppKey string) HotelConfigApiGetMarketCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetMarketCodesRequest) XHotelid(xHotelid string) HotelConfigApiGetMarketCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetMarketCodesRequest) Limit(limit int32) HotelConfigApiGetMarketCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetMarketCodesRequest) PageNumber(pageNumber int32) HotelConfigApiGetMarketCodesRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r HotelConfigApiGetMarketCodesRequest) HotelIds(hotelIds []string) HotelConfigApiGetMarketCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r HotelConfigApiGetMarketCodesRequest) MarketCodes(marketCodes []string) HotelConfigApiGetMarketCodesRequest {
	r.marketCodes = &marketCodes
	return r
}

func (r HotelConfigApiGetMarketCodesRequest) MarketGroupsCodes(marketGroupsCodes []string) HotelConfigApiGetMarketCodesRequest {
	r.marketGroupsCodes = &marketGroupsCodes
	return r
}

// Search inactive Market Codes.
func (r HotelConfigApiGetMarketCodesRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetMarketCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r HotelConfigApiGetMarketCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetMarketCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetMarketCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetMarketCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetMarketCodesRequest) Execute() (*MarketCodesDetails, *http.Response, error) {
	return r.ApiService.GetMarketCodesExecute(r)
}

/*
GetMarketCodes Get Market codes

Use this API to get Market codes. <p><strong>OperationId:</strong>getMarketCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetMarketCodesRequest
*/
func (a *HotelConfigApiService) GetMarketCodes(ctx context.Context) HotelConfigApiGetMarketCodesRequest {
	return HotelConfigApiGetMarketCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarketCodesDetails
func (a *HotelConfigApiService) GetMarketCodesExecute(r HotelConfigApiGetMarketCodesRequest) (*MarketCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarketCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetMarketCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.marketCodes != nil {
		t := *r.marketCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketCodes", t, "multi")
		}
	}
	if r.marketGroupsCodes != nil {
		t := *r.marketGroupsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroupsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroupsCodes", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostGuaranteeCodeRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	guaranteeCodeCriteria *PostGuaranteeCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostGuaranteeCodeRequest) Authorization(authorization string) HotelConfigApiPostGuaranteeCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostGuaranteeCodeRequest) XAppKey(xAppKey string) HotelConfigApiPostGuaranteeCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostGuaranteeCodeRequest) XHotelid(xHotelid string) HotelConfigApiPostGuaranteeCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of Guarantee Code to be created.
func (r HotelConfigApiPostGuaranteeCodeRequest) GuaranteeCodeCriteria(guaranteeCodeCriteria PostGuaranteeCodeRequest) HotelConfigApiPostGuaranteeCodeRequest {
	r.guaranteeCodeCriteria = &guaranteeCodeCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostGuaranteeCodeRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostGuaranteeCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostGuaranteeCodeRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostGuaranteeCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostGuaranteeCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuaranteeCodeExecute(r)
}

/*
PostGuaranteeCode Create Guarantee Code

Use this API to create Guarantee Code. <p><strong>OperationId:</strong>postGuaranteeCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostGuaranteeCodeRequest
*/
func (a *HotelConfigApiService) PostGuaranteeCode(ctx context.Context) HotelConfigApiPostGuaranteeCodeRequest {
	return HotelConfigApiPostGuaranteeCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostGuaranteeCodeExecute(r HotelConfigApiPostGuaranteeCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostGuaranteeCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guaranteeCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guaranteeCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostGuaranteeCodeScheduleRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guaranteeCodeScheduleCriteria *PostGuaranteeCodeScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) Authorization(authorization string) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) XAppKey(xAppKey string) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) XHotelid(xHotelid string) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Creates the Guarantee Code schedule based on the details provided by the request.
func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) GuaranteeCodeScheduleCriteria(guaranteeCodeScheduleCriteria PostGuaranteeCodeScheduleRequest) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	r.guaranteeCodeScheduleCriteria = &guaranteeCodeScheduleCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostGuaranteeCodeScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuaranteeCodeScheduleExecute(r)
}

/*
PostGuaranteeCodeSchedule Create schedule for guarantee codes 

Use this API to create schedule for guarantee codes. <p><strong>OperationId:</strong>postGuaranteeCodeSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostGuaranteeCodeScheduleRequest
*/
func (a *HotelConfigApiService) PostGuaranteeCodeSchedule(ctx context.Context, hotelId string) HotelConfigApiPostGuaranteeCodeScheduleRequest {
	return HotelConfigApiPostGuaranteeCodeScheduleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostGuaranteeCodeScheduleExecute(r HotelConfigApiPostGuaranteeCodeScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostGuaranteeCodeSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/guaranteeCodeSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guaranteeCodeScheduleCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostNewPolicyScheduleRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	policyScheduleCriteria *PostNewPolicyScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostNewPolicyScheduleRequest) Authorization(authorization string) HotelConfigApiPostNewPolicyScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostNewPolicyScheduleRequest) XAppKey(xAppKey string) HotelConfigApiPostNewPolicyScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostNewPolicyScheduleRequest) XHotelid(xHotelid string) HotelConfigApiPostNewPolicyScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Creates the Policy schedule based on the details provided by the request.
func (r HotelConfigApiPostNewPolicyScheduleRequest) PolicyScheduleCriteria(policyScheduleCriteria PostNewPolicyScheduleRequest) HotelConfigApiPostNewPolicyScheduleRequest {
	r.policyScheduleCriteria = &policyScheduleCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostNewPolicyScheduleRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostNewPolicyScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostNewPolicyScheduleRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostNewPolicyScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostNewPolicyScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostNewPolicyScheduleExecute(r)
}

/*
PostNewPolicySchedule Create a Policy Schedule

Use this API to create schedule for deposit or cancel policy. <p><strong>OperationId:</strong>postNewPolicySchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostNewPolicyScheduleRequest
*/
func (a *HotelConfigApiService) PostNewPolicySchedule(ctx context.Context, hotelId string) HotelConfigApiPostNewPolicyScheduleRequest {
	return HotelConfigApiPostNewPolicyScheduleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostNewPolicyScheduleExecute(r HotelConfigApiPostNewPolicyScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostNewPolicySchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/policyschedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.policyScheduleCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostTemplateMarketCodeRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateMarketCodeCriteria *PostTemplateMarketCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostTemplateMarketCodeRequest) Authorization(authorization string) HotelConfigApiPostTemplateMarketCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostTemplateMarketCodeRequest) XAppKey(xAppKey string) HotelConfigApiPostTemplateMarketCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostTemplateMarketCodeRequest) XHotelid(xHotelid string) HotelConfigApiPostTemplateMarketCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of template Market Code to be created.
func (r HotelConfigApiPostTemplateMarketCodeRequest) TemplateMarketCodeCriteria(templateMarketCodeCriteria PostTemplateMarketCodeRequest) HotelConfigApiPostTemplateMarketCodeRequest {
	r.templateMarketCodeCriteria = &templateMarketCodeCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostTemplateMarketCodeRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostTemplateMarketCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostTemplateMarketCodeRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostTemplateMarketCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostTemplateMarketCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateMarketCodeExecute(r)
}

/*
PostTemplateMarketCode Create Market Code Template

This API is used to create a new Template Market Code. Only one template Market Code can be Use this API to created at a time. <p><strong>OperationId:</strong>postTemplateMarketCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostTemplateMarketCodeRequest
*/
func (a *HotelConfigApiService) PostTemplateMarketCode(ctx context.Context) HotelConfigApiPostTemplateMarketCodeRequest {
	return HotelConfigApiPostTemplateMarketCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostTemplateMarketCodeExecute(r HotelConfigApiPostTemplateMarketCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostTemplateMarketCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketCodeTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateMarketCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostTemplateSourceCodeRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateSourceCodeCriteria *PostTemplateSourceCodeRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostTemplateSourceCodeRequest) Authorization(authorization string) HotelConfigApiPostTemplateSourceCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostTemplateSourceCodeRequest) XAppKey(xAppKey string) HotelConfigApiPostTemplateSourceCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostTemplateSourceCodeRequest) XHotelid(xHotelid string) HotelConfigApiPostTemplateSourceCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object that holds the details of template Source Code to be created.
func (r HotelConfigApiPostTemplateSourceCodeRequest) TemplateSourceCodeCriteria(templateSourceCodeCriteria PostTemplateSourceCodeRequest) HotelConfigApiPostTemplateSourceCodeRequest {
	r.templateSourceCodeCriteria = &templateSourceCodeCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostTemplateSourceCodeRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostTemplateSourceCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostTemplateSourceCodeRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostTemplateSourceCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostTemplateSourceCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateSourceCodeExecute(r)
}

/*
PostTemplateSourceCode Create a Template Source Code

Use this API to create a new Template Source Code. Only one template Source Code can be created at a time. <p><strong>OperationId:</strong>postTemplateSourceCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiPostTemplateSourceCodeRequest
*/
func (a *HotelConfigApiService) PostTemplateSourceCode(ctx context.Context) HotelConfigApiPostTemplateSourceCodeRequest {
	return HotelConfigApiPostTemplateSourceCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostTemplateSourceCodeExecute(r HotelConfigApiPostTemplateSourceCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostTemplateSourceCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/templates/sourceCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateSourceCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
