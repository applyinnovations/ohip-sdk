/*
OPERA Cloud Reservation Master Data Management API

APIs to cater for Reservation Configuration in OPERA Cloud. In this module you can retrieve, create, modify or delete configuration related to Reservations, Blocks and Leisure Management.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvcfg

import (
	"encoding/json"
	"fmt"
)

// MarketCodePrintGroupType Group Print Group Type for country code Sweden.
type MarketCodePrintGroupType string

// List of marketCodePrintGroupType
const (
	MARKETCODEPRINTGROUPTYPE_BUSINESS MarketCodePrintGroupType = "Business"
	MARKETCODEPRINTGROUPTYPE_CONFERENCE MarketCodePrintGroupType = "Conference"
	MARKETCODEPRINTGROUPTYPE_LEISURE MarketCodePrintGroupType = "Leisure"
	MARKETCODEPRINTGROUPTYPE_BUSINESS_SE MarketCodePrintGroupType = "BusinessSe"
	MARKETCODEPRINTGROUPTYPE_CONFERENCE_SE MarketCodePrintGroupType = "ConferenceSe"
	MARKETCODEPRINTGROUPTYPE_LEISURE_SE MarketCodePrintGroupType = "LeisureSe"
	MARKETCODEPRINTGROUPTYPE_GROUP_SE MarketCodePrintGroupType = "GroupSe"
)

// All allowed values of MarketCodePrintGroupType enum
var AllowedMarketCodePrintGroupTypeEnumValues = []MarketCodePrintGroupType{
	"Business",
	"Conference",
	"Leisure",
	"BusinessSe",
	"ConferenceSe",
	"LeisureSe",
	"GroupSe",
}

func (v *MarketCodePrintGroupType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := MarketCodePrintGroupType(value)
	for _, existing := range AllowedMarketCodePrintGroupTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid MarketCodePrintGroupType", value)
}

// NewMarketCodePrintGroupTypeFromValue returns a pointer to a valid MarketCodePrintGroupType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewMarketCodePrintGroupTypeFromValue(v string) (*MarketCodePrintGroupType, error) {
	ev := MarketCodePrintGroupType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for MarketCodePrintGroupType: valid values are %v", v, AllowedMarketCodePrintGroupTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v MarketCodePrintGroupType) IsValid() bool {
	for _, existing := range AllowedMarketCodePrintGroupTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to marketCodePrintGroupType value
func (v MarketCodePrintGroupType) Ptr() *MarketCodePrintGroupType {
	return &v
}

type NullableMarketCodePrintGroupType struct {
	value *MarketCodePrintGroupType
	isSet bool
}

func (v NullableMarketCodePrintGroupType) Get() *MarketCodePrintGroupType {
	return v.value
}

func (v *NullableMarketCodePrintGroupType) Set(val *MarketCodePrintGroupType) {
	v.value = val
	v.isSet = true
}

func (v NullableMarketCodePrintGroupType) IsSet() bool {
	return v.isSet
}

func (v *NullableMarketCodePrintGroupType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableMarketCodePrintGroupType(val *MarketCodePrintGroupType) *NullableMarketCodePrintGroupType {
	return &NullableMarketCodePrintGroupType{value: val, isSet: true}
}

func (v NullableMarketCodePrintGroupType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableMarketCodePrintGroupType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

