/*
OPERA Cloud Cashiering API

APIs to cater for Cashiering related functionality in OPERA Cloud.<br /><br /> Cashiering provides access to a guest folio, posting journals, receipt histories, currency calculations, credit card settlements, and check a guest out.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package csh

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// CashieringAPIService CashieringAPI service
type CashieringAPIService service

type CashieringAPIActivatePrepaidCardRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activatePrepaidCard *ActivatePrepaidCard
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIActivatePrepaidCardRequest) Authorization(authorization string) CashieringAPIActivatePrepaidCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIActivatePrepaidCardRequest) XAppKey(xAppKey string) CashieringAPIActivatePrepaidCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIActivatePrepaidCardRequest) XHotelid(xHotelid string) CashieringAPIActivatePrepaidCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for activate prepaid card.
func (r CashieringAPIActivatePrepaidCardRequest) ActivatePrepaidCard(activatePrepaidCard ActivatePrepaidCard) CashieringAPIActivatePrepaidCardRequest {
	r.activatePrepaidCard = &activatePrepaidCard
	return r
}

// External system code.
func (r CashieringAPIActivatePrepaidCardRequest) XExternalsystem(xExternalsystem string) CashieringAPIActivatePrepaidCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIActivatePrepaidCardRequest) AcceptLanguage(acceptLanguage string) CashieringAPIActivatePrepaidCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIActivatePrepaidCardRequest) Execute() (*ActivatePrepaidCardStatus, *http.Response, error) {
	return r.ApiService.ActivatePrepaidCardExecute(r)
}

/*
ActivatePrepaidCard Operation to activate prepaid card.

You can use this API to activate Prepaid Card. <p><strong>OperationId:</strong>activatePrepaidCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIActivatePrepaidCardRequest
*/
func (a *CashieringAPIService) ActivatePrepaidCard(ctx context.Context, hotelId string) CashieringAPIActivatePrepaidCardRequest {
	return CashieringAPIActivatePrepaidCardRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivatePrepaidCardStatus
func (a *CashieringAPIService) ActivatePrepaidCardExecute(r CashieringAPIActivatePrepaidCardRequest) (*ActivatePrepaidCardStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivatePrepaidCardStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ActivatePrepaidCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activatePrepaidCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIAdjustTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionsAdjustment *TransactionsAdjustment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIAdjustTransactionsRequest) Authorization(authorization string) CashieringAPIAdjustTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIAdjustTransactionsRequest) XAppKey(xAppKey string) CashieringAPIAdjustTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIAdjustTransactionsRequest) XHotelid(xHotelid string) CashieringAPIAdjustTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to adjust a transaction. In order to adjust a transaction, a valid amount or percentage is required. A valid reason code and reason text is also required. Only negative adjustments are done. The adjust process will post a new negative transaction for the same transaction code for the current day.
func (r CashieringAPIAdjustTransactionsRequest) TransactionsAdjustment(transactionsAdjustment TransactionsAdjustment) CashieringAPIAdjustTransactionsRequest {
	r.transactionsAdjustment = &transactionsAdjustment
	return r
}

// External system code.
func (r CashieringAPIAdjustTransactionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIAdjustTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIAdjustTransactionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIAdjustTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIAdjustTransactionsRequest) Execute() (*AdjustedTransactions, *http.Response, error) {
	return r.ApiService.AdjustTransactionsExecute(r)
}

/*
AdjustTransactions Adjust Transactions

You can use this API to Adjust Transactions. <p><strong>OperationId:</strong>adjustTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIAdjustTransactionsRequest
*/
func (a *CashieringAPIService) AdjustTransactions(ctx context.Context, hotelId string) CashieringAPIAdjustTransactionsRequest {
	return CashieringAPIAdjustTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdjustedTransactions
func (a *CashieringAPIService) AdjustTransactionsExecute(r CashieringAPIAdjustTransactionsRequest) (*AdjustedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdjustedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.AdjustTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/adjust"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionsAdjustment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIApplyFinalPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	finalPostings *FinalPostings
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIApplyFinalPostingsRequest) Authorization(authorization string) CashieringAPIApplyFinalPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIApplyFinalPostingsRequest) XAppKey(xAppKey string) CashieringAPIApplyFinalPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIApplyFinalPostingsRequest) XHotelid(xHotelid string) CashieringAPIApplyFinalPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to apply any final charges or payments to a reservation prior to checkout. This operation should be called prior to the guest settlement which would then reflect the balance the guest has to pay.
func (r CashieringAPIApplyFinalPostingsRequest) FinalPostings(finalPostings FinalPostings) CashieringAPIApplyFinalPostingsRequest {
	r.finalPostings = &finalPostings
	return r
}

// External system code.
func (r CashieringAPIApplyFinalPostingsRequest) XExternalsystem(xExternalsystem string) CashieringAPIApplyFinalPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIApplyFinalPostingsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIApplyFinalPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIApplyFinalPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ApplyFinalPostingsExecute(r)
}

/*
ApplyFinalPostings Apply final Postings

You can use this API to apply final postings on a reservation. <p><strong>OperationId:</strong>applyFinalPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIApplyFinalPostingsRequest
*/
func (a *CashieringAPIService) ApplyFinalPostings(ctx context.Context, reservationId string, hotelId string) CashieringAPIApplyFinalPostingsRequest {
	return CashieringAPIApplyFinalPostingsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ApplyFinalPostingsExecute(r CashieringAPIApplyFinalPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ApplyFinalPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/finalCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.finalPostings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIApplyFlexibleBenefitPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	flexibleBenefitPostingsCriteria *FlexibleBenefitPostingsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) Authorization(authorization string) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) XAppKey(xAppKey string) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) XHotelid(xHotelid string) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Apply Flexible Benefit Postings.
func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) FlexibleBenefitPostingsCriteria(flexibleBenefitPostingsCriteria FlexibleBenefitPostingsCriteria) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	r.flexibleBenefitPostingsCriteria = &flexibleBenefitPostingsCriteria
	return r
}

// External system code.
func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) XExternalsystem(xExternalsystem string) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIApplyFlexibleBenefitPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ApplyFlexibleBenefitPostingsExecute(r)
}

/*
ApplyFlexibleBenefitPostings Apply flexible benefit postings

You can use this API to apply flexible benefit postings. <p><strong>OperationId:</strong>applyFlexibleBenefitPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIApplyFlexibleBenefitPostingsRequest
*/
func (a *CashieringAPIService) ApplyFlexibleBenefitPostings(ctx context.Context, reservationId string, hotelId string) CashieringAPIApplyFlexibleBenefitPostingsRequest {
	return CashieringAPIApplyFlexibleBenefitPostingsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ApplyFlexibleBenefitPostingsExecute(r CashieringAPIApplyFlexibleBenefitPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ApplyFlexibleBenefitPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/flexibleBenefitPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.flexibleBenefitPostingsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIAttachDepositPolicyToPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	policyId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attachPolicyApplyCriteria *AttachPolicyApplyCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIAttachDepositPolicyToPaymentRequest) Authorization(authorization string) CashieringAPIAttachDepositPolicyToPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIAttachDepositPolicyToPaymentRequest) XAppKey(xAppKey string) CashieringAPIAttachDepositPolicyToPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIAttachDepositPolicyToPaymentRequest) XHotelid(xHotelid string) CashieringAPIAttachDepositPolicyToPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to attach an existing Deposit Policy on a reservation towards an existing deposit payment on the same reservation.
func (r CashieringAPIAttachDepositPolicyToPaymentRequest) AttachPolicyApplyCriteria(attachPolicyApplyCriteria AttachPolicyApplyCriteria) CashieringAPIAttachDepositPolicyToPaymentRequest {
	r.attachPolicyApplyCriteria = &attachPolicyApplyCriteria
	return r
}

// External system code.
func (r CashieringAPIAttachDepositPolicyToPaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIAttachDepositPolicyToPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIAttachDepositPolicyToPaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIAttachDepositPolicyToPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIAttachDepositPolicyToPaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.AttachDepositPolicyToPaymentExecute(r)
}

/*
AttachDepositPolicyToPayment Attach Deposit Policy to Payment

You can use this API to attach Deposit Policy to Payment. <p><strong>OperationId:</strong>attachDepositPolicyToPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param policyId Unique ID of the policy
 @param hotelId Unique ID of the hotel
 @return CashieringAPIAttachDepositPolicyToPaymentRequest
*/
func (a *CashieringAPIService) AttachDepositPolicyToPayment(ctx context.Context, transactionId string, policyId string, hotelId string) CashieringAPIAttachDepositPolicyToPaymentRequest {
	return CashieringAPIAttachDepositPolicyToPaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		policyId: policyId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) AttachDepositPolicyToPaymentExecute(r CashieringAPIAttachDepositPolicyToPaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.AttachDepositPolicyToPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/policies/{policyId}/transactions/{transactionId}/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", url.PathEscape(parameterValueToString(r.policyId, "policyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.policyId) < 1 {
		return localVarReturnValue, nil, reportError("policyId must have at least 1 elements")
	}
	if strlen(r.policyId) > 2000 {
		return localVarReturnValue, nil, reportError("policyId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attachPolicyApplyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIAuthorizeCreditCardAmountRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccAuthorizationCriteria *CcAuthorizationCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIAuthorizeCreditCardAmountRequest) Authorization(authorization string) CashieringAPIAuthorizeCreditCardAmountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIAuthorizeCreditCardAmountRequest) XAppKey(xAppKey string) CashieringAPIAuthorizeCreditCardAmountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIAuthorizeCreditCardAmountRequest) XHotelid(xHotelid string) CashieringAPIAuthorizeCreditCardAmountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for a credit card authorization. An authorization request will be sent to the Credit Card Vendor as part of this request.
func (r CashieringAPIAuthorizeCreditCardAmountRequest) CcAuthorizationCriteria(ccAuthorizationCriteria CcAuthorizationCriteria) CashieringAPIAuthorizeCreditCardAmountRequest {
	r.ccAuthorizationCriteria = &ccAuthorizationCriteria
	return r
}

// External system code.
func (r CashieringAPIAuthorizeCreditCardAmountRequest) XExternalsystem(xExternalsystem string) CashieringAPIAuthorizeCreditCardAmountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIAuthorizeCreditCardAmountRequest) AcceptLanguage(acceptLanguage string) CashieringAPIAuthorizeCreditCardAmountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIAuthorizeCreditCardAmountRequest) Execute() (*AuthorizationInfo, *http.Response, error) {
	return r.ApiService.AuthorizeCreditCardAmountExecute(r)
}

/*
AuthorizeCreditCardAmount Authorize Credit Card Amount

You can use this API to authorize Credit Card Amount by Reservation. <p><strong>OperationId:</strong>authorizeCreditCardAmount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIAuthorizeCreditCardAmountRequest
*/
func (a *CashieringAPIService) AuthorizeCreditCardAmount(ctx context.Context, reservationId string, hotelId string) CashieringAPIAuthorizeCreditCardAmountRequest {
	return CashieringAPIAuthorizeCreditCardAmountRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizationInfo
func (a *CashieringAPIService) AuthorizeCreditCardAmountExecute(r CashieringAPIAuthorizeCreditCardAmountRequest) (*AuthorizationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.AuthorizeCreditCardAmount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods/creditCard/authorize"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccAuthorizationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIAuthorizeCreditCardAmountByProfileRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccAuthorizationCriteria *CcAuthorizationCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) Authorization(authorization string) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) XAppKey(xAppKey string) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) XHotelid(xHotelid string) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for a credit card authorization. An authorization request will be sent to the Credit Card Vendor as part of this request.
func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) CcAuthorizationCriteria(ccAuthorizationCriteria CcAuthorizationCriteria) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	r.ccAuthorizationCriteria = &ccAuthorizationCriteria
	return r
}

// External system code.
func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) XExternalsystem(xExternalsystem string) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) AcceptLanguage(acceptLanguage string) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) Execute() (*AuthorizationInfo, *http.Response, error) {
	return r.ApiService.AuthorizeCreditCardAmountByProfileExecute(r)
}

/*
AuthorizeCreditCardAmountByProfile Authorize Credit Card Amount by Profile

You can use this API to authorize Credit Card Amount by Profile. <p><strong>OperationId:</strong>authorizeCreditCardAmountByProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return CashieringAPIAuthorizeCreditCardAmountByProfileRequest
*/
func (a *CashieringAPIService) AuthorizeCreditCardAmountByProfile(ctx context.Context, profileId string, hotelId string) CashieringAPIAuthorizeCreditCardAmountByProfileRequest {
	return CashieringAPIAuthorizeCreditCardAmountByProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizationInfo
func (a *CashieringAPIService) AuthorizeCreditCardAmountByProfileExecute(r CashieringAPIAuthorizeCreditCardAmountByProfileRequest) (*AuthorizationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.AuthorizeCreditCardAmountByProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/paymentMethods/creditCard/authorize"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccAuthorizationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIAutoSettleCompFoliosRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	autoSettleCompFolios *AutoSettleCompFolios
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIAutoSettleCompFoliosRequest) Authorization(authorization string) CashieringAPIAutoSettleCompFoliosRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIAutoSettleCompFoliosRequest) XAppKey(xAppKey string) CashieringAPIAutoSettleCompFoliosRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIAutoSettleCompFoliosRequest) XHotelid(xHotelid string) CashieringAPIAutoSettleCompFoliosRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to auto settle comp folios. OPERA will reference the &#39;Default Comp Payment Method&#39; setting to settle the folio if no authorizer AR account is associated with the folio.
func (r CashieringAPIAutoSettleCompFoliosRequest) AutoSettleCompFolios(autoSettleCompFolios AutoSettleCompFolios) CashieringAPIAutoSettleCompFoliosRequest {
	r.autoSettleCompFolios = &autoSettleCompFolios
	return r
}

// External system code.
func (r CashieringAPIAutoSettleCompFoliosRequest) XExternalsystem(xExternalsystem string) CashieringAPIAutoSettleCompFoliosRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIAutoSettleCompFoliosRequest) AcceptLanguage(acceptLanguage string) CashieringAPIAutoSettleCompFoliosRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIAutoSettleCompFoliosRequest) Execute() (*AutoSettleCompFoliosStatus, *http.Response, error) {
	return r.ApiService.AutoSettleCompFoliosExecute(r)
}

/*
AutoSettleCompFolios Operation to auto settle comp folios.

You can use this API to auto Settle CompFolios <p><strong>OperationId:</strong>autoSettleCompFolios</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIAutoSettleCompFoliosRequest
*/
func (a *CashieringAPIService) AutoSettleCompFolios(ctx context.Context, reservationId string, hotelId string) CashieringAPIAutoSettleCompFoliosRequest {
	return CashieringAPIAutoSettleCompFoliosRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AutoSettleCompFoliosStatus
func (a *CashieringAPIService) AutoSettleCompFoliosExecute(r CashieringAPIAutoSettleCompFoliosRequest) (*AutoSettleCompFoliosStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoSettleCompFoliosStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.AutoSettleCompFolios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/comp/folios/autoSettlements"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.autoSettleCompFolios
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIBreakCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIBreakCashierLockRequest) Authorization(authorization string) CashieringAPIBreakCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIBreakCashierLockRequest) XAppKey(xAppKey string) CashieringAPIBreakCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIBreakCashierLockRequest) XHotelid(xHotelid string) CashieringAPIBreakCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIBreakCashierLockRequest) XExternalsystem(xExternalsystem string) CashieringAPIBreakCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIBreakCashierLockRequest) AcceptLanguage(acceptLanguage string) CashieringAPIBreakCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIBreakCashierLockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.BreakCashierLockExecute(r)
}

/*
BreakCashierLock Break Cashier Lock

You can use this API to Break Cashier Lock. <p><strong>OperationId:</strong>breakCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return CashieringAPIBreakCashierLockRequest
*/
func (a *CashieringAPIService) BreakCashierLock(ctx context.Context, cashierId string) CashieringAPIBreakCashierLockRequest {
	return CashieringAPIBreakCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) BreakCashierLockExecute(r CashieringAPIBreakCashierLockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.BreakCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/locks"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPICalculateForeignCurrencyRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	foreignCurrencyCriteria *ForeignCurrencyCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPICalculateForeignCurrencyRequest) Authorization(authorization string) CashieringAPICalculateForeignCurrencyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPICalculateForeignCurrencyRequest) XAppKey(xAppKey string) CashieringAPICalculateForeignCurrencyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPICalculateForeignCurrencyRequest) XHotelid(xHotelid string) CashieringAPICalculateForeignCurrencyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to calculate foreign currency exchange.
func (r CashieringAPICalculateForeignCurrencyRequest) ForeignCurrencyCriteria(foreignCurrencyCriteria ForeignCurrencyCriteria) CashieringAPICalculateForeignCurrencyRequest {
	r.foreignCurrencyCriteria = &foreignCurrencyCriteria
	return r
}

// External system code.
func (r CashieringAPICalculateForeignCurrencyRequest) XExternalsystem(xExternalsystem string) CashieringAPICalculateForeignCurrencyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPICalculateForeignCurrencyRequest) AcceptLanguage(acceptLanguage string) CashieringAPICalculateForeignCurrencyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPICalculateForeignCurrencyRequest) Execute() (*CalculatedForeignCurrency, *http.Response, error) {
	return r.ApiService.CalculateForeignCurrencyExecute(r)
}

/*
CalculateForeignCurrency Calculate Foreign Currency

This API will allow you to Calculate Foreign Currency exchange. <p><strong>OperationId:</strong>calculateForeignCurrency</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPICalculateForeignCurrencyRequest
*/
func (a *CashieringAPIService) CalculateForeignCurrency(ctx context.Context) CashieringAPICalculateForeignCurrencyRequest {
	return CashieringAPICalculateForeignCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CalculatedForeignCurrency
func (a *CashieringAPIService) CalculateForeignCurrencyExecute(r CashieringAPICalculateForeignCurrencyRequest) (*CalculatedForeignCurrency, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CalculatedForeignCurrency
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.CalculateForeignCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.foreignCurrencyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPICancelPrepaidCardTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cancelPrepaidCardTransaction *CancelPrepaidCardTransaction
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPICancelPrepaidCardTransactionRequest) Authorization(authorization string) CashieringAPICancelPrepaidCardTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPICancelPrepaidCardTransactionRequest) XAppKey(xAppKey string) CashieringAPICancelPrepaidCardTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPICancelPrepaidCardTransactionRequest) XHotelid(xHotelid string) CashieringAPICancelPrepaidCardTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for reload prepaid card.
func (r CashieringAPICancelPrepaidCardTransactionRequest) CancelPrepaidCardTransaction(cancelPrepaidCardTransaction CancelPrepaidCardTransaction) CashieringAPICancelPrepaidCardTransactionRequest {
	r.cancelPrepaidCardTransaction = &cancelPrepaidCardTransaction
	return r
}

// External system code.
func (r CashieringAPICancelPrepaidCardTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPICancelPrepaidCardTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPICancelPrepaidCardTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPICancelPrepaidCardTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPICancelPrepaidCardTransactionRequest) Execute() (*CancelPrepaidCardTransactionStatus, *http.Response, error) {
	return r.ApiService.CancelPrepaidCardTransactionExecute(r)
}

/*
CancelPrepaidCardTransaction Operation to cancel prepaid card transaction.

You can use this API to cancel PrepaidCard Transaction. <p><strong>OperationId:</strong>cancelPrepaidCardTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPICancelPrepaidCardTransactionRequest
*/
func (a *CashieringAPIService) CancelPrepaidCardTransaction(ctx context.Context, hotelId string) CashieringAPICancelPrepaidCardTransactionRequest {
	return CashieringAPICancelPrepaidCardTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CancelPrepaidCardTransactionStatus
func (a *CashieringAPIService) CancelPrepaidCardTransactionExecute(r CashieringAPICancelPrepaidCardTransactionRequest) (*CancelPrepaidCardTransactionStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelPrepaidCardTransactionStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.CancelPrepaidCardTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cancelPrepaidCardTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPICashOutPrepaidCardRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashOutPrepaidCard *CashOutPrepaidCard
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPICashOutPrepaidCardRequest) Authorization(authorization string) CashieringAPICashOutPrepaidCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPICashOutPrepaidCardRequest) XAppKey(xAppKey string) CashieringAPICashOutPrepaidCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPICashOutPrepaidCardRequest) XHotelid(xHotelid string) CashieringAPICashOutPrepaidCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for cashout prepaid card.
func (r CashieringAPICashOutPrepaidCardRequest) CashOutPrepaidCard(cashOutPrepaidCard CashOutPrepaidCard) CashieringAPICashOutPrepaidCardRequest {
	r.cashOutPrepaidCard = &cashOutPrepaidCard
	return r
}

// External system code.
func (r CashieringAPICashOutPrepaidCardRequest) XExternalsystem(xExternalsystem string) CashieringAPICashOutPrepaidCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPICashOutPrepaidCardRequest) AcceptLanguage(acceptLanguage string) CashieringAPICashOutPrepaidCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPICashOutPrepaidCardRequest) Execute() (*CashOutPrepaidCardStatus, *http.Response, error) {
	return r.ApiService.CashOutPrepaidCardExecute(r)
}

/*
CashOutPrepaidCard Operation to cash out prepaid card.

You can use this API to cashOut Prepaid Card. <p><strong>OperationId:</strong>cashOutPrepaidCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPICashOutPrepaidCardRequest
*/
func (a *CashieringAPIService) CashOutPrepaidCard(ctx context.Context, hotelId string) CashieringAPICashOutPrepaidCardRequest {
	return CashieringAPICashOutPrepaidCardRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashOutPrepaidCardStatus
func (a *CashieringAPIService) CashOutPrepaidCardExecute(r CashieringAPICashOutPrepaidCardRequest) (*CashOutPrepaidCardStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashOutPrepaidCardStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.CashOutPrepaidCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/cashOut"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashOutPrepaidCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIChangeBillingPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingPaymentToChange *BillingPaymentToChange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIChangeBillingPaymentRequest) Authorization(authorization string) CashieringAPIChangeBillingPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIChangeBillingPaymentRequest) XAppKey(xAppKey string) CashieringAPIChangeBillingPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIChangeBillingPaymentRequest) XHotelid(xHotelid string) CashieringAPIChangeBillingPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change a payment posting.
func (r CashieringAPIChangeBillingPaymentRequest) BillingPaymentToChange(billingPaymentToChange BillingPaymentToChange) CashieringAPIChangeBillingPaymentRequest {
	r.billingPaymentToChange = &billingPaymentToChange
	return r
}

// External system code.
func (r CashieringAPIChangeBillingPaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIChangeBillingPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIChangeBillingPaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIChangeBillingPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIChangeBillingPaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeBillingPaymentExecute(r)
}

/*
ChangeBillingPayment Change Billing Payment

You can use this API to change Billing Payment. <p><strong>OperationId:</strong>changeBillingPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return CashieringAPIChangeBillingPaymentRequest
*/
func (a *CashieringAPIService) ChangeBillingPayment(ctx context.Context, transactionId string, hotelId string) CashieringAPIChangeBillingPaymentRequest {
	return CashieringAPIChangeBillingPaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ChangeBillingPaymentExecute(r CashieringAPIChangeBillingPaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ChangeBillingPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingPaymentToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIChangeRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructionsToChange *RoutingInstructionsToChange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIChangeRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIChangeRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIChangeRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIChangeRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIChangeRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIChangeRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request when changing a routing instruction.
func (r CashieringAPIChangeRoutingInstructionsRequest) RoutingInstructionsToChange(routingInstructionsToChange RoutingInstructionsToChange) CashieringAPIChangeRoutingInstructionsRequest {
	r.routingInstructionsToChange = &routingInstructionsToChange
	return r
}

// External system code.
func (r CashieringAPIChangeRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIChangeRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIChangeRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIChangeRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIChangeRoutingInstructionsRequest) Execute() (*ChangedRoutingInstructions, *http.Response, error) {
	return r.ApiService.ChangeRoutingInstructionsExecute(r)
}

/*
ChangeRoutingInstructions Change routing instructions

You can use this API to update routing instructions for a specified reservation. <p><strong>OperationId:</strong>changeRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIChangeRoutingInstructionsRequest
*/
func (a *CashieringAPIService) ChangeRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIChangeRoutingInstructionsRequest {
	return CashieringAPIChangeRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedRoutingInstructions
func (a *CashieringAPIService) ChangeRoutingInstructionsExecute(r CashieringAPIChangeRoutingInstructionsRequest) (*ChangedRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ChangeRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/change"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructionsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPICheckPostRateCodeRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	rateCode string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postRateCodeCriteria *PostRateCodeCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPICheckPostRateCodeRequest) Authorization(authorization string) CashieringAPICheckPostRateCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPICheckPostRateCodeRequest) XAppKey(xAppKey string) CashieringAPICheckPostRateCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPICheckPostRateCodeRequest) XHotelid(xHotelid string) CashieringAPICheckPostRateCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to check if a Rate Code can be posted to the room manually. This will check if the Rate Code is valid, if the Products(Packages) which are defined as part of the Rate Code can be posted or reversed.
func (r CashieringAPICheckPostRateCodeRequest) PostRateCodeCriteria(postRateCodeCriteria PostRateCodeCriteria) CashieringAPICheckPostRateCodeRequest {
	r.postRateCodeCriteria = &postRateCodeCriteria
	return r
}

// External system code.
func (r CashieringAPICheckPostRateCodeRequest) XExternalsystem(xExternalsystem string) CashieringAPICheckPostRateCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPICheckPostRateCodeRequest) AcceptLanguage(acceptLanguage string) CashieringAPICheckPostRateCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPICheckPostRateCodeRequest) Execute() (*CheckedRateCode, *http.Response, error) {
	return r.ApiService.CheckPostRateCodeExecute(r)
}

/*
CheckPostRateCode Change posted rate codes

You can use this API to change posted rate codes. <p><strong>OperationId:</strong>checkPostRateCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode The Rate Code which is to be posted on the Guest Folio.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPICheckPostRateCodeRequest
*/
func (a *CashieringAPIService) CheckPostRateCode(ctx context.Context, rateCode string, reservationId string, hotelId string) CashieringAPICheckPostRateCodeRequest {
	return CashieringAPICheckPostRateCodeRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckedRateCode
func (a *CashieringAPIService) CheckPostRateCodeExecute(r CashieringAPICheckPostRateCodeRequest) (*CheckedRateCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedRateCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.CheckPostRateCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservation/{reservationId}/rateCode/{rateCode}/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postRateCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPICloseReservationFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closeFolioCriteria *CloseFolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPICloseReservationFolioRequest) Authorization(authorization string) CashieringAPICloseReservationFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPICloseReservationFolioRequest) XAppKey(xAppKey string) CashieringAPICloseReservationFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPICloseReservationFolioRequest) XHotelid(xHotelid string) CashieringAPICloseReservationFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to close an Open Folio Reservation. The Property should be using the Open Folio Functionality to use this operation.
func (r CashieringAPICloseReservationFolioRequest) CloseFolioCriteria(closeFolioCriteria CloseFolioCriteria) CashieringAPICloseReservationFolioRequest {
	r.closeFolioCriteria = &closeFolioCriteria
	return r
}

// External system code.
func (r CashieringAPICloseReservationFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPICloseReservationFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPICloseReservationFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPICloseReservationFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPICloseReservationFolioRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CloseReservationFolioExecute(r)
}

/*
CloseReservationFolio Close Reservation Folio

You can use this API to close the Reservation Folio on a reservation. <p><strong>OperationId:</strong>closeReservationFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPICloseReservationFolioRequest
*/
func (a *CashieringAPIService) CloseReservationFolio(ctx context.Context, reservationId string, hotelId string) CashieringAPICloseReservationFolioRequest {
	return CashieringAPICloseReservationFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) CloseReservationFolioExecute(r CashieringAPICloseReservationFolioRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.CloseReservationFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.closeFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIConvertFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	convertFolioCriteria *ConvertFolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIConvertFolioRequest) Authorization(authorization string) CashieringAPIConvertFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIConvertFolioRequest) XAppKey(xAppKey string) CashieringAPIConvertFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIConvertFolioRequest) XHotelid(xHotelid string) CashieringAPIConvertFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to convert folio from a Non Fiscal Folio type to a Fiscal Folio Type. Functionality is used in Italy and is only available when the country mode is set to Italy.
func (r CashieringAPIConvertFolioRequest) ConvertFolioCriteria(convertFolioCriteria ConvertFolioCriteria) CashieringAPIConvertFolioRequest {
	r.convertFolioCriteria = &convertFolioCriteria
	return r
}

// External system code.
func (r CashieringAPIConvertFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIConvertFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIConvertFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIConvertFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIConvertFolioRequest) Execute() (*ConvertFolioDetails, *http.Response, error) {
	return r.ApiService.ConvertFolioExecute(r)
}

/*
ConvertFolio Convert Folio

You can use this API to Convert folio. <p><strong>OperationId:</strong>convertFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio
 @param hotelId Unique ID of the hotel
 @return CashieringAPIConvertFolioRequest
*/
func (a *CashieringAPIService) ConvertFolio(ctx context.Context, folioId string, hotelId string) CashieringAPIConvertFolioRequest {
	return CashieringAPIConvertFolioRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ConvertFolioDetails
func (a *CashieringAPIService) ConvertFolioExecute(r CashieringAPIConvertFolioRequest) (*ConvertFolioDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConvertFolioDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ConvertFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folio/{folioId}/convert"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.convertFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDeleteAdvanceRoomChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDeleteAdvanceRoomChargesRequest) Authorization(authorization string) CashieringAPIDeleteAdvanceRoomChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDeleteAdvanceRoomChargesRequest) XAppKey(xAppKey string) CashieringAPIDeleteAdvanceRoomChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDeleteAdvanceRoomChargesRequest) XHotelid(xHotelid string) CashieringAPIDeleteAdvanceRoomChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIDeleteAdvanceRoomChargesRequest) CashierId(cashierId float32) CashieringAPIDeleteAdvanceRoomChargesRequest {
	r.cashierId = &cashierId
	return r
}

// External system code.
func (r CashieringAPIDeleteAdvanceRoomChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIDeleteAdvanceRoomChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDeleteAdvanceRoomChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDeleteAdvanceRoomChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDeleteAdvanceRoomChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAdvanceRoomChargesExecute(r)
}

/*
DeleteAdvanceRoomCharges Delete Advance Folio Transactions

You can use this API to reverse the Advance Folio Transactions on a reservation. As part of reversal, the actual charges may not be deleted but only an offset will be posted.<p><strong>OperationId:</strong>reverseAdvanceFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDeleteAdvanceRoomChargesRequest
*/
func (a *CashieringAPIService) DeleteAdvanceRoomCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIDeleteAdvanceRoomChargesRequest {
	return CashieringAPIDeleteAdvanceRoomChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) DeleteAdvanceRoomChargesExecute(r CashieringAPIDeleteAdvanceRoomChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DeleteAdvanceRoomCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advanceRoomCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDeleteCompRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	folioWindowNo *int32
	payeeId *string
	membershipIdNo *int32
	authorizerId *string
	userId *int32
	userName *string
	comments *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	creditLimit *[]float32
	percentageLimit *[]float32
	covers *[]float32
	transactionCode *[]string
	billingCode *[]string
	routingInstructionsId *[]float32
	routingLinkId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) PayeeId(payeeId string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.payeeId = &payeeId
	return r
}

// Unique Id of membership
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) MembershipIdNo(membershipIdNo int32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.membershipIdNo = &membershipIdNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) AuthorizerId(authorizerId string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.authorizerId = &authorizerId
	return r
}

// User Id of the Opera User
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) UserId(userId int32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.userId = &userId
	return r
}

// Name of the Opera User
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) UserName(userName string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.userName = &userName
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Comments(comments string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.comments = &comments
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Daily(daily bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Sunday(sunday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Monday(monday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Tuesday(tuesday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Wednesday(wednesday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Thursday(thursday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Friday(friday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Saturday(saturday bool) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) StartDate(startDate string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) EndDate(endDate string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) CreditLimit(creditLimit []float32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) PercentageLimit(percentageLimit []float32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Covers(covers []float32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.covers = &covers
	return r
}

// Unique identifier for the Transaction code.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) TransactionCode(transactionCode []string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.transactionCode = &transactionCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) BillingCode(billingCode []string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.billingCode = &billingCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) RoutingInstructionsId(routingInstructionsId []float32) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) RoutingLinkId(routingLinkId string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.routingLinkId = &routingLinkId
	return r
}

// External system code.
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDeleteCompRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDeleteCompRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteCompRoutingInstructionsExecute(r)
}

/*
DeleteCompRoutingInstructions Delete comp routing instructions

You can use this API to delete comp routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteCompRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDeleteCompRoutingInstructionsRequest
*/
func (a *CashieringAPIService) DeleteCompRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIDeleteCompRoutingInstructionsRequest {
	return CashieringAPIDeleteCompRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringAPIService) DeleteCompRoutingInstructionsExecute(r CashieringAPIDeleteCompRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DeleteCompRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/comp"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
  }
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
  }
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
  }
	if r.payeeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payeeId", r.payeeId, "")
  }
	if r.membershipIdNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipIdNo", r.membershipIdNo, "")
  }
	if r.authorizerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerId", r.authorizerId, "")
  }
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
  }
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "")
  }
	if r.comments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comments", r.comments, "")
  }
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.creditLimit != nil {
		t := *r.creditLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", t, "multi")
		}
  }
	if r.percentageLimit != nil {
		t := *r.percentageLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", t, "multi")
		}
  }
	if r.covers != nil {
		t := *r.covers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "covers", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "covers", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
  }
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
  }
	if r.routingLinkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkId", r.routingLinkId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDeleteFolioRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	folioWindowNo *int32
	payeeId *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	creditLimit *[]float32
	percentageLimit *[]float32
	covers *[]float32
	transactionCode *[]string
	billingCode *[]string
	routingInstructionsId *[]float32
	routingLinkId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) PayeeId(payeeId string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.payeeId = &payeeId
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Daily(daily bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Sunday(sunday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Monday(monday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Tuesday(tuesday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Wednesday(wednesday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Thursday(thursday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Friday(friday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Saturday(saturday bool) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) StartDate(startDate string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) EndDate(endDate string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) CreditLimit(creditLimit []float32) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) PercentageLimit(percentageLimit []float32) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Covers(covers []float32) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.covers = &covers
	return r
}

// Unique identifier for the Transaction code.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) TransactionCode(transactionCode []string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.transactionCode = &transactionCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) BillingCode(billingCode []string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.billingCode = &billingCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) RoutingInstructionsId(routingInstructionsId []float32) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) RoutingLinkId(routingLinkId string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.routingLinkId = &routingLinkId
	return r
}

// External system code.
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDeleteFolioRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteFolioRoutingInstructionsExecute(r)
}

/*
DeleteFolioRoutingInstructions Delete Folio routing instructions

You can use this API to delete folio routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteFolioRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDeleteFolioRoutingInstructionsRequest
*/
func (a *CashieringAPIService) DeleteFolioRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIDeleteFolioRoutingInstructionsRequest {
	return CashieringAPIDeleteFolioRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringAPIService) DeleteFolioRoutingInstructionsExecute(r CashieringAPIDeleteFolioRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DeleteFolioRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/folio"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
  }
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
  }
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
  }
	if r.payeeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payeeId", r.payeeId, "")
  }
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.creditLimit != nil {
		t := *r.creditLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", t, "multi")
		}
  }
	if r.percentageLimit != nil {
		t := *r.percentageLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", t, "multi")
		}
  }
	if r.covers != nil {
		t := *r.covers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "covers", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "covers", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
  }
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
  }
	if r.routingLinkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkId", r.routingLinkId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDeleteRequestRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	userName *string
	comments *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

// Name of the Opera User
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) UserName(userName string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.userName = &userName
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Comments(comments string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.comments = &comments
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Daily(daily bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Sunday(sunday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Monday(monday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Tuesday(tuesday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Wednesday(wednesday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Thursday(thursday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Friday(friday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Saturday(saturday bool) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) StartDate(startDate string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) EndDate(endDate string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// External system code.
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDeleteRequestRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteRequestRoutingInstructionsExecute(r)
}

/*
DeleteRequestRoutingInstructions Delete request routing instructions

You can use this API to delete request routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteRequestRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDeleteRequestRoutingInstructionsRequest
*/
func (a *CashieringAPIService) DeleteRequestRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIDeleteRequestRoutingInstructionsRequest {
	return CashieringAPIDeleteRequestRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringAPIService) DeleteRequestRoutingInstructionsExecute(r CashieringAPIDeleteRequestRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DeleteRequestRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/request"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
  }
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
  }
	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "")
  }
	if r.comments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comments", r.comments, "")
  }
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDeleteRoomRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	refreshFolio *bool
	retrievePostingsForRoomRouting *bool
	reservationNameId *string
	daily *bool
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	startDate *string
	endDate *string
	creditLimit *[]float32
	percentageLimit *[]float32
	covers *[]float32
	transactionCode *[]string
	billingCode *[]string
	routingInstructionsId *[]float32
	routingLinkId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// On a successful update, the transactions that are already posted in the guest&#39;s folio will be re-organized based on the configured instructions.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) RefreshFolio(refreshFolio bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.refreshFolio = &refreshFolio
	return r
}

// This flag indicates if postings that can be refreshed need to be part of the response when a routing instruction is created, updated or deleted.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) RetrievePostingsForRoomRouting(retrievePostingsForRoomRouting bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.retrievePostingsForRoomRouting = &retrievePostingsForRoomRouting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) ReservationNameId(reservationNameId string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.reservationNameId = &reservationNameId
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Daily(daily bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.daily = &daily
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Sunday(sunday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.sunday = &sunday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Monday(monday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.monday = &monday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Tuesday(tuesday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.tuesday = &tuesday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Wednesday(wednesday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.wednesday = &wednesday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Thursday(thursday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.thursday = &thursday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Friday(friday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.friday = &friday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Saturday(saturday bool) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.saturday = &saturday
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) StartDate(startDate string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) EndDate(endDate string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.endDate = &endDate
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) CreditLimit(creditLimit []float32) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) PercentageLimit(percentageLimit []float32) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Covers(covers []float32) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.covers = &covers
	return r
}

// Unique identifier for the Transaction code.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) TransactionCode(transactionCode []string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.transactionCode = &transactionCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) BillingCode(billingCode []string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.billingCode = &billingCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) RoutingInstructionsId(routingInstructionsId []float32) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) RoutingLinkId(routingLinkId string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.routingLinkId = &routingLinkId
	return r
}

// External system code.
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDeleteRoomRoutingInstructionsRequest) Execute() (*RoomRoutingPostings, *http.Response, error) {
	return r.ApiService.DeleteRoomRoutingInstructionsExecute(r)
}

/*
DeleteRoomRoutingInstructions Delete Room routing instructions

You can use this API to delete room routing instructions for a specified reservation. <p><strong>OperationId:</strong>deleteRoomRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDeleteRoomRoutingInstructionsRequest
*/
func (a *CashieringAPIService) DeleteRoomRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIDeleteRoomRoutingInstructionsRequest {
	return CashieringAPIDeleteRoomRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomRoutingPostings
func (a *CashieringAPIService) DeleteRoomRoutingInstructionsExecute(r CashieringAPIDeleteRoomRoutingInstructionsRequest) (*RoomRoutingPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomRoutingPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DeleteRoomRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/room"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.refreshFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshFolio", r.refreshFolio, "")
  }
	if r.retrievePostingsForRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retrievePostingsForRoomRouting", r.retrievePostingsForRoomRouting, "")
  }
	if r.reservationNameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationNameId", r.reservationNameId, "")
  }
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.creditLimit != nil {
		t := *r.creditLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", t, "multi")
		}
  }
	if r.percentageLimit != nil {
		t := *r.percentageLimit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", t, "multi")
		}
  }
	if r.covers != nil {
		t := *r.covers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "covers", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "covers", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
  }
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
  }
	if r.routingLinkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkId", r.routingLinkId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDeleteRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDeleteRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIDeleteRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDeleteRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIDeleteRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDeleteRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIDeleteRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIDeleteRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIDeleteRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDeleteRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDeleteRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDeleteRoutingInstructionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoutingInstructionsExecute(r)
}

/*
DeleteRoutingInstructions Delete routing instructions

You can use this API to delete routing instructions for a specified reservation.<br><p><strong><mark>This API is deprecated. Please use deleteFolioRoutingInstructions or  deleteRoomRoutingInstructions or deleteCompRoutingInstructions or deleteRequestRoutingInstructions instead</mark></strong></p> <p><strong>OperationId:</strong>deleteRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDeleteRoutingInstructionsRequest

Deprecated
*/
func (a *CashieringAPIService) DeleteRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIDeleteRoutingInstructionsRequest {
	return CashieringAPIDeleteRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringAPIService) DeleteRoutingInstructionsExecute(r CashieringAPIDeleteRoutingInstructionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DeleteRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIDetachDepositPolicyFromPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	detachPolicyApplyCriteria *DetachPolicyApplyCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) Authorization(authorization string) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) XAppKey(xAppKey string) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) XHotelid(xHotelid string) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to detach a deposit payment from a Deposit Policy on a reservation.
func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) DetachPolicyApplyCriteria(detachPolicyApplyCriteria DetachPolicyApplyCriteria) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	r.detachPolicyApplyCriteria = &detachPolicyApplyCriteria
	return r
}

// External system code.
func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIDetachDepositPolicyFromPaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DetachDepositPolicyFromPaymentExecute(r)
}

/*
DetachDepositPolicyFromPayment Detach Deposit Policy from Payment

You can use this API to detach Deposit Policy from Payment. <p><strong>OperationId:</strong>detachDepositPolicyFromPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return CashieringAPIDetachDepositPolicyFromPaymentRequest
*/
func (a *CashieringAPIService) DetachDepositPolicyFromPayment(ctx context.Context, transactionId string, hotelId string) CashieringAPIDetachDepositPolicyFromPaymentRequest {
	return CashieringAPIDetachDepositPolicyFromPaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) DetachDepositPolicyFromPaymentExecute(r CashieringAPIDetachDepositPolicyFromPaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.DetachDepositPolicyFromPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/policies/detach/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.detachPolicyApplyCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGenerateFiscalFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalInfoFolioCriteria *FiscalInfoFolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGenerateFiscalFolioRequest) Authorization(authorization string) CashieringAPIGenerateFiscalFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGenerateFiscalFolioRequest) XAppKey(xAppKey string) CashieringAPIGenerateFiscalFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGenerateFiscalFolioRequest) XHotelid(xHotelid string) CashieringAPIGenerateFiscalFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate fiscal Information folio.
func (r CashieringAPIGenerateFiscalFolioRequest) FiscalInfoFolioCriteria(fiscalInfoFolioCriteria FiscalInfoFolioCriteria) CashieringAPIGenerateFiscalFolioRequest {
	r.fiscalInfoFolioCriteria = &fiscalInfoFolioCriteria
	return r
}

// External system code.
func (r CashieringAPIGenerateFiscalFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIGenerateFiscalFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGenerateFiscalFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGenerateFiscalFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGenerateFiscalFolioRequest) Execute() (*FiscalInformationFolio, *http.Response, error) {
	return r.ApiService.GenerateFiscalFolioExecute(r)
}

/*
GenerateFiscalFolio Create Fiscal Information Folio

You can use this API to create Fiscal Information Folio. <p><strong>OperationId:</strong>generateFiscalFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGenerateFiscalFolioRequest
*/
func (a *CashieringAPIService) GenerateFiscalFolio(ctx context.Context, hotelId string) CashieringAPIGenerateFiscalFolioRequest {
	return CashieringAPIGenerateFiscalFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalInformationFolio
func (a *CashieringAPIService) GenerateFiscalFolioExecute(r CashieringAPIGenerateFiscalFolioRequest) (*FiscalInformationFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalInformationFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GenerateFiscalFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalFolios"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalInfoFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGenerateFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioCriteria *FolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGenerateFolioRequest) Authorization(authorization string) CashieringAPIGenerateFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGenerateFolioRequest) XAppKey(xAppKey string) CashieringAPIGenerateFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGenerateFolioRequest) XHotelid(xHotelid string) CashieringAPIGenerateFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Generate Folio request can be used to create a folio for checked in reservation or reservation with open folios
func (r CashieringAPIGenerateFolioRequest) FolioCriteria(folioCriteria FolioCriteria) CashieringAPIGenerateFolioRequest {
	r.folioCriteria = &folioCriteria
	return r
}

// External system code.
func (r CashieringAPIGenerateFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIGenerateFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGenerateFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGenerateFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGenerateFolioRequest) Execute() (*GeneratedFolio, *http.Response, error) {
	return r.ApiService.GenerateFolioExecute(r)
}

/*
GenerateFolio Generate Folios

You can use this API to generate folios for a reservation. <p><strong>OperationId:</strong>generateFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGenerateFolioRequest
*/
func (a *CashieringAPIService) GenerateFolio(ctx context.Context, reservationId string, hotelId string) CashieringAPIGenerateFolioRequest {
	return CashieringAPIGenerateFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GeneratedFolio
func (a *CashieringAPIService) GenerateFolioExecute(r CashieringAPIGenerateFolioRequest) (*GeneratedFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GeneratedFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GenerateFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetAdditionalTaxesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	folioView *int32
	currencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetAdditionalTaxesRequest) Authorization(authorization string) CashieringAPIGetAdditionalTaxesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetAdditionalTaxesRequest) XAppKey(xAppKey string) CashieringAPIGetAdditionalTaxesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetAdditionalTaxesRequest) XHotelid(xHotelid string) CashieringAPIGetAdditionalTaxesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetAdditionalTaxesRequest) IdContext(idContext string) CashieringAPIGetAdditionalTaxesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetAdditionalTaxesRequest) Type_(type_ string) CashieringAPIGetAdditionalTaxesRequest {
	r.type_ = &type_
	return r
}

// Folio Window.
func (r CashieringAPIGetAdditionalTaxesRequest) FolioView(folioView int32) CashieringAPIGetAdditionalTaxesRequest {
	r.folioView = &folioView
	return r
}

// Currency code on which tax is to be calculated
func (r CashieringAPIGetAdditionalTaxesRequest) CurrencyCode(currencyCode string) CashieringAPIGetAdditionalTaxesRequest {
	r.currencyCode = &currencyCode
	return r
}

// External system code.
func (r CashieringAPIGetAdditionalTaxesRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetAdditionalTaxesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetAdditionalTaxesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetAdditionalTaxesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetAdditionalTaxesRequest) Execute() (*AdditionalTaxesDetails, *http.Response, error) {
	return r.ApiService.GetAdditionalTaxesExecute(r)
}

/*
GetAdditionalTaxes Get additional Taxes

You can use this API to get Additional Taxes. <p><strong>OperationId:</strong>getAdditionalTaxes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetAdditionalTaxesRequest
*/
func (a *CashieringAPIService) GetAdditionalTaxes(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetAdditionalTaxesRequest {
	return CashieringAPIGetAdditionalTaxesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdditionalTaxesDetails
func (a *CashieringAPIService) GetAdditionalTaxesExecute(r CashieringAPIGetAdditionalTaxesRequest) (*AdditionalTaxesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdditionalTaxesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetAdditionalTaxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/additionalTaxes"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetAdvancePaymentBalanceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	fromDate *string
	numberOfNights *int32
	eventType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetAdvancePaymentBalanceRequest) Authorization(authorization string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetAdvancePaymentBalanceRequest) XAppKey(xAppKey string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetAdvancePaymentBalanceRequest) XHotelid(xHotelid string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetAdvancePaymentBalanceRequest) IdContext(idContext string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetAdvancePaymentBalanceRequest) Type_(type_ string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.type_ = &type_
	return r
}

// From date of reservation.
func (r CashieringAPIGetAdvancePaymentBalanceRequest) FromDate(fromDate string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.fromDate = &fromDate
	return r
}

// Number of nights to calculate advance payment.
func (r CashieringAPIGetAdvancePaymentBalanceRequest) NumberOfNights(numberOfNights int32) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.numberOfNights = &numberOfNights
	return r
}

// Event to which this process will be logged.
func (r CashieringAPIGetAdvancePaymentBalanceRequest) EventType(eventType string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.eventType = &eventType
	return r
}

// External system code.
func (r CashieringAPIGetAdvancePaymentBalanceRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetAdvancePaymentBalanceRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetAdvancePaymentBalanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetAdvancePaymentBalanceRequest) Execute() (*AdvancePaymentBalance, *http.Response, error) {
	return r.ApiService.GetAdvancePaymentBalanceExecute(r)
}

/*
GetAdvancePaymentBalance Get advance payment balance

You can use this API to get advance payment balance. <p><strong>OperationId:</strong>getAdvancePaymentBalance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetAdvancePaymentBalanceRequest
*/
func (a *CashieringAPIService) GetAdvancePaymentBalance(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetAdvancePaymentBalanceRequest {
	return CashieringAPIGetAdvancePaymentBalanceRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdvancePaymentBalance
func (a *CashieringAPIService) GetAdvancePaymentBalanceExecute(r CashieringAPIGetAdvancePaymentBalanceRequest) (*AdvancePaymentBalance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdvancePaymentBalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetAdvancePaymentBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advancePaymentBalance"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
  }
	if r.numberOfNights != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfNights", r.numberOfNights, "")
  }
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetAlertsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	alertArea *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetAlertsRequest) Authorization(authorization string) CashieringAPIGetAlertsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetAlertsRequest) XAppKey(xAppKey string) CashieringAPIGetAlertsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetAlertsRequest) XHotelid(xHotelid string) CashieringAPIGetAlertsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringAPIGetAlertsRequest) AlertArea(alertArea string) CashieringAPIGetAlertsRequest {
	r.alertArea = &alertArea
	return r
}

// External system code.
func (r CashieringAPIGetAlertsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetAlertsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetAlertsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetAlertsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetAlertsRequest) Execute() (*AlertNotices, *http.Response, error) {
	return r.ApiService.GetAlertsExecute(r)
}

/*
GetAlerts Get Alert Notices

You can use this API to get Alert Notices.<br><p><strong><mark>This API is deprecated.</mark></strong></p> <p><strong>OperationId:</strong>getAlerts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique OPERA reservation ID which is used to find reservation from OPERA. This ID is a primary identification of a reservation in OPERA.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetAlertsRequest

Deprecated
*/
func (a *CashieringAPIService) GetAlerts(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetAlertsRequest {
	return CashieringAPIGetAlertsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AlertNotices
// Deprecated
func (a *CashieringAPIService) GetAlertsExecute(r CashieringAPIGetAlertsRequest) (*AlertNotices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertNotices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.alertArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertArea", r.alertArea, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetAuthorizationHistoryRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	includeAuthorizations *bool
	includePayments *bool
	includeRefunds *bool
	includeFailures *bool
	folioView *int32
	transactionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetAuthorizationHistoryRequest) Authorization(authorization string) CashieringAPIGetAuthorizationHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetAuthorizationHistoryRequest) XAppKey(xAppKey string) CashieringAPIGetAuthorizationHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetAuthorizationHistoryRequest) XHotelid(xHotelid string) CashieringAPIGetAuthorizationHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetAuthorizationHistoryRequest) IdContext(idContext string) CashieringAPIGetAuthorizationHistoryRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetAuthorizationHistoryRequest) Type_(type_ string) CashieringAPIGetAuthorizationHistoryRequest {
	r.type_ = &type_
	return r
}

// A flag which indicates whether authorizations should be included in the returned list.
func (r CashieringAPIGetAuthorizationHistoryRequest) IncludeAuthorizations(includeAuthorizations bool) CashieringAPIGetAuthorizationHistoryRequest {
	r.includeAuthorizations = &includeAuthorizations
	return r
}

// A flag which indicates whether payments should be included in the returned list.
func (r CashieringAPIGetAuthorizationHistoryRequest) IncludePayments(includePayments bool) CashieringAPIGetAuthorizationHistoryRequest {
	r.includePayments = &includePayments
	return r
}

// A flag which indicates whether refunds should be included in the returned list.
func (r CashieringAPIGetAuthorizationHistoryRequest) IncludeRefunds(includeRefunds bool) CashieringAPIGetAuthorizationHistoryRequest {
	r.includeRefunds = &includeRefunds
	return r
}

// A flag which indicates whether failures should be included in the returned list.
func (r CashieringAPIGetAuthorizationHistoryRequest) IncludeFailures(includeFailures bool) CashieringAPIGetAuthorizationHistoryRequest {
	r.includeFailures = &includeFailures
	return r
}

func (r CashieringAPIGetAuthorizationHistoryRequest) FolioView(folioView int32) CashieringAPIGetAuthorizationHistoryRequest {
	r.folioView = &folioView
	return r
}

// Currently supported transaction type categories used for credit card authorization.
func (r CashieringAPIGetAuthorizationHistoryRequest) TransactionType(transactionType string) CashieringAPIGetAuthorizationHistoryRequest {
	r.transactionType = &transactionType
	return r
}

// External system code.
func (r CashieringAPIGetAuthorizationHistoryRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetAuthorizationHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetAuthorizationHistoryRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetAuthorizationHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetAuthorizationHistoryRequest) Execute() (*AuthorizationHistory, *http.Response, error) {
	return r.ApiService.GetAuthorizationHistoryExecute(r)
}

/*
GetAuthorizationHistory Get authorization history

You can use this API to get authorization history. <p><strong>OperationId:</strong>getAuthorizationHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetAuthorizationHistoryRequest
*/
func (a *CashieringAPIService) GetAuthorizationHistory(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetAuthorizationHistoryRequest {
	return CashieringAPIGetAuthorizationHistoryRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizationHistory
func (a *CashieringAPIService) GetAuthorizationHistoryExecute(r CashieringAPIGetAuthorizationHistoryRequest) (*AuthorizationHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetAuthorizationHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/authorizationHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.includeAuthorizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAuthorizations", r.includeAuthorizations, "")
  }
	if r.includePayments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePayments", r.includePayments, "")
  }
	if r.includeRefunds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRefunds", r.includeRefunds, "")
  }
	if r.includeFailures != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFailures", r.includeFailures, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.transactionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", r.transactionType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetAuthorizersCreditInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	startDate *string
	endDate *string
	duration *string
	code *[]string
	includeCreditDetails *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetAuthorizersCreditInfoRequest) Authorization(authorization string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetAuthorizersCreditInfoRequest) XAppKey(xAppKey string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetAuthorizersCreditInfoRequest) XHotelid(xHotelid string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringAPIGetAuthorizersCreditInfoRequest) StartDate(startDate string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetAuthorizersCreditInfoRequest) EndDate(endDate string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringAPIGetAuthorizersCreditInfoRequest) Duration(duration string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.duration = &duration
	return r
}

func (r CashieringAPIGetAuthorizersCreditInfoRequest) Code(code []string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.code = &code
	return r
}

// This flag will notify the service if the Credit details will also be returned or not.
func (r CashieringAPIGetAuthorizersCreditInfoRequest) IncludeCreditDetails(includeCreditDetails bool) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.includeCreditDetails = &includeCreditDetails
	return r
}

// External system code.
func (r CashieringAPIGetAuthorizersCreditInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetAuthorizersCreditInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetAuthorizersCreditInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetAuthorizersCreditInfoRequest) Execute() (*AuthorizersCreditInfo, *http.Response, error) {
	return r.ApiService.GetAuthorizersCreditInfoExecute(r)
}

/*
GetAuthorizersCreditInfo Get Authorizers Credit Info

You can use this API to get Authorizers Credit Info. <p><strong>OperationId:</strong>getAuthorizersCreditInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetAuthorizersCreditInfoRequest
*/
func (a *CashieringAPIService) GetAuthorizersCreditInfo(ctx context.Context, hotelId string) CashieringAPIGetAuthorizersCreditInfoRequest {
	return CashieringAPIGetAuthorizersCreditInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AuthorizersCreditInfo
func (a *CashieringAPIService) GetAuthorizersCreditInfoExecute(r CashieringAPIGetAuthorizersCreditInfoRequest) (*AuthorizersCreditInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizersCreditInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetAuthorizersCreditInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/authorizers/credits"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.includeCreditDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCreditDetails", r.includeCreditDetails, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetBalanceInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	id *string
	idContext *string
	type_ *string
	folioWindowNo *[]int32
	cashierId *[]float32
	transactionCode *[]string
	articleCode *[]string
	amount *[]float32
	currencyCode *[]string
	postingQuantity *[]int32
	postingReference *[]string
	postingRemark *[]string
	checkNumber *[]string
	arrangementCode *[]string
	applyRoutingInstructions *[]bool
	usePackageAllowance *[]bool
	autoPosting *[]bool
	uniqueIdId *[]string
	uniqueIdIdContext *[]string
	uniqueIdType *[]string
	postItNumberId *string
	postItNumberIdContext *string
	postItNumberType *string
	profileIdId *string
	profileIdIdContext *string
	profileIdType *string
	reservationIdId *string
	reservationIdIdContext *string
	reservationIdType *string
	policyIdId *string
	policyIdIdContext *string
	policyIdType *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetBalanceInfoRequest) Authorization(authorization string) CashieringAPIGetBalanceInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetBalanceInfoRequest) XAppKey(xAppKey string) CashieringAPIGetBalanceInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetBalanceInfoRequest) XHotelid(xHotelid string) CashieringAPIGetBalanceInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r CashieringAPIGetBalanceInfoRequest) Event(event string) CashieringAPIGetBalanceInfoRequest {
	r.event = &event
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBalanceInfoRequest) Id(id string) CashieringAPIGetBalanceInfoRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBalanceInfoRequest) IdContext(idContext string) CashieringAPIGetBalanceInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBalanceInfoRequest) Type_(type_ string) CashieringAPIGetBalanceInfoRequest {
	r.type_ = &type_
	return r
}

func (r CashieringAPIGetBalanceInfoRequest) FolioWindowNo(folioWindowNo []int32) CashieringAPIGetBalanceInfoRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetBalanceInfoRequest) CashierId(cashierId []float32) CashieringAPIGetBalanceInfoRequest {
	r.cashierId = &cashierId
	return r
}

// Transaction Code to post.
func (r CashieringAPIGetBalanceInfoRequest) TransactionCode(transactionCode []string) CashieringAPIGetBalanceInfoRequest {
	r.transactionCode = &transactionCode
	return r
}

// Article ID.
func (r CashieringAPIGetBalanceInfoRequest) ArticleCode(articleCode []string) CashieringAPIGetBalanceInfoRequest {
	r.articleCode = &articleCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetBalanceInfoRequest) Amount(amount []float32) CashieringAPIGetBalanceInfoRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetBalanceInfoRequest) CurrencyCode(currencyCode []string) CashieringAPIGetBalanceInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// Quantity to post to the folio.
func (r CashieringAPIGetBalanceInfoRequest) PostingQuantity(postingQuantity []int32) CashieringAPIGetBalanceInfoRequest {
	r.postingQuantity = &postingQuantity
	return r
}

// User-defined posting reference.
func (r CashieringAPIGetBalanceInfoRequest) PostingReference(postingReference []string) CashieringAPIGetBalanceInfoRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r CashieringAPIGetBalanceInfoRequest) PostingRemark(postingRemark []string) CashieringAPIGetBalanceInfoRequest {
	r.postingRemark = &postingRemark
	return r
}

// Indicates the Cheque number.
func (r CashieringAPIGetBalanceInfoRequest) CheckNumber(checkNumber []string) CashieringAPIGetBalanceInfoRequest {
	r.checkNumber = &checkNumber
	return r
}

// Corrected arrangement code from the package associated to this transaction.
func (r CashieringAPIGetBalanceInfoRequest) ArrangementCode(arrangementCode []string) CashieringAPIGetBalanceInfoRequest {
	r.arrangementCode = &arrangementCode
	return r
}

// Apply room routing when making this posting.
func (r CashieringAPIGetBalanceInfoRequest) ApplyRoutingInstructions(applyRoutingInstructions []bool) CashieringAPIGetBalanceInfoRequest {
	r.applyRoutingInstructions = &applyRoutingInstructions
	return r
}

// Use the applicable package allowance when making this posting.
func (r CashieringAPIGetBalanceInfoRequest) UsePackageAllowance(usePackageAllowance []bool) CashieringAPIGetBalanceInfoRequest {
	r.usePackageAllowance = &usePackageAllowance
	return r
}

// True indicates the Transaction Code is allowed to be posted automatically.
func (r CashieringAPIGetBalanceInfoRequest) AutoPosting(autoPosting []bool) CashieringAPIGetBalanceInfoRequest {
	r.autoPosting = &autoPosting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBalanceInfoRequest) UniqueIdId(uniqueIdId []string) CashieringAPIGetBalanceInfoRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBalanceInfoRequest) UniqueIdIdContext(uniqueIdIdContext []string) CashieringAPIGetBalanceInfoRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBalanceInfoRequest) UniqueIdType(uniqueIdType []string) CashieringAPIGetBalanceInfoRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBalanceInfoRequest) PostItNumberId(postItNumberId string) CashieringAPIGetBalanceInfoRequest {
	r.postItNumberId = &postItNumberId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBalanceInfoRequest) PostItNumberIdContext(postItNumberIdContext string) CashieringAPIGetBalanceInfoRequest {
	r.postItNumberIdContext = &postItNumberIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBalanceInfoRequest) PostItNumberType(postItNumberType string) CashieringAPIGetBalanceInfoRequest {
	r.postItNumberType = &postItNumberType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBalanceInfoRequest) ProfileIdId(profileIdId string) CashieringAPIGetBalanceInfoRequest {
	r.profileIdId = &profileIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBalanceInfoRequest) ProfileIdIdContext(profileIdIdContext string) CashieringAPIGetBalanceInfoRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBalanceInfoRequest) ProfileIdType(profileIdType string) CashieringAPIGetBalanceInfoRequest {
	r.profileIdType = &profileIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBalanceInfoRequest) ReservationIdId(reservationIdId string) CashieringAPIGetBalanceInfoRequest {
	r.reservationIdId = &reservationIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBalanceInfoRequest) ReservationIdIdContext(reservationIdIdContext string) CashieringAPIGetBalanceInfoRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBalanceInfoRequest) ReservationIdType(reservationIdType string) CashieringAPIGetBalanceInfoRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBalanceInfoRequest) PolicyIdId(policyIdId string) CashieringAPIGetBalanceInfoRequest {
	r.policyIdId = &policyIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBalanceInfoRequest) PolicyIdIdContext(policyIdIdContext string) CashieringAPIGetBalanceInfoRequest {
	r.policyIdIdContext = &policyIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBalanceInfoRequest) PolicyIdType(policyIdType string) CashieringAPIGetBalanceInfoRequest {
	r.policyIdType = &policyIdType
	return r
}

// The Fiscal Bill number of this posting
func (r CashieringAPIGetBalanceInfoRequest) FiscalBillNo(fiscalBillNo string) CashieringAPIGetBalanceInfoRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r CashieringAPIGetBalanceInfoRequest) FolioDate(folioDate string) CashieringAPIGetBalanceInfoRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r CashieringAPIGetBalanceInfoRequest) FolioNo(folioNo float32) CashieringAPIGetBalanceInfoRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r CashieringAPIGetBalanceInfoRequest) FolioStatus(folioStatus string) CashieringAPIGetBalanceInfoRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r CashieringAPIGetBalanceInfoRequest) FolioTypeName(folioTypeName string) CashieringAPIGetBalanceInfoRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r CashieringAPIGetBalanceInfoRequest) InternalFolioWindowID(internalFolioWindowID string) CashieringAPIGetBalanceInfoRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r CashieringAPIGetBalanceInfoRequest) InvoiceNo(invoiceNo float32) CashieringAPIGetBalanceInfoRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r CashieringAPIGetBalanceInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetBalanceInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetBalanceInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetBalanceInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetBalanceInfoRequest) Execute() (*BalanceInfoCriteria, *http.Response, error) {
	return r.ApiService.GetBalanceInfoExecute(r)
}

/*
GetBalanceInfo Get Balance Information

You can use this API to get Balance Information. <p><strong>OperationId:</strong>getBalanceInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetBalanceInfoRequest
*/
func (a *CashieringAPIService) GetBalanceInfo(ctx context.Context, hotelId string) CashieringAPIGetBalanceInfoRequest {
	return CashieringAPIGetBalanceInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BalanceInfoCriteria
func (a *CashieringAPIService) GetBalanceInfoExecute(r CashieringAPIGetBalanceInfoRequest) (*BalanceInfoCriteria, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceInfoCriteria
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetBalanceInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionsTotal"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
  }
	if r.cashierId != nil {
		t := *r.cashierId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.amount != nil {
		t := *r.amount
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amount", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amount", t, "multi")
		}
  }
	if r.currencyCode != nil {
		t := *r.currencyCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", t, "multi")
		}
  }
	if r.postingQuantity != nil {
		t := *r.postingQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", t, "multi")
		}
  }
	if r.postingReference != nil {
		t := *r.postingReference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", t, "multi")
		}
  }
	if r.postingRemark != nil {
		t := *r.postingRemark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", t, "multi")
		}
  }
	if r.checkNumber != nil {
		t := *r.checkNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", t, "multi")
		}
  }
	if r.arrangementCode != nil {
		t := *r.arrangementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", t, "multi")
		}
  }
	if r.applyRoutingInstructions != nil {
		t := *r.applyRoutingInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", t, "multi")
		}
  }
	if r.usePackageAllowance != nil {
		t := *r.usePackageAllowance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", t, "multi")
		}
  }
	if r.autoPosting != nil {
		t := *r.autoPosting
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", t, "multi")
		}
  }
	if r.uniqueIdId != nil {
		t := *r.uniqueIdId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", t, "multi")
		}
  }
	if r.uniqueIdIdContext != nil {
		t := *r.uniqueIdIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", t, "multi")
		}
  }
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
  }
	if r.postItNumberId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postItNumberId", r.postItNumberId, "")
  }
	if r.postItNumberIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postItNumberIdContext", r.postItNumberIdContext, "")
  }
	if r.postItNumberType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postItNumberType", r.postItNumberType, "")
  }
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
  }
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	if r.reservationIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdId", r.reservationIdId, "")
  }
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.policyIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdId", r.policyIdId, "")
  }
	if r.policyIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdIdContext", r.policyIdIdContext, "")
  }
	if r.policyIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdType", r.policyIdType, "")
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
  }
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
  }
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
  }
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
  }
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetBatchCCSettlementsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	offlineSettlement *bool
	transactionDate *string
	guestName *string
	roomId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetBatchCCSettlementsRequest) Authorization(authorization string) CashieringAPIGetBatchCCSettlementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetBatchCCSettlementsRequest) XAppKey(xAppKey string) CashieringAPIGetBatchCCSettlementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetBatchCCSettlementsRequest) XHotelid(xHotelid string) CashieringAPIGetBatchCCSettlementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// fetch only offline settlements.
func (r CashieringAPIGetBatchCCSettlementsRequest) OfflineSettlement(offlineSettlement bool) CashieringAPIGetBatchCCSettlementsRequest {
	r.offlineSettlement = &offlineSettlement
	return r
}

// Transaction Date associated with the transaction.
func (r CashieringAPIGetBatchCCSettlementsRequest) TransactionDate(transactionDate string) CashieringAPIGetBatchCCSettlementsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Guest name associated with the transaction.
func (r CashieringAPIGetBatchCCSettlementsRequest) GuestName(guestName string) CashieringAPIGetBatchCCSettlementsRequest {
	r.guestName = &guestName
	return r
}

// Room number associated with the transaction.
func (r CashieringAPIGetBatchCCSettlementsRequest) RoomId(roomId string) CashieringAPIGetBatchCCSettlementsRequest {
	r.roomId = &roomId
	return r
}

// External system code.
func (r CashieringAPIGetBatchCCSettlementsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetBatchCCSettlementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetBatchCCSettlementsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetBatchCCSettlementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetBatchCCSettlementsRequest) Execute() (*CcBatchSettlements, *http.Response, error) {
	return r.ApiService.GetBatchCCSettlementsExecute(r)
}

/*
GetBatchCCSettlements Get batch CC Settlements

You can use this API to get batch CC Settlements. <p><strong>OperationId:</strong>getBatchCCSettlements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetBatchCCSettlementsRequest
*/
func (a *CashieringAPIService) GetBatchCCSettlements(ctx context.Context, hotelId string) CashieringAPIGetBatchCCSettlementsRequest {
	return CashieringAPIGetBatchCCSettlementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcBatchSettlements
func (a *CashieringAPIService) GetBatchCCSettlementsExecute(r CashieringAPIGetBatchCCSettlementsRequest) (*CcBatchSettlements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcBatchSettlements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetBatchCCSettlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/cCSettlements"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.offlineSettlement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offlineSettlement", r.offlineSettlement, "")
  }
	if r.transactionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", r.transactionDate, "")
  }
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
  }
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetBatchCCSettlementsStatusRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	batchId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) Authorization(authorization string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) XAppKey(xAppKey string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) XHotelid(xHotelid string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) Id(id []string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) IdContext(idContext []string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) Type_(type_ []string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetBatchCCSettlementsStatusRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetBatchCCSettlementsStatusRequest) Execute() (*CcBatchSettlementsStatus, *http.Response, error) {
	return r.ApiService.GetBatchCCSettlementsStatusExecute(r)
}

/*
GetBatchCCSettlementsStatus Get Batch CC Settlements Status

You can use this API to get Batch CC Settlements Status. <p><strong>OperationId:</strong>getBatchCCSettlementsStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchId Unique ID of the batch
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetBatchCCSettlementsStatusRequest
*/
func (a *CashieringAPIService) GetBatchCCSettlementsStatus(ctx context.Context, batchId string, hotelId string) CashieringAPIGetBatchCCSettlementsStatusRequest {
	return CashieringAPIGetBatchCCSettlementsStatusRequest{
		ApiService: a,
		ctx: ctx,
		batchId: batchId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcBatchSettlementsStatus
func (a *CashieringAPIService) GetBatchCCSettlementsStatusExecute(r CashieringAPIGetBatchCCSettlementsStatusRequest) (*CcBatchSettlementsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcBatchSettlementsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetBatchCCSettlementsStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bulkCCSettlements/{batchId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"batchId"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.batchId) < 1 {
		return localVarReturnValue, nil, reportError("batchId must have at least 1 elements")
	}
	if strlen(r.batchId) > 2000 {
		return localVarReturnValue, nil, reportError("batchId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arrival *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetBedTaxInfoRequest) Authorization(authorization string) CashieringAPIGetBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetBedTaxInfoRequest) XAppKey(xAppKey string) CashieringAPIGetBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetBedTaxInfoRequest) XHotelid(xHotelid string) CashieringAPIGetBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Arrival Date of the reservation
func (r CashieringAPIGetBedTaxInfoRequest) Arrival(arrival string) CashieringAPIGetBedTaxInfoRequest {
	r.arrival = &arrival
	return r
}

// External system code.
func (r CashieringAPIGetBedTaxInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetBedTaxInfoRequest) Execute() (*BedTaxInfo, *http.Response, error) {
	return r.ApiService.GetBedTaxInfoExecute(r)
}

/*
GetBedTaxInfo Get bed tax information

You can use this API to Retrieve bed tax information for a property. <p><strong>OperationId:</strong>getBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetBedTaxInfoRequest
*/
func (a *CashieringAPIService) GetBedTaxInfo(ctx context.Context, hotelId string) CashieringAPIGetBedTaxInfoRequest {
	return CashieringAPIGetBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BedTaxInfo
func (a *CashieringAPIService) GetBedTaxInfoExecute(r CashieringAPIGetBedTaxInfoRequest) (*BedTaxInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BedTaxInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.arrival != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrival", r.arrival, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetBillingInstructionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeTransactionCodes *bool
	includeBillingInstructions *bool
	includeCompInstructions *bool
	codeWildCard *string
	descriptionWildCard *string
	id *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetBillingInstructionCodesRequest) Authorization(authorization string) CashieringAPIGetBillingInstructionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetBillingInstructionCodesRequest) XAppKey(xAppKey string) CashieringAPIGetBillingInstructionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetBillingInstructionCodesRequest) XHotelid(xHotelid string) CashieringAPIGetBillingInstructionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to include the search in the Transaction Codes.
func (r CashieringAPIGetBillingInstructionCodesRequest) IncludeTransactionCodes(includeTransactionCodes bool) CashieringAPIGetBillingInstructionCodesRequest {
	r.includeTransactionCodes = &includeTransactionCodes
	return r
}

// Flag to include the search in the Billing Instructions.
func (r CashieringAPIGetBillingInstructionCodesRequest) IncludeBillingInstructions(includeBillingInstructions bool) CashieringAPIGetBillingInstructionCodesRequest {
	r.includeBillingInstructions = &includeBillingInstructions
	return r
}

// Flag to include the comp instructions in the available list.
func (r CashieringAPIGetBillingInstructionCodesRequest) IncludeCompInstructions(includeCompInstructions bool) CashieringAPIGetBillingInstructionCodesRequest {
	r.includeCompInstructions = &includeCompInstructions
	return r
}

// Lookup string which will try to match an existing Billing and/or Transaction Codes.
func (r CashieringAPIGetBillingInstructionCodesRequest) CodeWildCard(codeWildCard string) CashieringAPIGetBillingInstructionCodesRequest {
	r.codeWildCard = &codeWildCard
	return r
}

// Lookup string which will try to match an existing Billing and/or Transaction Code Description.
func (r CashieringAPIGetBillingInstructionCodesRequest) DescriptionWildCard(descriptionWildCard string) CashieringAPIGetBillingInstructionCodesRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetBillingInstructionCodesRequest) Id(id string) CashieringAPIGetBillingInstructionCodesRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetBillingInstructionCodesRequest) IdContext(idContext string) CashieringAPIGetBillingInstructionCodesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetBillingInstructionCodesRequest) Type_(type_ string) CashieringAPIGetBillingInstructionCodesRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r CashieringAPIGetBillingInstructionCodesRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetBillingInstructionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetBillingInstructionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetBillingInstructionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetBillingInstructionCodesRequest) Execute() (*BillingInstructionCodes, *http.Response, error) {
	return r.ApiService.GetBillingInstructionCodesExecute(r)
}

/*
GetBillingInstructionCodes Get Billing (routing) Instruction Codes

You can use this API to get Billing Instruction Codes. <p><strong>OperationId:</strong>getBillingInstructionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetBillingInstructionCodesRequest
*/
func (a *CashieringAPIService) GetBillingInstructionCodes(ctx context.Context, hotelId string) CashieringAPIGetBillingInstructionCodesRequest {
	return CashieringAPIGetBillingInstructionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingInstructionCodes
func (a *CashieringAPIService) GetBillingInstructionCodesExecute(r CashieringAPIGetBillingInstructionCodesRequest) (*BillingInstructionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingInstructionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetBillingInstructionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/routingInstructionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeTransactionCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionCodes", r.includeTransactionCodes, "")
  }
	if r.includeBillingInstructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeBillingInstructions", r.includeBillingInstructions, "")
  }
	if r.includeCompInstructions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompInstructions", r.includeCompInstructions, "")
  }
	if r.codeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "codeWildCard", r.codeWildCard, "")
  }
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCCAuthorizationInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	evaluateApprovalAmount *bool
	sourceOfAuthorization *string
	updateReservation *bool
	idContext *string
	type_ *string
	profileIdIdContext *string
	profileIdType *string
	amount *float32
	currencyCode *string
	folioView *int32
	description *string
	paymentFolioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	storeToCreditCardWallet *bool
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	cardPresent *bool
	citId *string
	userDefinedCardType *string
	cardIdId *string
	cardIdIdContext *string
	cardIdType *string
	currentAuthorizedAmountAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *string
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *string
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	terminalId *string
	incidentalAmountAmount *float32
	incidentalAmountCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Authorization(authorization string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) XAppKey(xAppKey string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) XHotelid(xHotelid string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the approval amount should be calculated before authorization. If this is true and if the amount is 0 the approval amount will be calculated based on the rules.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) EvaluateApprovalAmount(evaluateApprovalAmount bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.evaluateApprovalAmount = &evaluateApprovalAmount
	return r
}

// Currently supported transaction type categories used for credit card authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) SourceOfAuthorization(sourceOfAuthorization string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.sourceOfAuthorization = &sourceOfAuthorization
	return r
}

// Update the card details on the reservations for Chip and Pin Authorizations.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) UpdateReservation(updateReservation bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.updateReservation = &updateReservation
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) IdContext(idContext string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Type_(type_ string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ProfileIdIdContext(profileIdIdContext string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ProfileIdType(profileIdType string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.profileIdType = &profileIdType
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Amount(amount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CurrencyCode(currencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.currencyCode = &currencyCode
	return r
}

// The folio window where this authorization is applied.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) FolioView(folioView int32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.folioView = &folioView
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Description(description string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.description = &description
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) PaymentFolioView(paymentFolioView int32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.paymentFolioView = &paymentFolioView
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) PaymentMethod(paymentMethod string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Track2Data(track2Data string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardHolderName(cardHolderName string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardNumber(cardNumber string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardNumberMasked(cardNumberMasked string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardOrToken(cardOrToken string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// Attach the credit card to the wallet.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) StoreToCreditCardWallet(storeToCreditCardWallet bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.storeToCreditCardWallet = &storeToCreditCardWallet
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardType(cardType string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ExpirationDate(expirationDate string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ExpirationDateExpired(expirationDateExpired bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ExpirationDateMasked(expirationDateMasked string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Processing(processing string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.processing = &processing
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Swiped(swiped bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.swiped = &swiped
	return r
}

// Flag to determine if the credit card was swiped/manually entered , This element is only used when PAYMENT SERVICE DIRECTIVE(PSD) Opera Control is active.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardPresent(cardPresent bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardPresent = &cardPresent
	return r
}

// Customer Initiated Transaction(CIT) Id for Credit Cards. This is only used when PAYMENT SERVICES DIRECTIVE (PSD2) Opera Control is active.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CitId(citId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.citId = &citId
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) UserDefinedCardType(userDefinedCardType string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardIdId(cardIdId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardIdId = &cardIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardIdIdContext(cardIdIdContext string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardIdIdContext = &cardIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CardIdType(cardIdType string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.cardIdType = &cardIdType
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CurrentAuthorizedAmountAmount(currentAuthorizedAmountAmount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.currentAuthorizedAmountAmount = &currentAuthorizedAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) BalanceAmount(balanceAmount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) BalanceCurrencyCode(balanceCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Code(code int32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) AmountAmount(amountAmount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) AmountCurrencyCode(amountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Percent(percent float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.percent = &percent
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) EmailFolio(emailFolio bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) UniqueIdId(uniqueIdId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) UniqueIdIdContext(uniqueIdIdContext string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) UniqueIdType(uniqueIdType string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CreateDateTime(createDateTime string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) CreatorId(creatorId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) EmailAddress(emailAddress string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) EmailFormat(emailFormat string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) LastModifierId(lastModifierId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) LastModifyDateTime(lastModifyDateTime string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) OrderSequence(orderSequence float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) PrimaryInd(primaryInd bool) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) PurgeDate(purgeDate string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) EmailType(emailType string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) TypeDescription(typeDescription string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ApprovalCode(approvalCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) OriginalAuthSequence(originalAuthSequence int32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) VendorTranId(vendorTranId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ApprovalAmountAmount(approvalAmountAmount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Applicable for chip and pin. The ID of the terminal where the chip and pin device is connected.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) TerminalId(terminalId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.terminalId = &terminalId
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) IncidentalAmountAmount(incidentalAmountAmount float32) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.incidentalAmountAmount = &incidentalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) IncidentalAmountCurrencyCode(incidentalAmountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.incidentalAmountCurrencyCode = &incidentalAmountCurrencyCode
	return r
}

// External system code.
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCCAuthorizationInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsRequest) Execute() (*CcAuthorizationInstructions, *http.Response, error) {
	return r.ApiService.GetCCAuthorizationInstructionsExecute(r)
}

/*
GetCCAuthorizationInstructions Get CC Authorization Instructions

You can use this API to get Credit Card Authorization Instructions by Reservation. <p><strong>OperationId:</strong>getCCAuthorizationInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCCAuthorizationInstructionsRequest
*/
func (a *CashieringAPIService) GetCCAuthorizationInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetCCAuthorizationInstructionsRequest {
	return CashieringAPIGetCCAuthorizationInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcAuthorizationInstructions
func (a *CashieringAPIService) GetCCAuthorizationInstructionsExecute(r CashieringAPIGetCCAuthorizationInstructionsRequest) (*CcAuthorizationInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcAuthorizationInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCCAuthorizationInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods/creditCard/authorizeInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.evaluateApprovalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evaluateApprovalAmount", r.evaluateApprovalAmount, "")
  }
	if r.sourceOfAuthorization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceOfAuthorization", r.sourceOfAuthorization, "")
  }
	if r.updateReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateReservation", r.updateReservation, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.paymentFolioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentFolioView", r.paymentFolioView, "")
  }
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
  }
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.storeToCreditCardWallet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storeToCreditCardWallet", r.storeToCreditCardWallet, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.cardPresent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardPresent", r.cardPresent, "")
  }
	if r.citId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citId", r.citId, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.cardIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdId", r.cardIdId, "")
  }
	if r.cardIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIdContext", r.cardIdIdContext, "")
  }
	if r.cardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdType", r.cardIdType, "")
  }
	if r.currentAuthorizedAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountAmount", r.currentAuthorizedAmountAmount, "")
  }
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
  }
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
  }
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
  }
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
  }
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
  }
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
  }
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
  }
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
  }
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
  }
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
  }
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
  }
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
  }
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
  }
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
  }
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
  }
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
  }
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
  }
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
  }
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
  }
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
  }
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
  }
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.terminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminalId", r.terminalId, "")
  }
	if r.incidentalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountAmount", r.incidentalAmountAmount, "")
  }
	if r.incidentalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountCurrencyCode", r.incidentalAmountCurrencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCCAuthorizationInstructionsByProfileRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	evaluateApprovalAmount *bool
	sourceOfAuthorization *string
	updateReservation *bool
	idContext *string
	type_ *string
	profileIdIdContext *string
	profileIdType *string
	amount *float32
	currencyCode *string
	folioView *int32
	description *string
	paymentFolioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	cardPresent *bool
	citId *string
	userDefinedCardType *string
	cardIdId *string
	cardIdIdContext *string
	cardIdType *string
	currentAuthorizedAmountAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *string
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *string
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	terminalId *string
	incidentalAmountAmount *float32
	incidentalAmountCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Authorization(authorization string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) XAppKey(xAppKey string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) XHotelid(xHotelid string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the approval amount should be calculated before authorization. If this is true and if the amount is 0 the approval amount will be calculated based on the rules.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) EvaluateApprovalAmount(evaluateApprovalAmount bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.evaluateApprovalAmount = &evaluateApprovalAmount
	return r
}

// Currently supported transaction type categories used for credit card authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) SourceOfAuthorization(sourceOfAuthorization string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.sourceOfAuthorization = &sourceOfAuthorization
	return r
}

// Update the card details on the reservations for Chip and Pin Authorizations.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) UpdateReservation(updateReservation bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.updateReservation = &updateReservation
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) IdContext(idContext string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Type_(type_ string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ProfileIdIdContext(profileIdIdContext string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ProfileIdType(profileIdType string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.profileIdType = &profileIdType
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Amount(amount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CurrencyCode(currencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.currencyCode = &currencyCode
	return r
}

// The folio window where this authorization is applied.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) FolioView(folioView int32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.folioView = &folioView
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Description(description string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.description = &description
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) PaymentFolioView(paymentFolioView int32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.paymentFolioView = &paymentFolioView
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) PaymentMethod(paymentMethod string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Track2Data(track2Data string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardHolderName(cardHolderName string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardNumber(cardNumber string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardNumberLast4Digits(cardNumberLast4Digits string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardNumberMasked(cardNumberMasked string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardOrToken(cardOrToken string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardType(cardType string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ExpirationDate(expirationDate string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ExpirationDateExpired(expirationDateExpired bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ExpirationDateMasked(expirationDateMasked string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Processing(processing string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.processing = &processing
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Swiped(swiped bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.swiped = &swiped
	return r
}

// Flag to determine if the credit card was swiped/manually entered , This element is only used when PAYMENT SERVICE DIRECTIVE(PSD) Opera Control is active.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardPresent(cardPresent bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardPresent = &cardPresent
	return r
}

// Customer Initiated Transaction(CIT) Id for Credit Cards. This is only used when PAYMENT SERVICES DIRECTIVE (PSD2) Opera Control is active.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CitId(citId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.citId = &citId
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) UserDefinedCardType(userDefinedCardType string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardIdId(cardIdId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardIdId = &cardIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardIdIdContext(cardIdIdContext string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardIdIdContext = &cardIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CardIdType(cardIdType string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.cardIdType = &cardIdType
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CurrentAuthorizedAmountAmount(currentAuthorizedAmountAmount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.currentAuthorizedAmountAmount = &currentAuthorizedAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) BalanceAmount(balanceAmount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) BalanceCurrencyCode(balanceCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Code(code int32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) AmountAmount(amountAmount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) AmountCurrencyCode(amountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Percent(percent float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.percent = &percent
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) EmailFolio(emailFolio bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) UniqueIdId(uniqueIdId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) UniqueIdIdContext(uniqueIdIdContext string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) UniqueIdType(uniqueIdType string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CreateDateTime(createDateTime string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) CreatorId(creatorId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) EmailAddress(emailAddress string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) EmailFormat(emailFormat string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) LastModifierId(lastModifierId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) LastModifyDateTime(lastModifyDateTime string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) OrderSequence(orderSequence float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) PrimaryInd(primaryInd bool) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) PurgeDate(purgeDate string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) EmailType(emailType string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) TypeDescription(typeDescription string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ApprovalCode(approvalCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) OriginalAuthSequence(originalAuthSequence int32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) VendorTranId(vendorTranId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountAmount(approvalAmountAmount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Applicable for chip and pin. The ID of the terminal where the chip and pin device is connected.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) TerminalId(terminalId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.terminalId = &terminalId
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) IncidentalAmountAmount(incidentalAmountAmount float32) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.incidentalAmountAmount = &incidentalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) IncidentalAmountCurrencyCode(incidentalAmountCurrencyCode string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.incidentalAmountCurrencyCode = &incidentalAmountCurrencyCode
	return r
}

// External system code.
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) Execute() (*CcAuthorizationInstructions, *http.Response, error) {
	return r.ApiService.GetCCAuthorizationInstructionsByProfileExecute(r)
}

/*
GetCCAuthorizationInstructionsByProfile Get CC Authorization Instructions by Profile

You can use this API to get Credit Card Authorization Instructions by Profile. <p><strong>OperationId:</strong>getCCAuthorizationInstructionsByProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCCAuthorizationInstructionsByProfileRequest
*/
func (a *CashieringAPIService) GetCCAuthorizationInstructionsByProfile(ctx context.Context, profileId string, hotelId string) CashieringAPIGetCCAuthorizationInstructionsByProfileRequest {
	return CashieringAPIGetCCAuthorizationInstructionsByProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcAuthorizationInstructions
func (a *CashieringAPIService) GetCCAuthorizationInstructionsByProfileExecute(r CashieringAPIGetCCAuthorizationInstructionsByProfileRequest) (*CcAuthorizationInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcAuthorizationInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCCAuthorizationInstructionsByProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/paymentMethods/creditCard/authorizeInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.evaluateApprovalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evaluateApprovalAmount", r.evaluateApprovalAmount, "")
  }
	if r.sourceOfAuthorization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceOfAuthorization", r.sourceOfAuthorization, "")
  }
	if r.updateReservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateReservation", r.updateReservation, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.paymentFolioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentFolioView", r.paymentFolioView, "")
  }
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
  }
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.cardPresent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardPresent", r.cardPresent, "")
  }
	if r.citId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citId", r.citId, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.cardIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdId", r.cardIdId, "")
  }
	if r.cardIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdIdContext", r.cardIdIdContext, "")
  }
	if r.cardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdType", r.cardIdType, "")
  }
	if r.currentAuthorizedAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountAmount", r.currentAuthorizedAmountAmount, "")
  }
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
  }
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
  }
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
  }
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
  }
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
  }
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
  }
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
  }
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
  }
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
  }
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
  }
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
  }
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
  }
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
  }
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
  }
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
  }
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
  }
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
  }
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
  }
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
  }
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
  }
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
  }
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.terminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminalId", r.terminalId, "")
  }
	if r.incidentalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountAmount", r.incidentalAmountAmount, "")
  }
	if r.incidentalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incidentalAmountCurrencyCode", r.incidentalAmountCurrencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCCSurchargeInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	description *string
	folioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	id *string
	idContext *string
	type_ *string
	amount *float32
	currencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *string
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *string
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	postingAmountAmount *float32
	postingAmountCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCCSurchargeInfoRequest) Authorization(authorization string) CashieringAPIGetCCSurchargeInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCCSurchargeInfoRequest) XAppKey(xAppKey string) CashieringAPIGetCCSurchargeInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCCSurchargeInfoRequest) XHotelid(xHotelid string) CashieringAPIGetCCSurchargeInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetCCSurchargeInfoRequest) CashierId(cashierId float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.cashierId = &cashierId
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) Description(description string) CashieringAPIGetCCSurchargeInfoRequest {
	r.description = &description
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) FolioView(folioView int32) CashieringAPIGetCCSurchargeInfoRequest {
	r.folioView = &folioView
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) PaymentMethod(paymentMethod string) CashieringAPIGetCCSurchargeInfoRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r CashieringAPIGetCCSurchargeInfoRequest) Track2Data(track2Data string) CashieringAPIGetCCSurchargeInfoRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r CashieringAPIGetCCSurchargeInfoRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) CashieringAPIGetCCSurchargeInfoRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) CardHolderName(cardHolderName string) CashieringAPIGetCCSurchargeInfoRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) CardNumber(cardNumber string) CashieringAPIGetCCSurchargeInfoRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) CardNumberLast4Digits(cardNumberLast4Digits string) CashieringAPIGetCCSurchargeInfoRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) CardNumberMasked(cardNumberMasked string) CashieringAPIGetCCSurchargeInfoRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r CashieringAPIGetCCSurchargeInfoRequest) CardOrToken(cardOrToken string) CashieringAPIGetCCSurchargeInfoRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r CashieringAPIGetCCSurchargeInfoRequest) CardType(cardType string) CashieringAPIGetCCSurchargeInfoRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r CashieringAPIGetCCSurchargeInfoRequest) ExpirationDate(expirationDate string) CashieringAPIGetCCSurchargeInfoRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) ExpirationDateExpired(expirationDateExpired bool) CashieringAPIGetCCSurchargeInfoRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r CashieringAPIGetCCSurchargeInfoRequest) ExpirationDateMasked(expirationDateMasked string) CashieringAPIGetCCSurchargeInfoRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) Processing(processing string) CashieringAPIGetCCSurchargeInfoRequest {
	r.processing = &processing
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) Swiped(swiped bool) CashieringAPIGetCCSurchargeInfoRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r CashieringAPIGetCCSurchargeInfoRequest) UserDefinedCardType(userDefinedCardType string) CashieringAPIGetCCSurchargeInfoRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCCSurchargeInfoRequest) Id(id string) CashieringAPIGetCCSurchargeInfoRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCSurchargeInfoRequest) IdContext(idContext string) CashieringAPIGetCCSurchargeInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCSurchargeInfoRequest) Type_(type_ string) CashieringAPIGetCCSurchargeInfoRequest {
	r.type_ = &type_
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCSurchargeInfoRequest) Amount(amount float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCSurchargeInfoRequest) CurrencyCode(currencyCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCSurchargeInfoRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCSurchargeInfoRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCSurchargeInfoRequest) BalanceAmount(balanceAmount float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCSurchargeInfoRequest) BalanceCurrencyCode(balanceCurrencyCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r CashieringAPIGetCCSurchargeInfoRequest) Code(code int32) CashieringAPIGetCCSurchargeInfoRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCSurchargeInfoRequest) AmountAmount(amountAmount float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCSurchargeInfoRequest) AmountCurrencyCode(amountCurrencyCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r CashieringAPIGetCCSurchargeInfoRequest) Percent(percent float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.percent = &percent
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) EmailFolio(emailFolio bool) CashieringAPIGetCCSurchargeInfoRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCCSurchargeInfoRequest) UniqueIdId(uniqueIdId string) CashieringAPIGetCCSurchargeInfoRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCCSurchargeInfoRequest) UniqueIdIdContext(uniqueIdIdContext string) CashieringAPIGetCCSurchargeInfoRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCCSurchargeInfoRequest) UniqueIdType(uniqueIdType string) CashieringAPIGetCCSurchargeInfoRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r CashieringAPIGetCCSurchargeInfoRequest) CreateDateTime(createDateTime string) CashieringAPIGetCCSurchargeInfoRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r CashieringAPIGetCCSurchargeInfoRequest) CreatorId(creatorId string) CashieringAPIGetCCSurchargeInfoRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r CashieringAPIGetCCSurchargeInfoRequest) EmailAddress(emailAddress string) CashieringAPIGetCCSurchargeInfoRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r CashieringAPIGetCCSurchargeInfoRequest) EmailFormat(emailFormat string) CashieringAPIGetCCSurchargeInfoRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r CashieringAPIGetCCSurchargeInfoRequest) LastModifierId(lastModifierId string) CashieringAPIGetCCSurchargeInfoRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r CashieringAPIGetCCSurchargeInfoRequest) LastModifyDateTime(lastModifyDateTime string) CashieringAPIGetCCSurchargeInfoRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r CashieringAPIGetCCSurchargeInfoRequest) OrderSequence(orderSequence float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r CashieringAPIGetCCSurchargeInfoRequest) PrimaryInd(primaryInd bool) CashieringAPIGetCCSurchargeInfoRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r CashieringAPIGetCCSurchargeInfoRequest) PurgeDate(purgeDate string) CashieringAPIGetCCSurchargeInfoRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r CashieringAPIGetCCSurchargeInfoRequest) EmailType(emailType string) CashieringAPIGetCCSurchargeInfoRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r CashieringAPIGetCCSurchargeInfoRequest) TypeDescription(typeDescription string) CashieringAPIGetCCSurchargeInfoRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r CashieringAPIGetCCSurchargeInfoRequest) ApprovalCode(approvalCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r CashieringAPIGetCCSurchargeInfoRequest) OriginalAuthSequence(originalAuthSequence int32) CashieringAPIGetCCSurchargeInfoRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r CashieringAPIGetCCSurchargeInfoRequest) VendorTranId(vendorTranId string) CashieringAPIGetCCSurchargeInfoRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCSurchargeInfoRequest) ApprovalAmountAmount(approvalAmountAmount float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCSurchargeInfoRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetCCSurchargeInfoRequest) PostingAmountAmount(postingAmountAmount float32) CashieringAPIGetCCSurchargeInfoRequest {
	r.postingAmountAmount = &postingAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetCCSurchargeInfoRequest) PostingAmountCurrencyCode(postingAmountCurrencyCode string) CashieringAPIGetCCSurchargeInfoRequest {
	r.postingAmountCurrencyCode = &postingAmountCurrencyCode
	return r
}

// External system code.
func (r CashieringAPIGetCCSurchargeInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCCSurchargeInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCCSurchargeInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCCSurchargeInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCCSurchargeInfoRequest) Execute() (*CcSurchargeDetails, *http.Response, error) {
	return r.ApiService.GetCCSurchargeInfoExecute(r)
}

/*
GetCCSurchargeInfo Get CC Surcharge Information

You can use this API to get CC Surcharge Information. <p><strong>OperationId:</strong>getCCSurchargeInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCCSurchargeInfoRequest
*/
func (a *CashieringAPIService) GetCCSurchargeInfo(ctx context.Context, hotelId string) CashieringAPIGetCCSurchargeInfoRequest {
	return CashieringAPIGetCCSurchargeInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CcSurchargeDetails
func (a *CashieringAPIService) GetCCSurchargeInfoExecute(r CashieringAPIGetCCSurchargeInfoRequest) (*CcSurchargeDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CcSurchargeDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCCSurchargeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardsurcharge"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
  }
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
  }
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
  }
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
  }
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
  }
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
  }
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
  }
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
  }
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
  }
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
  }
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
  }
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
  }
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
  }
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
  }
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
  }
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
  }
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
  }
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
  }
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
  }
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
  }
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
  }
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.postingAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountAmount", r.postingAmountAmount, "")
  }
	if r.postingAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountCurrencyCode", r.postingAmountCurrencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCashierClosureRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierLockHandle *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCashierClosureRequest) Authorization(authorization string) CashieringAPIGetCashierClosureRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCashierClosureRequest) XAppKey(xAppKey string) CashieringAPIGetCashierClosureRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCashierClosureRequest) XHotelid(xHotelid string) CashieringAPIGetCashierClosureRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Lock Handle to pass along with operation which required cashier to be locked.
func (r CashieringAPIGetCashierClosureRequest) CashierLockHandle(cashierLockHandle float32) CashieringAPIGetCashierClosureRequest {
	r.cashierLockHandle = &cashierLockHandle
	return r
}

// External system code.
func (r CashieringAPIGetCashierClosureRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCashierClosureRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCashierClosureRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCashierClosureRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCashierClosureRequest) Execute() (*CashierClosureDetails, *http.Response, error) {
	return r.ApiService.GetCashierClosureExecute(r)
}

/*
GetCashierClosure Get Cashier Closure

You can use this API to get Cashier Closure. <p><strong>OperationId:</strong>getCashierClosure</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCashierClosureRequest
*/
func (a *CashieringAPIService) GetCashierClosure(ctx context.Context, cashierId string, hotelId string) CashieringAPIGetCashierClosureRequest {
	return CashieringAPIGetCashierClosureRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierClosureDetails
func (a *CashieringAPIService) GetCashierClosureExecute(r CashieringAPIGetCashierClosureRequest) (*CashierClosureDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierClosureDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCashierClosure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashiers/{cashierId}/closure"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cashierLockHandle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierLockHandle", r.cashierLockHandle, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCashierClosureInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closureNo *float32
	cashierId *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	closureBusinessDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCashierClosureInfoRequest) Authorization(authorization string) CashieringAPIGetCashierClosureInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCashierClosureInfoRequest) XAppKey(xAppKey string) CashieringAPIGetCashierClosureInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCashierClosureInfoRequest) XHotelid(xHotelid string) CashieringAPIGetCashierClosureInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Shift Number.
func (r CashieringAPIGetCashierClosureInfoRequest) ClosureNo(closureNo float32) CashieringAPIGetCashierClosureInfoRequest {
	r.closureNo = &closureNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetCashierClosureInfoRequest) CashierId(cashierId float32) CashieringAPIGetCashierClosureInfoRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier closure shift drop location code.
func (r CashieringAPIGetCashierClosureInfoRequest) ShiftDropLocationCode(shiftDropLocationCode string) CashieringAPIGetCashierClosureInfoRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r CashieringAPIGetCashierClosureInfoRequest) BagNumberForOthers(bagNumberForOthers string) CashieringAPIGetCashierClosureInfoRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r CashieringAPIGetCashierClosureInfoRequest) BagNumberForCash(bagNumberForCash string) CashieringAPIGetCashierClosureInfoRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// Business Date of cashier closure.
func (r CashieringAPIGetCashierClosureInfoRequest) ClosureBusinessDate(closureBusinessDate string) CashieringAPIGetCashierClosureInfoRequest {
	r.closureBusinessDate = &closureBusinessDate
	return r
}

// External system code.
func (r CashieringAPIGetCashierClosureInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCashierClosureInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCashierClosureInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCashierClosureInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCashierClosureInfoRequest) Execute() (*CashierClosureInformation, *http.Response, error) {
	return r.ApiService.GetCashierClosureInfoExecute(r)
}

/*
GetCashierClosureInfo Get Cashier Closure Information

You can use this API to get Cashier Closure Information. <p><strong>OperationId:</strong>getCashierClosureInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCashierClosureInfoRequest
*/
func (a *CashieringAPIService) GetCashierClosureInfo(ctx context.Context, hotelId string) CashieringAPIGetCashierClosureInfoRequest {
	return CashieringAPIGetCashierClosureInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierClosureInformation
func (a *CashieringAPIService) GetCashierClosureInfoExecute(r CashieringAPIGetCashierClosureInfoRequest) (*CashierClosureInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierClosureInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCashierClosureInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/closureList"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
  }
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
  }
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
  }
	if r.closureBusinessDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureBusinessDate", r.closureBusinessDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCashierClosureReportsListRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closureNo *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCashierClosureReportsListRequest) Authorization(authorization string) CashieringAPIGetCashierClosureReportsListRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCashierClosureReportsListRequest) XAppKey(xAppKey string) CashieringAPIGetCashierClosureReportsListRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCashierClosureReportsListRequest) XHotelid(xHotelid string) CashieringAPIGetCashierClosureReportsListRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Shift Number.
func (r CashieringAPIGetCashierClosureReportsListRequest) ClosureNo(closureNo float32) CashieringAPIGetCashierClosureReportsListRequest {
	r.closureNo = &closureNo
	return r
}

// Cashier closure shift drop location code.
func (r CashieringAPIGetCashierClosureReportsListRequest) ShiftDropLocationCode(shiftDropLocationCode string) CashieringAPIGetCashierClosureReportsListRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r CashieringAPIGetCashierClosureReportsListRequest) BagNumberForOthers(bagNumberForOthers string) CashieringAPIGetCashierClosureReportsListRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r CashieringAPIGetCashierClosureReportsListRequest) BagNumberForCash(bagNumberForCash string) CashieringAPIGetCashierClosureReportsListRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// External system code.
func (r CashieringAPIGetCashierClosureReportsListRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCashierClosureReportsListRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCashierClosureReportsListRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCashierClosureReportsListRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCashierClosureReportsListRequest) Execute() (*CashierClosureReportsList, *http.Response, error) {
	return r.ApiService.GetCashierClosureReportsListExecute(r)
}

/*
GetCashierClosureReportsList Get Cashier Closure Reports List

You can use this API to get Cashier Closure Reports List. <p><strong>OperationId:</strong>getCashierClosureReportsList</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCashierClosureReportsListRequest
*/
func (a *CashieringAPIService) GetCashierClosureReportsList(ctx context.Context, cashierId string, hotelId string) CashieringAPIGetCashierClosureReportsListRequest {
	return CashieringAPIGetCashierClosureReportsListRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CashierClosureReportsList
func (a *CashieringAPIService) GetCashierClosureReportsListExecute(r CashieringAPIGetCashierClosureReportsListRequest) (*CashierClosureReportsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierClosureReportsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCashierClosureReportsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashiers/{cashierId}/closureReports"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
  }
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
  }
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
  }
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCashierLockRequest) Authorization(authorization string) CashieringAPIGetCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCashierLockRequest) XAppKey(xAppKey string) CashieringAPIGetCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCashierLockRequest) XHotelid(xHotelid string) CashieringAPIGetCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIGetCashierLockRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCashierLockRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCashierLockRequest) Execute() (*AcquiredCashierLock, *http.Response, error) {
	return r.ApiService.GetCashierLockExecute(r)
}

/*
GetCashierLock Acquire Cashier Locks

You can use this API to Acquire Cashier Locks. <p><strong>OperationId:</strong>getCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return CashieringAPIGetCashierLockRequest
*/
func (a *CashieringAPIService) GetCashierLock(ctx context.Context, cashierId string) CashieringAPIGetCashierLockRequest {
	return CashieringAPIGetCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return AcquiredCashierLock
func (a *CashieringAPIService) GetCashierLockExecute(r CashieringAPIGetCashierLockRequest) (*AcquiredCashierLock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AcquiredCashierLock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/locks"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCashierReportPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	startDate *string
	endDate *string
	duration *string
	requestType *string
	closureNo *float32
	cashierId *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCashierReportPostingsRequest) Authorization(authorization string) CashieringAPIGetCashierReportPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCashierReportPostingsRequest) XAppKey(xAppKey string) CashieringAPIGetCashierReportPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCashierReportPostingsRequest) XHotelid(xHotelid string) CashieringAPIGetCashierReportPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringAPIGetCashierReportPostingsRequest) HotelId(hotelId []string) CashieringAPIGetCashierReportPostingsRequest {
	r.hotelId = &hotelId
	return r
}

func (r CashieringAPIGetCashierReportPostingsRequest) StartDate(startDate string) CashieringAPIGetCashierReportPostingsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetCashierReportPostingsRequest) EndDate(endDate string) CashieringAPIGetCashierReportPostingsRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringAPIGetCashierReportPostingsRequest) Duration(duration string) CashieringAPIGetCashierReportPostingsRequest {
	r.duration = &duration
	return r
}

// Shift drop report created when cashier closure is completed. It is an integral part of closure report and is not to be printed or accessed by itself.
func (r CashieringAPIGetCashierReportPostingsRequest) RequestType(requestType string) CashieringAPIGetCashierReportPostingsRequest {
	r.requestType = &requestType
	return r
}

// The Cashier Shift Number.
func (r CashieringAPIGetCashierReportPostingsRequest) ClosureNo(closureNo float32) CashieringAPIGetCashierReportPostingsRequest {
	r.closureNo = &closureNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetCashierReportPostingsRequest) CashierId(cashierId float32) CashieringAPIGetCashierReportPostingsRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier closure shift drop location code.
func (r CashieringAPIGetCashierReportPostingsRequest) ShiftDropLocationCode(shiftDropLocationCode string) CashieringAPIGetCashierReportPostingsRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r CashieringAPIGetCashierReportPostingsRequest) BagNumberForOthers(bagNumberForOthers string) CashieringAPIGetCashierReportPostingsRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r CashieringAPIGetCashierReportPostingsRequest) BagNumberForCash(bagNumberForCash string) CashieringAPIGetCashierReportPostingsRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// External system code.
func (r CashieringAPIGetCashierReportPostingsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCashierReportPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCashierReportPostingsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCashierReportPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCashierReportPostingsRequest) Execute() (*CashierReportPostingsInfo, *http.Response, error) {
	return r.ApiService.GetCashierReportPostingsExecute(r)
}

/*
GetCashierReportPostings Get Cashier Report Postings

You can use this API to get Cashier Report postings. <p><strong>OperationId:</strong>getCashierReportPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPIGetCashierReportPostingsRequest
*/
func (a *CashieringAPIService) GetCashierReportPostings(ctx context.Context) CashieringAPIGetCashierReportPostingsRequest {
	return CashieringAPIGetCashierReportPostingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CashierReportPostingsInfo
func (a *CashieringAPIService) GetCashierReportPostingsExecute(r CashieringAPIGetCashierReportPostingsRequest) (*CashierReportPostingsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierReportPostingsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCashierReportPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashierReportPostings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.requestType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestType", r.requestType, "")
  }
	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
  }
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
  }
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCashierTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	closureNo *float32
	shiftDropLocationCode *string
	bagNumberForOthers *string
	bagNumberForCash *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCashierTransactionsRequest) Authorization(authorization string) CashieringAPIGetCashierTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCashierTransactionsRequest) XAppKey(xAppKey string) CashieringAPIGetCashierTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCashierTransactionsRequest) XHotelid(xHotelid string) CashieringAPIGetCashierTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier Shift Number.
func (r CashieringAPIGetCashierTransactionsRequest) ClosureNo(closureNo float32) CashieringAPIGetCashierTransactionsRequest {
	r.closureNo = &closureNo
	return r
}

// Cashier closure shift drop location code.
func (r CashieringAPIGetCashierTransactionsRequest) ShiftDropLocationCode(shiftDropLocationCode string) CashieringAPIGetCashierTransactionsRequest {
	r.shiftDropLocationCode = &shiftDropLocationCode
	return r
}

// Cashier closure shift drop others payment method type bag number.
func (r CashieringAPIGetCashierTransactionsRequest) BagNumberForOthers(bagNumberForOthers string) CashieringAPIGetCashierTransactionsRequest {
	r.bagNumberForOthers = &bagNumberForOthers
	return r
}

// Cashier closure shift drop cash payment method type bag number.
func (r CashieringAPIGetCashierTransactionsRequest) BagNumberForCash(bagNumberForCash string) CashieringAPIGetCashierTransactionsRequest {
	r.bagNumberForCash = &bagNumberForCash
	return r
}

// External system code.
func (r CashieringAPIGetCashierTransactionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCashierTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCashierTransactionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCashierTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCashierTransactionsRequest) Execute() (*CashierTransactionsDetails, *http.Response, error) {
	return r.ApiService.GetCashierTransactionsExecute(r)
}

/*
GetCashierTransactions Get Cashier Transactions

You can use this API to get Cashier Transactions. <p><strong>OperationId:</strong>getCashierTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return CashieringAPIGetCashierTransactionsRequest
*/
func (a *CashieringAPIService) GetCashierTransactions(ctx context.Context, cashierId string) CashieringAPIGetCashierTransactionsRequest {
	return CashieringAPIGetCashierTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return CashierTransactionsDetails
func (a *CashieringAPIService) GetCashierTransactionsExecute(r CashieringAPIGetCashierTransactionsRequest) (*CashierTransactionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CashierTransactionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCashierTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}

	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
  }
	if r.shiftDropLocationCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shiftDropLocationCode", r.shiftDropLocationCode, "")
  }
	if r.bagNumberForOthers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForOthers", r.bagNumberForOthers, "")
  }
	if r.bagNumberForCash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bagNumberForCash", r.bagNumberForCash, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCheckDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	checkNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCheckDetailsRequest) Authorization(authorization string) CashieringAPIGetCheckDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCheckDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetCheckDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCheckDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetCheckDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIGetCheckDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCheckDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCheckDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCheckDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCheckDetailsRequest) Execute() (*CheckDetails, *http.Response, error) {
	return r.ApiService.GetCheckDetailsExecute(r)
}

/*
GetCheckDetails Get check details

You can use this API to get check details. <p><strong>OperationId:</strong>getCheckDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCheckDetailsRequest
*/
func (a *CashieringAPIService) GetCheckDetails(ctx context.Context, checkNumber string, hotelId string) CashieringAPIGetCheckDetailsRequest {
	return CashieringAPIGetCheckDetailsRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CheckDetails
func (a *CashieringAPIService) GetCheckDetailsExecute(r CashieringAPIGetCheckDetailsRequest) (*CheckDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCheckDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/check/{checkNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCompAccountingJournalRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	startDate *string
	endDate *string
	duration *string
	filterTransactionCode *[]string
	hotelId *[]string
	filterRoomNumber *[]string
	id *[]string
	idContext *[]string
	type_ *[]string
	approvalCode *string
	code *[]string
	authorizerNameCode *[]string
	referenceNumberWildCard *string
	supplementWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCompAccountingJournalRequest) Authorization(authorization string) CashieringAPIGetCompAccountingJournalRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCompAccountingJournalRequest) XAppKey(xAppKey string) CashieringAPIGetCompAccountingJournalRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCompAccountingJournalRequest) XHotelid(xHotelid string) CashieringAPIGetCompAccountingJournalRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringAPIGetCompAccountingJournalRequest) Limit(limit int32) CashieringAPIGetCompAccountingJournalRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringAPIGetCompAccountingJournalRequest) Offset(offset int32) CashieringAPIGetCompAccountingJournalRequest {
	r.offset = &offset
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) StartDate(startDate string) CashieringAPIGetCompAccountingJournalRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) EndDate(endDate string) CashieringAPIGetCompAccountingJournalRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) Duration(duration string) CashieringAPIGetCompAccountingJournalRequest {
	r.duration = &duration
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) FilterTransactionCode(filterTransactionCode []string) CashieringAPIGetCompAccountingJournalRequest {
	r.filterTransactionCode = &filterTransactionCode
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) HotelId(hotelId []string) CashieringAPIGetCompAccountingJournalRequest {
	r.hotelId = &hotelId
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) FilterRoomNumber(filterRoomNumber []string) CashieringAPIGetCompAccountingJournalRequest {
	r.filterRoomNumber = &filterRoomNumber
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCompAccountingJournalRequest) Id(id []string) CashieringAPIGetCompAccountingJournalRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCompAccountingJournalRequest) IdContext(idContext []string) CashieringAPIGetCompAccountingJournalRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCompAccountingJournalRequest) Type_(type_ []string) CashieringAPIGetCompAccountingJournalRequest {
	r.type_ = &type_
	return r
}

// Filters the results for approval code.
func (r CashieringAPIGetCompAccountingJournalRequest) ApprovalCode(approvalCode string) CashieringAPIGetCompAccountingJournalRequest {
	r.approvalCode = &approvalCode
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) Code(code []string) CashieringAPIGetCompAccountingJournalRequest {
	r.code = &code
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) AuthorizerNameCode(authorizerNameCode []string) CashieringAPIGetCompAccountingJournalRequest {
	r.authorizerNameCode = &authorizerNameCode
	return r
}

// Filters the results for reference number.
func (r CashieringAPIGetCompAccountingJournalRequest) ReferenceNumberWildCard(referenceNumberWildCard string) CashieringAPIGetCompAccountingJournalRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for supplement.
func (r CashieringAPIGetCompAccountingJournalRequest) SupplementWildCard(supplementWildCard string) CashieringAPIGetCompAccountingJournalRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// External system code.
func (r CashieringAPIGetCompAccountingJournalRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCompAccountingJournalRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCompAccountingJournalRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCompAccountingJournalRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCompAccountingJournalRequest) Execute() (*CompAccountingJournal, *http.Response, error) {
	return r.ApiService.GetCompAccountingJournalExecute(r)
}

/*
GetCompAccountingJournal Get Comp Accounting Journal

You can use this API to get Comp Accounting Journal. <br><p><strong><mark>This API is deprecated. Please use getCompPostingJournal instead</mark></strong></p> <p><strong>OperationId:</strong>getCompAccountingJournal</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPIGetCompAccountingJournalRequest

Deprecated
*/
func (a *CashieringAPIService) GetCompAccountingJournal(ctx context.Context) CashieringAPIGetCompAccountingJournalRequest {
	return CashieringAPIGetCompAccountingJournalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompAccountingJournal
// Deprecated
func (a *CashieringAPIService) GetCompAccountingJournalExecute(r CashieringAPIGetCompAccountingJournalRequest) (*CompAccountingJournal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompAccountingJournal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCompAccountingJournal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compAccountingJournal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.filterTransactionCode != nil {
		t := *r.filterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", t, "multi")
		}
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.filterRoomNumber != nil {
		t := *r.filterRoomNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", t, "multi")
		}
  }
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.authorizerNameCode != nil {
		t := *r.authorizerNameCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerNameCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerNameCode", t, "multi")
		}
  }
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
  }
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCompPostingJournalRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	startDate *string
	endDate *string
	duration *string
	filterTransactionCode *[]string
	filterRoomNumber *[]string
	id *[]string
	idContext *[]string
	type_ *[]string
	approvalCode *string
	code *[]string
	authorizerNameCode *[]string
	referenceNumberWildCard *string
	supplementWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCompPostingJournalRequest) Authorization(authorization string) CashieringAPIGetCompPostingJournalRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCompPostingJournalRequest) XAppKey(xAppKey string) CashieringAPIGetCompPostingJournalRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCompPostingJournalRequest) XHotelid(xHotelid string) CashieringAPIGetCompPostingJournalRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringAPIGetCompPostingJournalRequest) Limit(limit int32) CashieringAPIGetCompPostingJournalRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringAPIGetCompPostingJournalRequest) Offset(offset int32) CashieringAPIGetCompPostingJournalRequest {
	r.offset = &offset
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) StartDate(startDate string) CashieringAPIGetCompPostingJournalRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) EndDate(endDate string) CashieringAPIGetCompPostingJournalRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) Duration(duration string) CashieringAPIGetCompPostingJournalRequest {
	r.duration = &duration
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) FilterTransactionCode(filterTransactionCode []string) CashieringAPIGetCompPostingJournalRequest {
	r.filterTransactionCode = &filterTransactionCode
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) FilterRoomNumber(filterRoomNumber []string) CashieringAPIGetCompPostingJournalRequest {
	r.filterRoomNumber = &filterRoomNumber
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCompPostingJournalRequest) Id(id []string) CashieringAPIGetCompPostingJournalRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCompPostingJournalRequest) IdContext(idContext []string) CashieringAPIGetCompPostingJournalRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCompPostingJournalRequest) Type_(type_ []string) CashieringAPIGetCompPostingJournalRequest {
	r.type_ = &type_
	return r
}

// Filters the results for approval code.
func (r CashieringAPIGetCompPostingJournalRequest) ApprovalCode(approvalCode string) CashieringAPIGetCompPostingJournalRequest {
	r.approvalCode = &approvalCode
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) Code(code []string) CashieringAPIGetCompPostingJournalRequest {
	r.code = &code
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) AuthorizerNameCode(authorizerNameCode []string) CashieringAPIGetCompPostingJournalRequest {
	r.authorizerNameCode = &authorizerNameCode
	return r
}

// Filters the results for reference number.
func (r CashieringAPIGetCompPostingJournalRequest) ReferenceNumberWildCard(referenceNumberWildCard string) CashieringAPIGetCompPostingJournalRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for supplement.
func (r CashieringAPIGetCompPostingJournalRequest) SupplementWildCard(supplementWildCard string) CashieringAPIGetCompPostingJournalRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// External system code.
func (r CashieringAPIGetCompPostingJournalRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCompPostingJournalRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCompPostingJournalRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCompPostingJournalRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCompPostingJournalRequest) Execute() (*CompAccountingJournal, *http.Response, error) {
	return r.ApiService.GetCompPostingJournalExecute(r)
}

/*
GetCompPostingJournal Get Comp Accounting Journal

You can use this API to get Comp Accounting Journal. <p><strong>OperationId:</strong>getCompPostingJournal</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCompPostingJournalRequest
*/
func (a *CashieringAPIService) GetCompPostingJournal(ctx context.Context, hotelId string) CashieringAPIGetCompPostingJournalRequest {
	return CashieringAPIGetCompPostingJournalRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompAccountingJournal
func (a *CashieringAPIService) GetCompPostingJournalExecute(r CashieringAPIGetCompPostingJournalRequest) (*CompAccountingJournal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompAccountingJournal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCompPostingJournal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compAccountingJournal"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.filterTransactionCode != nil {
		t := *r.filterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", t, "multi")
		}
  }
	if r.filterRoomNumber != nil {
		t := *r.filterRoomNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", t, "multi")
		}
  }
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.authorizerNameCode != nil {
		t := *r.authorizerNameCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerNameCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerNameCode", t, "multi")
		}
  }
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
  }
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCompRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	end *string
	start *string
	nameWildcard *string
	firstNameWildCard *string
	roomNumberCodes *[]string
	id *[]string
	idContext *[]string
	type_ *[]string
	membershipId *string
	code *[]string
	resStatusCode *[]string
	compRoutingStatuses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCompRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCompRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCompRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r CashieringAPIGetCompRoutingInstructionsRequest) End(end string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r CashieringAPIGetCompRoutingInstructionsRequest) Start(start string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.start = &start
	return r
}

// Family name or last name of the guest
func (r CashieringAPIGetCompRoutingInstructionsRequest) NameWildcard(nameWildcard string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.nameWildcard = &nameWildcard
	return r
}

// Given name or first name of the guest.
func (r CashieringAPIGetCompRoutingInstructionsRequest) FirstNameWildCard(firstNameWildCard string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.firstNameWildCard = &firstNameWildCard
	return r
}

func (r CashieringAPIGetCompRoutingInstructionsRequest) RoomNumberCodes(roomNumberCodes []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.roomNumberCodes = &roomNumberCodes
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCompRoutingInstructionsRequest) Id(id []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCompRoutingInstructionsRequest) IdContext(idContext []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCompRoutingInstructionsRequest) Type_(type_ []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.type_ = &type_
	return r
}

// Membership Card number.
func (r CashieringAPIGetCompRoutingInstructionsRequest) MembershipId(membershipId string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.membershipId = &membershipId
	return r
}

func (r CashieringAPIGetCompRoutingInstructionsRequest) Code(code []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.code = &code
	return r
}

// This reservation is in checked in status and the business date is past departure date. This could occur when ORS and PMS are in same environment.
func (r CashieringAPIGetCompRoutingInstructionsRequest) ResStatusCode(resStatusCode []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.resStatusCode = &resStatusCode
	return r
}

// Status which indicates that the Request of Comp Routing was declined
func (r CashieringAPIGetCompRoutingInstructionsRequest) CompRoutingStatuses(compRoutingStatuses []string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.compRoutingStatuses = &compRoutingStatuses
	return r
}

// External system code.
func (r CashieringAPIGetCompRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCompRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCompRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCompRoutingInstructionsRequest) Execute() (*CompRoutingInstructions, *http.Response, error) {
	return r.ApiService.GetCompRoutingInstructionsExecute(r)
}

/*
GetCompRoutingInstructions Get Comp Routing Instructions

You can use this API to get Comp Routing Instructions. <p><strong>OperationId:</strong>getCompRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCompRoutingInstructionsRequest
*/
func (a *CashieringAPIService) GetCompRoutingInstructions(ctx context.Context, hotelId string) CashieringAPIGetCompRoutingInstructionsRequest {
	return CashieringAPIGetCompRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompRoutingInstructions
func (a *CashieringAPIService) GetCompRoutingInstructionsExecute(r CashieringAPIGetCompRoutingInstructionsRequest) (*CompRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCompRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compRoutingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
  }
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
  }
	if r.nameWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameWildcard", r.nameWildcard, "")
  }
	if r.firstNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstNameWildCard", r.firstNameWildCard, "")
  }
	if r.roomNumberCodes != nil {
		t := *r.roomNumberCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberCodes", t, "multi")
		}
  }
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.resStatusCode != nil {
		t := *r.resStatusCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "resStatusCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "resStatusCode", t, "multi")
		}
  }
	if r.compRoutingStatuses != nil {
		t := *r.compRoutingStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compRoutingStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compRoutingStatuses", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCompTrxAuthorizersRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	id *[]string
	idContext *[]string
	type_ *[]string
	targetFolioWindowNo *int32
	uniqueIdId *[]string
	uniqueIdIdContext *[]string
	uniqueIdType *[]string
	transaction *[]float32
	authorizerIdId *string
	authorizerIdIdContext *string
	authorizerIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCompTrxAuthorizersRequest) Authorization(authorization string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCompTrxAuthorizersRequest) XAppKey(xAppKey string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCompTrxAuthorizersRequest) XHotelid(xHotelid string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetCompTrxAuthorizersRequest) CashierId(cashierId float32) CashieringAPIGetCompTrxAuthorizersRequest {
	r.cashierId = &cashierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCompTrxAuthorizersRequest) Id(id []string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCompTrxAuthorizersRequest) IdContext(idContext []string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCompTrxAuthorizersRequest) Type_(type_ []string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.type_ = &type_
	return r
}

// Folio Window Number to where transactions will be transfered.
func (r CashieringAPIGetCompTrxAuthorizersRequest) TargetFolioWindowNo(targetFolioWindowNo int32) CashieringAPIGetCompTrxAuthorizersRequest {
	r.targetFolioWindowNo = &targetFolioWindowNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCompTrxAuthorizersRequest) UniqueIdId(uniqueIdId []string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCompTrxAuthorizersRequest) UniqueIdIdContext(uniqueIdIdContext []string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCompTrxAuthorizersRequest) UniqueIdType(uniqueIdType []string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// List of transactions to be transfered.
func (r CashieringAPIGetCompTrxAuthorizersRequest) Transaction(transaction []float32) CashieringAPIGetCompTrxAuthorizersRequest {
	r.transaction = &transaction
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetCompTrxAuthorizersRequest) AuthorizerIdId(authorizerIdId string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.authorizerIdId = &authorizerIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetCompTrxAuthorizersRequest) AuthorizerIdIdContext(authorizerIdIdContext string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.authorizerIdIdContext = &authorizerIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetCompTrxAuthorizersRequest) AuthorizerIdType(authorizerIdType string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.authorizerIdType = &authorizerIdType
	return r
}

// External system code.
func (r CashieringAPIGetCompTrxAuthorizersRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCompTrxAuthorizersRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCompTrxAuthorizersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCompTrxAuthorizersRequest) Execute() (*CompTrxAuthorizers, *http.Response, error) {
	return r.ApiService.GetCompTrxAuthorizersExecute(r)
}

/*
GetCompTrxAuthorizers Get Comp Trx Authorizers

You can use this API to get Comp Trx Authorizers. <p><strong>OperationId:</strong>getCompTrxAuthorizers</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCompTrxAuthorizersRequest
*/
func (a *CashieringAPIService) GetCompTrxAuthorizers(ctx context.Context, hotelId string) CashieringAPIGetCompTrxAuthorizersRequest {
	return CashieringAPIGetCompTrxAuthorizersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompTrxAuthorizers
func (a *CashieringAPIService) GetCompTrxAuthorizersExecute(r CashieringAPIGetCompTrxAuthorizersRequest) (*CompTrxAuthorizers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompTrxAuthorizers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCompTrxAuthorizers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/compTrxAuthorizers"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.targetFolioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetFolioWindowNo", r.targetFolioWindowNo, "")
  }
	if r.uniqueIdId != nil {
		t := *r.uniqueIdId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", t, "multi")
		}
  }
	if r.uniqueIdIdContext != nil {
		t := *r.uniqueIdIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", t, "multi")
		}
  }
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
  }
	if r.transaction != nil {
		t := *r.transaction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transaction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transaction", t, "multi")
		}
  }
	if r.authorizerIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerIdId", r.authorizerIdId, "")
  }
	if r.authorizerIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerIdIdContext", r.authorizerIdIdContext, "")
  }
	if r.authorizerIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizerIdType", r.authorizerIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetCreditLimitOveragePaymentsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestNameWildCard *string
	roomNumberWildCard *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) Authorization(authorization string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) XAppKey(xAppKey string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) XHotelid(xHotelid string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Guest name associated with the transaction.
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) GuestNameWildCard(guestNameWildCard string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.guestNameWildCard = &guestNameWildCard
	return r
}

// Room number associated with the transaction.
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) RoomNumberWildCard(roomNumberWildCard string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.roomNumberWildCard = &roomNumberWildCard
	return r
}

func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) Code(code []string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.code = &code
	return r
}

// External system code.
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetCreditLimitOveragePaymentsRequest) Execute() (*CreditLimitOveragePaymentsInfo, *http.Response, error) {
	return r.ApiService.GetCreditLimitOveragePaymentsExecute(r)
}

/*
GetCreditLimitOveragePayments Get Credit Limits Overage Payments

You can use this API to get Credit Limits Overage Payments. <p><strong>OperationId:</strong>getCreditLimitOveragePayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetCreditLimitOveragePaymentsRequest
*/
func (a *CashieringAPIService) GetCreditLimitOveragePayments(ctx context.Context, hotelId string) CashieringAPIGetCreditLimitOveragePaymentsRequest {
	return CashieringAPIGetCreditLimitOveragePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreditLimitOveragePaymentsInfo
func (a *CashieringAPIService) GetCreditLimitOveragePaymentsExecute(r CashieringAPIGetCreditLimitOveragePaymentsRequest) (*CreditLimitOveragePaymentsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditLimitOveragePaymentsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetCreditLimitOveragePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditLimitsOveragePayments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.guestNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestNameWildCard", r.guestNameWildCard, "")
  }
	if r.roomNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomNumberWildCard", r.roomNumberWildCard, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetDepositFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	id *string
	policyIdId *string
	blockIdId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetDepositFolioRequest) Authorization(authorization string) CashieringAPIGetDepositFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetDepositFolioRequest) XAppKey(xAppKey string) CashieringAPIGetDepositFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetDepositFolioRequest) XHotelid(xHotelid string) CashieringAPIGetDepositFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for deposit folio instructions that can be used in requests for partial operations.
func (r CashieringAPIGetDepositFolioRequest) FetchInstructions(fetchInstructions []string) CashieringAPIGetDepositFolioRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetDepositFolioRequest) Id(id string) CashieringAPIGetDepositFolioRequest {
	r.id = &id
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetDepositFolioRequest) PolicyIdId(policyIdId string) CashieringAPIGetDepositFolioRequest {
	r.policyIdId = &policyIdId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetDepositFolioRequest) BlockIdId(blockIdId string) CashieringAPIGetDepositFolioRequest {
	r.blockIdId = &blockIdId
	return r
}

// External system code.
func (r CashieringAPIGetDepositFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetDepositFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetDepositFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetDepositFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetDepositFolioRequest) Execute() (*ReservationDepositFolios, *http.Response, error) {
	return r.ApiService.GetDepositFolioExecute(r)
}

/*
GetDepositFolio Get Deposit Folio

You can use this API to get Deposit Folio. <p><strong>OperationId:</strong>getDepositFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetDepositFolioRequest
*/
func (a *CashieringAPIService) GetDepositFolio(ctx context.Context, hotelId string) CashieringAPIGetDepositFolioRequest {
	return CashieringAPIGetDepositFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationDepositFolios
func (a *CashieringAPIService) GetDepositFolioExecute(r CashieringAPIGetDepositFolioRequest) (*ReservationDepositFolios, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationDepositFolios
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetDepositFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositFolio"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.policyIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIdId", r.policyIdId, "")
  }
	if r.blockIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockIdId", r.blockIdId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetDepositFolioTransactionDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	transactionNo *[]float32
	includeExchangeInformation *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) Authorization(authorization string) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the automatically generated transactions, related to the main transaction number above, are also to be retrieved as part of this request.
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) IncludeGenerates(includeGenerates bool) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// Unique Transaction Number of the transaction(posting) for which details are required.
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) TransactionNo(transactionNo []float32) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Flag to indicate what currency exchange information text needs to be included in response.
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) IncludeExchangeInformation(includeExchangeInformation bool) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.includeExchangeInformation = &includeExchangeInformation
	return r
}

// External system code.
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetDepositFolioTransactionDetailsRequest) Execute() (*DepositFolioTransactionDetails, *http.Response, error) {
	return r.ApiService.GetDepositFolioTransactionDetailsExecute(r)
}

/*
GetDepositFolioTransactionDetails Get Deposit Folio Transaction Details

You can use this API to get Deposit Folio Transaction Details. <p><strong>OperationId:</strong>getDepositFolioTransactionDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetDepositFolioTransactionDetailsRequest
*/
func (a *CashieringAPIService) GetDepositFolioTransactionDetails(ctx context.Context, hotelId string) CashieringAPIGetDepositFolioTransactionDetailsRequest {
	return CashieringAPIGetDepositFolioTransactionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositFolioTransactionDetails
func (a *CashieringAPIService) GetDepositFolioTransactionDetailsExecute(r CashieringAPIGetDepositFolioTransactionDetailsRequest) (*DepositFolioTransactionDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositFolioTransactionDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetDepositFolioTransactionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
  }
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
  }
	if r.includeExchangeInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExchangeInformation", r.includeExchangeInformation, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetDepositMaturityInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetDepositMaturityInfoRequest) Authorization(authorization string) CashieringAPIGetDepositMaturityInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetDepositMaturityInfoRequest) XAppKey(xAppKey string) CashieringAPIGetDepositMaturityInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetDepositMaturityInfoRequest) XHotelid(xHotelid string) CashieringAPIGetDepositMaturityInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetDepositMaturityInfoRequest) CashierId(cashierId float32) CashieringAPIGetDepositMaturityInfoRequest {
	r.cashierId = &cashierId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetDepositMaturityInfoRequest) IdContext(idContext string) CashieringAPIGetDepositMaturityInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetDepositMaturityInfoRequest) Type_(type_ string) CashieringAPIGetDepositMaturityInfoRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r CashieringAPIGetDepositMaturityInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetDepositMaturityInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetDepositMaturityInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetDepositMaturityInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetDepositMaturityInfoRequest) Execute() (*DepositMaturityDetails, *http.Response, error) {
	return r.ApiService.GetDepositMaturityInfoExecute(r)
}

/*
GetDepositMaturityInfo Get Deposit Maturity Information

You can use this API to get Deposit Maturity Information. <p><strong>OperationId:</strong>getDepositMaturityInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetDepositMaturityInfoRequest
*/
func (a *CashieringAPIService) GetDepositMaturityInfo(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetDepositMaturityInfoRequest {
	return CashieringAPIGetDepositMaturityInfoRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositMaturityDetails
func (a *CashieringAPIService) GetDepositMaturityInfoExecute(r CashieringAPIGetDepositMaturityInfoRequest) (*DepositMaturityDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositMaturityDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetDepositMaturityInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositMaturity"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetEligibleBillAmountRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioView *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetEligibleBillAmountRequest) Authorization(authorization string) CashieringAPIGetEligibleBillAmountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetEligibleBillAmountRequest) XAppKey(xAppKey string) CashieringAPIGetEligibleBillAmountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetEligibleBillAmountRequest) XHotelid(xHotelid string) CashieringAPIGetEligibleBillAmountRequest {
	r.xHotelid = &xHotelid
	return r
}

// The folio window where this settlement is applied.
func (r CashieringAPIGetEligibleBillAmountRequest) FolioView(folioView int32) CashieringAPIGetEligibleBillAmountRequest {
	r.folioView = &folioView
	return r
}

// External system code.
func (r CashieringAPIGetEligibleBillAmountRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetEligibleBillAmountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetEligibleBillAmountRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetEligibleBillAmountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetEligibleBillAmountRequest) Execute() (*AmountEligible, *http.Response, error) {
	return r.ApiService.GetEligibleBillAmountExecute(r)
}

/*
GetEligibleBillAmount Get Eligible Bill Amount

Retrieves eligible bill amount in order to post redemption on a reservation folio <p><strong>OperationId:</strong>getEligibleBillAmount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @param reservationId Unique ID of the reservation
 @return CashieringAPIGetEligibleBillAmountRequest
*/
func (a *CashieringAPIService) GetEligibleBillAmount(ctx context.Context, hotelId string, reservationId string) CashieringAPIGetEligibleBillAmountRequest {
	return CashieringAPIGetEligibleBillAmountRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return AmountEligible
func (a *CashieringAPIService) GetEligibleBillAmountExecute(r CashieringAPIGetEligibleBillAmountRequest) (*AmountEligible, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AmountEligible
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetEligibleBillAmount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/eligibleBillAmount"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFinancialPostingsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	startDate *string
	endDate *string
	duration *string
	cashierId *float32
	filterTransactionCode *[]string
	code *[]string
	filterRoomNumber *[]string
	referenceNumberWildCard *string
	checkNumberWildCard *string
	supplementWildCard *string
	approvalCode *string
	approvalStatusCode *[]string
	folioWindowNo *[]int32
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	id *string
	idContext *string
	type_ *string
	amount *float32
	currencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	closureNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFinancialPostingsRequest) Authorization(authorization string) CashieringAPIGetFinancialPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFinancialPostingsRequest) XAppKey(xAppKey string) CashieringAPIGetFinancialPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFinancialPostingsRequest) XHotelid(xHotelid string) CashieringAPIGetFinancialPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringAPIGetFinancialPostingsRequest) Limit(limit int32) CashieringAPIGetFinancialPostingsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringAPIGetFinancialPostingsRequest) Offset(offset int32) CashieringAPIGetFinancialPostingsRequest {
	r.offset = &offset
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) StartDate(startDate string) CashieringAPIGetFinancialPostingsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) EndDate(endDate string) CashieringAPIGetFinancialPostingsRequest {
	r.endDate = &endDate
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) Duration(duration string) CashieringAPIGetFinancialPostingsRequest {
	r.duration = &duration
	return r
}

// Cashier Id of the Cashier.
func (r CashieringAPIGetFinancialPostingsRequest) CashierId(cashierId float32) CashieringAPIGetFinancialPostingsRequest {
	r.cashierId = &cashierId
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) FilterTransactionCode(filterTransactionCode []string) CashieringAPIGetFinancialPostingsRequest {
	r.filterTransactionCode = &filterTransactionCode
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) Code(code []string) CashieringAPIGetFinancialPostingsRequest {
	r.code = &code
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) FilterRoomNumber(filterRoomNumber []string) CashieringAPIGetFinancialPostingsRequest {
	r.filterRoomNumber = &filterRoomNumber
	return r
}

// Filters the results for reference number.
func (r CashieringAPIGetFinancialPostingsRequest) ReferenceNumberWildCard(referenceNumberWildCard string) CashieringAPIGetFinancialPostingsRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for Cheque number&#39;s code.
func (r CashieringAPIGetFinancialPostingsRequest) CheckNumberWildCard(checkNumberWildCard string) CashieringAPIGetFinancialPostingsRequest {
	r.checkNumberWildCard = &checkNumberWildCard
	return r
}

// Filter the results for supplement.
func (r CashieringAPIGetFinancialPostingsRequest) SupplementWildCard(supplementWildCard string) CashieringAPIGetFinancialPostingsRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// Filters the results for approval code.
func (r CashieringAPIGetFinancialPostingsRequest) ApprovalCode(approvalCode string) CashieringAPIGetFinancialPostingsRequest {
	r.approvalCode = &approvalCode
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) ApprovalStatusCode(approvalStatusCode []string) CashieringAPIGetFinancialPostingsRequest {
	r.approvalStatusCode = &approvalStatusCode
	return r
}

// Filters the result to only include transactions in this window number.
func (r CashieringAPIGetFinancialPostingsRequest) FolioWindowNo(folioWindowNo []int32) CashieringAPIGetFinancialPostingsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Attach the credit card to profile.
func (r CashieringAPIGetFinancialPostingsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) CashieringAPIGetFinancialPostingsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) CardHolderName(cardHolderName string) CashieringAPIGetFinancialPostingsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) CardNumber(cardNumber string) CashieringAPIGetFinancialPostingsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) CashieringAPIGetFinancialPostingsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) CardNumberMasked(cardNumberMasked string) CashieringAPIGetFinancialPostingsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r CashieringAPIGetFinancialPostingsRequest) CardOrToken(cardOrToken string) CashieringAPIGetFinancialPostingsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r CashieringAPIGetFinancialPostingsRequest) CardType(cardType string) CashieringAPIGetFinancialPostingsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r CashieringAPIGetFinancialPostingsRequest) ExpirationDate(expirationDate string) CashieringAPIGetFinancialPostingsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) ExpirationDateExpired(expirationDateExpired bool) CashieringAPIGetFinancialPostingsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r CashieringAPIGetFinancialPostingsRequest) ExpirationDateMasked(expirationDateMasked string) CashieringAPIGetFinancialPostingsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) Processing(processing string) CashieringAPIGetFinancialPostingsRequest {
	r.processing = &processing
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) Swiped(swiped bool) CashieringAPIGetFinancialPostingsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r CashieringAPIGetFinancialPostingsRequest) UserDefinedCardType(userDefinedCardType string) CashieringAPIGetFinancialPostingsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFinancialPostingsRequest) Id(id string) CashieringAPIGetFinancialPostingsRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFinancialPostingsRequest) IdContext(idContext string) CashieringAPIGetFinancialPostingsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFinancialPostingsRequest) Type_(type_ string) CashieringAPIGetFinancialPostingsRequest {
	r.type_ = &type_
	return r
}

// A monetary amount.
func (r CashieringAPIGetFinancialPostingsRequest) Amount(amount float32) CashieringAPIGetFinancialPostingsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFinancialPostingsRequest) CurrencyCode(currencyCode string) CashieringAPIGetFinancialPostingsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFinancialPostingsRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) CashieringAPIGetFinancialPostingsRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFinancialPostingsRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) CashieringAPIGetFinancialPostingsRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// Filters the result to only display the postings that were made during the cashier closure range
func (r CashieringAPIGetFinancialPostingsRequest) ClosureNo(closureNo int32) CashieringAPIGetFinancialPostingsRequest {
	r.closureNo = &closureNo
	return r
}

// External system code.
func (r CashieringAPIGetFinancialPostingsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFinancialPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFinancialPostingsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFinancialPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFinancialPostingsRequest) Execute() (*FinancialPostings, *http.Response, error) {
	return r.ApiService.GetFinancialPostingsExecute(r)
}

/*
GetFinancialPostings Get Financial Postings

You can use this API to get Financial postings. <p><strong>OperationId:</strong>getFinancialPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFinancialPostingsRequest
*/
func (a *CashieringAPIService) GetFinancialPostings(ctx context.Context, hotelId string) CashieringAPIGetFinancialPostingsRequest {
	return CashieringAPIGetFinancialPostingsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FinancialPostings
func (a *CashieringAPIService) GetFinancialPostingsExecute(r CashieringAPIGetFinancialPostingsRequest) (*FinancialPostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FinancialPostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFinancialPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/financialPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.filterTransactionCode != nil {
		t := *r.filterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterTransactionCode", t, "multi")
		}
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.filterRoomNumber != nil {
		t := *r.filterRoomNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filterRoomNumber", t, "multi")
		}
  }
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
  }
	if r.checkNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumberWildCard", r.checkNumberWildCard, "")
  }
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.approvalStatusCode != nil {
		t := *r.approvalStatusCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatusCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatusCode", t, "multi")
		}
  }
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
  }
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
  }
	if r.closureNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closureNo", r.closureNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFinancialPostingsNetVatRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	reservationId *string
	folioWindowNo *int32
	authorization *string
	xAppKey *string
	xHotelid *string
	startDate *string
	endDate *string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Unique ID of the reservation
func (r CashieringAPIGetFinancialPostingsNetVatRequest) ReservationId(reservationId string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.reservationId = &reservationId
	return r
}

func (r CashieringAPIGetFinancialPostingsNetVatRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFinancialPostingsNetVatRequest) Authorization(authorization string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFinancialPostingsNetVatRequest) XAppKey(xAppKey string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFinancialPostingsNetVatRequest) XHotelid(xHotelid string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringAPIGetFinancialPostingsNetVatRequest) StartDate(startDate string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetFinancialPostingsNetVatRequest) EndDate(endDate string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.endDate = &endDate
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringAPIGetFinancialPostingsNetVatRequest) Limit(limit int32) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringAPIGetFinancialPostingsNetVatRequest) Offset(offset int32) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r CashieringAPIGetFinancialPostingsNetVatRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFinancialPostingsNetVatRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFinancialPostingsNetVatRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFinancialPostingsNetVatRequest) Execute() (*FinancialPostingsNetVat, *http.Response, error) {
	return r.ApiService.GetFinancialPostingsNetVatExecute(r)
}

/*
GetFinancialPostingsNetVat Get Financial Postings with breakdown

You can use this API to get Financial postings with Net and Vat breakdown. <p><strong>OperationId:</strong>financialPostingsNetVat</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFinancialPostingsNetVatRequest
*/
func (a *CashieringAPIService) GetFinancialPostingsNetVat(ctx context.Context, hotelId string) CashieringAPIGetFinancialPostingsNetVatRequest {
	return CashieringAPIGetFinancialPostingsNetVatRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FinancialPostingsNetVat
func (a *CashieringAPIService) GetFinancialPostingsNetVatExecute(r CashieringAPIGetFinancialPostingsNetVatRequest) (*FinancialPostingsNetVat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FinancialPostingsNetVat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFinancialPostingsNetVat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/financialPostingsNetVat"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(*r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(*r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFiscalFolioActivityRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioSeqNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFiscalFolioActivityRequest) Authorization(authorization string) CashieringAPIGetFiscalFolioActivityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFiscalFolioActivityRequest) XAppKey(xAppKey string) CashieringAPIGetFiscalFolioActivityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFiscalFolioActivityRequest) XHotelid(xHotelid string) CashieringAPIGetFiscalFolioActivityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio Sequence number for a folio
func (r CashieringAPIGetFiscalFolioActivityRequest) FolioSeqNo(folioSeqNo int32) CashieringAPIGetFiscalFolioActivityRequest {
	r.folioSeqNo = &folioSeqNo
	return r
}

// External system code.
func (r CashieringAPIGetFiscalFolioActivityRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFiscalFolioActivityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFiscalFolioActivityRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFiscalFolioActivityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFiscalFolioActivityRequest) Execute() (*FolioActivityDetailsType, *http.Response, error) {
	return r.ApiService.GetFiscalFolioActivityExecute(r)
}

/*
GetFiscalFolioActivity Get the Fiscal Folio Activity for a folio

You can use this API to get the fiscal folio activity details for a folio. <p><strong>OperationId:</strong>getFiscalFolioActivity</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFiscalFolioActivityRequest
*/
func (a *CashieringAPIService) GetFiscalFolioActivity(ctx context.Context, hotelId string) CashieringAPIGetFiscalFolioActivityRequest {
	return CashieringAPIGetFiscalFolioActivityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioActivityDetailsType
func (a *CashieringAPIService) GetFiscalFolioActivityExecute(r CashieringAPIGetFiscalFolioActivityRequest) (*FolioActivityDetailsType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioActivityDetailsType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFiscalFolioActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalFolioResponse"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.folioSeqNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioSeqNo", r.folioSeqNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFiscalFolioActivityDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioSeqNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	responseAttemptNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) Authorization(authorization string) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Number of fiscal response attempt made for the folio
func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) ResponseAttemptNo(responseAttemptNo int32) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	r.responseAttemptNo = &responseAttemptNo
	return r
}

// External system code.
func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFiscalFolioActivityDetailsRequest) Execute() (*FolioActivityResponseDetailType, *http.Response, error) {
	return r.ApiService.GetFiscalFolioActivityDetailsExecute(r)
}

/*
GetFiscalFolioActivityDetails Get the Fiscal Folio Activity Response details for a folio

You can use this API to get the fiscal folio activity response details for a folio. <p><strong>OperationId:</strong>getFiscalFolioActivityDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioSeqNo Unique ID of the folio
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFiscalFolioActivityDetailsRequest
*/
func (a *CashieringAPIService) GetFiscalFolioActivityDetails(ctx context.Context, folioSeqNo string, hotelId string) CashieringAPIGetFiscalFolioActivityDetailsRequest {
	return CashieringAPIGetFiscalFolioActivityDetailsRequest{
		ApiService: a,
		ctx: ctx,
		folioSeqNo: folioSeqNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioActivityResponseDetailType
func (a *CashieringAPIService) GetFiscalFolioActivityDetailsExecute(r CashieringAPIGetFiscalFolioActivityDetailsRequest) (*FolioActivityResponseDetailType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioActivityResponseDetailType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFiscalFolioActivityDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalFolioResponse/{folioSeqNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioSeqNo"+"}", url.PathEscape(parameterValueToString(r.folioSeqNo, "folioSeqNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioSeqNo) < 1 {
		return localVarReturnValue, nil, reportError("folioSeqNo must have at least 1 elements")
	}
	if strlen(r.folioSeqNo) > 2000 {
		return localVarReturnValue, nil, reportError("folioSeqNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.responseAttemptNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseAttemptNo", r.responseAttemptNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFiscalPrintingDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioView *int32
	folioType *string
	id *string
	code *[]string
	fetchInstruction *[]string
	profileIdId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFiscalPrintingDetailsRequest) Authorization(authorization string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFiscalPrintingDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFiscalPrintingDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The folio window where this settlement is applied.
func (r CashieringAPIGetFiscalPrintingDetailsRequest) FolioView(folioView int32) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.folioView = &folioView
	return r
}

// Folio Type
func (r CashieringAPIGetFiscalPrintingDetailsRequest) FolioType(folioType string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.folioType = &folioType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFiscalPrintingDetailsRequest) Id(id string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.id = &id
	return r
}

func (r CashieringAPIGetFiscalPrintingDetailsRequest) Code(code []string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.code = &code
	return r
}

// Reservation Related information.
func (r CashieringAPIGetFiscalPrintingDetailsRequest) FetchInstruction(fetchInstruction []string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.fetchInstruction = &fetchInstruction
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFiscalPrintingDetailsRequest) ProfileIdId(profileIdId string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.profileIdId = &profileIdId
	return r
}

// External system code.
func (r CashieringAPIGetFiscalPrintingDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFiscalPrintingDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFiscalPrintingDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFiscalPrintingDetailsRequest) Execute() (*FiscalCallStatus, *http.Response, error) {
	return r.ApiService.GetFiscalPrintingDetailsExecute(r)
}

/*
GetFiscalPrintingDetails Get Fiscal Printing Details

You can use this API to get Fiscal Printing Details.<br><p><strong><mark>This API is deprecated. Please use getValidateFiscalPrintingDetails instead</mark></strong></p> <p><strong>OperationId:</strong>getFiscalPrintingDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFiscalPrintingDetailsRequest

Deprecated
*/
func (a *CashieringAPIService) GetFiscalPrintingDetails(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetFiscalPrintingDetailsRequest {
	return CashieringAPIGetFiscalPrintingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCallStatus
// Deprecated
func (a *CashieringAPIService) GetFiscalPrintingDetailsExecute(r CashieringAPIGetFiscalPrintingDetailsRequest) (*FiscalCallStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCallStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFiscalPrintingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fiscalPrinting"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.fetchInstruction != nil {
		t := *r.fetchInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", t, "multi")
		}
  }
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFiscalSupportingDocumentsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	surname *string
	givenName *string
	confirmationNo *string
	arrivalStartDate *string
	arrivalEndDate *string
	departureStartDate *string
	departureEndDate *string
	roomId *string
	documentType *[]string
	documentNo *string
	pendingDocumentsOnly *bool
	fromCreateDateTime *string
	limit *int32
	offset *int32
	orderBy *[]string
	sortOrder *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) Authorization(authorization string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) XAppKey(xAppKey string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) XHotelid(xHotelid string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Family name, last name.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) Surname(surname string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.surname = &surname
	return r
}

// Given name, first name or names.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) GivenName(givenName string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.givenName = &givenName
	return r
}

// Confirmation number of the reservation.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) ConfirmationNo(confirmationNo string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.confirmationNo = &confirmationNo
	return r
}

// The starting value of the date range.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) ArrivalStartDate(arrivalStartDate string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.arrivalStartDate = &arrivalStartDate
	return r
}

// The ending value of the date range.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) ArrivalEndDate(arrivalEndDate string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.arrivalEndDate = &arrivalEndDate
	return r
}

// The starting value of the date range.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) DepartureStartDate(departureStartDate string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.departureStartDate = &departureStartDate
	return r
}

// The ending value of the date range.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) DepartureEndDate(departureEndDate string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.departureEndDate = &departureEndDate
	return r
}

// Room number of the the transaction.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) RoomId(roomId string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.roomId = &roomId
	return r
}

// Supporting document type.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) DocumentType(documentType []string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.documentType = &documentType
	return r
}

// Supporting document number.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) DocumentNo(documentNo string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.documentNo = &documentNo
	return r
}

// Indicator to fetch only failed supporting documents, that were not sent successfully to the fiscal partner.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) PendingDocumentsOnly(pendingDocumentsOnly bool) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.pendingDocumentsOnly = &pendingDocumentsOnly
	return r
}

// Time stamp of the creation.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) FromCreateDateTime(fromCreateDateTime string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.fromCreateDateTime = &fromCreateDateTime
	return r
}

// Indicates maximum number of records the API should return. Default is 50
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) Limit(limit int32) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.limit = &limit
	return r
}

// Index of the page being requested. If the index goes out of the bounds of the total set count, no data will be returned.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) Offset(offset int32) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.offset = &offset
	return r
}

func (r CashieringAPIGetFiscalSupportingDocumentsRequest) OrderBy(orderBy []string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.orderBy = &orderBy
	return r
}

func (r CashieringAPIGetFiscalSupportingDocumentsRequest) SortOrder(sortOrder []string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.sortOrder = &sortOrder
	return r
}

// External system code.
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFiscalSupportingDocumentsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFiscalSupportingDocumentsRequest) Execute() (*FiscalSupportingDocumentsResponse, *http.Response, error) {
	return r.ApiService.GetFiscalSupportingDocumentsExecute(r)
}

/*
GetFiscalSupportingDocuments Get supporting documents details.

This API is used to get the list of supporting documents for the reservations. <p><strong>OperationId:</strong>getSupportingDocuments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel.
 @return CashieringAPIGetFiscalSupportingDocumentsRequest
*/
func (a *CashieringAPIService) GetFiscalSupportingDocuments(ctx context.Context, hotelId string) CashieringAPIGetFiscalSupportingDocumentsRequest {
	return CashieringAPIGetFiscalSupportingDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalSupportingDocumentsResponse
func (a *CashieringAPIService) GetFiscalSupportingDocumentsExecute(r CashieringAPIGetFiscalSupportingDocumentsRequest) (*FiscalSupportingDocumentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalSupportingDocumentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFiscalSupportingDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalSupportingDocuments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.surname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "surname", r.surname, "")
  }
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
  }
	if r.confirmationNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "confirmationNo", r.confirmationNo, "")
  }
	if r.arrivalStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalStartDate", r.arrivalStartDate, "")
  }
	if r.arrivalEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arrivalEndDate", r.arrivalEndDate, "")
  }
	if r.departureStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureStartDate", r.departureStartDate, "")
  }
	if r.departureEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureEndDate", r.departureEndDate, "")
  }
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
  }
	if r.documentType != nil {
		t := *r.documentType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "documentType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "documentType", t, "multi")
		}
  }
	if r.documentNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "documentNo", r.documentNo, "")
  }
	if r.pendingDocumentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pendingDocumentsOnly", r.pendingDocumentsOnly, "")
  }
	if r.fromCreateDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromCreateDateTime", r.fromCreateDateTime, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", t, "multi")
		}
  }
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFixedChargesRequest) Authorization(authorization string) CashieringAPIGetFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFixedChargesRequest) XAppKey(xAppKey string) CashieringAPIGetFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFixedChargesRequest) XHotelid(xHotelid string) CashieringAPIGetFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFixedChargesRequest) IdContext(idContext string) CashieringAPIGetFixedChargesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFixedChargesRequest) Type_(type_ string) CashieringAPIGetFixedChargesRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r CashieringAPIGetFixedChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFixedChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFixedChargesRequest) Execute() (*FixedChargesDetails, *http.Response, error) {
	return r.ApiService.GetFixedChargesExecute(r)
}

/*
GetFixedCharges Get Fixed Charges

You can use this API to get fixed Charges for a reservation. <p><strong>OperationId:</strong>getFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFixedChargesRequest
*/
func (a *CashieringAPIService) GetFixedCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetFixedChargesRequest {
	return CashieringAPIGetFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FixedChargesDetails
func (a *CashieringAPIService) GetFixedChargesExecute(r CashieringAPIGetFixedChargesRequest) (*FixedChargesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FixedChargesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestPayOnly *bool
	includeFolioHistory *bool
	reservationBalanceOnly *bool
	fetchInstructions *[]string
	end *[]string
	folioWindowNo *[]int32
	limit *[]int32
	offset *[]int32
	start *[]string
	summaryOnly *bool
	groupType *string
	exchangeCurrency *string
	calculateCollectingAgentTaxes *bool
	vATOffset *bool
	includeDepositTaxes *bool
	simpleFolio *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioRequest) Authorization(authorization string) CashieringAPIGetFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioRequest) XAppKey(xAppKey string) CashieringAPIGetFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioRequest) XHotelid(xHotelid string) CashieringAPIGetFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to return the Folio Windows information where the Reservation Guest is the Payee, i.e the Folio Window is not Routed to another Reservation or another Profile.
func (r CashieringAPIGetFolioRequest) GuestPayOnly(guestPayOnly bool) CashieringAPIGetFolioRequest {
	r.guestPayOnly = &guestPayOnly
	return r
}

// This flag will notify the service if the folio history will also be returned or not.
func (r CashieringAPIGetFolioRequest) IncludeFolioHistory(includeFolioHistory bool) CashieringAPIGetFolioRequest {
	r.includeFolioHistory = &includeFolioHistory
	return r
}

// This flag will notify the service if the reservation summary information will be returned. If TRUE then we will only return the reservation&#39;s outstanding balance.
func (r CashieringAPIGetFolioRequest) ReservationBalanceOnly(reservationBalanceOnly bool) CashieringAPIGetFolioRequest {
	r.reservationBalanceOnly = &reservationBalanceOnly
	return r
}

// Posting details of each window.
func (r CashieringAPIGetFolioRequest) FetchInstructions(fetchInstructions []string) CashieringAPIGetFolioRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// The ending value of the date range.
func (r CashieringAPIGetFolioRequest) End(end []string) CashieringAPIGetFolioRequest {
	r.end = &end
	return r
}

func (r CashieringAPIGetFolioRequest) FolioWindowNo(folioWindowNo []int32) CashieringAPIGetFolioRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r CashieringAPIGetFolioRequest) Limit(limit []int32) CashieringAPIGetFolioRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r CashieringAPIGetFolioRequest) Offset(offset []int32) CashieringAPIGetFolioRequest {
	r.offset = &offset
	return r
}

// The starting value of the date range.
func (r CashieringAPIGetFolioRequest) Start(start []string) CashieringAPIGetFolioRequest {
	r.start = &start
	return r
}

// This flag will notify the service that transactional postings will not be returned.
func (r CashieringAPIGetFolioRequest) SummaryOnly(summaryOnly bool) CashieringAPIGetFolioRequest {
	r.summaryOnly = &summaryOnly
	return r
}

// Grouping by Transactin Type.
func (r CashieringAPIGetFolioRequest) GroupType(groupType string) CashieringAPIGetFolioRequest {
	r.groupType = &groupType
	return r
}

// Currency to which the Credit and Debit Amounts will be converted for each Folio. The response will have the ExchangeAmounts element with the converted amounts. The Posting Exchange Rate of the current business date will be used for the conversion
func (r CashieringAPIGetFolioRequest) ExchangeCurrency(exchangeCurrency string) CashieringAPIGetFolioRequest {
	r.exchangeCurrency = &exchangeCurrency
	return r
}

func (r CashieringAPIGetFolioRequest) CalculateCollectingAgentTaxes(calculateCollectingAgentTaxes bool) CashieringAPIGetFolioRequest {
	r.calculateCollectingAgentTaxes = &calculateCollectingAgentTaxes
	return r
}

func (r CashieringAPIGetFolioRequest) VATOffset(vATOffset bool) CashieringAPIGetFolioRequest {
	r.vATOffset = &vATOffset
	return r
}

func (r CashieringAPIGetFolioRequest) IncludeDepositTaxes(includeDepositTaxes bool) CashieringAPIGetFolioRequest {
	r.includeDepositTaxes = &includeDepositTaxes
	return r
}

// This flag signifies that generated Folio is Normal or Simple Folio. Certain countries of the World mandate a simple folio when the invoice amount is less than defined threshold.
func (r CashieringAPIGetFolioRequest) SimpleFolio(simpleFolio bool) CashieringAPIGetFolioRequest {
	r.simpleFolio = &simpleFolio
	return r
}

// External system code.
func (r CashieringAPIGetFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioRequest) Execute() (*Folio, *http.Response, error) {
	return r.ApiService.GetFolioExecute(r)
}

/*
GetFolio Get folios

This API is used to fetch the folios for a given reservation. A guest reservation could have 1 or more folios per reservation. Folios will only exist for a reservation once the guest has checked into the hotel. <p><strong>OperationId:</strong>getFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioRequest
*/
func (a *CashieringAPIService) GetFolio(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetFolioRequest {
	return CashieringAPIGetFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Folio
func (a *CashieringAPIService) GetFolioExecute(r CashieringAPIGetFolioRequest) (*Folio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Folio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.guestPayOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestPayOnly", r.guestPayOnly, "")
  }
	if r.includeFolioHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFolioHistory", r.includeFolioHistory, "")
  }
	if r.reservationBalanceOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationBalanceOnly", r.reservationBalanceOnly, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.end != nil {
		t := *r.end
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end", t, "multi")
		}
  }
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
  }
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
  }
	if r.offset != nil {
		t := *r.offset
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "offset", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "offset", t, "multi")
		}
  }
	if r.start != nil {
		t := *r.start
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start", t, "multi")
		}
  }
	if r.summaryOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryOnly", r.summaryOnly, "")
  }
	if r.groupType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupType", r.groupType, "")
  }
	if r.exchangeCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeCurrency", r.exchangeCurrency, "")
  }
	if r.calculateCollectingAgentTaxes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "calculateCollectingAgentTaxes", r.calculateCollectingAgentTaxes, "")
  }
	if r.vATOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vATOffset", r.vATOffset, "")
  }
	if r.includeDepositTaxes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDepositTaxes", r.includeDepositTaxes, "")
  }
	if r.simpleFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "simpleFolio", r.simpleFolio, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioHistoryRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idContext *string
	type_ *string
	aR *bool
	checkOut *bool
	creditBill *bool
	supplementalFolio *bool
	includeAssociatedFolios *bool
	noShow *bool
	offlineFolio *bool
	passerBy *bool
	postIt *bool
	videoCheckOut *bool
	folioDate *string
	reservationIdId *string
	reservationIdIdContext *string
	reservationIdType *string
	room *string
	name *string
	firstName *string
	creditCardNo *string
	folioNo *string
	invoiceNo *float32
	addresseeName *string
	fiscalFolioNo *string
	code *[]string
	partnerFiscalFolioStatusCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioHistoryRequest) Authorization(authorization string) CashieringAPIGetFolioHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioHistoryRequest) XAppKey(xAppKey string) CashieringAPIGetFolioHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioHistoryRequest) XHotelid(xHotelid string) CashieringAPIGetFolioHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioHistoryRequest) Id(id string) CashieringAPIGetFolioHistoryRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFolioHistoryRequest) IdContext(idContext string) CashieringAPIGetFolioHistoryRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFolioHistoryRequest) Type_(type_ string) CashieringAPIGetFolioHistoryRequest {
	r.type_ = &type_
	return r
}

// Indicates if search includes AR Folios.
func (r CashieringAPIGetFolioHistoryRequest) AR(aR bool) CashieringAPIGetFolioHistoryRequest {
	r.aR = &aR
	return r
}

// Indicates if search includes Check Out Folios.
func (r CashieringAPIGetFolioHistoryRequest) CheckOut(checkOut bool) CashieringAPIGetFolioHistoryRequest {
	r.checkOut = &checkOut
	return r
}

// Indicates if search includes Credit Bill Folios.
func (r CashieringAPIGetFolioHistoryRequest) CreditBill(creditBill bool) CashieringAPIGetFolioHistoryRequest {
	r.creditBill = &creditBill
	return r
}

// Indicates if search includes Debit Bill Folios.
func (r CashieringAPIGetFolioHistoryRequest) SupplementalFolio(supplementalFolio bool) CashieringAPIGetFolioHistoryRequest {
	r.supplementalFolio = &supplementalFolio
	return r
}

// Indicates if search result includes Associated Bills and is only applied when Folio History for a particular reservation (i.e. ReservationID has a value) is requested.
func (r CashieringAPIGetFolioHistoryRequest) IncludeAssociatedFolios(includeAssociatedFolios bool) CashieringAPIGetFolioHistoryRequest {
	r.includeAssociatedFolios = &includeAssociatedFolios
	return r
}

// Indicates if search includes No Show Folios.
func (r CashieringAPIGetFolioHistoryRequest) NoShow(noShow bool) CashieringAPIGetFolioHistoryRequest {
	r.noShow = &noShow
	return r
}

// Indicates if search includes Offline Folios.
func (r CashieringAPIGetFolioHistoryRequest) OfflineFolio(offlineFolio bool) CashieringAPIGetFolioHistoryRequest {
	r.offlineFolio = &offlineFolio
	return r
}

// Indicates if search includes Passer By Folios.
func (r CashieringAPIGetFolioHistoryRequest) PasserBy(passerBy bool) CashieringAPIGetFolioHistoryRequest {
	r.passerBy = &passerBy
	return r
}

// Indicates if search includes Post-It Folios.
func (r CashieringAPIGetFolioHistoryRequest) PostIt(postIt bool) CashieringAPIGetFolioHistoryRequest {
	r.postIt = &postIt
	return r
}

// Indicates if search includes Video Check Out Folios.
func (r CashieringAPIGetFolioHistoryRequest) VideoCheckOut(videoCheckOut bool) CashieringAPIGetFolioHistoryRequest {
	r.videoCheckOut = &videoCheckOut
	return r
}

// Folio History Date.
func (r CashieringAPIGetFolioHistoryRequest) FolioDate(folioDate string) CashieringAPIGetFolioHistoryRequest {
	r.folioDate = &folioDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioHistoryRequest) ReservationIdId(reservationIdId string) CashieringAPIGetFolioHistoryRequest {
	r.reservationIdId = &reservationIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFolioHistoryRequest) ReservationIdIdContext(reservationIdIdContext string) CashieringAPIGetFolioHistoryRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFolioHistoryRequest) ReservationIdType(reservationIdType string) CashieringAPIGetFolioHistoryRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Room Number to which this record applies.
func (r CashieringAPIGetFolioHistoryRequest) Room(room string) CashieringAPIGetFolioHistoryRequest {
	r.room = &room
	return r
}

// Family name, last name or Company Name.
func (r CashieringAPIGetFolioHistoryRequest) Name(name string) CashieringAPIGetFolioHistoryRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r CashieringAPIGetFolioHistoryRequest) FirstName(firstName string) CashieringAPIGetFolioHistoryRequest {
	r.firstName = &firstName
	return r
}

// Credit card number used.
func (r CashieringAPIGetFolioHistoryRequest) CreditCardNo(creditCardNo string) CashieringAPIGetFolioHistoryRequest {
	r.creditCardNo = &creditCardNo
	return r
}

// Folio Number.
func (r CashieringAPIGetFolioHistoryRequest) FolioNo(folioNo string) CashieringAPIGetFolioHistoryRequest {
	r.folioNo = &folioNo
	return r
}

// Invoice Number.
func (r CashieringAPIGetFolioHistoryRequest) InvoiceNo(invoiceNo float32) CashieringAPIGetFolioHistoryRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r CashieringAPIGetFolioHistoryRequest) AddresseeName(addresseeName string) CashieringAPIGetFolioHistoryRequest {
	r.addresseeName = &addresseeName
	return r
}

// Fiscal Folio Number filter. Works with the Fiscal Folio Number Functionality.
func (r CashieringAPIGetFolioHistoryRequest) FiscalFolioNo(fiscalFolioNo string) CashieringAPIGetFolioHistoryRequest {
	r.fiscalFolioNo = &fiscalFolioNo
	return r
}

func (r CashieringAPIGetFolioHistoryRequest) Code(code []string) CashieringAPIGetFolioHistoryRequest {
	r.code = &code
	return r
}

func (r CashieringAPIGetFolioHistoryRequest) PartnerFiscalFolioStatusCode(partnerFiscalFolioStatusCode []string) CashieringAPIGetFolioHistoryRequest {
	r.partnerFiscalFolioStatusCode = &partnerFiscalFolioStatusCode
	return r
}

// External system code.
func (r CashieringAPIGetFolioHistoryRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioHistoryRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioHistoryRequest) Execute() (*FolioHistoryResponse, *http.Response, error) {
	return r.ApiService.GetFolioHistoryExecute(r)
}

/*
GetFolioHistory Get folio history

You can use this API to get folio history for a reservation. <p><strong>OperationId:</strong>getFolioHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioHistoryRequest
*/
func (a *CashieringAPIService) GetFolioHistory(ctx context.Context, hotelId string) CashieringAPIGetFolioHistoryRequest {
	return CashieringAPIGetFolioHistoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioHistoryResponse
func (a *CashieringAPIService) GetFolioHistoryExecute(r CashieringAPIGetFolioHistoryRequest) (*FolioHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolioHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.aR != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aR", r.aR, "")
  }
	if r.checkOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkOut", r.checkOut, "")
  }
	if r.creditBill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditBill", r.creditBill, "")
  }
	if r.supplementalFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementalFolio", r.supplementalFolio, "")
  }
	if r.includeAssociatedFolios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAssociatedFolios", r.includeAssociatedFolios, "")
  }
	if r.noShow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noShow", r.noShow, "")
  }
	if r.offlineFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offlineFolio", r.offlineFolio, "")
  }
	if r.passerBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "passerBy", r.passerBy, "")
  }
	if r.postIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postIt", r.postIt, "")
  }
	if r.videoCheckOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCheckOut", r.videoCheckOut, "")
  }
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
  }
	if r.reservationIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdId", r.reservationIdId, "")
  }
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
  }
	if r.creditCardNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardNo", r.creditCardNo, "")
  }
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	if r.addresseeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeName", r.addresseeName, "")
  }
	if r.fiscalFolioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalFolioNo", r.fiscalFolioNo, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.partnerFiscalFolioStatusCode != nil {
		t := *r.partnerFiscalFolioStatusCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partnerFiscalFolioStatusCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partnerFiscalFolioStatusCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioPrintersRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	allFolioWindow *bool
	correction *bool
	debitFolio *bool
	folioWindowNo *int32
	manualFolioNo *int32
	cashierId *float32
	fiscalTerminalId *string
	eventType *string
	id *string
	profileIdId *string
	currencyCode *string
	exchangeRate *float32
	associatedBillNumber *float32
	associatedBillFolioType *string
	associatedBillQueueName *string
	associatedBillFiscalBillNumber *string
	associatedBillGenerationDate *string
	folioType *string
	generateFiscalFolio *bool
	queueName *string
	folioSeqId *int32
	fiscalFolioInstruction *string
	transactionServiceType *string
	amount *float32
	balanceCurrencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioPrintersRequest) Authorization(authorization string) CashieringAPIGetFolioPrintersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioPrintersRequest) XAppKey(xAppKey string) CashieringAPIGetFolioPrintersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioPrintersRequest) XHotelid(xHotelid string) CashieringAPIGetFolioPrintersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to decide if folios is to be generated for all windows in addition to the one requested with applicable postings and zero balance. If any of the windows have non-zero balance then folios are not generated for other windows.
func (r CashieringAPIGetFolioPrintersRequest) AllFolioWindow(allFolioWindow bool) CashieringAPIGetFolioPrintersRequest {
	r.allFolioWindow = &allFolioWindow
	return r
}

// Correction flag
func (r CashieringAPIGetFolioPrintersRequest) Correction(correction bool) CashieringAPIGetFolioPrintersRequest {
	r.correction = &correction
	return r
}

// Indicates the type of folio to be generated
func (r CashieringAPIGetFolioPrintersRequest) DebitFolio(debitFolio bool) CashieringAPIGetFolioPrintersRequest {
	r.debitFolio = &debitFolio
	return r
}

func (r CashieringAPIGetFolioPrintersRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIGetFolioPrintersRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Manual Folio Number used for settlement during checkout
func (r CashieringAPIGetFolioPrintersRequest) ManualFolioNo(manualFolioNo int32) CashieringAPIGetFolioPrintersRequest {
	r.manualFolioNo = &manualFolioNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetFolioPrintersRequest) CashierId(cashierId float32) CashieringAPIGetFolioPrintersRequest {
	r.cashierId = &cashierId
	return r
}

// Applicable for Fiscal Terminal. The ID of the terminal where the fiscal device is connected.
func (r CashieringAPIGetFolioPrintersRequest) FiscalTerminalId(fiscalTerminalId string) CashieringAPIGetFolioPrintersRequest {
	r.fiscalTerminalId = &fiscalTerminalId
	return r
}

// Event being generated by a Supplemental Folio.
func (r CashieringAPIGetFolioPrintersRequest) EventType(eventType string) CashieringAPIGetFolioPrintersRequest {
	r.eventType = &eventType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioPrintersRequest) Id(id string) CashieringAPIGetFolioPrintersRequest {
	r.id = &id
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioPrintersRequest) ProfileIdId(profileIdId string) CashieringAPIGetFolioPrintersRequest {
	r.profileIdId = &profileIdId
	return r
}

// Description of currency Code.
func (r CashieringAPIGetFolioPrintersRequest) CurrencyCode(currencyCode string) CashieringAPIGetFolioPrintersRequest {
	r.currencyCode = &currencyCode
	return r
}

// Description of exchange rate.
func (r CashieringAPIGetFolioPrintersRequest) ExchangeRate(exchangeRate float32) CashieringAPIGetFolioPrintersRequest {
	r.exchangeRate = &exchangeRate
	return r
}

// The bill number of the original bill for which the Credit Bill is being generated.
func (r CashieringAPIGetFolioPrintersRequest) AssociatedBillNumber(associatedBillNumber float32) CashieringAPIGetFolioPrintersRequest {
	r.associatedBillNumber = &associatedBillNumber
	return r
}

// The folio type of the original bill for which the Credit Bill is being generated.
func (r CashieringAPIGetFolioPrintersRequest) AssociatedBillFolioType(associatedBillFolioType string) CashieringAPIGetFolioPrintersRequest {
	r.associatedBillFolioType = &associatedBillFolioType
	return r
}

// The folio number queue(used in certain countries) of the original bill for which the Credit Bill is being generated.
func (r CashieringAPIGetFolioPrintersRequest) AssociatedBillQueueName(associatedBillQueueName string) CashieringAPIGetFolioPrintersRequest {
	r.associatedBillQueueName = &associatedBillQueueName
	return r
}

// The Fiscal Folio Bill Number(from a Fiscal System) of the original bill for which the Credit Bill is being generated.
func (r CashieringAPIGetFolioPrintersRequest) AssociatedBillFiscalBillNumber(associatedBillFiscalBillNumber string) CashieringAPIGetFolioPrintersRequest {
	r.associatedBillFiscalBillNumber = &associatedBillFiscalBillNumber
	return r
}

// The bill generation date of the original bill for which the Credit Bill is being generated.
func (r CashieringAPIGetFolioPrintersRequest) AssociatedBillGenerationDate(associatedBillGenerationDate string) CashieringAPIGetFolioPrintersRequest {
	r.associatedBillGenerationDate = &associatedBillGenerationDate
	return r
}

// Folio Type to be assigned to generated folio. This is a country requirement.
func (r CashieringAPIGetFolioPrintersRequest) FolioType(folioType string) CashieringAPIGetFolioPrintersRequest {
	r.folioType = &folioType
	return r
}

// Fiscal folio flag to call fiscal folio web service after folio generation.
func (r CashieringAPIGetFolioPrintersRequest) GenerateFiscalFolio(generateFiscalFolio bool) CashieringAPIGetFolioPrintersRequest {
	r.generateFiscalFolio = &generateFiscalFolio
	return r
}

// Folio Queue name.
func (r CashieringAPIGetFolioPrintersRequest) QueueName(queueName string) CashieringAPIGetFolioPrintersRequest {
	r.queueName = &queueName
	return r
}

// Fiscal Folio sequence ID stored in queue table.
func (r CashieringAPIGetFolioPrintersRequest) FolioSeqId(folioSeqId int32) CashieringAPIGetFolioPrintersRequest {
	r.folioSeqId = &folioSeqId
	return r
}

// Action to generate Offline folio when no reponse is received from fiscal service.
func (r CashieringAPIGetFolioPrintersRequest) FiscalFolioInstruction(fiscalFolioInstruction string) CashieringAPIGetFolioPrintersRequest {
	r.fiscalFolioInstruction = &fiscalFolioInstruction
	return r
}

// Contains transaction service type.
func (r CashieringAPIGetFolioPrintersRequest) TransactionServiceType(transactionServiceType string) CashieringAPIGetFolioPrintersRequest {
	r.transactionServiceType = &transactionServiceType
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioPrintersRequest) Amount(amount float32) CashieringAPIGetFolioPrintersRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioPrintersRequest) BalanceCurrencyCode(balanceCurrencyCode string) CashieringAPIGetFolioPrintersRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// External system code.
func (r CashieringAPIGetFolioPrintersRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioPrintersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioPrintersRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioPrintersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioPrintersRequest) Execute() (*FolioPrinters, *http.Response, error) {
	return r.ApiService.GetFolioPrintersExecute(r)
}

/*
GetFolioPrinters Get folio printers

You can use this API to get folio printers. <p><strong>OperationId:</strong>getFolioPrinters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioPrintersRequest
*/
func (a *CashieringAPIService) GetFolioPrinters(ctx context.Context, hotelId string) CashieringAPIGetFolioPrintersRequest {
	return CashieringAPIGetFolioPrintersRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioPrinters
func (a *CashieringAPIService) GetFolioPrintersExecute(r CashieringAPIGetFolioPrintersRequest) (*FolioPrinters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioPrinters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolioPrinters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioPrinters"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.allFolioWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allFolioWindow", r.allFolioWindow, "")
  }
	if r.correction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "correction", r.correction, "")
  }
	if r.debitFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "debitFolio", r.debitFolio, "")
  }
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
  }
	if r.manualFolioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualFolioNo", r.manualFolioNo, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.fiscalTerminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalTerminalId", r.fiscalTerminalId, "")
  }
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.exchangeRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeRate", r.exchangeRate, "")
  }
	if r.associatedBillNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillNumber", r.associatedBillNumber, "")
  }
	if r.associatedBillFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillFolioType", r.associatedBillFolioType, "")
  }
	if r.associatedBillQueueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillQueueName", r.associatedBillQueueName, "")
  }
	if r.associatedBillFiscalBillNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillFiscalBillNumber", r.associatedBillFiscalBillNumber, "")
  }
	if r.associatedBillGenerationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedBillGenerationDate", r.associatedBillGenerationDate, "")
  }
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
  }
	if r.generateFiscalFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateFiscalFolio", r.generateFiscalFolio, "")
  }
	if r.queueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", r.queueName, "")
  }
	if r.folioSeqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioSeqId", r.folioSeqId, "")
  }
	if r.fiscalFolioInstruction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalFolioInstruction", r.fiscalFolioInstruction, "")
  }
	if r.transactionServiceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionServiceType", r.transactionServiceType, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioTaxPaymentsInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioWindowNo *int32
	cashierId *float32
	description *string
	folioView *int32
	paymentMethod *string
	track2Data *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	id *string
	idContext *string
	type_ *string
	amount *float32
	currencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	uniqueIdIdContext *string
	uniqueIdType *string
	createDateTime *string
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *string
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	approvalCode *string
	originalAuthSequence *int32
	vendorTranId *string
	approvalAmountAmount *float32
	approvalAmountCurrencyCode *string
	postingAmountAmount *float32
	postingAmountCurrencyCode *string
	postingReference *string
	postingRemark *string
	comments *string
	applyCCSurcharge *bool
	manualPaymentTaxInfoFolioWindowNo *int32
	transactionCode *string
	transactionDate *string
	transactionDescription *string
	transactionNo *float32
	taxInvoiceNo *string
	paymentType *string
	manualPaymentTaxAmount *float32
	manualPaymentTaxCurrencyCode *string
	taxableAmountAmount *float32
	taxableAmountCurrencyCode *string
	nonTaxableAmountAmount *float32
	nonTaxableAmountCurrencyCode *string
	availableCreditAmount *float32
	availableCreditCurrencyCode *string
	paymentDate *string
	taxFolioWindowNo *[]int32
	taxTransactionCode *[]string
	taxTransactionDate *[]string
	taxTransactionDescription *[]string
	taxTransactionNo *[]float32
	taxTaxInvoiceNo *[]string
	taxPaymentType *[]string
	creditablePaymentTaxesAmount *float32
	creditablePaymentTaxesCurrencyCode *string
	creditablePaymentTaxableAmount *float32
	creditablePaymentTaxableCurrencyCode *string
	creditablePaymentNonTaxableAmount *float32
	creditablePaymentNonTaxableCurrencyCode *string
	availableTaxCreditAmount *float32
	availableTaxCreditCurrencyCode *string
	taxPaymentDate *[]string
	terminalId *string
	overrideInsufficientCC *bool
	changeDueAmount *float32
	changeDueAmountCurrencyCode *string
	overrideARCreditLimit *bool
	applyCurrencyTaxes *bool
	vATOffset *bool
	action *string
	reservationIdIdContext *string
	reservationIdType *string
	profileIdId *string
	profileIdIdContext *string
	profileIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Authorization(authorization string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) XAppKey(xAppKey string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) XHotelid(xHotelid string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CashierId(cashierId float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cashierId = &cashierId
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Description(description string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.description = &description
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) FolioView(folioView int32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.folioView = &folioView
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PaymentMethod(paymentMethod string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Track2 data for the card which would be sent to the CC vendor as part of the authorization.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Track2Data(track2Data string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.track2Data = &track2Data
	return r
}

// Attach the credit card to profile.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CardHolderName(cardHolderName string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CardNumber(cardNumber string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CardNumberLast4Digits(cardNumberLast4Digits string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CardNumberMasked(cardNumberMasked string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CardOrToken(cardOrToken string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CardType(cardType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ExpirationDate(expirationDate string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ExpirationDateExpired(expirationDateExpired bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ExpirationDateMasked(expirationDateMasked string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Processing(processing string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.processing = &processing
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Swiped(swiped bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) UserDefinedCardType(userDefinedCardType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Id(id string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) IdContext(idContext string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Type_(type_ string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.type_ = &type_
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Amount(amount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CurrencyCode(currencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) BalanceAmount(balanceAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) BalanceCurrencyCode(balanceCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Code(code int32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AmountAmount(amountAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AmountCurrencyCode(amountCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Percent(percent float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.percent = &percent
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) EmailFolio(emailFolio bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) UniqueIdId(uniqueIdId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) UniqueIdIdContext(uniqueIdIdContext string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) UniqueIdType(uniqueIdType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// Time stamp of the creation.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreateDateTime(createDateTime string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreatorId(creatorId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) EmailAddress(emailAddress string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) EmailFormat(emailFormat string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) LastModifierId(lastModifierId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) LastModifyDateTime(lastModifyDateTime string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) OrderSequence(orderSequence float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PrimaryInd(primaryInd bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PurgeDate(purgeDate string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) EmailType(emailType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TypeDescription(typeDescription string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.typeDescription = &typeDescription
	return r
}

// The approval code authenticates the authorization.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApprovalCode(approvalCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.approvalCode = &approvalCode
	return r
}

// Unique Authorization Sequence for the authorization and settlement.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) OriginalAuthSequence(originalAuthSequence int32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.originalAuthSequence = &originalAuthSequence
	return r
}

// Vendor transaction id for the authorization.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) VendorTranId(vendorTranId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.vendorTranId = &vendorTranId
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApprovalAmountAmount(approvalAmountAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountAmount = &approvalAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PostingAmountAmount(postingAmountAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.postingAmountAmount = &postingAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PostingAmountCurrencyCode(postingAmountCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.postingAmountCurrencyCode = &postingAmountCurrencyCode
	return r
}

// User-defined posting reference.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PostingReference(postingReference string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PostingRemark(postingRemark string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.postingRemark = &postingRemark
	return r
}

// User Defined Comments. Used for Deposit Payment postings.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Comments(comments string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.comments = &comments
	return r
}

// Flag to indicate if Credit Card Surcharge has to be applied to this payment, when the functionality for Credit Card Surcharge is available.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApplyCCSurcharge(applyCCSurcharge bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.applyCCSurcharge = &applyCCSurcharge
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ManualPaymentTaxInfoFolioWindowNo(manualPaymentTaxInfoFolioWindowNo int32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.manualPaymentTaxInfoFolioWindowNo = &manualPaymentTaxInfoFolioWindowNo
	return r
}

// Billing Transaction Code of the Payment.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TransactionCode(transactionCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.transactionCode = &transactionCode
	return r
}

// Transaction Date of the Payment.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TransactionDate(transactionDate string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.transactionDate = &transactionDate
	return r
}

// Billing Transaction Description.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TransactionDescription(transactionDescription string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Unique Transaction Identifier.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TransactionNo(transactionNo float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.transactionNo = &transactionNo
	return r
}

// The Tax Invoice for this payment.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxInvoiceNo(taxInvoiceNo string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxInvoiceNo = &taxInvoiceNo
	return r
}

// The types of Payment Tax transactions.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PaymentType(paymentType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.paymentType = &paymentType
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ManualPaymentTaxAmount(manualPaymentTaxAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.manualPaymentTaxAmount = &manualPaymentTaxAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ManualPaymentTaxCurrencyCode(manualPaymentTaxCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.manualPaymentTaxCurrencyCode = &manualPaymentTaxCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxableAmountAmount(taxableAmountAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxableAmountAmount = &taxableAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxableAmountCurrencyCode(taxableAmountCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxableAmountCurrencyCode = &taxableAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) NonTaxableAmountAmount(nonTaxableAmountAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.nonTaxableAmountAmount = &nonTaxableAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) NonTaxableAmountCurrencyCode(nonTaxableAmountCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.nonTaxableAmountCurrencyCode = &nonTaxableAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AvailableCreditAmount(availableCreditAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.availableCreditAmount = &availableCreditAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AvailableCreditCurrencyCode(availableCreditCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.availableCreditCurrencyCode = &availableCreditCurrencyCode
	return r
}

// The Payment Invoice date
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) PaymentDate(paymentDate string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.paymentDate = &paymentDate
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxFolioWindowNo(taxFolioWindowNo []int32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxFolioWindowNo = &taxFolioWindowNo
	return r
}

// Billing Transaction Code of the Payment.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxTransactionCode(taxTransactionCode []string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionCode = &taxTransactionCode
	return r
}

// Transaction Date of the Payment.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxTransactionDate(taxTransactionDate []string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionDate = &taxTransactionDate
	return r
}

// Billing Transaction Description.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxTransactionDescription(taxTransactionDescription []string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionDescription = &taxTransactionDescription
	return r
}

// Unique Transaction Identifier.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxTransactionNo(taxTransactionNo []float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxTransactionNo = &taxTransactionNo
	return r
}

// The Tax Invoice for this payment.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxTaxInvoiceNo(taxTaxInvoiceNo []string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxTaxInvoiceNo = &taxTaxInvoiceNo
	return r
}

// The types of Payment Tax transactions.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxPaymentType(taxPaymentType []string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxPaymentType = &taxPaymentType
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxesAmount(creditablePaymentTaxesAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxesAmount = &creditablePaymentTaxesAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxesCurrencyCode(creditablePaymentTaxesCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxesCurrencyCode = &creditablePaymentTaxesCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxableAmount(creditablePaymentTaxableAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxableAmount = &creditablePaymentTaxableAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreditablePaymentTaxableCurrencyCode(creditablePaymentTaxableCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentTaxableCurrencyCode = &creditablePaymentTaxableCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreditablePaymentNonTaxableAmount(creditablePaymentNonTaxableAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentNonTaxableAmount = &creditablePaymentNonTaxableAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) CreditablePaymentNonTaxableCurrencyCode(creditablePaymentNonTaxableCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.creditablePaymentNonTaxableCurrencyCode = &creditablePaymentNonTaxableCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AvailableTaxCreditAmount(availableTaxCreditAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.availableTaxCreditAmount = &availableTaxCreditAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AvailableTaxCreditCurrencyCode(availableTaxCreditCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.availableTaxCreditCurrencyCode = &availableTaxCreditCurrencyCode
	return r
}

// The Payment Invoice date
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TaxPaymentDate(taxPaymentDate []string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.taxPaymentDate = &taxPaymentDate
	return r
}

// Applicable for chip and pin. The ID of the terminal where the chip and pin device is connected and where the payment is made.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) TerminalId(terminalId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.terminalId = &terminalId
	return r
}

// Flag to allow a rebate by Credit Card
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) OverrideInsufficientCC(overrideInsufficientCC bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.overrideInsufficientCC = &overrideInsufficientCC
	return r
}

// A monetary amount.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ChangeDueAmount(changeDueAmount float32) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.changeDueAmount = &changeDueAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ChangeDueAmountCurrencyCode(changeDueAmountCurrencyCode string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.changeDueAmountCurrencyCode = &changeDueAmountCurrencyCode
	return r
}

// Flag to override account receivable credit limit
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) OverrideARCreditLimit(overrideARCreditLimit bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.overrideARCreditLimit = &overrideARCreditLimit
	return r
}

// Flag to indidcate if currency taxes need to be applied or not. For ex, in case of Chile, it depends upon nationality of the guest.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ApplyCurrencyTaxes(applyCurrencyTaxes bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.applyCurrencyTaxes = &applyCurrencyTaxes
	return r
}

// Flag to indidcate if currency taxes need to be applied or not. For ex, in case of Chile, it depends upon nationality of the guest.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) VATOffset(vATOffset bool) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.vATOffset = &vATOffset
	return r
}

// Payment action to know from where the payment has been made.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Action(action string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.action = &action
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ReservationIdIdContext(reservationIdIdContext string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ReservationIdType(reservationIdType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ProfileIdId(profileIdId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.profileIdId = &profileIdId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ProfileIdIdContext(profileIdIdContext string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.profileIdIdContext = &profileIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) ProfileIdType(profileIdType string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.profileIdType = &profileIdType
	return r
}

// External system code.
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioTaxPaymentsInfoRequest) Execute() (*FolioTaxPaymentsInfo, *http.Response, error) {
	return r.ApiService.GetFolioTaxPaymentsInfoExecute(r)
}

/*
GetFolioTaxPaymentsInfo Get folio tax payments information

You can use this API to get folio tax payments information. <p><strong>OperationId:</strong>getFolioTaxPaymentsInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioTaxPaymentsInfoRequest
*/
func (a *CashieringAPIService) GetFolioTaxPaymentsInfo(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetFolioTaxPaymentsInfoRequest {
	return CashieringAPIGetFolioTaxPaymentsInfoRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTaxPaymentsInfo
func (a *CashieringAPIService) GetFolioTaxPaymentsInfoExecute(r CashieringAPIGetFolioTaxPaymentsInfoRequest) (*FolioTaxPaymentsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTaxPaymentsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolioTaxPaymentsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/folioTaxPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
  }
	if r.track2Data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "track2Data", r.track2Data, "")
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
  }
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
  }
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
  }
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
  }
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
  }
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
  }
	if r.uniqueIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", r.uniqueIdIdContext, "")
  }
	if r.uniqueIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", r.uniqueIdType, "")
  }
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
  }
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
  }
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
  }
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
  }
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
  }
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
  }
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
  }
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
  }
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
  }
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
  }
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
  }
	if r.approvalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalCode", r.approvalCode, "")
  }
	if r.originalAuthSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAuthSequence", r.originalAuthSequence, "")
  }
	if r.vendorTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendorTranId", r.vendorTranId, "")
  }
	if r.approvalAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountAmount", r.approvalAmountAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.postingAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountAmount", r.postingAmountAmount, "")
  }
	if r.postingAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingAmountCurrencyCode", r.postingAmountCurrencyCode, "")
  }
	if r.postingReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", r.postingReference, "")
  }
	if r.postingRemark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", r.postingRemark, "")
  }
	if r.comments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comments", r.comments, "")
  }
	if r.applyCCSurcharge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applyCCSurcharge", r.applyCCSurcharge, "")
  }
	if r.manualPaymentTaxInfoFolioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPaymentTaxInfoFolioWindowNo", r.manualPaymentTaxInfoFolioWindowNo, "")
  }
	if r.transactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", r.transactionCode, "")
  }
	if r.transactionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", r.transactionDate, "")
  }
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
  }
	if r.transactionNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", r.transactionNo, "")
  }
	if r.taxInvoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxInvoiceNo", r.taxInvoiceNo, "")
  }
	if r.paymentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentType", r.paymentType, "")
  }
	if r.manualPaymentTaxAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPaymentTaxAmount", r.manualPaymentTaxAmount, "")
  }
	if r.manualPaymentTaxCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPaymentTaxCurrencyCode", r.manualPaymentTaxCurrencyCode, "")
  }
	if r.taxableAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxableAmountAmount", r.taxableAmountAmount, "")
  }
	if r.taxableAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxableAmountCurrencyCode", r.taxableAmountCurrencyCode, "")
  }
	if r.nonTaxableAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nonTaxableAmountAmount", r.nonTaxableAmountAmount, "")
  }
	if r.nonTaxableAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nonTaxableAmountCurrencyCode", r.nonTaxableAmountCurrencyCode, "")
  }
	if r.availableCreditAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableCreditAmount", r.availableCreditAmount, "")
  }
	if r.availableCreditCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableCreditCurrencyCode", r.availableCreditCurrencyCode, "")
  }
	if r.paymentDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentDate", r.paymentDate, "")
  }
	if r.taxFolioWindowNo != nil {
		t := *r.taxFolioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxFolioWindowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxFolioWindowNo", t, "multi")
		}
  }
	if r.taxTransactionCode != nil {
		t := *r.taxTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionCode", t, "multi")
		}
  }
	if r.taxTransactionDate != nil {
		t := *r.taxTransactionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDate", t, "multi")
		}
  }
	if r.taxTransactionDescription != nil {
		t := *r.taxTransactionDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionDescription", t, "multi")
		}
  }
	if r.taxTransactionNo != nil {
		t := *r.taxTransactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTransactionNo", t, "multi")
		}
  }
	if r.taxTaxInvoiceNo != nil {
		t := *r.taxTaxInvoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxTaxInvoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxTaxInvoiceNo", t, "multi")
		}
  }
	if r.taxPaymentType != nil {
		t := *r.taxPaymentType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentType", t, "multi")
		}
  }
	if r.creditablePaymentTaxesAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxesAmount", r.creditablePaymentTaxesAmount, "")
  }
	if r.creditablePaymentTaxesCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxesCurrencyCode", r.creditablePaymentTaxesCurrencyCode, "")
  }
	if r.creditablePaymentTaxableAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxableAmount", r.creditablePaymentTaxableAmount, "")
  }
	if r.creditablePaymentTaxableCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentTaxableCurrencyCode", r.creditablePaymentTaxableCurrencyCode, "")
  }
	if r.creditablePaymentNonTaxableAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentNonTaxableAmount", r.creditablePaymentNonTaxableAmount, "")
  }
	if r.creditablePaymentNonTaxableCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditablePaymentNonTaxableCurrencyCode", r.creditablePaymentNonTaxableCurrencyCode, "")
  }
	if r.availableTaxCreditAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableTaxCreditAmount", r.availableTaxCreditAmount, "")
  }
	if r.availableTaxCreditCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableTaxCreditCurrencyCode", r.availableTaxCreditCurrencyCode, "")
  }
	if r.taxPaymentDate != nil {
		t := *r.taxPaymentDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taxPaymentDate", t, "multi")
		}
  }
	if r.terminalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminalId", r.terminalId, "")
  }
	if r.overrideInsufficientCC != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideInsufficientCC", r.overrideInsufficientCC, "")
  }
	if r.changeDueAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeDueAmount", r.changeDueAmount, "")
  }
	if r.changeDueAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changeDueAmountCurrencyCode", r.changeDueAmountCurrencyCode, "")
  }
	if r.overrideARCreditLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideARCreditLimit", r.overrideARCreditLimit, "")
  }
	if r.applyCurrencyTaxes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applyCurrencyTaxes", r.applyCurrencyTaxes, "")
  }
	if r.vATOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vATOffset", r.vATOffset, "")
  }
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "")
  }
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
  }
	if r.profileIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdIdContext", r.profileIdIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioTransactionDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	transactionNo *[]float32
	includeExchangeInformation *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioTransactionDetailsRequest) Authorization(authorization string) CashieringAPIGetFolioTransactionDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioTransactionDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetFolioTransactionDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioTransactionDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetFolioTransactionDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if the automatically generated transactions, related to the main transaction number above, are also to be retrieved as part of this request.
func (r CashieringAPIGetFolioTransactionDetailsRequest) IncludeGenerates(includeGenerates bool) CashieringAPIGetFolioTransactionDetailsRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// Unique Transaction Number of the transaction(posting) for which details are required.
func (r CashieringAPIGetFolioTransactionDetailsRequest) TransactionNo(transactionNo []float32) CashieringAPIGetFolioTransactionDetailsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Flag to indicate what currency exchange information text needs to be included in response.
func (r CashieringAPIGetFolioTransactionDetailsRequest) IncludeExchangeInformation(includeExchangeInformation bool) CashieringAPIGetFolioTransactionDetailsRequest {
	r.includeExchangeInformation = &includeExchangeInformation
	return r
}

// External system code.
func (r CashieringAPIGetFolioTransactionDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioTransactionDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioTransactionDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioTransactionDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioTransactionDetailsRequest) Execute() (*FolioTransactionDetails, *http.Response, error) {
	return r.ApiService.GetFolioTransactionDetailsExecute(r)
}

/*
GetFolioTransactionDetails Get Folio Transaction Details

You can use this API to get Folio Transaction Details. <p><strong>OperationId:</strong>getFolioTransactionDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioTransactionDetailsRequest
*/
func (a *CashieringAPIService) GetFolioTransactionDetails(ctx context.Context, hotelId string) CashieringAPIGetFolioTransactionDetailsRequest {
	return CashieringAPIGetFolioTransactionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTransactionDetails
func (a *CashieringAPIService) GetFolioTransactionDetailsExecute(r CashieringAPIGetFolioTransactionDetailsRequest) (*FolioTransactionDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTransactionDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolioTransactionDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
  }
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
  }
	if r.includeExchangeInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExchangeInformation", r.includeExchangeInformation, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioTypeNameRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	internalFolioWindowId *string
	languageCode *string
	folioTypeName *string
	folioReportGroup *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioTypeNameRequest) Authorization(authorization string) CashieringAPIGetFolioTypeNameRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioTypeNameRequest) XAppKey(xAppKey string) CashieringAPIGetFolioTypeNameRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioTypeNameRequest) XHotelid(xHotelid string) CashieringAPIGetFolioTypeNameRequest {
	r.xHotelid = &xHotelid
	return r
}

// The internal folio window Id for the reservation to determine the guest language details.
func (r CashieringAPIGetFolioTypeNameRequest) InternalFolioWindowId(internalFolioWindowId string) CashieringAPIGetFolioTypeNameRequest {
	r.internalFolioWindowId = &internalFolioWindowId
	return r
}

// The Filter language code which will be used to retrieve the report name set for this language.
func (r CashieringAPIGetFolioTypeNameRequest) LanguageCode(languageCode string) CashieringAPIGetFolioTypeNameRequest {
	r.languageCode = &languageCode
	return r
}

// The Folio Type for which the details are requested.
func (r CashieringAPIGetFolioTypeNameRequest) FolioTypeName(folioTypeName string) CashieringAPIGetFolioTypeNameRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// The Folio Report Group name. The folio report will be defined under each group and based on where the folio has to be printed, Opera will pick up the correct folio report name to print.
func (r CashieringAPIGetFolioTypeNameRequest) FolioReportGroup(folioReportGroup string) CashieringAPIGetFolioTypeNameRequest {
	r.folioReportGroup = &folioReportGroup
	return r
}

// External system code.
func (r CashieringAPIGetFolioTypeNameRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioTypeNameRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioTypeNameRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioTypeNameRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioTypeNameRequest) Execute() (*FolioTypeNameInfo, *http.Response, error) {
	return r.ApiService.GetFolioTypeNameExecute(r)
}

/*
GetFolioTypeName Get Folio Type Name

You can use this API to get Folio Type Name. <p><strong>OperationId:</strong>getFolioTypeName</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioTypeNameRequest
*/
func (a *CashieringAPIService) GetFolioTypeName(ctx context.Context, hotelId string) CashieringAPIGetFolioTypeNameRequest {
	return CashieringAPIGetFolioTypeNameRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTypeNameInfo
func (a *CashieringAPIService) GetFolioTypeNameExecute(r CashieringAPIGetFolioTypeNameRequest) (*FolioTypeNameInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypeNameInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolioTypeName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioTypeNames"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.internalFolioWindowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowId", r.internalFolioWindowId, "")
  }
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "languageCode", r.languageCode, "")
  }
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
  }
	if r.folioReportGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioReportGroup", r.folioReportGroup, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetFolioTypesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeCompress *bool
	includeCredit *bool
	folioType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetFolioTypesRequest) Authorization(authorization string) CashieringAPIGetFolioTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetFolioTypesRequest) XAppKey(xAppKey string) CashieringAPIGetFolioTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetFolioTypesRequest) XHotelid(xHotelid string) CashieringAPIGetFolioTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Folio to be use for compress bills.
func (r CashieringAPIGetFolioTypesRequest) IncludeCompress(includeCompress bool) CashieringAPIGetFolioTypesRequest {
	r.includeCompress = &includeCompress
	return r
}

// Folio to be use for credit bills.
func (r CashieringAPIGetFolioTypesRequest) IncludeCredit(includeCredit bool) CashieringAPIGetFolioTypesRequest {
	r.includeCredit = &includeCredit
	return r
}

// Folio Type.
func (r CashieringAPIGetFolioTypesRequest) FolioType(folioType string) CashieringAPIGetFolioTypesRequest {
	r.folioType = &folioType
	return r
}

// External system code.
func (r CashieringAPIGetFolioTypesRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetFolioTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetFolioTypesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetFolioTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetFolioTypesRequest) Execute() (*FolioTypesInfo, *http.Response, error) {
	return r.ApiService.GetFolioTypesExecute(r)
}

/*
GetFolioTypes Get Folio Types

You can use this API to get Folio Types. <p><strong>OperationId:</strong>getFolioTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetFolioTypesRequest
*/
func (a *CashieringAPIService) GetFolioTypes(ctx context.Context, hotelId string) CashieringAPIGetFolioTypesRequest {
	return CashieringAPIGetFolioTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTypesInfo
func (a *CashieringAPIService) GetFolioTypesExecute(r CashieringAPIGetFolioTypesRequest) (*FolioTypesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTypesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetFolioTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folioTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeCompress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompress", r.includeCompress, "")
  }
	if r.includeCredit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCredit", r.includeCredit, "")
  }
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetGamingRequestStatusInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetGamingRequestStatusInfoRequest) Authorization(authorization string) CashieringAPIGetGamingRequestStatusInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetGamingRequestStatusInfoRequest) XAppKey(xAppKey string) CashieringAPIGetGamingRequestStatusInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetGamingRequestStatusInfoRequest) XHotelid(xHotelid string) CashieringAPIGetGamingRequestStatusInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIGetGamingRequestStatusInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetGamingRequestStatusInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetGamingRequestStatusInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetGamingRequestStatusInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetGamingRequestStatusInfoRequest) Execute() (*GamingRequestStatusInfo, *http.Response, error) {
	return r.ApiService.GetGamingRequestStatusInfoExecute(r)
}

/*
GetGamingRequestStatusInfo Get Gaming Request Status 

You can use this API to get Gaming Request Status Information. <p><strong>OperationId:</strong>getGamingRequestStatusInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetGamingRequestStatusInfoRequest
*/
func (a *CashieringAPIService) GetGamingRequestStatusInfo(ctx context.Context, transactionId string, hotelId string) CashieringAPIGetGamingRequestStatusInfoRequest {
	return CashieringAPIGetGamingRequestStatusInfoRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GamingRequestStatusInfo
func (a *CashieringAPIService) GetGamingRequestStatusInfoExecute(r CashieringAPIGetGamingRequestStatusInfoRequest) (*GamingRequestStatusInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GamingRequestStatusInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetGamingRequestStatusInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/compRequestStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetGuestsTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	reservationList *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	includeTransactionsWithARInvoiceNo *bool
	includeTransactionsWithFolioNo *bool
	includeTransactionsWithManualPostingOnly *bool
	idContext *[]string
	type_ *[]string
	transactionNo *[]float32
	transactionGroup *[]string
	transactionSubGroup *[]string
	billingCode *[]string
	billingHotelId *[]string
	desc *[]string
	routingInstructionsId *[]float32
	trxCodeWildCard *string
	trxDescriptionWildCard *string
	checkNumberWildCard *string
	referenceNumberWildCard *string
	supplementWildCard *string
	windowNo *[]int32
	cashieringTransactionType *[]string
	startDate *string
	endDate *string
	cashierId *float32
	code *[]string
	commissionable *bool
	serviceRecoveryAllowed *bool
	postedTransactionType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetGuestsTransactionsRequest) ReservationList(reservationList []string) CashieringAPIGetGuestsTransactionsRequest {
	r.reservationList = &reservationList
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetGuestsTransactionsRequest) Authorization(authorization string) CashieringAPIGetGuestsTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetGuestsTransactionsRequest) XAppKey(xAppKey string) CashieringAPIGetGuestsTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetGuestsTransactionsRequest) XHotelid(xHotelid string) CashieringAPIGetGuestsTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuring this flag to be TRUE will return transactions that are auto generated like taxes.
func (r CashieringAPIGetGuestsTransactionsRequest) IncludeGenerates(includeGenerates bool) CashieringAPIGetGuestsTransactionsRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// Configuring this flag to be TRUE will return transactions that are included in an Accounts Receivable invoice.
func (r CashieringAPIGetGuestsTransactionsRequest) IncludeTransactionsWithARInvoiceNo(includeTransactionsWithARInvoiceNo bool) CashieringAPIGetGuestsTransactionsRequest {
	r.includeTransactionsWithARInvoiceNo = &includeTransactionsWithARInvoiceNo
	return r
}

// Configuring this flag to be TRUE will return transactions that already belongs to a folio.
func (r CashieringAPIGetGuestsTransactionsRequest) IncludeTransactionsWithFolioNo(includeTransactionsWithFolioNo bool) CashieringAPIGetGuestsTransactionsRequest {
	r.includeTransactionsWithFolioNo = &includeTransactionsWithFolioNo
	return r
}

// Configuring this flag to be TRUE will return transactions whose transaction codes have manual posting enabled, or when an adjustment code is attached to the transaction code, the adjustment code&#39;s manual posting is enabled.
func (r CashieringAPIGetGuestsTransactionsRequest) IncludeTransactionsWithManualPostingOnly(includeTransactionsWithManualPostingOnly bool) CashieringAPIGetGuestsTransactionsRequest {
	r.includeTransactionsWithManualPostingOnly = &includeTransactionsWithManualPostingOnly
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetGuestsTransactionsRequest) IdContext(idContext []string) CashieringAPIGetGuestsTransactionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetGuestsTransactionsRequest) Type_(type_ []string) CashieringAPIGetGuestsTransactionsRequest {
	r.type_ = &type_
	return r
}

// Transaction number of the payment being corrected.
func (r CashieringAPIGetGuestsTransactionsRequest) TransactionNo(transactionNo []float32) CashieringAPIGetGuestsTransactionsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Category of the transaction code to filter the result.
func (r CashieringAPIGetGuestsTransactionsRequest) TransactionGroup(transactionGroup []string) CashieringAPIGetGuestsTransactionsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code to filter the result.
func (r CashieringAPIGetGuestsTransactionsRequest) TransactionSubGroup(transactionSubGroup []string) CashieringAPIGetGuestsTransactionsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique identifier for the Billing Instruction.
func (r CashieringAPIGetGuestsTransactionsRequest) BillingCode(billingCode []string) CashieringAPIGetGuestsTransactionsRequest {
	r.billingCode = &billingCode
	return r
}

// Hotel context of the Billing Instruction.
func (r CashieringAPIGetGuestsTransactionsRequest) BillingHotelId(billingHotelId []string) CashieringAPIGetGuestsTransactionsRequest {
	r.billingHotelId = &billingHotelId
	return r
}

// Billing Instruction code description.
func (r CashieringAPIGetGuestsTransactionsRequest) Desc(desc []string) CashieringAPIGetGuestsTransactionsRequest {
	r.desc = &desc
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r CashieringAPIGetGuestsTransactionsRequest) RoutingInstructionsId(routingInstructionsId []float32) CashieringAPIGetGuestsTransactionsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Lookup string which will try to match an existing Transaction Code/s.
func (r CashieringAPIGetGuestsTransactionsRequest) TrxCodeWildCard(trxCodeWildCard string) CashieringAPIGetGuestsTransactionsRequest {
	r.trxCodeWildCard = &trxCodeWildCard
	return r
}

// Lookup string which will try to match an existing Transaction Code&#39;s Description.
func (r CashieringAPIGetGuestsTransactionsRequest) TrxDescriptionWildCard(trxDescriptionWildCard string) CashieringAPIGetGuestsTransactionsRequest {
	r.trxDescriptionWildCard = &trxDescriptionWildCard
	return r
}

// Lookup string which will try to match an existing Cheque number&#39;s code.
func (r CashieringAPIGetGuestsTransactionsRequest) CheckNumberWildCard(checkNumberWildCard string) CashieringAPIGetGuestsTransactionsRequest {
	r.checkNumberWildCard = &checkNumberWildCard
	return r
}

// Filters the results for reference number.
func (r CashieringAPIGetGuestsTransactionsRequest) ReferenceNumberWildCard(referenceNumberWildCard string) CashieringAPIGetGuestsTransactionsRequest {
	r.referenceNumberWildCard = &referenceNumberWildCard
	return r
}

// Filter the results for supplement.
func (r CashieringAPIGetGuestsTransactionsRequest) SupplementWildCard(supplementWildCard string) CashieringAPIGetGuestsTransactionsRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// Filters the result to only include transactions in this window number.
func (r CashieringAPIGetGuestsTransactionsRequest) WindowNo(windowNo []int32) CashieringAPIGetGuestsTransactionsRequest {
	r.windowNo = &windowNo
	return r
}

// Wrapper Transaction Type.
func (r CashieringAPIGetGuestsTransactionsRequest) CashieringTransactionType(cashieringTransactionType []string) CashieringAPIGetGuestsTransactionsRequest {
	r.cashieringTransactionType = &cashieringTransactionType
	return r
}

func (r CashieringAPIGetGuestsTransactionsRequest) StartDate(startDate string) CashieringAPIGetGuestsTransactionsRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetGuestsTransactionsRequest) EndDate(endDate string) CashieringAPIGetGuestsTransactionsRequest {
	r.endDate = &endDate
	return r
}

// Cashier Id of the Cashier.
func (r CashieringAPIGetGuestsTransactionsRequest) CashierId(cashierId float32) CashieringAPIGetGuestsTransactionsRequest {
	r.cashierId = &cashierId
	return r
}

func (r CashieringAPIGetGuestsTransactionsRequest) Code(code []string) CashieringAPIGetGuestsTransactionsRequest {
	r.code = &code
	return r
}

// Filters the result based on its commission property. Do not set this criteria if all transactions should be included whether or not they are commissionable.
func (r CashieringAPIGetGuestsTransactionsRequest) Commissionable(commissionable bool) CashieringAPIGetGuestsTransactionsRequest {
	r.commissionable = &commissionable
	return r
}

// Filters the result which are allow for service recovery.
func (r CashieringAPIGetGuestsTransactionsRequest) ServiceRecoveryAllowed(serviceRecoveryAllowed bool) CashieringAPIGetGuestsTransactionsRequest {
	r.serviceRecoveryAllowed = &serviceRecoveryAllowed
	return r
}

// Returns only postings without bill number.
func (r CashieringAPIGetGuestsTransactionsRequest) PostedTransactionType(postedTransactionType []string) CashieringAPIGetGuestsTransactionsRequest {
	r.postedTransactionType = &postedTransactionType
	return r
}

// External system code.
func (r CashieringAPIGetGuestsTransactionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetGuestsTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetGuestsTransactionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetGuestsTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetGuestsTransactionsRequest) Execute() (*GuestsTransactions, *http.Response, error) {
	return r.ApiService.GetGuestsTransactionsExecute(r)
}

/*
GetGuestsTransactions Get Guests Transactions

You can use this API to get  Guests Transactions. <p><strong>OperationId:</strong>getGuestsTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetGuestsTransactionsRequest
*/
func (a *CashieringAPIService) GetGuestsTransactions(ctx context.Context, hotelId string) CashieringAPIGetGuestsTransactionsRequest {
	return CashieringAPIGetGuestsTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestsTransactions
func (a *CashieringAPIService) GetGuestsTransactionsExecute(r CashieringAPIGetGuestsTransactionsRequest) (*GuestsTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestsTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetGuestsTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.reservationList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationList", t, "multi")
		}
	}
	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
  }
	if r.includeTransactionsWithARInvoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionsWithARInvoiceNo", r.includeTransactionsWithARInvoiceNo, "")
  }
	if r.includeTransactionsWithFolioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionsWithFolioNo", r.includeTransactionsWithFolioNo, "")
  }
	if r.includeTransactionsWithManualPostingOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTransactionsWithManualPostingOnly", r.includeTransactionsWithManualPostingOnly, "")
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
  }
	if r.transactionGroup != nil {
		t := *r.transactionGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", t, "multi")
		}
  }
	if r.transactionSubGroup != nil {
		t := *r.transactionSubGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", t, "multi")
		}
  }
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
  }
	if r.billingHotelId != nil {
		t := *r.billingHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", t, "multi")
		}
  }
	if r.desc != nil {
		t := *r.desc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "desc", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "desc", t, "multi")
		}
  }
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
  }
	if r.trxCodeWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxCodeWildCard", r.trxCodeWildCard, "")
  }
	if r.trxDescriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxDescriptionWildCard", r.trxDescriptionWildCard, "")
  }
	if r.checkNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumberWildCard", r.checkNumberWildCard, "")
  }
	if r.referenceNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNumberWildCard", r.referenceNumberWildCard, "")
  }
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
  }
	if r.windowNo != nil {
		t := *r.windowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "windowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "windowNo", t, "multi")
		}
  }
	if r.cashieringTransactionType != nil {
		t := *r.cashieringTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "cashieringTransactionType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "cashieringTransactionType", t, "multi")
		}
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.commissionable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "commissionable", r.commissionable, "")
  }
	if r.serviceRecoveryAllowed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRecoveryAllowed", r.serviceRecoveryAllowed, "")
  }
	if r.postedTransactionType != nil {
		t := *r.postedTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postedTransactionType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postedTransactionType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetHotelCreditCardWalletRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetHotelCreditCardWalletRequest) Authorization(authorization string) CashieringAPIGetHotelCreditCardWalletRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetHotelCreditCardWalletRequest) XAppKey(xAppKey string) CashieringAPIGetHotelCreditCardWalletRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetHotelCreditCardWalletRequest) XHotelid(xHotelid string) CashieringAPIGetHotelCreditCardWalletRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIGetHotelCreditCardWalletRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetHotelCreditCardWalletRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetHotelCreditCardWalletRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetHotelCreditCardWalletRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetHotelCreditCardWalletRequest) Execute() (*CreditCardWallet, *http.Response, error) {
	return r.ApiService.GetHotelCreditCardWalletExecute(r)
}

/*
GetHotelCreditCardWallet credit card wallet

This API is used to fetch the credit card wallet from the specified hotel and profile. <p><strong>OperationId: getHotelCreditCardWallet</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @param profileId Unique ID of the profile
 @return CashieringAPIGetHotelCreditCardWalletRequest
*/
func (a *CashieringAPIService) GetHotelCreditCardWallet(ctx context.Context, hotelId string, profileId string) CashieringAPIGetHotelCreditCardWalletRequest {
	return CashieringAPIGetHotelCreditCardWalletRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return CreditCardWallet
func (a *CashieringAPIService) GetHotelCreditCardWalletExecute(r CashieringAPIGetHotelCreditCardWalletRequest) (*CreditCardWallet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditCardWallet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetHotelCreditCardWallet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/creditCardWallet"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetHotelRevenueRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	businessDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetHotelRevenueRequest) Authorization(authorization string) CashieringAPIGetHotelRevenueRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetHotelRevenueRequest) XAppKey(xAppKey string) CashieringAPIGetHotelRevenueRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetHotelRevenueRequest) XHotelid(xHotelid string) CashieringAPIGetHotelRevenueRequest {
	r.xHotelid = &xHotelid
	return r
}

// Business date.
func (r CashieringAPIGetHotelRevenueRequest) BusinessDate(businessDate string) CashieringAPIGetHotelRevenueRequest {
	r.businessDate = &businessDate
	return r
}

// External system code.
func (r CashieringAPIGetHotelRevenueRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetHotelRevenueRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetHotelRevenueRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetHotelRevenueRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetHotelRevenueRequest) Execute() (*HotelRevenueDetails, *http.Response, error) {
	return r.ApiService.GetHotelRevenueExecute(r)
}

/*
GetHotelRevenue Get Hotel Revenue

You can use this API to get Hotel Revenue. <p><strong>OperationId:</strong>getHotelRevenue</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetHotelRevenueRequest
*/
func (a *CashieringAPIService) GetHotelRevenue(ctx context.Context, hotelId string) CashieringAPIGetHotelRevenueRequest {
	return CashieringAPIGetHotelRevenueRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelRevenueDetails
func (a *CashieringAPIService) GetHotelRevenueExecute(r CashieringAPIGetHotelRevenueRequest) (*HotelRevenueDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelRevenueDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetHotelRevenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/revenue"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.businessDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessDate", r.businessDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetMaturedDepositsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetMaturedDepositsRequest) Authorization(authorization string) CashieringAPIGetMaturedDepositsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetMaturedDepositsRequest) XAppKey(xAppKey string) CashieringAPIGetMaturedDepositsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetMaturedDepositsRequest) XHotelid(xHotelid string) CashieringAPIGetMaturedDepositsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIGetMaturedDepositsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetMaturedDepositsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetMaturedDepositsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetMaturedDepositsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetMaturedDepositsRequest) Execute() (*MaturedDepositsDetails, *http.Response, error) {
	return r.ApiService.GetMaturedDepositsExecute(r)
}

/*
GetMaturedDeposits Get matured deposits

You can use this API to fetch matured deposits. <p><strong>OperationId:</strong>getMaturedDeposits</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetMaturedDepositsRequest
*/
func (a *CashieringAPIService) GetMaturedDeposits(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetMaturedDepositsRequest {
	return CashieringAPIGetMaturedDepositsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MaturedDepositsDetails
func (a *CashieringAPIService) GetMaturedDepositsExecute(r CashieringAPIGetMaturedDepositsRequest) (*MaturedDepositsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MaturedDepositsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetMaturedDeposits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetPostBillingChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierId *float32
	folioWindowNo *[]int32
	chargeCashierId *[]float32
	transactionCode *[]string
	articleCode *[]string
	amount *float32
	currencyCode *string
	postingQuantity *[]int32
	postingReference *[]string
	postingRemark *[]string
	checkNumber *[]string
	arrangementCode *[]string
	applyRoutingInstructions *[]bool
	usePackageAllowance *[]bool
	autoPosting *[]bool
	id *[]string
	idContext *[]string
	type_ *[]string
	reservationIdIdContext *string
	reservationIdType *string
	option *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetPostBillingChargesRequest) Authorization(authorization string) CashieringAPIGetPostBillingChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetPostBillingChargesRequest) XAppKey(xAppKey string) CashieringAPIGetPostBillingChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetPostBillingChargesRequest) XHotelid(xHotelid string) CashieringAPIGetPostBillingChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetPostBillingChargesRequest) CashierId(cashierId float32) CashieringAPIGetPostBillingChargesRequest {
	r.cashierId = &cashierId
	return r
}

func (r CashieringAPIGetPostBillingChargesRequest) FolioWindowNo(folioWindowNo []int32) CashieringAPIGetPostBillingChargesRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetPostBillingChargesRequest) ChargeCashierId(chargeCashierId []float32) CashieringAPIGetPostBillingChargesRequest {
	r.chargeCashierId = &chargeCashierId
	return r
}

// Transaction Code to post.
func (r CashieringAPIGetPostBillingChargesRequest) TransactionCode(transactionCode []string) CashieringAPIGetPostBillingChargesRequest {
	r.transactionCode = &transactionCode
	return r
}

// Article ID.
func (r CashieringAPIGetPostBillingChargesRequest) ArticleCode(articleCode []string) CashieringAPIGetPostBillingChargesRequest {
	r.articleCode = &articleCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetPostBillingChargesRequest) Amount(amount float32) CashieringAPIGetPostBillingChargesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetPostBillingChargesRequest) CurrencyCode(currencyCode string) CashieringAPIGetPostBillingChargesRequest {
	r.currencyCode = &currencyCode
	return r
}

// Quantity to post to the folio.
func (r CashieringAPIGetPostBillingChargesRequest) PostingQuantity(postingQuantity []int32) CashieringAPIGetPostBillingChargesRequest {
	r.postingQuantity = &postingQuantity
	return r
}

// User-defined posting reference.
func (r CashieringAPIGetPostBillingChargesRequest) PostingReference(postingReference []string) CashieringAPIGetPostBillingChargesRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r CashieringAPIGetPostBillingChargesRequest) PostingRemark(postingRemark []string) CashieringAPIGetPostBillingChargesRequest {
	r.postingRemark = &postingRemark
	return r
}

// Indicates the Cheque number.
func (r CashieringAPIGetPostBillingChargesRequest) CheckNumber(checkNumber []string) CashieringAPIGetPostBillingChargesRequest {
	r.checkNumber = &checkNumber
	return r
}

// Corrected arrangement code from the package associated to this transaction.
func (r CashieringAPIGetPostBillingChargesRequest) ArrangementCode(arrangementCode []string) CashieringAPIGetPostBillingChargesRequest {
	r.arrangementCode = &arrangementCode
	return r
}

// Apply room routing when making this posting.
func (r CashieringAPIGetPostBillingChargesRequest) ApplyRoutingInstructions(applyRoutingInstructions []bool) CashieringAPIGetPostBillingChargesRequest {
	r.applyRoutingInstructions = &applyRoutingInstructions
	return r
}

// Use the applicable package allowance when making this posting.
func (r CashieringAPIGetPostBillingChargesRequest) UsePackageAllowance(usePackageAllowance []bool) CashieringAPIGetPostBillingChargesRequest {
	r.usePackageAllowance = &usePackageAllowance
	return r
}

// True indicates the Transaction Code is allowed to be posted automatically.
func (r CashieringAPIGetPostBillingChargesRequest) AutoPosting(autoPosting []bool) CashieringAPIGetPostBillingChargesRequest {
	r.autoPosting = &autoPosting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetPostBillingChargesRequest) Id(id []string) CashieringAPIGetPostBillingChargesRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetPostBillingChargesRequest) IdContext(idContext []string) CashieringAPIGetPostBillingChargesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetPostBillingChargesRequest) Type_(type_ []string) CashieringAPIGetPostBillingChargesRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetPostBillingChargesRequest) ReservationIdIdContext(reservationIdIdContext string) CashieringAPIGetPostBillingChargesRequest {
	r.reservationIdIdContext = &reservationIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetPostBillingChargesRequest) ReservationIdType(reservationIdType string) CashieringAPIGetPostBillingChargesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// This is the Default option. Operation checks if charges can be posted to the reservation based on the status of the reservation.
func (r CashieringAPIGetPostBillingChargesRequest) Option(option []string) CashieringAPIGetPostBillingChargesRequest {
	r.option = &option
	return r
}

// External system code.
func (r CashieringAPIGetPostBillingChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetPostBillingChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetPostBillingChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetPostBillingChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetPostBillingChargesRequest) Execute() (*BillingChargesStatus, *http.Response, error) {
	return r.ApiService.GetPostBillingChargesExecute(r)
}

/*
GetPostBillingCharges Get Billing Charges

You can use this API to get post Billing Charges. <p><strong>OperationId:</strong>getPostBillingCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetPostBillingChargesRequest
*/
func (a *CashieringAPIService) GetPostBillingCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetPostBillingChargesRequest {
	return CashieringAPIGetPostBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingChargesStatus
func (a *CashieringAPIService) GetPostBillingChargesExecute(r CashieringAPIGetPostBillingChargesRequest) (*BillingChargesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetPostBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
  }
	if r.chargeCashierId != nil {
		t := *r.chargeCashierId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.postingQuantity != nil {
		t := *r.postingQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", t, "multi")
		}
  }
	if r.postingReference != nil {
		t := *r.postingReference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", t, "multi")
		}
  }
	if r.postingRemark != nil {
		t := *r.postingRemark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", t, "multi")
		}
  }
	if r.checkNumber != nil {
		t := *r.checkNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", t, "multi")
		}
  }
	if r.arrangementCode != nil {
		t := *r.arrangementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", t, "multi")
		}
  }
	if r.applyRoutingInstructions != nil {
		t := *r.applyRoutingInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", t, "multi")
		}
  }
	if r.usePackageAllowance != nil {
		t := *r.usePackageAllowance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", t, "multi")
		}
  }
	if r.autoPosting != nil {
		t := *r.autoPosting
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", t, "multi")
		}
  }
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.reservationIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdIdContext", r.reservationIdIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.option != nil {
		t := *r.option
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "option", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "option", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetPostingActivityDetailRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	module *string
	logDate *string
	refActionId *float32
	logUserId *int32
	logUserName *string
	machineStation *string
	croCode *string
	actionType *string
	actionDescription *string
	iPAddress *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetPostingActivityDetailRequest) Authorization(authorization string) CashieringAPIGetPostingActivityDetailRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetPostingActivityDetailRequest) XAppKey(xAppKey string) CashieringAPIGetPostingActivityDetailRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetPostingActivityDetailRequest) XHotelid(xHotelid string) CashieringAPIGetPostingActivityDetailRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetPostingActivityDetailRequest) IdContext(idContext string) CashieringAPIGetPostingActivityDetailRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetPostingActivityDetailRequest) Type_(type_ string) CashieringAPIGetPostingActivityDetailRequest {
	r.type_ = &type_
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) Module(module string) CashieringAPIGetPostingActivityDetailRequest {
	r.module = &module
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) LogDate(logDate string) CashieringAPIGetPostingActivityDetailRequest {
	r.logDate = &logDate
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) RefActionId(refActionId float32) CashieringAPIGetPostingActivityDetailRequest {
	r.refActionId = &refActionId
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) LogUserId(logUserId int32) CashieringAPIGetPostingActivityDetailRequest {
	r.logUserId = &logUserId
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) LogUserName(logUserName string) CashieringAPIGetPostingActivityDetailRequest {
	r.logUserName = &logUserName
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) MachineStation(machineStation string) CashieringAPIGetPostingActivityDetailRequest {
	r.machineStation = &machineStation
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) CroCode(croCode string) CashieringAPIGetPostingActivityDetailRequest {
	r.croCode = &croCode
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) ActionType(actionType string) CashieringAPIGetPostingActivityDetailRequest {
	r.actionType = &actionType
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) ActionDescription(actionDescription string) CashieringAPIGetPostingActivityDetailRequest {
	r.actionDescription = &actionDescription
	return r
}

// The IP Address of the machine that performed the activity
func (r CashieringAPIGetPostingActivityDetailRequest) IPAddress(iPAddress string) CashieringAPIGetPostingActivityDetailRequest {
	r.iPAddress = &iPAddress
	return r
}

// External system code.
func (r CashieringAPIGetPostingActivityDetailRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetPostingActivityDetailRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetPostingActivityDetailRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetPostingActivityDetailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetPostingActivityDetailRequest) Execute() (*PostingActivityDetail, *http.Response, error) {
	return r.ApiService.GetPostingActivityDetailExecute(r)
}

/*
GetPostingActivityDetail Get posting activity details

You can use this API to get posting activity details. <p><strong>OperationId:</strong>getPostingActivityDetail</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetPostingActivityDetailRequest
*/
func (a *CashieringAPIService) GetPostingActivityDetail(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetPostingActivityDetailRequest {
	return CashieringAPIGetPostingActivityDetailRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostingActivityDetail
func (a *CashieringAPIService) GetPostingActivityDetailExecute(r CashieringAPIGetPostingActivityDetailRequest) (*PostingActivityDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostingActivityDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetPostingActivityDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/postingActivities"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
  }
	if r.logDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logDate", r.logDate, "")
  }
	if r.refActionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refActionId", r.refActionId, "")
  }
	if r.logUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logUserId", r.logUserId, "")
  }
	if r.logUserName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logUserName", r.logUserName, "")
  }
	if r.machineStation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "machineStation", r.machineStation, "")
  }
	if r.croCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "croCode", r.croCode, "")
  }
	if r.actionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "")
  }
	if r.actionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionDescription", r.actionDescription, "")
  }
	if r.iPAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iPAddress", r.iPAddress, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetPostingSummaryRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeGenerates *bool
	postingDate *string
	checkPostings *bool
	postingsByExternalSystem *bool
	cashierId *float32
	currency *string
	postingSummaryType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetPostingSummaryRequest) Authorization(authorization string) CashieringAPIGetPostingSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetPostingSummaryRequest) XAppKey(xAppKey string) CashieringAPIGetPostingSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetPostingSummaryRequest) XHotelid(xHotelid string) CashieringAPIGetPostingSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuring this flag to be TRUE will return transactions that are auto generated like taxes.
func (r CashieringAPIGetPostingSummaryRequest) IncludeGenerates(includeGenerates bool) CashieringAPIGetPostingSummaryRequest {
	r.includeGenerates = &includeGenerates
	return r
}

// The date on which the charge is posted.
func (r CashieringAPIGetPostingSummaryRequest) PostingDate(postingDate string) CashieringAPIGetPostingSummaryRequest {
	r.postingDate = &postingDate
	return r
}

// When set to true,the summary of only the postings using checks will be fetched.
func (r CashieringAPIGetPostingSummaryRequest) CheckPostings(checkPostings bool) CashieringAPIGetPostingSummaryRequest {
	r.checkPostings = &checkPostings
	return r
}

// When set to true,the summary of only the postings done by external systems will be fetched.
func (r CashieringAPIGetPostingSummaryRequest) PostingsByExternalSystem(postingsByExternalSystem bool) CashieringAPIGetPostingSummaryRequest {
	r.postingsByExternalSystem = &postingsByExternalSystem
	return r
}

// Cashier Id of the Cashier.
func (r CashieringAPIGetPostingSummaryRequest) CashierId(cashierId float32) CashieringAPIGetPostingSummaryRequest {
	r.cashierId = &cashierId
	return r
}

// Currency in which the postings are done. If null,amounts posted in local currency will be fetched.
func (r CashieringAPIGetPostingSummaryRequest) Currency(currency string) CashieringAPIGetPostingSummaryRequest {
	r.currency = &currency
	return r
}

// Enumeration Type of Posting Summary Information.
func (r CashieringAPIGetPostingSummaryRequest) PostingSummaryType(postingSummaryType string) CashieringAPIGetPostingSummaryRequest {
	r.postingSummaryType = &postingSummaryType
	return r
}

// External system code.
func (r CashieringAPIGetPostingSummaryRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetPostingSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetPostingSummaryRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetPostingSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetPostingSummaryRequest) Execute() (*PostingSummaryList, *http.Response, error) {
	return r.ApiService.GetPostingSummaryExecute(r)
}

/*
GetPostingSummary Get Posting Summary

You can use this API to get posting Summary. <p><strong>OperationId:</strong>getPostingSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetPostingSummaryRequest
*/
func (a *CashieringAPIService) GetPostingSummary(ctx context.Context, hotelId string) CashieringAPIGetPostingSummaryRequest {
	return CashieringAPIGetPostingSummaryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostingSummaryList
func (a *CashieringAPIService) GetPostingSummaryExecute(r CashieringAPIGetPostingSummaryRequest) (*PostingSummaryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostingSummaryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetPostingSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/postingDates/date/postingSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeGenerates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGenerates", r.includeGenerates, "")
  }
	if r.postingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", r.postingDate, "")
  }
	if r.checkPostings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkPostings", r.checkPostings, "")
  }
	if r.postingsByExternalSystem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingsByExternalSystem", r.postingsByExternalSystem, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
  }
	if r.postingSummaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingSummaryType", r.postingSummaryType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetPostingsForRefreshRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	targetReservationId string
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	targetResvNameIdContext *string
	targetResvNameIdType *string
	daily *bool
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	startDate *string
	endDate *string
	transactionHotelId *[]string
	printTrxReceipt *[]bool
	transactionCode *[]string
	description *[]string
	transactionGroup *[]string
	transactionSubGroup *[]string
	universalProductCode *[]string
	routingInstructionsId *[]float32
	articleCode *[]string
	articleHotelId *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	articleTransactionCode *[]string
	amount *float32
	currencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	billingCode *[]string
	billingHotelId *[]string
	desc *[]string
	billingInstructionRoutingInstructionsId *[]float32
	creditLimit *float32
	percentageLimit *float32
	covers *float32
	limitUsed *float32
	id *string
	routingLinkIdIdContext *string
	routingLinkIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetPostingsForRefreshRequest) Authorization(authorization string) CashieringAPIGetPostingsForRefreshRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetPostingsForRefreshRequest) XAppKey(xAppKey string) CashieringAPIGetPostingsForRefreshRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetPostingsForRefreshRequest) XHotelid(xHotelid string) CashieringAPIGetPostingsForRefreshRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetPostingsForRefreshRequest) IdContext(idContext string) CashieringAPIGetPostingsForRefreshRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetPostingsForRefreshRequest) Type_(type_ string) CashieringAPIGetPostingsForRefreshRequest {
	r.type_ = &type_
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetPostingsForRefreshRequest) TargetResvNameIdContext(targetResvNameIdContext string) CashieringAPIGetPostingsForRefreshRequest {
	r.targetResvNameIdContext = &targetResvNameIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetPostingsForRefreshRequest) TargetResvNameIdType(targetResvNameIdType string) CashieringAPIGetPostingsForRefreshRequest {
	r.targetResvNameIdType = &targetResvNameIdType
	return r
}

// Flag to indicate if the routing instruction is a daily instruction.
func (r CashieringAPIGetPostingsForRefreshRequest) Daily(daily bool) CashieringAPIGetPostingsForRefreshRequest {
	r.daily = &daily
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Friday(friday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.friday = &friday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Monday(monday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.monday = &monday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Saturday(saturday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.saturday = &saturday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Sunday(sunday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.sunday = &sunday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Thursday(thursday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.thursday = &thursday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Tuesday(tuesday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.tuesday = &tuesday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Wednesday(wednesday bool) CashieringAPIGetPostingsForRefreshRequest {
	r.wednesday = &wednesday
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) StartDate(startDate string) CashieringAPIGetPostingsForRefreshRequest {
	r.startDate = &startDate
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) EndDate(endDate string) CashieringAPIGetPostingsForRefreshRequest {
	r.endDate = &endDate
	return r
}

// Hotel context of the Transaction code.
func (r CashieringAPIGetPostingsForRefreshRequest) TransactionHotelId(transactionHotelId []string) CashieringAPIGetPostingsForRefreshRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r CashieringAPIGetPostingsForRefreshRequest) PrintTrxReceipt(printTrxReceipt []bool) CashieringAPIGetPostingsForRefreshRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r CashieringAPIGetPostingsForRefreshRequest) TransactionCode(transactionCode []string) CashieringAPIGetPostingsForRefreshRequest {
	r.transactionCode = &transactionCode
	return r
}

// Transaction codes info.
func (r CashieringAPIGetPostingsForRefreshRequest) Description(description []string) CashieringAPIGetPostingsForRefreshRequest {
	r.description = &description
	return r
}

// Category of the transaction code.
func (r CashieringAPIGetPostingsForRefreshRequest) TransactionGroup(transactionGroup []string) CashieringAPIGetPostingsForRefreshRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r CashieringAPIGetPostingsForRefreshRequest) TransactionSubGroup(transactionSubGroup []string) CashieringAPIGetPostingsForRefreshRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r CashieringAPIGetPostingsForRefreshRequest) UniversalProductCode(universalProductCode []string) CashieringAPIGetPostingsForRefreshRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r CashieringAPIGetPostingsForRefreshRequest) RoutingInstructionsId(routingInstructionsId []float32) CashieringAPIGetPostingsForRefreshRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r CashieringAPIGetPostingsForRefreshRequest) ArticleCode(articleCode []string) CashieringAPIGetPostingsForRefreshRequest {
	r.articleCode = &articleCode
	return r
}

// Hotel code to which the article belongs.
func (r CashieringAPIGetPostingsForRefreshRequest) ArticleHotelId(articleHotelId []string) CashieringAPIGetPostingsForRefreshRequest {
	r.articleHotelId = &articleHotelId
	return r
}

// Indicates whether the article is inactive or not.
func (r CashieringAPIGetPostingsForRefreshRequest) Inactive(inactive []bool) CashieringAPIGetPostingsForRefreshRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r CashieringAPIGetPostingsForRefreshRequest) OrderSequence(orderSequence []float32) CashieringAPIGetPostingsForRefreshRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r CashieringAPIGetPostingsForRefreshRequest) ArticleDescription(articleDescription []string) CashieringAPIGetPostingsForRefreshRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r CashieringAPIGetPostingsForRefreshRequest) ArticleTransactionCode(articleTransactionCode []string) CashieringAPIGetPostingsForRefreshRequest {
	r.articleTransactionCode = &articleTransactionCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetPostingsForRefreshRequest) Amount(amount float32) CashieringAPIGetPostingsForRefreshRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetPostingsForRefreshRequest) CurrencyCode(currencyCode string) CashieringAPIGetPostingsForRefreshRequest {
	r.currencyCode = &currencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r CashieringAPIGetPostingsForRefreshRequest) AvailableForPostIt(availableForPostIt bool) CashieringAPIGetPostingsForRefreshRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r CashieringAPIGetPostingsForRefreshRequest) Color(color string) CashieringAPIGetPostingsForRefreshRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r CashieringAPIGetPostingsForRefreshRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) CashieringAPIGetPostingsForRefreshRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Unique identifier for the Billing Instruction.
func (r CashieringAPIGetPostingsForRefreshRequest) BillingCode(billingCode []string) CashieringAPIGetPostingsForRefreshRequest {
	r.billingCode = &billingCode
	return r
}

// Hotel context of the Billing Instruction.
func (r CashieringAPIGetPostingsForRefreshRequest) BillingHotelId(billingHotelId []string) CashieringAPIGetPostingsForRefreshRequest {
	r.billingHotelId = &billingHotelId
	return r
}

// Billing Instruction code description.
func (r CashieringAPIGetPostingsForRefreshRequest) Desc(desc []string) CashieringAPIGetPostingsForRefreshRequest {
	r.desc = &desc
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r CashieringAPIGetPostingsForRefreshRequest) BillingInstructionRoutingInstructionsId(billingInstructionRoutingInstructionsId []float32) CashieringAPIGetPostingsForRefreshRequest {
	r.billingInstructionRoutingInstructionsId = &billingInstructionRoutingInstructionsId
	return r
}

// Allowable credit amount for this routing instruction. Null value means no limit, 0 equals zero.
func (r CashieringAPIGetPostingsForRefreshRequest) CreditLimit(creditLimit float32) CashieringAPIGetPostingsForRefreshRequest {
	r.creditLimit = &creditLimit
	return r
}

// The routing limit percentage allowed for this routing instruction.
func (r CashieringAPIGetPostingsForRefreshRequest) PercentageLimit(percentageLimit float32) CashieringAPIGetPostingsForRefreshRequest {
	r.percentageLimit = &percentageLimit
	return r
}

// Number of covers for this routing instruction.
func (r CashieringAPIGetPostingsForRefreshRequest) Covers(covers float32) CashieringAPIGetPostingsForRefreshRequest {
	r.covers = &covers
	return r
}

// Amount of Credit used for this routing instruction.
func (r CashieringAPIGetPostingsForRefreshRequest) LimitUsed(limitUsed float32) CashieringAPIGetPostingsForRefreshRequest {
	r.limitUsed = &limitUsed
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetPostingsForRefreshRequest) Id(id string) CashieringAPIGetPostingsForRefreshRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetPostingsForRefreshRequest) RoutingLinkIdIdContext(routingLinkIdIdContext string) CashieringAPIGetPostingsForRefreshRequest {
	r.routingLinkIdIdContext = &routingLinkIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetPostingsForRefreshRequest) RoutingLinkIdType(routingLinkIdType string) CashieringAPIGetPostingsForRefreshRequest {
	r.routingLinkIdType = &routingLinkIdType
	return r
}

// External system code.
func (r CashieringAPIGetPostingsForRefreshRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetPostingsForRefreshRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetPostingsForRefreshRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetPostingsForRefreshRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetPostingsForRefreshRequest) Execute() (*PostingsForRefresh, *http.Response, error) {
	return r.ApiService.GetPostingsForRefreshExecute(r)
}

/*
GetPostingsForRefresh Get Postings For Refresh

You can use this API to get postings For Refresh. <p><strong>OperationId:</strong>getPostingsForRefresh</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetReservationId Unique ID of the target reservation
 @param sourceReservationId Unique ID of the source reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetPostingsForRefreshRequest
*/
func (a *CashieringAPIService) GetPostingsForRefresh(ctx context.Context, targetReservationId string, sourceReservationId string, hotelId string) CashieringAPIGetPostingsForRefreshRequest {
	return CashieringAPIGetPostingsForRefreshRequest{
		ApiService: a,
		ctx: ctx,
		targetReservationId: targetReservationId,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostingsForRefresh
func (a *CashieringAPIService) GetPostingsForRefreshExecute(r CashieringAPIGetPostingsForRefreshRequest) (*PostingsForRefresh, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostingsForRefresh
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetPostingsForRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/targetReservations/{targetReservationId}/roomRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"targetReservationId"+"}", url.PathEscape(parameterValueToString(r.targetReservationId, "targetReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetReservationId) < 1 {
		return localVarReturnValue, nil, reportError("targetReservationId must have at least 1 elements")
	}
	if strlen(r.targetReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("targetReservationId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.targetResvNameIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetResvNameIdContext", r.targetResvNameIdContext, "")
  }
	if r.targetResvNameIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetResvNameIdType", r.targetResvNameIdType, "")
  }
	if r.daily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daily", r.daily, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.transactionHotelId != nil {
		t := *r.transactionHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", t, "multi")
		}
  }
	if r.printTrxReceipt != nil {
		t := *r.printTrxReceipt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
  }
	if r.transactionGroup != nil {
		t := *r.transactionGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", t, "multi")
		}
  }
	if r.transactionSubGroup != nil {
		t := *r.transactionSubGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", t, "multi")
		}
  }
	if r.universalProductCode != nil {
		t := *r.universalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", t, "multi")
		}
  }
	if r.routingInstructionsId != nil {
		t := *r.routingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", t, "multi")
		}
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.articleHotelId != nil {
		t := *r.articleHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelId", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
  }
	if r.articleTransactionCode != nil {
		t := *r.articleTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleTransactionCode", t, "multi")
		}
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
  }
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
  }
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
  }
	if r.billingCode != nil {
		t := *r.billingCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingCode", t, "multi")
		}
  }
	if r.billingHotelId != nil {
		t := *r.billingHotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingHotelId", t, "multi")
		}
  }
	if r.desc != nil {
		t := *r.desc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "desc", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "desc", t, "multi")
		}
  }
	if r.billingInstructionRoutingInstructionsId != nil {
		t := *r.billingInstructionRoutingInstructionsId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "billingInstructionRoutingInstructionsId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "billingInstructionRoutingInstructionsId", t, "multi")
		}
  }
	if r.creditLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditLimit", r.creditLimit, "")
  }
	if r.percentageLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentageLimit", r.percentageLimit, "")
  }
	if r.covers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "covers", r.covers, "")
  }
	if r.limitUsed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limitUsed", r.limitUsed, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.routingLinkIdIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkIdIdContext", r.routingLinkIdIdContext, "")
  }
	if r.routingLinkIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingLinkIdType", r.routingLinkIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetReceiptHistoryRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fromDate *string
	toDate *string
	name *string
	firstName *string
	receiptTypeName *string
	taxInvoice *string
	receiptNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetReceiptHistoryRequest) Authorization(authorization string) CashieringAPIGetReceiptHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetReceiptHistoryRequest) XAppKey(xAppKey string) CashieringAPIGetReceiptHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetReceiptHistoryRequest) XHotelid(xHotelid string) CashieringAPIGetReceiptHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Receipt History Date Range(from).
func (r CashieringAPIGetReceiptHistoryRequest) FromDate(fromDate string) CashieringAPIGetReceiptHistoryRequest {
	r.fromDate = &fromDate
	return r
}

// Receipt History Date Range(to).
func (r CashieringAPIGetReceiptHistoryRequest) ToDate(toDate string) CashieringAPIGetReceiptHistoryRequest {
	r.toDate = &toDate
	return r
}

// Family name, last name or Company Name.
func (r CashieringAPIGetReceiptHistoryRequest) Name(name string) CashieringAPIGetReceiptHistoryRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r CashieringAPIGetReceiptHistoryRequest) FirstName(firstName string) CashieringAPIGetReceiptHistoryRequest {
	r.firstName = &firstName
	return r
}

// Receipt Type.
func (r CashieringAPIGetReceiptHistoryRequest) ReceiptTypeName(receiptTypeName string) CashieringAPIGetReceiptHistoryRequest {
	r.receiptTypeName = &receiptTypeName
	return r
}

// Tax Invoice Number.
func (r CashieringAPIGetReceiptHistoryRequest) TaxInvoice(taxInvoice string) CashieringAPIGetReceiptHistoryRequest {
	r.taxInvoice = &taxInvoice
	return r
}

// Receipt Number.
func (r CashieringAPIGetReceiptHistoryRequest) ReceiptNo(receiptNo float32) CashieringAPIGetReceiptHistoryRequest {
	r.receiptNo = &receiptNo
	return r
}

// External system code.
func (r CashieringAPIGetReceiptHistoryRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetReceiptHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetReceiptHistoryRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetReceiptHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetReceiptHistoryRequest) Execute() (*ReceiptHistoryResponse, *http.Response, error) {
	return r.ApiService.GetReceiptHistoryExecute(r)
}

/*
GetReceiptHistory Get Receipt History

You can use this API to get Receipt History. <p><strong>OperationId:</strong>getReceiptHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetReceiptHistoryRequest
*/
func (a *CashieringAPIService) GetReceiptHistory(ctx context.Context, hotelId string) CashieringAPIGetReceiptHistoryRequest {
	return CashieringAPIGetReceiptHistoryRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReceiptHistoryResponse
func (a *CashieringAPIService) GetReceiptHistoryExecute(r CashieringAPIGetReceiptHistoryRequest) (*ReceiptHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiptHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetReceiptHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/receiptHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
  }
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
  }
	if r.receiptTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptTypeName", r.receiptTypeName, "")
  }
	if r.taxInvoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxInvoice", r.taxInvoice, "")
  }
	if r.receiptNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptNo", r.receiptNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetReservationPackageOptionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetReservationPackageOptionsRequest) Authorization(authorization string) CashieringAPIGetReservationPackageOptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetReservationPackageOptionsRequest) XAppKey(xAppKey string) CashieringAPIGetReservationPackageOptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetReservationPackageOptionsRequest) XHotelid(xHotelid string) CashieringAPIGetReservationPackageOptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIGetReservationPackageOptionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetReservationPackageOptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetReservationPackageOptionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetReservationPackageOptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetReservationPackageOptionsRequest) Execute() (*ReservationPackageOptions, *http.Response, error) {
	return r.ApiService.GetReservationPackageOptionsExecute(r)
}

/*
GetReservationPackageOptions Get Reservation Package Options

You can use this API to get Reservation Package Options. <p><strong>OperationId:</strong>getReservationPackageOptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetReservationPackageOptionsRequest
*/
func (a *CashieringAPIService) GetReservationPackageOptions(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetReservationPackageOptionsRequest {
	return CashieringAPIGetReservationPackageOptionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationPackageOptions
func (a *CashieringAPIService) GetReservationPackageOptionsExecute(r CashieringAPIGetReservationPackageOptionsRequest) (*ReservationPackageOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationPackageOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetReservationPackageOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packageOptions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetReservationRevenueBucketTotalsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	revenueBucketType *string
	compRevenue *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) Authorization(authorization string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) XAppKey(xAppKey string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) XHotelid(xHotelid string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) IdContext(idContext string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) Type_(type_ string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.type_ = &type_
	return r
}

// Type if the revenue bucket.
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) RevenueBucketType(revenueBucketType string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.revenueBucketType = &revenueBucketType
	return r
}

// This flag will notify the service if the revenue is of complimentary type.
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) CompRevenue(compRevenue bool) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.compRevenue = &compRevenue
	return r
}

// External system code.
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetReservationRevenueBucketTotalsRequest) Execute() (*RevenueBucketTotals, *http.Response, error) {
	return r.ApiService.GetReservationRevenueBucketTotalsExecute(r)
}

/*
GetReservationRevenueBucketTotals Get Reservations Revenue Bucket Totals

You can use this API to get a reservations Revenue Bucket Totals. <p><strong>OperationId:</strong>getReservationRevenueBucketTotals</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetReservationRevenueBucketTotalsRequest
*/
func (a *CashieringAPIService) GetReservationRevenueBucketTotals(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetReservationRevenueBucketTotalsRequest {
	return CashieringAPIGetReservationRevenueBucketTotalsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RevenueBucketTotals
func (a *CashieringAPIService) GetReservationRevenueBucketTotalsExecute(r CashieringAPIGetReservationRevenueBucketTotalsRequest) (*RevenueBucketTotals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevenueBucketTotals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetReservationRevenueBucketTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/revenueBuckets"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.revenueBucketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueBucketType", r.revenueBucketType, "")
  }
	if r.compRevenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compRevenue", r.compRevenue, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetRoundingDifferenceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	folioWindowNo *int32
	internalFolioWindowID *string
	cashierId *float32
	hotelId *string
	id *string
	amount *float32
	currencyCode *string
	description *string
	folioView *int32
	paymentMethod *string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	cardIdId *string
	currentAuthorizedAmountAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmountNeededAmount *float32
	approvalAmountNeededCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	code *int32
	amountAmount *float32
	amountCurrencyCode *string
	percent *float32
	emailFolio *bool
	uniqueIdId *string
	createDateTime *string
	creatorId *string
	emailAddress *string
	emailFormat *string
	lastModifierId *string
	lastModifyDateTime *string
	orderSequence *float32
	primaryInd *bool
	purgeDate *string
	emailType *string
	typeDescription *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetRoundingDifferenceRequest) Authorization(authorization string) CashieringAPIGetRoundingDifferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetRoundingDifferenceRequest) XAppKey(xAppKey string) CashieringAPIGetRoundingDifferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetRoundingDifferenceRequest) XHotelid(xHotelid string) CashieringAPIGetRoundingDifferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r CashieringAPIGetRoundingDifferenceRequest) Event(event string) CashieringAPIGetRoundingDifferenceRequest {
	r.event = &event
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIGetRoundingDifferenceRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r CashieringAPIGetRoundingDifferenceRequest) InternalFolioWindowID(internalFolioWindowID string) CashieringAPIGetRoundingDifferenceRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIGetRoundingDifferenceRequest) CashierId(cashierId float32) CashieringAPIGetRoundingDifferenceRequest {
	r.cashierId = &cashierId
	return r
}

// Hotel context of the reservation.
func (r CashieringAPIGetRoundingDifferenceRequest) HotelId(hotelId string) CashieringAPIGetRoundingDifferenceRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetRoundingDifferenceRequest) Id(id string) CashieringAPIGetRoundingDifferenceRequest {
	r.id = &id
	return r
}

// A monetary amount.
func (r CashieringAPIGetRoundingDifferenceRequest) Amount(amount float32) CashieringAPIGetRoundingDifferenceRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetRoundingDifferenceRequest) CurrencyCode(currencyCode string) CashieringAPIGetRoundingDifferenceRequest {
	r.currencyCode = &currencyCode
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) Description(description string) CashieringAPIGetRoundingDifferenceRequest {
	r.description = &description
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) FolioView(folioView int32) CashieringAPIGetRoundingDifferenceRequest {
	r.folioView = &folioView
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) PaymentMethod(paymentMethod string) CashieringAPIGetRoundingDifferenceRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Attach the credit card to profile.
func (r CashieringAPIGetRoundingDifferenceRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) CashieringAPIGetRoundingDifferenceRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) CardHolderName(cardHolderName string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) CardNumber(cardNumber string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) CardNumberLast4Digits(cardNumberLast4Digits string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) CardNumberMasked(cardNumberMasked string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r CashieringAPIGetRoundingDifferenceRequest) CardOrToken(cardOrToken string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r CashieringAPIGetRoundingDifferenceRequest) CardType(cardType string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r CashieringAPIGetRoundingDifferenceRequest) ExpirationDate(expirationDate string) CashieringAPIGetRoundingDifferenceRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) ExpirationDateExpired(expirationDateExpired bool) CashieringAPIGetRoundingDifferenceRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r CashieringAPIGetRoundingDifferenceRequest) ExpirationDateMasked(expirationDateMasked string) CashieringAPIGetRoundingDifferenceRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) Processing(processing string) CashieringAPIGetRoundingDifferenceRequest {
	r.processing = &processing
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) Swiped(swiped bool) CashieringAPIGetRoundingDifferenceRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r CashieringAPIGetRoundingDifferenceRequest) UserDefinedCardType(userDefinedCardType string) CashieringAPIGetRoundingDifferenceRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetRoundingDifferenceRequest) CardIdId(cardIdId string) CashieringAPIGetRoundingDifferenceRequest {
	r.cardIdId = &cardIdId
	return r
}

// A monetary amount.
func (r CashieringAPIGetRoundingDifferenceRequest) CurrentAuthorizedAmountAmount(currentAuthorizedAmountAmount float32) CashieringAPIGetRoundingDifferenceRequest {
	r.currentAuthorizedAmountAmount = &currentAuthorizedAmountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetRoundingDifferenceRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) CashieringAPIGetRoundingDifferenceRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetRoundingDifferenceRequest) ApprovalAmountNeededAmount(approvalAmountNeededAmount float32) CashieringAPIGetRoundingDifferenceRequest {
	r.approvalAmountNeededAmount = &approvalAmountNeededAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetRoundingDifferenceRequest) ApprovalAmountNeededCurrencyCode(approvalAmountNeededCurrencyCode string) CashieringAPIGetRoundingDifferenceRequest {
	r.approvalAmountNeededCurrencyCode = &approvalAmountNeededCurrencyCode
	return r
}

// A monetary amount.
func (r CashieringAPIGetRoundingDifferenceRequest) BalanceAmount(balanceAmount float32) CashieringAPIGetRoundingDifferenceRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetRoundingDifferenceRequest) BalanceCurrencyCode(balanceCurrencyCode string) CashieringAPIGetRoundingDifferenceRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// The authorization rule code.
func (r CashieringAPIGetRoundingDifferenceRequest) Code(code int32) CashieringAPIGetRoundingDifferenceRequest {
	r.code = &code
	return r
}

// A monetary amount.
func (r CashieringAPIGetRoundingDifferenceRequest) AmountAmount(amountAmount float32) CashieringAPIGetRoundingDifferenceRequest {
	r.amountAmount = &amountAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIGetRoundingDifferenceRequest) AmountCurrencyCode(amountCurrencyCode string) CashieringAPIGetRoundingDifferenceRequest {
	r.amountCurrencyCode = &amountCurrencyCode
	return r
}

// A percentage value if the authorization rule is percentage based.
func (r CashieringAPIGetRoundingDifferenceRequest) Percent(percent float32) CashieringAPIGetRoundingDifferenceRequest {
	r.percent = &percent
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) EmailFolio(emailFolio bool) CashieringAPIGetRoundingDifferenceRequest {
	r.emailFolio = &emailFolio
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetRoundingDifferenceRequest) UniqueIdId(uniqueIdId string) CashieringAPIGetRoundingDifferenceRequest {
	r.uniqueIdId = &uniqueIdId
	return r
}

// Time stamp of the creation.
func (r CashieringAPIGetRoundingDifferenceRequest) CreateDateTime(createDateTime string) CashieringAPIGetRoundingDifferenceRequest {
	r.createDateTime = &createDateTime
	return r
}

// ID of creator. The creator could be a software system identifier or an identifier of an employee resposible for the creation.
func (r CashieringAPIGetRoundingDifferenceRequest) CreatorId(creatorId string) CashieringAPIGetRoundingDifferenceRequest {
	r.creatorId = &creatorId
	return r
}

// Defines the e-mail address.
func (r CashieringAPIGetRoundingDifferenceRequest) EmailAddress(emailAddress string) CashieringAPIGetRoundingDifferenceRequest {
	r.emailAddress = &emailAddress
	return r
}

// Supported Email format.
func (r CashieringAPIGetRoundingDifferenceRequest) EmailFormat(emailFormat string) CashieringAPIGetRoundingDifferenceRequest {
	r.emailFormat = &emailFormat
	return r
}

// Identifies the last software system or person to modify a record.
func (r CashieringAPIGetRoundingDifferenceRequest) LastModifierId(lastModifierId string) CashieringAPIGetRoundingDifferenceRequest {
	r.lastModifierId = &lastModifierId
	return r
}

// Time stamp of last modification.
func (r CashieringAPIGetRoundingDifferenceRequest) LastModifyDateTime(lastModifyDateTime string) CashieringAPIGetRoundingDifferenceRequest {
	r.lastModifyDateTime = &lastModifyDateTime
	return r
}

// Display Order sequence.
func (r CashieringAPIGetRoundingDifferenceRequest) OrderSequence(orderSequence float32) CashieringAPIGetRoundingDifferenceRequest {
	r.orderSequence = &orderSequence
	return r
}

// When true, indicates a primary information.
func (r CashieringAPIGetRoundingDifferenceRequest) PrimaryInd(primaryInd bool) CashieringAPIGetRoundingDifferenceRequest {
	r.primaryInd = &primaryInd
	return r
}

// Date an item will be purged from a database (e.g., from a live database to an archive).
func (r CashieringAPIGetRoundingDifferenceRequest) PurgeDate(purgeDate string) CashieringAPIGetRoundingDifferenceRequest {
	r.purgeDate = &purgeDate
	return r
}

// Defines the purpose of the e-mail address (e.g. personal, business, listserve).
func (r CashieringAPIGetRoundingDifferenceRequest) EmailType(emailType string) CashieringAPIGetRoundingDifferenceRequest {
	r.emailType = &emailType
	return r
}

// Describes the Type code
func (r CashieringAPIGetRoundingDifferenceRequest) TypeDescription(typeDescription string) CashieringAPIGetRoundingDifferenceRequest {
	r.typeDescription = &typeDescription
	return r
}

// External system code.
func (r CashieringAPIGetRoundingDifferenceRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetRoundingDifferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetRoundingDifferenceRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetRoundingDifferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetRoundingDifferenceRequest) Execute() (*RoundingDifferenceAmount, *http.Response, error) {
	return r.ApiService.GetRoundingDifferenceExecute(r)
}

/*
GetRoundingDifference Get Rounding Difference

You can use this API to get Rounding Difference. <p><strong>OperationId:</strong>getRoundingDifference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPIGetRoundingDifferenceRequest
*/
func (a *CashieringAPIService) GetRoundingDifference(ctx context.Context) CashieringAPIGetRoundingDifferenceRequest {
	return CashieringAPIGetRoundingDifferenceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoundingDifferenceAmount
func (a *CashieringAPIService) GetRoundingDifferenceExecute(r CashieringAPIGetRoundingDifferenceRequest) (*RoundingDifferenceAmount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoundingDifferenceAmount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetRoundingDifference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roundingDifference"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
  }
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
  }
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.cardIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardIdId", r.cardIdId, "")
  }
	if r.currentAuthorizedAmountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountAmount", r.currentAuthorizedAmountAmount, "")
  }
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
  }
	if r.approvalAmountNeededAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededAmount", r.approvalAmountNeededAmount, "")
  }
	if r.approvalAmountNeededCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountNeededCurrencyCode", r.approvalAmountNeededCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.amountAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAmount", r.amountAmount, "")
  }
	if r.amountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountCurrencyCode", r.amountCurrencyCode, "")
  }
	if r.percent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent", r.percent, "")
  }
	if r.emailFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFolio", r.emailFolio, "")
  }
	if r.uniqueIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdId", r.uniqueIdId, "")
  }
	if r.createDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createDateTime", r.createDateTime, "")
  }
	if r.creatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorId", r.creatorId, "")
  }
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
  }
	if r.emailFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailFormat", r.emailFormat, "")
  }
	if r.lastModifierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifierId", r.lastModifierId, "")
  }
	if r.lastModifyDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastModifyDateTime", r.lastModifyDateTime, "")
  }
	if r.orderSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", r.orderSequence, "")
  }
	if r.primaryInd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryInd", r.primaryInd, "")
  }
	if r.purgeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeDate", r.purgeDate, "")
  }
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailType", r.emailType, "")
  }
	if r.typeDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeDescription", r.typeDescription, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	includeWindowRouting *bool
	includeRoomRouting *bool
	includeCompRouting *bool
	includeCompRoutingRequests *bool
	effectiveOn *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIGetRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIGetRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIGetRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIGetRoutingInstructionsRequest) IdContext(idContext string) CashieringAPIGetRoutingInstructionsRequest {
	r.idContext = &idContext
	return r
}

// Include the window routing instructions to the response.
func (r CashieringAPIGetRoutingInstructionsRequest) IncludeWindowRouting(includeWindowRouting bool) CashieringAPIGetRoutingInstructionsRequest {
	r.includeWindowRouting = &includeWindowRouting
	return r
}

// Include the room routing instructions in the response.
func (r CashieringAPIGetRoutingInstructionsRequest) IncludeRoomRouting(includeRoomRouting bool) CashieringAPIGetRoutingInstructionsRequest {
	r.includeRoomRouting = &includeRoomRouting
	return r
}

// Include the comp routing instructions in the response.
func (r CashieringAPIGetRoutingInstructionsRequest) IncludeCompRouting(includeCompRouting bool) CashieringAPIGetRoutingInstructionsRequest {
	r.includeCompRouting = &includeCompRouting
	return r
}

// Include the comp routing requests in the response.
func (r CashieringAPIGetRoutingInstructionsRequest) IncludeCompRoutingRequests(includeCompRoutingRequests bool) CashieringAPIGetRoutingInstructionsRequest {
	r.includeCompRoutingRequests = &includeCompRoutingRequests
	return r
}

// If date is included then the search result should only be valid for dates which includes this date.
func (r CashieringAPIGetRoutingInstructionsRequest) EffectiveOn(effectiveOn string) CashieringAPIGetRoutingInstructionsRequest {
	r.effectiveOn = &effectiveOn
	return r
}

// External system code.
func (r CashieringAPIGetRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetRoutingInstructionsRequest) Execute() (*RoutingInstructionsDetails, *http.Response, error) {
	return r.ApiService.GetRoutingInstructionsExecute(r)
}

/*
GetRoutingInstructions Get routing instructions

You can use this API to retrieve routing instructions for a specified reservation. <p><strong>OperationId:</strong>getRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetRoutingInstructionsRequest
*/
func (a *CashieringAPIService) GetRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetRoutingInstructionsRequest {
	return CashieringAPIGetRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoutingInstructionsDetails
func (a *CashieringAPIService) GetRoutingInstructionsExecute(r CashieringAPIGetRoutingInstructionsRequest) (*RoutingInstructionsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutingInstructionsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.includeWindowRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeWindowRouting", r.includeWindowRouting, "")
  }
	if r.includeRoomRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRoomRouting", r.includeRoomRouting, "")
  }
	if r.includeCompRouting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompRouting", r.includeCompRouting, "")
  }
	if r.includeCompRoutingRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompRoutingRequests", r.includeCompRoutingRequests, "")
  }
	if r.effectiveOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "effectiveOn", r.effectiveOn, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetStoredFolioDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalBillNo *string
	folioDate *string
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetStoredFolioDetailsRequest) Authorization(authorization string) CashieringAPIGetStoredFolioDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetStoredFolioDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetStoredFolioDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetStoredFolioDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetStoredFolioDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Fiscal Bill number of this posting
func (r CashieringAPIGetStoredFolioDetailsRequest) FiscalBillNo(fiscalBillNo string) CashieringAPIGetStoredFolioDetailsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r CashieringAPIGetStoredFolioDetailsRequest) FolioDate(folioDate string) CashieringAPIGetStoredFolioDetailsRequest {
	r.folioDate = &folioDate
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r CashieringAPIGetStoredFolioDetailsRequest) FolioStatus(folioStatus string) CashieringAPIGetStoredFolioDetailsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r CashieringAPIGetStoredFolioDetailsRequest) FolioTypeName(folioTypeName string) CashieringAPIGetStoredFolioDetailsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r CashieringAPIGetStoredFolioDetailsRequest) InternalFolioWindowID(internalFolioWindowID string) CashieringAPIGetStoredFolioDetailsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r CashieringAPIGetStoredFolioDetailsRequest) InvoiceNo(invoiceNo float32) CashieringAPIGetStoredFolioDetailsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r CashieringAPIGetStoredFolioDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetStoredFolioDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetStoredFolioDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetStoredFolioDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetStoredFolioDetailsRequest) Execute() (*StoredFolioDetailsInfo, *http.Response, error) {
	return r.ApiService.GetStoredFolioDetailsExecute(r)
}

/*
GetStoredFolioDetails Get Stored Folio Details

You can use this API to get Stored Folio Details. <p><strong>OperationId:</strong>getStoredFolioDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetStoredFolioDetailsRequest
*/
func (a *CashieringAPIService) GetStoredFolioDetails(ctx context.Context, folioId string, hotelId string) CashieringAPIGetStoredFolioDetailsRequest {
	return CashieringAPIGetStoredFolioDetailsRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StoredFolioDetailsInfo
func (a *CashieringAPIService) GetStoredFolioDetailsExecute(r CashieringAPIGetStoredFolioDetailsRequest) (*StoredFolioDetailsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StoredFolioDetailsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetStoredFolioDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/storedFolios/{folioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
  }
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
  }
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
  }
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	includeArticles *bool
	userRoleTransactions *bool
	manualPostAllowed *bool
	code *string
	description *string
	wildCard *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	trxServiceType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetTransactionCodesRequest) Authorization(authorization string) CashieringAPIGetTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetTransactionCodesRequest) XAppKey(xAppKey string) CashieringAPIGetTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetTransactionCodesRequest) XHotelid(xHotelid string) CashieringAPIGetTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r CashieringAPIGetTransactionCodesRequest) Event(event string) CashieringAPIGetTransactionCodesRequest {
	r.event = &event
	return r
}

// Flag to indicate if Article Codes are required, along with the parent Transaction Codes.
func (r CashieringAPIGetTransactionCodesRequest) IncludeArticles(includeArticles bool) CashieringAPIGetTransactionCodesRequest {
	r.includeArticles = &includeArticles
	return r
}

// Flag to indicate if it is allowed to manually post transaction codes.
func (r CashieringAPIGetTransactionCodesRequest) UserRoleTransactions(userRoleTransactions bool) CashieringAPIGetTransactionCodesRequest {
	r.userRoleTransactions = &userRoleTransactions
	return r
}

// Flag to include the search for Manual Post Allowed.
func (r CashieringAPIGetTransactionCodesRequest) ManualPostAllowed(manualPostAllowed bool) CashieringAPIGetTransactionCodesRequest {
	r.manualPostAllowed = &manualPostAllowed
	return r
}

// Lookup string which will try to match an existing Transaction Codes.
func (r CashieringAPIGetTransactionCodesRequest) Code(code string) CashieringAPIGetTransactionCodesRequest {
	r.code = &code
	return r
}

// Lookup string which will try to match an existing Transaction Code Description.
func (r CashieringAPIGetTransactionCodesRequest) Description(description string) CashieringAPIGetTransactionCodesRequest {
	r.description = &description
	return r
}

func (r CashieringAPIGetTransactionCodesRequest) WildCard(wildCard string) CashieringAPIGetTransactionCodesRequest {
	r.wildCard = &wildCard
	return r
}

// The Fiscal Bill number of this posting
func (r CashieringAPIGetTransactionCodesRequest) FiscalBillNo(fiscalBillNo string) CashieringAPIGetTransactionCodesRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r CashieringAPIGetTransactionCodesRequest) FolioDate(folioDate string) CashieringAPIGetTransactionCodesRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r CashieringAPIGetTransactionCodesRequest) FolioNo(folioNo float32) CashieringAPIGetTransactionCodesRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r CashieringAPIGetTransactionCodesRequest) FolioStatus(folioStatus string) CashieringAPIGetTransactionCodesRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r CashieringAPIGetTransactionCodesRequest) FolioTypeName(folioTypeName string) CashieringAPIGetTransactionCodesRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r CashieringAPIGetTransactionCodesRequest) InternalFolioWindowID(internalFolioWindowID string) CashieringAPIGetTransactionCodesRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r CashieringAPIGetTransactionCodesRequest) InvoiceNo(invoiceNo float32) CashieringAPIGetTransactionCodesRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Goods Type Transactions.
func (r CashieringAPIGetTransactionCodesRequest) TrxServiceType(trxServiceType string) CashieringAPIGetTransactionCodesRequest {
	r.trxServiceType = &trxServiceType
	return r
}

// External system code.
func (r CashieringAPIGetTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetTransactionCodesRequest) Execute() (*TransactionCodes, *http.Response, error) {
	return r.ApiService.GetTransactionCodesExecute(r)
}

/*
GetTransactionCodes Get Transaction Codes

You can use this API to retrieve a list of Transaction Codes configured for a property. <p><strong>OperationId:</strong>getTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetTransactionCodesRequest
*/
func (a *CashieringAPIService) GetTransactionCodes(ctx context.Context, hotelId string) CashieringAPIGetTransactionCodesRequest {
	return CashieringAPIGetTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransactionCodes
func (a *CashieringAPIService) GetTransactionCodesExecute(r CashieringAPIGetTransactionCodesRequest) (*TransactionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
  }
	if r.includeArticles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArticles", r.includeArticles, "")
  }
	if r.userRoleTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userRoleTransactions", r.userRoleTransactions, "")
  }
	if r.manualPostAllowed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manualPostAllowed", r.manualPostAllowed, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
  }
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
  }
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
  }
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
  }
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	if r.trxServiceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trxServiceType", r.trxServiceType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetValidateFiscalPrintingDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioView *int32
	folioType *string
	id *string
	code *[]string
	fetchInstruction *[]string
	profileIdId *string
	fiscalServiceMode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) Authorization(authorization string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) XAppKey(xAppKey string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) XHotelid(xHotelid string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The folio window where this settlement is applied.
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) FolioView(folioView int32) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.folioView = &folioView
	return r
}

// Folio Type
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) FolioType(folioType string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.folioType = &folioType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) Id(id string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.id = &id
	return r
}

func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) Code(code []string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.code = &code
	return r
}

// Reservation Related information.
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) FetchInstruction(fetchInstruction []string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.fetchInstruction = &fetchInstruction
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) ProfileIdId(profileIdId string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.profileIdId = &profileIdId
	return r
}

// Mode when fiscal printing is called.
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) FiscalServiceMode(fiscalServiceMode string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.fiscalServiceMode = &fiscalServiceMode
	return r
}

// External system code.
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetValidateFiscalPrintingDetailsRequest) Execute() (*FiscalCallStatus, *http.Response, error) {
	return r.ApiService.GetValidateFiscalPrintingDetailsExecute(r)
}

/*
GetValidateFiscalPrintingDetails Get Fiscal Printing Details

You can use this API to get Fiscal Printing Details. <p><strong>OperationId:</strong>getValidateFiscalPrintingDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetValidateFiscalPrintingDetailsRequest
*/
func (a *CashieringAPIService) GetValidateFiscalPrintingDetails(ctx context.Context, hotelId string) CashieringAPIGetValidateFiscalPrintingDetailsRequest {
	return CashieringAPIGetValidateFiscalPrintingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCallStatus
func (a *CashieringAPIService) GetValidateFiscalPrintingDetailsExecute(r CashieringAPIGetValidateFiscalPrintingDetailsRequest) (*FiscalCallStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCallStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetValidateFiscalPrintingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalPrinting"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.folioView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioView", r.folioView, "")
  }
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.fetchInstruction != nil {
		t := *r.fetchInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstruction", t, "multi")
		}
  }
	if r.profileIdId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdId", r.profileIdId, "")
  }
	if r.fiscalServiceMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalServiceMode", r.fiscalServiceMode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIGetfetchStagedTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId2 *string
	folioWindowNo *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIGetfetchStagedTransactionsRequest) Authorization(authorization string) CashieringAPIGetfetchStagedTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIGetfetchStagedTransactionsRequest) XAppKey(xAppKey string) CashieringAPIGetfetchStagedTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIGetfetchStagedTransactionsRequest) XHotelid(xHotelid string) CashieringAPIGetfetchStagedTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r CashieringAPIGetfetchStagedTransactionsRequest) HotelId2(hotelId2 string) CashieringAPIGetfetchStagedTransactionsRequest {
	r.hotelId2 = &hotelId2
	return r
}

// Folio Window Number of the staged transactions.
func (r CashieringAPIGetfetchStagedTransactionsRequest) FolioWindowNo(folioWindowNo int32) CashieringAPIGetfetchStagedTransactionsRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// External system code.
func (r CashieringAPIGetfetchStagedTransactionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIGetfetchStagedTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIGetfetchStagedTransactionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIGetfetchStagedTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIGetfetchStagedTransactionsRequest) Execute() (*StagedTransactions, *http.Response, error) {
	return r.ApiService.GetfetchStagedTransactionsExecute(r)
}

/*
GetfetchStagedTransactions Get fetchStagedTransactions

This API is used to fetch the staged transactions for a given reservation. <p><strong>OperationId:</strong>getfetchStagedTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIGetfetchStagedTransactionsRequest
*/
func (a *CashieringAPIService) GetfetchStagedTransactions(ctx context.Context, reservationId string, hotelId string) CashieringAPIGetfetchStagedTransactionsRequest {
	return CashieringAPIGetfetchStagedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StagedTransactions
func (a *CashieringAPIService) GetfetchStagedTransactionsExecute(r CashieringAPIGetfetchStagedTransactionsRequest) (*StagedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StagedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.GetfetchStagedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fetchStagedTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId2, "")
  }
	if r.folioWindowNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", r.folioWindowNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIIsDepositRefundEligibleRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIIsDepositRefundEligibleRequest) Authorization(authorization string) CashieringAPIIsDepositRefundEligibleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIIsDepositRefundEligibleRequest) XAppKey(xAppKey string) CashieringAPIIsDepositRefundEligibleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIIsDepositRefundEligibleRequest) XHotelid(xHotelid string) CashieringAPIIsDepositRefundEligibleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIIsDepositRefundEligibleRequest) IdContext(idContext string) CashieringAPIIsDepositRefundEligibleRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIIsDepositRefundEligibleRequest) Type_(type_ string) CashieringAPIIsDepositRefundEligibleRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r CashieringAPIIsDepositRefundEligibleRequest) XExternalsystem(xExternalsystem string) CashieringAPIIsDepositRefundEligibleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIIsDepositRefundEligibleRequest) AcceptLanguage(acceptLanguage string) CashieringAPIIsDepositRefundEligibleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIIsDepositRefundEligibleRequest) Execute() (*DepositRefundEligibleCheck, *http.Response, error) {
	return r.ApiService.IsDepositRefundEligibleExecute(r)
}

/*
IsDepositRefundEligible Get eligibility of Deposit Refund

You can use this API to get eligibility of Deposit Refund. <p><strong>OperationId:</strong>isDepositRefundEligible</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIIsDepositRefundEligibleRequest
*/
func (a *CashieringAPIService) IsDepositRefundEligible(ctx context.Context, transactionId string, reservationId string, hotelId string) CashieringAPIIsDepositRefundEligibleRequest {
	return CashieringAPIIsDepositRefundEligibleRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositRefundEligibleCheck
func (a *CashieringAPIService) IsDepositRefundEligibleExecute(r CashieringAPIIsDepositRefundEligibleRequest) (*DepositRefundEligibleCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositRefundEligibleCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.IsDepositRefundEligible")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPILinkReservationPackageAllowanceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	destinationReservationId string
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	linkReservationPackageAllowance *LinkReservationPackageAllowance
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPILinkReservationPackageAllowanceRequest) Authorization(authorization string) CashieringAPILinkReservationPackageAllowanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPILinkReservationPackageAllowanceRequest) XAppKey(xAppKey string) CashieringAPILinkReservationPackageAllowanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPILinkReservationPackageAllowanceRequest) XHotelid(xHotelid string) CashieringAPILinkReservationPackageAllowanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to create package allowance link from a source reservation to the target reservation.
func (r CashieringAPILinkReservationPackageAllowanceRequest) LinkReservationPackageAllowance(linkReservationPackageAllowance LinkReservationPackageAllowance) CashieringAPILinkReservationPackageAllowanceRequest {
	r.linkReservationPackageAllowance = &linkReservationPackageAllowance
	return r
}

// External system code.
func (r CashieringAPILinkReservationPackageAllowanceRequest) XExternalsystem(xExternalsystem string) CashieringAPILinkReservationPackageAllowanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPILinkReservationPackageAllowanceRequest) AcceptLanguage(acceptLanguage string) CashieringAPILinkReservationPackageAllowanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPILinkReservationPackageAllowanceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.LinkReservationPackageAllowanceExecute(r)
}

/*
LinkReservationPackageAllowance Link Reservation package allowance

You can use this API to link reservation package allowance. <p><strong>OperationId:</strong>linkReservationPackageAllowance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param destinationReservationId Unique ID of the destination reservation.
 @param sourceReservationId Unique ID of the source reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPILinkReservationPackageAllowanceRequest
*/
func (a *CashieringAPIService) LinkReservationPackageAllowance(ctx context.Context, destinationReservationId string, sourceReservationId string, hotelId string) CashieringAPILinkReservationPackageAllowanceRequest {
	return CashieringAPILinkReservationPackageAllowanceRequest{
		ApiService: a,
		ctx: ctx,
		destinationReservationId: destinationReservationId,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) LinkReservationPackageAllowanceExecute(r CashieringAPILinkReservationPackageAllowanceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.LinkReservationPackageAllowance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/destinationReservations/{destinationReservationId}/packageAllowance/links"
	localVarPath = strings.Replace(localVarPath, "{"+"destinationReservationId"+"}", url.PathEscape(parameterValueToString(r.destinationReservationId, "destinationReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.destinationReservationId) < 1 {
		return localVarReturnValue, nil, reportError("destinationReservationId must have at least 1 elements")
	}
	if strlen(r.destinationReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("destinationReservationId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.linkReservationPackageAllowance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostAdvanceFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchAdvanceFolio *BatchAdvanceFolio
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostAdvanceFolioRequest) Authorization(authorization string) CashieringAPIPostAdvanceFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostAdvanceFolioRequest) XAppKey(xAppKey string) CashieringAPIPostAdvanceFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostAdvanceFolioRequest) XHotelid(xHotelid string) CashieringAPIPostAdvanceFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for submitting batch advance folio.
func (r CashieringAPIPostAdvanceFolioRequest) BatchAdvanceFolio(batchAdvanceFolio BatchAdvanceFolio) CashieringAPIPostAdvanceFolioRequest {
	r.batchAdvanceFolio = &batchAdvanceFolio
	return r
}

// External system code.
func (r CashieringAPIPostAdvanceFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostAdvanceFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostAdvanceFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostAdvanceFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostAdvanceFolioRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAdvanceFolioExecute(r)
}

/*
PostAdvanceFolio Create Batch Advance Folio

You can use this API to create Batch Advance Folio. <p><strong>OperationId:</strong>postAdvanceFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostAdvanceFolioRequest
*/
func (a *CashieringAPIService) PostAdvanceFolio(ctx context.Context, hotelId string) CashieringAPIPostAdvanceFolioRequest {
	return CashieringAPIPostAdvanceFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostAdvanceFolioExecute(r CashieringAPIPostAdvanceFolioRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostAdvanceFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/advanceFolio/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchAdvanceFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostAdvanceRoomChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	advanceRoomCharges *AdvanceRoomCharges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostAdvanceRoomChargesRequest) Authorization(authorization string) CashieringAPIPostAdvanceRoomChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostAdvanceRoomChargesRequest) XAppKey(xAppKey string) CashieringAPIPostAdvanceRoomChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostAdvanceRoomChargesRequest) XHotelid(xHotelid string) CashieringAPIPostAdvanceRoomChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post the Room Charges for a reservation in advance. This request posts the Room Charges for a reservation for tonight or for many nights starting from the last posted night. This can also be used to verify if the reservation has already been charged for the full stay. Setting the Verify flag will return details regarding the last Room Charge posted date and if there are any available dates for which the room charges can be posted in advance. Room Charges cannot be posted for dates prior to the business date of the resort. To make the actual posting, the verification flag should be false.
func (r CashieringAPIPostAdvanceRoomChargesRequest) AdvanceRoomCharges(advanceRoomCharges AdvanceRoomCharges) CashieringAPIPostAdvanceRoomChargesRequest {
	r.advanceRoomCharges = &advanceRoomCharges
	return r
}

// External system code.
func (r CashieringAPIPostAdvanceRoomChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostAdvanceRoomChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostAdvanceRoomChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostAdvanceRoomChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostAdvanceRoomChargesRequest) Execute() (*AdvanceRoomChargesReservationInfo, *http.Response, error) {
	return r.ApiService.PostAdvanceRoomChargesExecute(r)
}

/*
PostAdvanceRoomCharges Create advance Room Charges

You can use this API to create advance Room Charges. <p><strong>OperationId:</strong>postAdvanceRoomCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostAdvanceRoomChargesRequest
*/
func (a *CashieringAPIService) PostAdvanceRoomCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostAdvanceRoomChargesRequest {
	return CashieringAPIPostAdvanceRoomChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AdvanceRoomChargesReservationInfo
func (a *CashieringAPIService) PostAdvanceRoomChargesExecute(r CashieringAPIPostAdvanceRoomChargesRequest) (*AdvanceRoomChargesReservationInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdvanceRoomChargesReservationInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostAdvanceRoomCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/advanceRoomCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.advanceRoomCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostArticlesSaleRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	articlesSaleCriteria *ArticlesSaleCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostArticlesSaleRequest) Authorization(authorization string) CashieringAPIPostArticlesSaleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostArticlesSaleRequest) XAppKey(xAppKey string) CashieringAPIPostArticlesSaleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostArticlesSaleRequest) XHotelid(xHotelid string) CashieringAPIPostArticlesSaleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a set of charges, payments and generate a bill for a PasserBy or for the Post-It functionality . A PasserBy is someone who is not staying at the Property. A PasserBy transaction requires a Profile in Opera for whom the the folio is being created.
func (r CashieringAPIPostArticlesSaleRequest) ArticlesSaleCriteria(articlesSaleCriteria ArticlesSaleCriteria) CashieringAPIPostArticlesSaleRequest {
	r.articlesSaleCriteria = &articlesSaleCriteria
	return r
}

// External system code.
func (r CashieringAPIPostArticlesSaleRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostArticlesSaleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostArticlesSaleRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostArticlesSaleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostArticlesSaleRequest) Execute() (*ArticlesSale, *http.Response, error) {
	return r.ApiService.PostArticlesSaleExecute(r)
}

/*
PostArticlesSale Create Articles Sale

You can use this API to create Articles Sale. <p><strong>OperationId:</strong>postArticlesSale</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostArticlesSaleRequest
*/
func (a *CashieringAPIService) PostArticlesSale(ctx context.Context, hotelId string) CashieringAPIPostArticlesSaleRequest {
	return CashieringAPIPostArticlesSaleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArticlesSale
func (a *CashieringAPIService) PostArticlesSaleExecute(r CashieringAPIPostArticlesSaleRequest) (*ArticlesSale, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArticlesSale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostArticlesSale")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/articlesSale"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.articlesSaleCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostAutoCheckoutReservationsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchAutoCheckoutReservation *BatchAutoCheckoutReservation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostAutoCheckoutReservationsRequest) Authorization(authorization string) CashieringAPIPostAutoCheckoutReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostAutoCheckoutReservationsRequest) XAppKey(xAppKey string) CashieringAPIPostAutoCheckoutReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostAutoCheckoutReservationsRequest) XHotelid(xHotelid string) CashieringAPIPostAutoCheckoutReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for batch auto checkout.
func (r CashieringAPIPostAutoCheckoutReservationsRequest) BatchAutoCheckoutReservation(batchAutoCheckoutReservation BatchAutoCheckoutReservation) CashieringAPIPostAutoCheckoutReservationsRequest {
	r.batchAutoCheckoutReservation = &batchAutoCheckoutReservation
	return r
}

// External system code.
func (r CashieringAPIPostAutoCheckoutReservationsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostAutoCheckoutReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostAutoCheckoutReservationsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostAutoCheckoutReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostAutoCheckoutReservationsRequest) Execute() (*BatchAutoCheckoutDetails, *http.Response, error) {
	return r.ApiService.PostAutoCheckoutReservationsExecute(r)
}

/*
PostAutoCheckoutReservations Create Auto Checkout Reservation Batch 

You can use this API to create Auto Checkout Reservation Batch. <p><strong>OperationId:</strong>postAutoCheckoutReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostAutoCheckoutReservationsRequest
*/
func (a *CashieringAPIService) PostAutoCheckoutReservations(ctx context.Context, hotelId string) CashieringAPIPostAutoCheckoutReservationsRequest {
	return CashieringAPIPostAutoCheckoutReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BatchAutoCheckoutDetails
func (a *CashieringAPIService) PostAutoCheckoutReservationsExecute(r CashieringAPIPostAutoCheckoutReservationsRequest) (*BatchAutoCheckoutDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchAutoCheckoutDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostAutoCheckoutReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoCheckoutReservations/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchAutoCheckoutReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostAwardTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	reservationId float32
	membershipId float32
	authorization *string
	xAppKey *string
	xHotelid *string
	awardDetails *AwardPaymentDetails
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostAwardTransactionRequest) Authorization(authorization string) CashieringAPIPostAwardTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostAwardTransactionRequest) XAppKey(xAppKey string) CashieringAPIPostAwardTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostAwardTransactionRequest) XHotelid(xHotelid string) CashieringAPIPostAwardTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating an award transaction.
func (r CashieringAPIPostAwardTransactionRequest) AwardDetails(awardDetails AwardPaymentDetails) CashieringAPIPostAwardTransactionRequest {
	r.awardDetails = &awardDetails
	return r
}

// External system code.
func (r CashieringAPIPostAwardTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostAwardTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostAwardTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostAwardTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostAwardTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAwardTransactionExecute(r)
}

/*
PostAwardTransaction Post a membership award payment transaction.

Creates a new membership award payment transaction. <p><strong>OperationId:</strong>postAwardTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel.
 @param reservationId Unique ID of the reservation.
 @param membershipId Membership number of the guest in the reservation.
 @return CashieringAPIPostAwardTransactionRequest
*/
func (a *CashieringAPIService) PostAwardTransaction(ctx context.Context, hotelId string, reservationId float32, membershipId float32) CashieringAPIPostAwardTransactionRequest {
	return CashieringAPIPostAwardTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		reservationId: reservationId,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostAwardTransactionExecute(r CashieringAPIPostAwardTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostAwardTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/memberships/{membershipId}/awardTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.awardDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBatchAutoSettlementRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchAutoSettlementCriteria *BatchAutoSettlementCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBatchAutoSettlementRequest) Authorization(authorization string) CashieringAPIPostBatchAutoSettlementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBatchAutoSettlementRequest) XAppKey(xAppKey string) CashieringAPIPostBatchAutoSettlementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBatchAutoSettlementRequest) XHotelid(xHotelid string) CashieringAPIPostBatchAutoSettlementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for batch auto settlement.
func (r CashieringAPIPostBatchAutoSettlementRequest) BatchAutoSettlementCriteria(batchAutoSettlementCriteria BatchAutoSettlementCriteria) CashieringAPIPostBatchAutoSettlementRequest {
	r.batchAutoSettlementCriteria = &batchAutoSettlementCriteria
	return r
}

// External system code.
func (r CashieringAPIPostBatchAutoSettlementRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBatchAutoSettlementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBatchAutoSettlementRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBatchAutoSettlementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBatchAutoSettlementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchAutoSettlementExecute(r)
}

/*
PostBatchAutoSettlement Create Batch Auto Settlement

You can use this API to create Batch Auto Settlement. <p><strong>OperationId:</strong>postBatchAutoSettlement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBatchAutoSettlementRequest
*/
func (a *CashieringAPIService) PostBatchAutoSettlement(ctx context.Context, hotelId string) CashieringAPIPostBatchAutoSettlementRequest {
	return CashieringAPIPostBatchAutoSettlementRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostBatchAutoSettlementExecute(r CashieringAPIPostBatchAutoSettlementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBatchAutoSettlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoSettlements/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchAutoSettlementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBatchCCSettlementsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccBatchSettlementsProcessCriteria *CcBatchSettlementsProcessCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBatchCCSettlementsRequest) Authorization(authorization string) CashieringAPIPostBatchCCSettlementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBatchCCSettlementsRequest) XAppKey(xAppKey string) CashieringAPIPostBatchCCSettlementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBatchCCSettlementsRequest) XHotelid(xHotelid string) CashieringAPIPostBatchCCSettlementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to process batch settlements
func (r CashieringAPIPostBatchCCSettlementsRequest) CcBatchSettlementsProcessCriteria(ccBatchSettlementsProcessCriteria CcBatchSettlementsProcessCriteria) CashieringAPIPostBatchCCSettlementsRequest {
	r.ccBatchSettlementsProcessCriteria = &ccBatchSettlementsProcessCriteria
	return r
}

// External system code.
func (r CashieringAPIPostBatchCCSettlementsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBatchCCSettlementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBatchCCSettlementsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBatchCCSettlementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBatchCCSettlementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchCCSettlementsExecute(r)
}

/*
PostBatchCCSettlements Create Batch CC Settlements

You can use this API to create Batch CC Settlements. <p><strong>OperationId:</strong>postBatchCCSettlements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBatchCCSettlementsRequest
*/
func (a *CashieringAPIService) PostBatchCCSettlements(ctx context.Context, hotelId string) CashieringAPIPostBatchCCSettlementsRequest {
	return CashieringAPIPostBatchCCSettlementsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostBatchCCSettlementsExecute(r CashieringAPIPostBatchCCSettlementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBatchCCSettlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ccSettlements/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccBatchSettlementsProcessCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBatchDepositRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchDeposit *BatchDeposit
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBatchDepositRequest) Authorization(authorization string) CashieringAPIPostBatchDepositRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBatchDepositRequest) XAppKey(xAppKey string) CashieringAPIPostBatchDepositRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBatchDepositRequest) XHotelid(xHotelid string) CashieringAPIPostBatchDepositRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for submitting batch deposit for reservations.
func (r CashieringAPIPostBatchDepositRequest) BatchDeposit(batchDeposit BatchDeposit) CashieringAPIPostBatchDepositRequest {
	r.batchDeposit = &batchDeposit
	return r
}

// External system code.
func (r CashieringAPIPostBatchDepositRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBatchDepositRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBatchDepositRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBatchDepositRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBatchDepositRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchDepositExecute(r)
}

/*
PostBatchDeposit Create batch deposits

You can use this API to create batch deposits. <p><strong>OperationId:</strong>postBatchDeposit</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBatchDepositRequest
*/
func (a *CashieringAPIService) PostBatchDeposit(ctx context.Context, hotelId string) CashieringAPIPostBatchDepositRequest {
	return CashieringAPIPostBatchDepositRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostBatchDepositExecute(r CashieringAPIPostBatchDepositRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBatchDeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/batchDeposits"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchDeposit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	bedTaxCriteria *BedTaxCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBedTaxInfoRequest) Authorization(authorization string) CashieringAPIPostBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBedTaxInfoRequest) XAppKey(xAppKey string) CashieringAPIPostBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBedTaxInfoRequest) XHotelid(xHotelid string) CashieringAPIPostBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for create bed transaction info
func (r CashieringAPIPostBedTaxInfoRequest) BedTaxCriteria(bedTaxCriteria BedTaxCriteria) CashieringAPIPostBedTaxInfoRequest {
	r.bedTaxCriteria = &bedTaxCriteria
	return r
}

// External system code.
func (r CashieringAPIPostBedTaxInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBedTaxInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBedTaxInfoExecute(r)
}

/*
PostBedTaxInfo Create bed tax information

You can use this API to create new bed tax information for a property. <p><strong>OperationId:</strong>postBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBedTaxInfoRequest
*/
func (a *CashieringAPIService) PostBedTaxInfo(ctx context.Context, hotelId string) CashieringAPIPostBedTaxInfoRequest {
	return CashieringAPIPostBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostBedTaxInfoExecute(r CashieringAPIPostBedTaxInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.bedTaxCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBillingChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingCharges *BillingCharges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBillingChargesRequest) Authorization(authorization string) CashieringAPIPostBillingChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBillingChargesRequest) XAppKey(xAppKey string) CashieringAPIPostBillingChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBillingChargesRequest) XHotelid(xHotelid string) CashieringAPIPostBillingChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a charge on a reservation&#39;s folio.
func (r CashieringAPIPostBillingChargesRequest) BillingCharges(billingCharges BillingCharges) CashieringAPIPostBillingChargesRequest {
	r.billingCharges = &billingCharges
	return r
}

// External system code.
func (r CashieringAPIPostBillingChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBillingChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBillingChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBillingChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBillingChargesRequest) Execute() (*BillingChargesDetails, *http.Response, error) {
	return r.ApiService.PostBillingChargesExecute(r)
}

/*
PostBillingCharges Post Charge to a folio

You can use this API to post a charge to a folio window. <p><strong>OperationId:</strong>postBillingCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBillingChargesRequest
*/
func (a *CashieringAPIService) PostBillingCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostBillingChargesRequest {
	return CashieringAPIPostBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingChargesDetails
func (a *CashieringAPIService) PostBillingChargesExecute(r CashieringAPIPostBillingChargesRequest) (*BillingChargesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBillingChargesInBatchRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingChargesInBatchCriteria *BillingChargesInBatchCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBillingChargesInBatchRequest) Authorization(authorization string) CashieringAPIPostBillingChargesInBatchRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBillingChargesInBatchRequest) XAppKey(xAppKey string) CashieringAPIPostBillingChargesInBatchRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBillingChargesInBatchRequest) XHotelid(xHotelid string) CashieringAPIPostBillingChargesInBatchRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to post billing charge to list of reservations.
func (r CashieringAPIPostBillingChargesInBatchRequest) BillingChargesInBatchCriteria(billingChargesInBatchCriteria BillingChargesInBatchCriteria) CashieringAPIPostBillingChargesInBatchRequest {
	r.billingChargesInBatchCriteria = &billingChargesInBatchCriteria
	return r
}

// External system code.
func (r CashieringAPIPostBillingChargesInBatchRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBillingChargesInBatchRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBillingChargesInBatchRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBillingChargesInBatchRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBillingChargesInBatchRequest) Execute() (*PostedBillingChargesInBatch, *http.Response, error) {
	return r.ApiService.PostBillingChargesInBatchExecute(r)
}

/*
PostBillingChargesInBatch Create Billing Charges in Batch

You can use this API to create Billing Charges in Batch. <p><strong>OperationId:</strong>postBillingChargesInBatch</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBillingChargesInBatchRequest
*/
func (a *CashieringAPIService) PostBillingChargesInBatch(ctx context.Context, hotelId string) CashieringAPIPostBillingChargesInBatchRequest {
	return CashieringAPIPostBillingChargesInBatchRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedBillingChargesInBatch
func (a *CashieringAPIService) PostBillingChargesInBatchExecute(r CashieringAPIPostBillingChargesInBatchRequest) (*PostedBillingChargesInBatch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedBillingChargesInBatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBillingChargesInBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/billingCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingChargesInBatchCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBillingCheckChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	checkNumber string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingCheckChargesCriteria *BillingCheckChargesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBillingCheckChargesRequest) Authorization(authorization string) CashieringAPIPostBillingCheckChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBillingCheckChargesRequest) XAppKey(xAppKey string) CashieringAPIPostBillingCheckChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBillingCheckChargesRequest) XHotelid(xHotelid string) CashieringAPIPostBillingCheckChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for PostBillingCheckCharges operation.
func (r CashieringAPIPostBillingCheckChargesRequest) BillingCheckChargesCriteria(billingCheckChargesCriteria BillingCheckChargesCriteria) CashieringAPIPostBillingCheckChargesRequest {
	r.billingCheckChargesCriteria = &billingCheckChargesCriteria
	return r
}

// External system code.
func (r CashieringAPIPostBillingCheckChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBillingCheckChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBillingCheckChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBillingCheckChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBillingCheckChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBillingCheckChargesExecute(r)
}

/*
PostBillingCheckCharges Pre-validate the Billing Charge

You can use this API to validate the posting prior to posting the charge to the folio <p><strong>OperationId:</strong>postBillingCheckCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBillingCheckChargesRequest
*/
func (a *CashieringAPIService) PostBillingCheckCharges(ctx context.Context, checkNumber string, reservationId string, hotelId string) CashieringAPIPostBillingCheckChargesRequest {
	return CashieringAPIPostBillingCheckChargesRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostBillingCheckChargesExecute(r CashieringAPIPostBillingCheckChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBillingCheckCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/check/{checkNumber}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingCheckChargesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostBillingPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingPayment *BillingPayment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostBillingPaymentRequest) Authorization(authorization string) CashieringAPIPostBillingPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostBillingPaymentRequest) XAppKey(xAppKey string) CashieringAPIPostBillingPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostBillingPaymentRequest) XHotelid(xHotelid string) CashieringAPIPostBillingPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a payment on a reservation&#39;s folio.
func (r CashieringAPIPostBillingPaymentRequest) BillingPayment(billingPayment BillingPayment) CashieringAPIPostBillingPaymentRequest {
	r.billingPayment = &billingPayment
	return r
}

// External system code.
func (r CashieringAPIPostBillingPaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostBillingPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostBillingPaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostBillingPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostBillingPaymentRequest) Execute() (*PostedBillingPayment, *http.Response, error) {
	return r.ApiService.PostBillingPaymentExecute(r)
}

/*
PostBillingPayment Create Billing Payment

You can use this API to create Billing Payment on the folio of a Reservation. <p><strong>OperationId:</strong>postBillingPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostBillingPaymentRequest
*/
func (a *CashieringAPIService) PostBillingPayment(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostBillingPaymentRequest {
	return CashieringAPIPostBillingPaymentRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedBillingPayment
func (a *CashieringAPIService) PostBillingPaymentExecute(r CashieringAPIPostBillingPaymentRequest) (*PostedBillingPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedBillingPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostBillingPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingPayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostCCSettlementRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccSettlementCriteria *CcSettlementCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostCCSettlementRequest) Authorization(authorization string) CashieringAPIPostCCSettlementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostCCSettlementRequest) XAppKey(xAppKey string) CashieringAPIPostCCSettlementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostCCSettlementRequest) XHotelid(xHotelid string) CashieringAPIPostCCSettlementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change credit card settlement information.
func (r CashieringAPIPostCCSettlementRequest) CcSettlementCriteria(ccSettlementCriteria CcSettlementCriteria) CashieringAPIPostCCSettlementRequest {
	r.ccSettlementCriteria = &ccSettlementCriteria
	return r
}

// External system code.
func (r CashieringAPIPostCCSettlementRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostCCSettlementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostCCSettlementRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostCCSettlementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostCCSettlementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCCSettlementExecute(r)
}

/*
PostCCSettlement Create CreditCard Settlement

You can use this API to create cc Settlement. <p><strong>OperationId:</strong>postCCSettlement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostCCSettlementRequest
*/
func (a *CashieringAPIService) PostCCSettlement(ctx context.Context, hotelId string) CashieringAPIPostCCSettlementRequest {
	return CashieringAPIPostCCSettlementRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostCCSettlementExecute(r CashieringAPIPostCCSettlementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostCCSettlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ccSettlement"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccSettlementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostCheckOutRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservation *Reservation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostCheckOutRequest) Authorization(authorization string) CashieringAPIPostCheckOutRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostCheckOutRequest) XAppKey(xAppKey string) CashieringAPIPostCheckOutRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostCheckOutRequest) XHotelid(xHotelid string) CashieringAPIPostCheckOutRequest {
	r.xHotelid = &xHotelid
	return r
}

// Checkout request can be used to verify a reservation for checkout and do an actual checkout. In case the verificationOnly attribute is sent false, the operation will perform an actual checkout. In case the verificationOnly attribute is sent true, the operation goes through the reservation in question and verifies if it&#39;s Ok to checkout, otherwise the verification status element will provide you the verification code. The verification codes are described in the documentation of verificationOnly attribute.
func (r CashieringAPIPostCheckOutRequest) Reservation(reservation Reservation) CashieringAPIPostCheckOutRequest {
	r.reservation = &reservation
	return r
}

// External system code.
func (r CashieringAPIPostCheckOutRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostCheckOutRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostCheckOutRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostCheckOutRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostCheckOutRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCheckOutExecute(r)
}

/*
PostCheckOut Check out a guest

This API enables you to check out a guest reservation which is in due out status, with options to update the room's housekeeping status and set a flag to email the guests folio. <p><strong>OperationId:</strong>postCheckOut</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostCheckOutRequest
*/
func (a *CashieringAPIService) PostCheckOut(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostCheckOutRequest {
	return CashieringAPIPostCheckOutRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostCheckOutExecute(r CashieringAPIPostCheckOutRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostCheckOut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkOuts"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postCompRedemptions *PostCompRedemptions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostCompRedemptionsRequest) Authorization(authorization string) CashieringAPIPostCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostCompRedemptionsRequest) XAppKey(xAppKey string) CashieringAPIPostCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostCompRedemptionsRequest) XHotelid(xHotelid string) CashieringAPIPostCompRedemptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type of Complimentary Bucket Redemptions posting.
func (r CashieringAPIPostCompRedemptionsRequest) PostCompRedemptions(postCompRedemptions PostCompRedemptions) CashieringAPIPostCompRedemptionsRequest {
	r.postCompRedemptions = &postCompRedemptions
	return r
}

// External system code.
func (r CashieringAPIPostCompRedemptionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostCompRedemptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostCompRedemptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompRedemptionsExecute(r)
}

/*
PostCompRedemptions Operation to post complimentary bucket redemptions for a guest having PTS Membership Type

You can use this API to post complimentary bucket redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>postCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostCompRedemptionsRequest
*/
func (a *CashieringAPIService) PostCompRedemptions(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostCompRedemptionsRequest {
	return CashieringAPIPostCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostCompRedemptionsExecute(r CashieringAPIPostCompRedemptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/compRedemptionPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostCompTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	compTransactionCriteria *CompTransactionCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostCompTransactionRequest) Authorization(authorization string) CashieringAPIPostCompTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostCompTransactionRequest) XAppKey(xAppKey string) CashieringAPIPostCompTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostCompTransactionRequest) XHotelid(xHotelid string) CashieringAPIPostCompTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to submit a comp transaction to gaming system
func (r CashieringAPIPostCompTransactionRequest) CompTransactionCriteria(compTransactionCriteria CompTransactionCriteria) CashieringAPIPostCompTransactionRequest {
	r.compTransactionCriteria = &compTransactionCriteria
	return r
}

// External system code.
func (r CashieringAPIPostCompTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostCompTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostCompTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostCompTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostCompTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompTransactionExecute(r)
}

/*
PostCompTransaction Submit Comp Transaction

You can use this API to submit Comp Transactions. <p><strong>OperationId:</strong>postCompTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostCompTransactionRequest
*/
func (a *CashieringAPIService) PostCompTransaction(ctx context.Context, transactionId string, hotelId string) CashieringAPIPostCompTransactionRequest {
	return CashieringAPIPostCompTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostCompTransactionExecute(r CashieringAPIPostCompTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostCompTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.compTransactionCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostCreditBillRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditBillCriteria *CreditBillCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostCreditBillRequest) Authorization(authorization string) CashieringAPIPostCreditBillRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostCreditBillRequest) XAppKey(xAppKey string) CashieringAPIPostCreditBillRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostCreditBillRequest) XHotelid(xHotelid string) CashieringAPIPostCreditBillRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a Credit Folio for an existing Folio. Credit Bill Functionality parameter is required.
func (r CashieringAPIPostCreditBillRequest) CreditBillCriteria(creditBillCriteria CreditBillCriteria) CashieringAPIPostCreditBillRequest {
	r.creditBillCriteria = &creditBillCriteria
	return r
}

// External system code.
func (r CashieringAPIPostCreditBillRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostCreditBillRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostCreditBillRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostCreditBillRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostCreditBillRequest) Execute() (*PostedCreditBill, *http.Response, error) {
	return r.ApiService.PostCreditBillExecute(r)
}

/*
PostCreditBill Create Credit Bill

You can use this API to create Credit Bill. <p><strong>OperationId:</strong>postCreditBill</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostCreditBillRequest
*/
func (a *CashieringAPIService) PostCreditBill(ctx context.Context, hotelId string) CashieringAPIPostCreditBillRequest {
	return CashieringAPIPostCreditBillRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedCreditBill
func (a *CashieringAPIService) PostCreditBillExecute(r CashieringAPIPostCreditBillRequest) (*PostedCreditBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedCreditBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostCreditBill")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditBill"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditBillCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostCreditLimitOveragePaymentsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditLimitOveragePayments *CreditLimitOveragePayments
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) Authorization(authorization string) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) XAppKey(xAppKey string) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) XHotelid(xHotelid string) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to start the Credit Limit Overage process for the reservations with a folio window balance equal or higher to the credit limit set for the credit card payment method of that folio window.
func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) CreditLimitOveragePayments(creditLimitOveragePayments CreditLimitOveragePayments) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	r.creditLimitOveragePayments = &creditLimitOveragePayments
	return r
}

// External system code.
func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostCreditLimitOveragePaymentsRequest) Execute() (*CreditLimitOveragePaymentsDetails, *http.Response, error) {
	return r.ApiService.PostCreditLimitOveragePaymentsExecute(r)
}

/*
PostCreditLimitOveragePayments Create Credit Limit Overage Payments

You can use this API to create Credit Limit Overage Payments. <p><strong>OperationId:</strong>postCreditLimitOveragePayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostCreditLimitOveragePaymentsRequest
*/
func (a *CashieringAPIService) PostCreditLimitOveragePayments(ctx context.Context, hotelId string) CashieringAPIPostCreditLimitOveragePaymentsRequest {
	return CashieringAPIPostCreditLimitOveragePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreditLimitOveragePaymentsDetails
func (a *CashieringAPIService) PostCreditLimitOveragePaymentsExecute(r CashieringAPIPostCreditLimitOveragePaymentsRequest) (*CreditLimitOveragePaymentsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditLimitOveragePaymentsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostCreditLimitOveragePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditLimitsOveragePayments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditLimitOveragePayments
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostDeferredTaxesProcessRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	deferredTaxesProcess *DeferredTaxesProcess
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostDeferredTaxesProcessRequest) Authorization(authorization string) CashieringAPIPostDeferredTaxesProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostDeferredTaxesProcessRequest) XAppKey(xAppKey string) CashieringAPIPostDeferredTaxesProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostDeferredTaxesProcessRequest) XHotelid(xHotelid string) CashieringAPIPostDeferredTaxesProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to submit a job to post the deferred taxes.
func (r CashieringAPIPostDeferredTaxesProcessRequest) DeferredTaxesProcess(deferredTaxesProcess DeferredTaxesProcess) CashieringAPIPostDeferredTaxesProcessRequest {
	r.deferredTaxesProcess = &deferredTaxesProcess
	return r
}

// External system code.
func (r CashieringAPIPostDeferredTaxesProcessRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostDeferredTaxesProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostDeferredTaxesProcessRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostDeferredTaxesProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostDeferredTaxesProcessRequest) Execute() (*DeferredTaxesProcessDetails, *http.Response, error) {
	return r.ApiService.PostDeferredTaxesProcessExecute(r)
}

/*
PostDeferredTaxesProcess Request to submit a job to post the deferred taxes.

Request to submit a job to post the deferred taxes. <p><strong>OperationId:</strong>postDeferredTaxesProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostDeferredTaxesProcessRequest
*/
func (a *CashieringAPIService) PostDeferredTaxesProcess(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostDeferredTaxesProcessRequest {
	return CashieringAPIPostDeferredTaxesProcessRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DeferredTaxesProcessDetails
func (a *CashieringAPIService) PostDeferredTaxesProcessExecute(r CashieringAPIPostDeferredTaxesProcessRequest) (*DeferredTaxesProcessDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeferredTaxesProcessDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostDeferredTaxesProcess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/deferredTaxesProcess"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.deferredTaxesProcess
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostDepositFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositFolioCriteria *DepositFolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostDepositFolioRequest) Authorization(authorization string) CashieringAPIPostDepositFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostDepositFolioRequest) XAppKey(xAppKey string) CashieringAPIPostDepositFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostDepositFolioRequest) XHotelid(xHotelid string) CashieringAPIPostDepositFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Deposit Folio for a reservation.
func (r CashieringAPIPostDepositFolioRequest) DepositFolioCriteria(depositFolioCriteria DepositFolioCriteria) CashieringAPIPostDepositFolioRequest {
	r.depositFolioCriteria = &depositFolioCriteria
	return r
}

// External system code.
func (r CashieringAPIPostDepositFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostDepositFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostDepositFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostDepositFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostDepositFolioRequest) Execute() (*PostedDepositFolio, *http.Response, error) {
	return r.ApiService.PostDepositFolioExecute(r)
}

/*
PostDepositFolio Create Deposit Folio

You can use this API to create Deposit Folio. <p><strong>OperationId:</strong>postDepositFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostDepositFolioRequest
*/
func (a *CashieringAPIService) PostDepositFolio(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostDepositFolioRequest {
	return CashieringAPIPostDepositFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedDepositFolio
func (a *CashieringAPIService) PostDepositFolioExecute(r CashieringAPIPostDepositFolioRequest) (*PostedDepositFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedDepositFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostDepositFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositFolios"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostDepositPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositPayment *DepositPayment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostDepositPaymentRequest) Authorization(authorization string) CashieringAPIPostDepositPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostDepositPaymentRequest) XAppKey(xAppKey string) CashieringAPIPostDepositPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostDepositPaymentRequest) XHotelid(xHotelid string) CashieringAPIPostDepositPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a deposit payment to a reservation.
func (r CashieringAPIPostDepositPaymentRequest) DepositPayment(depositPayment DepositPayment) CashieringAPIPostDepositPaymentRequest {
	r.depositPayment = &depositPayment
	return r
}

// External system code.
func (r CashieringAPIPostDepositPaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostDepositPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostDepositPaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostDepositPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostDepositPaymentRequest) Execute() (*DepositedPayment, *http.Response, error) {
	return r.ApiService.PostDepositPaymentExecute(r)
}

/*
PostDepositPayment Create Deposit Payment

You can use this API to create Deposit Payment. <p><strong>OperationId:</strong>postDepositPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostDepositPaymentRequest
*/
func (a *CashieringAPIService) PostDepositPayment(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostDepositPaymentRequest {
	return CashieringAPIPostDepositPaymentRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositedPayment
func (a *CashieringAPIService) PostDepositPaymentExecute(r CashieringAPIPostDepositPaymentRequest) (*DepositedPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositedPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostDepositPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositPayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostDepositPaymentByExtIdRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	externalSysCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositPayment *DepositPayment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostDepositPaymentByExtIdRequest) Authorization(authorization string) CashieringAPIPostDepositPaymentByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostDepositPaymentByExtIdRequest) XAppKey(xAppKey string) CashieringAPIPostDepositPaymentByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostDepositPaymentByExtIdRequest) XHotelid(xHotelid string) CashieringAPIPostDepositPaymentByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a deposit payment to a reservation.
func (r CashieringAPIPostDepositPaymentByExtIdRequest) DepositPayment(depositPayment DepositPayment) CashieringAPIPostDepositPaymentByExtIdRequest {
	r.depositPayment = &depositPayment
	return r
}

// External system code.
func (r CashieringAPIPostDepositPaymentByExtIdRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostDepositPaymentByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostDepositPaymentByExtIdRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostDepositPaymentByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostDepositPaymentByExtIdRequest) Execute() (*DepositedPayment, *http.Response, error) {
	return r.ApiService.PostDepositPaymentByExtIdExecute(r)
}

/*
PostDepositPaymentByExtId Create Deposit Payment using external reference.

You can use this API to create Deposit Payment with external reference. <p><strong>OperationId:</strong>postDepositPaymentByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId External System's reservation ID.
 @param externalSysCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostDepositPaymentByExtIdRequest
*/
func (a *CashieringAPIService) PostDepositPaymentByExtId(ctx context.Context, reservationId string, externalSysCode string, hotelId string) CashieringAPIPostDepositPaymentByExtIdRequest {
	return CashieringAPIPostDepositPaymentByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		externalSysCode: externalSysCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositedPayment
func (a *CashieringAPIService) PostDepositPaymentByExtIdExecute(r CashieringAPIPostDepositPaymentByExtIdRequest) (*DepositedPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositedPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostDepositPaymentByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalSystems/{externalSysCode}/reservations/{reservationId}/depositPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalSysCode"+"}", url.PathEscape(parameterValueToString(r.externalSysCode, "externalSysCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.externalSysCode) < 1 {
		return localVarReturnValue, nil, reportError("externalSysCode must have at least 1 elements")
	}
	if strlen(r.externalSysCode) > 2000 {
		return localVarReturnValue, nil, reportError("externalSysCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositPayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostFBAReimbursementRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fbaReimbursementCriteria *FbaReimbursementCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostFBAReimbursementRequest) Authorization(authorization string) CashieringAPIPostFBAReimbursementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostFBAReimbursementRequest) XAppKey(xAppKey string) CashieringAPIPostFBAReimbursementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostFBAReimbursementRequest) XHotelid(xHotelid string) CashieringAPIPostFBAReimbursementRequest {
	r.xHotelid = &xHotelid
	return r
}

// PostFBAReimbursement operation posts reimbursement against the selected certificate records.
func (r CashieringAPIPostFBAReimbursementRequest) FbaReimbursementCriteria(fbaReimbursementCriteria FbaReimbursementCriteria) CashieringAPIPostFBAReimbursementRequest {
	r.fbaReimbursementCriteria = &fbaReimbursementCriteria
	return r
}

// External system code.
func (r CashieringAPIPostFBAReimbursementRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostFBAReimbursementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostFBAReimbursementRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostFBAReimbursementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostFBAReimbursementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFBAReimbursementExecute(r)
}

/*
PostFBAReimbursement Create FBA Reimbursement

You can use this API to create FBA Reimbursement. <p><strong>OperationId:</strong>postFBAReimbursement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPIPostFBAReimbursementRequest
*/
func (a *CashieringAPIService) PostFBAReimbursement(ctx context.Context) CashieringAPIPostFBAReimbursementRequest {
	return CashieringAPIPostFBAReimbursementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostFBAReimbursementExecute(r CashieringAPIPostFBAReimbursementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostFBAReimbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fbaReimbursements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fbaReimbursementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostFBASettlementRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fbaReimbursementCriteria *FbaReimbursementCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostFBASettlementRequest) Authorization(authorization string) CashieringAPIPostFBASettlementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostFBASettlementRequest) XAppKey(xAppKey string) CashieringAPIPostFBASettlementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostFBASettlementRequest) XHotelid(xHotelid string) CashieringAPIPostFBASettlementRequest {
	r.xHotelid = &xHotelid
	return r
}

// PostFBASettlement operation posts settlement against the selected certificate records.
func (r CashieringAPIPostFBASettlementRequest) FbaReimbursementCriteria(fbaReimbursementCriteria FbaReimbursementCriteria) CashieringAPIPostFBASettlementRequest {
	r.fbaReimbursementCriteria = &fbaReimbursementCriteria
	return r
}

// External system code.
func (r CashieringAPIPostFBASettlementRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostFBASettlementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostFBASettlementRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostFBASettlementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostFBASettlementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFBASettlementExecute(r)
}

/*
PostFBASettlement Create FBA Settlement

You can use this API to create FBA Settlement. <p><strong>OperationId:</strong>postFBASettlement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPIPostFBASettlementRequest
*/
func (a *CashieringAPIService) PostFBASettlement(ctx context.Context) CashieringAPIPostFBASettlementRequest {
	return CashieringAPIPostFBASettlementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostFBASettlementExecute(r CashieringAPIPostFBASettlementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostFBASettlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fbaSettlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fbaReimbursementCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostFiscalCommandInvoiceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioCriteria *FiscalFolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostFiscalCommandInvoiceRequest) Authorization(authorization string) CashieringAPIPostFiscalCommandInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostFiscalCommandInvoiceRequest) XAppKey(xAppKey string) CashieringAPIPostFiscalCommandInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostFiscalCommandInvoiceRequest) XHotelid(xHotelid string) CashieringAPIPostFiscalCommandInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate commands and communicate with fiscal service from fiscal terminals screen..
func (r CashieringAPIPostFiscalCommandInvoiceRequest) FiscalFolioCriteria(fiscalFolioCriteria FiscalFolioCriteria) CashieringAPIPostFiscalCommandInvoiceRequest {
	r.fiscalFolioCriteria = &fiscalFolioCriteria
	return r
}

// External system code.
func (r CashieringAPIPostFiscalCommandInvoiceRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostFiscalCommandInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostFiscalCommandInvoiceRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostFiscalCommandInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostFiscalCommandInvoiceRequest) Execute() (*FiscalCommandsResponseInfo, *http.Response, error) {
	return r.ApiService.PostFiscalCommandInvoiceExecute(r)
}

/*
PostFiscalCommandInvoice Create Fiscal Invoice

You can use this API to create Fiscal Invoice. <p><strong>OperationId:</strong>postFiscalCommandInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostFiscalCommandInvoiceRequest
*/
func (a *CashieringAPIService) PostFiscalCommandInvoice(ctx context.Context, hotelId string) CashieringAPIPostFiscalCommandInvoiceRequest {
	return CashieringAPIPostFiscalCommandInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FiscalCommandsResponseInfo
func (a *CashieringAPIService) PostFiscalCommandInvoiceExecute(r CashieringAPIPostFiscalCommandInvoiceRequest) (*FiscalCommandsResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FiscalCommandsResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostFiscalCommandInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalCommands"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostFiscalInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postFiscalInfoType *PostFiscalInfoType
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostFiscalInfoRequest) Authorization(authorization string) CashieringAPIPostFiscalInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostFiscalInfoRequest) XAppKey(xAppKey string) CashieringAPIPostFiscalInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostFiscalInfoRequest) XHotelid(xHotelid string) CashieringAPIPostFiscalInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate CHECK OUT payload for a reservation.
func (r CashieringAPIPostFiscalInfoRequest) PostFiscalInfoType(postFiscalInfoType PostFiscalInfoType) CashieringAPIPostFiscalInfoRequest {
	r.postFiscalInfoType = &postFiscalInfoType
	return r
}

// External system code.
func (r CashieringAPIPostFiscalInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostFiscalInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostFiscalInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostFiscalInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostFiscalInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalInfoExecute(r)
}

/*
PostFiscalInfo Post fiscal Info

API to generate CHECK OUT payload for a reservation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @param reservationId Unique ID of the reservation
 @return CashieringAPIPostFiscalInfoRequest
*/
func (a *CashieringAPIService) PostFiscalInfo(ctx context.Context, hotelId string, reservationId string) CashieringAPIPostFiscalInfoRequest {
	return CashieringAPIPostFiscalInfoRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostFiscalInfoExecute(r CashieringAPIPostFiscalInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostFiscalInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fiscalInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postFiscalInfoType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostFiscalInvoiceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalFolioCriteria *FiscalFolioCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostFiscalInvoiceRequest) Authorization(authorization string) CashieringAPIPostFiscalInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostFiscalInvoiceRequest) XAppKey(xAppKey string) CashieringAPIPostFiscalInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostFiscalInvoiceRequest) XHotelid(xHotelid string) CashieringAPIPostFiscalInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to generate commands and communicate with fiscal service from fiscal terminals screen..
func (r CashieringAPIPostFiscalInvoiceRequest) FiscalFolioCriteria(fiscalFolioCriteria FiscalFolioCriteria) CashieringAPIPostFiscalInvoiceRequest {
	r.fiscalFolioCriteria = &fiscalFolioCriteria
	return r
}

// External system code.
func (r CashieringAPIPostFiscalInvoiceRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostFiscalInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostFiscalInvoiceRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostFiscalInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostFiscalInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFiscalInvoiceExecute(r)
}

/*
PostFiscalInvoice Create Fiscal Invoice

You can use this API to create Fiscal Invoice.<br><p><strong><mark>This API is deprecated. Please use postFiscalCommandInvoice instead</mark></strong></p> <p><strong>OperationId:</strong>postFiscalInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostFiscalInvoiceRequest

Deprecated
*/
func (a *CashieringAPIService) PostFiscalInvoice(ctx context.Context, folioId string, hotelId string) CashieringAPIPostFiscalInvoiceRequest {
	return CashieringAPIPostFiscalInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringAPIService) PostFiscalInvoiceExecute(r CashieringAPIPostFiscalInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostFiscalInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folio/{folioId}/fiscalCommands"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalFolioCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fixedCharges *FixedCharges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostFixedChargesRequest) Authorization(authorization string) CashieringAPIPostFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostFixedChargesRequest) XAppKey(xAppKey string) CashieringAPIPostFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostFixedChargesRequest) XHotelid(xHotelid string) CashieringAPIPostFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to create fixed charges of a reservation.
func (r CashieringAPIPostFixedChargesRequest) FixedCharges(fixedCharges FixedCharges) CashieringAPIPostFixedChargesRequest {
	r.fixedCharges = &fixedCharges
	return r
}

// External system code.
func (r CashieringAPIPostFixedChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostFixedChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostFixedChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFixedChargesExecute(r)
}

/*
PostFixedCharges Create Fixed Charges

You can use this API to create a fixed Charge for a reservation. <p><strong>OperationId:</strong>postFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostFixedChargesRequest
*/
func (a *CashieringAPIService) PostFixedCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostFixedChargesRequest {
	return CashieringAPIPostFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostFixedChargesExecute(r CashieringAPIPostFixedChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fixedCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostForeignCurrencyExchangeRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	foreignCurrencyExchange *ForeignCurrencyExchange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostForeignCurrencyExchangeRequest) Authorization(authorization string) CashieringAPIPostForeignCurrencyExchangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostForeignCurrencyExchangeRequest) XAppKey(xAppKey string) CashieringAPIPostForeignCurrencyExchangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostForeignCurrencyExchangeRequest) XHotelid(xHotelid string) CashieringAPIPostForeignCurrencyExchangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// A set of posting transactions that need to be posted with regards to exchange.
func (r CashieringAPIPostForeignCurrencyExchangeRequest) ForeignCurrencyExchange(foreignCurrencyExchange ForeignCurrencyExchange) CashieringAPIPostForeignCurrencyExchangeRequest {
	r.foreignCurrencyExchange = &foreignCurrencyExchange
	return r
}

// External system code.
func (r CashieringAPIPostForeignCurrencyExchangeRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostForeignCurrencyExchangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostForeignCurrencyExchangeRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostForeignCurrencyExchangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostForeignCurrencyExchangeRequest) Execute() (*ForeignCurrencyExchangeTransaction, *http.Response, error) {
	return r.ApiService.PostForeignCurrencyExchangeExecute(r)
}

/*
PostForeignCurrencyExchange Create Foreign Currency Exchange

You can use this API to Create Foreign Currency Exchange. <p><strong>OperationId:</strong>postForeignCurrencyExchange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CashieringAPIPostForeignCurrencyExchangeRequest
*/
func (a *CashieringAPIService) PostForeignCurrencyExchange(ctx context.Context) CashieringAPIPostForeignCurrencyExchangeRequest {
	return CashieringAPIPostForeignCurrencyExchangeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForeignCurrencyExchangeTransaction
func (a *CashieringAPIService) PostForeignCurrencyExchangeExecute(r CashieringAPIPostForeignCurrencyExchangeRequest) (*ForeignCurrencyExchangeTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForeignCurrencyExchangeTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostForeignCurrencyExchange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/foreignCurrencyExchange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.foreignCurrencyExchange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostGuestCheckDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	checkNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestCheckDetails *GuestCheckDetails
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostGuestCheckDetailsRequest) Authorization(authorization string) CashieringAPIPostGuestCheckDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostGuestCheckDetailsRequest) XAppKey(xAppKey string) CashieringAPIPostGuestCheckDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostGuestCheckDetailsRequest) XHotelid(xHotelid string) CashieringAPIPostGuestCheckDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to process a guest check detail.
func (r CashieringAPIPostGuestCheckDetailsRequest) GuestCheckDetails(guestCheckDetails GuestCheckDetails) CashieringAPIPostGuestCheckDetailsRequest {
	r.guestCheckDetails = &guestCheckDetails
	return r
}

// External system code.
func (r CashieringAPIPostGuestCheckDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostGuestCheckDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostGuestCheckDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostGuestCheckDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostGuestCheckDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuestCheckDetailsExecute(r)
}

/*
PostGuestCheckDetails Post Guest Check Details

This operation is to add guest check details for posted check transactions. <p><strong>OperationId:</strong>postGuestCheckDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostGuestCheckDetailsRequest
*/
func (a *CashieringAPIService) PostGuestCheckDetails(ctx context.Context, checkNumber string, hotelId string) CashieringAPIPostGuestCheckDetailsRequest {
	return CashieringAPIPostGuestCheckDetailsRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostGuestCheckDetailsExecute(r CashieringAPIPostGuestCheckDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostGuestCheckDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/check/{checkNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestCheckDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostPasserBySaleRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	passerBySalesCriteria *PasserBySalesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostPasserBySaleRequest) Authorization(authorization string) CashieringAPIPostPasserBySaleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostPasserBySaleRequest) XAppKey(xAppKey string) CashieringAPIPostPasserBySaleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostPasserBySaleRequest) XHotelid(xHotelid string) CashieringAPIPostPasserBySaleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a set of charges, payments and generate a bill for a PasserBy or for the Post-It functionality . A PasserBy is someone who is not staying at the Property. A PasserBy transaction requires a Profile in Opera for whom the the folio is being created.
func (r CashieringAPIPostPasserBySaleRequest) PasserBySalesCriteria(passerBySalesCriteria PasserBySalesCriteria) CashieringAPIPostPasserBySaleRequest {
	r.passerBySalesCriteria = &passerBySalesCriteria
	return r
}

// External system code.
func (r CashieringAPIPostPasserBySaleRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostPasserBySaleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostPasserBySaleRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostPasserBySaleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostPasserBySaleRequest) Execute() (*PasserBySale, *http.Response, error) {
	return r.ApiService.PostPasserBySaleExecute(r)
}

/*
PostPasserBySale Create passer by sale

You can use this API to create passer by sale. <p><strong>OperationId:</strong>postPasserBySale</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostPasserBySaleRequest
*/
func (a *CashieringAPIService) PostPasserBySale(ctx context.Context, hotelId string) CashieringAPIPostPasserBySaleRequest {
	return CashieringAPIPostPasserBySaleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PasserBySale
func (a *CashieringAPIService) PostPasserBySaleExecute(r CashieringAPIPostPasserBySaleRequest) (*PasserBySale, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PasserBySale
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostPasserBySale")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/passerBySale"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.passerBySalesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostPrepaidCardsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	prepaidCardCriteria *PrepaidCardCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostPrepaidCardsRequest) Authorization(authorization string) CashieringAPIPostPrepaidCardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostPrepaidCardsRequest) XAppKey(xAppKey string) CashieringAPIPostPrepaidCardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostPrepaidCardsRequest) XHotelid(xHotelid string) CashieringAPIPostPrepaidCardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for Prepaid card creation process
func (r CashieringAPIPostPrepaidCardsRequest) PrepaidCardCriteria(prepaidCardCriteria PrepaidCardCriteria) CashieringAPIPostPrepaidCardsRequest {
	r.prepaidCardCriteria = &prepaidCardCriteria
	return r
}

// External system code.
func (r CashieringAPIPostPrepaidCardsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostPrepaidCardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostPrepaidCardsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostPrepaidCardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostPrepaidCardsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPrepaidCardsExecute(r)
}

/*
PostPrepaidCards Create Prepaid Cards

You can use this API to create Prepaid Cards. <p><strong>OperationId:</strong>postPrepaidCards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostPrepaidCardsRequest
*/
func (a *CashieringAPIService) PostPrepaidCards(ctx context.Context, hotelId string) CashieringAPIPostPrepaidCardsRequest {
	return CashieringAPIPostPrepaidCardsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostPrepaidCardsExecute(r CashieringAPIPostPrepaidCardsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostPrepaidCards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.prepaidCardCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostProformaRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationFolio *ReservationFolio
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostProformaRequest) Authorization(authorization string) CashieringAPIPostProformaRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostProformaRequest) XAppKey(xAppKey string) CashieringAPIPostProformaRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostProformaRequest) XHotelid(xHotelid string) CashieringAPIPostProformaRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Proforma(folio) transactions for a reservation. The request generates the internal transactions required to create a Proforma report. After this request is called , the Opera Proforma report should be called so that these transactions can be used in the report. If the report is called without this request, the report will be incorrect and will not have the complete information. If the report is not used after this request, the internal transactions will be removed either by night audit or by the next request.
func (r CashieringAPIPostProformaRequest) ReservationFolio(reservationFolio ReservationFolio) CashieringAPIPostProformaRequest {
	r.reservationFolio = &reservationFolio
	return r
}

// External system code.
func (r CashieringAPIPostProformaRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostProformaRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostProformaRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostProformaRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostProformaRequest) Execute() (*ReservationFolioInformation, *http.Response, error) {
	return r.ApiService.PostProformaExecute(r)
}

/*
PostProforma Create proforma

You can use this API to create proforma for a specific reservation. <p><strong>OperationId:</strong>postProforma</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostProformaRequest
*/
func (a *CashieringAPIService) PostProforma(ctx context.Context, reservationId string, hotelId string) CashieringAPIPostProformaRequest {
	return CashieringAPIPostProformaRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationFolioInformation
func (a *CashieringAPIService) PostProformaExecute(r CashieringAPIPostProformaRequest) (*ReservationFolioInformation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationFolioInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostProforma")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/proforma"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostRateCodeRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	rateCode string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postRateCodeCriteria *PostRateCodeCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostRateCodeRequest) Authorization(authorization string) CashieringAPIPostRateCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostRateCodeRequest) XAppKey(xAppKey string) CashieringAPIPostRateCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostRateCodeRequest) XHotelid(xHotelid string) CashieringAPIPostRateCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to post a Rate Code amount to the Reservation. Based on the criteria, Products(Packages) which are included as part of the Rate Code may be posted along with the room rate amount.
func (r CashieringAPIPostRateCodeRequest) PostRateCodeCriteria(postRateCodeCriteria PostRateCodeCriteria) CashieringAPIPostRateCodeRequest {
	r.postRateCodeCriteria = &postRateCodeCriteria
	return r
}

// External system code.
func (r CashieringAPIPostRateCodeRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostRateCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostRateCodeRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostRateCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostRateCodeRequest) Execute() (*PostedRateCode, *http.Response, error) {
	return r.ApiService.PostRateCodeExecute(r)
}

/*
PostRateCode Create rate codes

You can use this API to create rate codes. <p><strong>OperationId:</strong>postRateCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode The Rate Code which is to be posted on the Guest Folio.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostRateCodeRequest
*/
func (a *CashieringAPIService) PostRateCode(ctx context.Context, rateCode string, reservationId string, hotelId string) CashieringAPIPostRateCodeRequest {
	return CashieringAPIPostRateCodeRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostedRateCode
func (a *CashieringAPIService) PostRateCodeExecute(r CashieringAPIPostRateCodeRequest) (*PostedRateCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostedRateCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostRateCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservation/{reservationId}/rateCode/{rateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postRateCodeCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostReversePaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	paymentReversalCriteria *PaymentReversalCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostReversePaymentRequest) Authorization(authorization string) CashieringAPIPostReversePaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostReversePaymentRequest) XAppKey(xAppKey string) CashieringAPIPostReversePaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostReversePaymentRequest) XHotelid(xHotelid string) CashieringAPIPostReversePaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for posting payment reversal.
func (r CashieringAPIPostReversePaymentRequest) PaymentReversalCriteria(paymentReversalCriteria PaymentReversalCriteria) CashieringAPIPostReversePaymentRequest {
	r.paymentReversalCriteria = &paymentReversalCriteria
	return r
}

// External system code.
func (r CashieringAPIPostReversePaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostReversePaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostReversePaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostReversePaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostReversePaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReversePaymentExecute(r)
}

/*
PostReversePayment Create reverse payments

You can use this API to create reverse payments. <p><strong>OperationId:</strong>postReversePayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the Transaction
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostReversePaymentRequest
*/
func (a *CashieringAPIService) PostReversePayment(ctx context.Context, transactionId string, hotelId string) CashieringAPIPostReversePaymentRequest {
	return CashieringAPIPostReversePaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostReversePaymentExecute(r CashieringAPIPostReversePaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostReversePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/reversePayments"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.paymentReversalCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostRoomAndTaxForDayUseRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postRoomAndTaxForDayUse *PostRoomAndTaxForDayUse
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostRoomAndTaxForDayUseRequest) Authorization(authorization string) CashieringAPIPostRoomAndTaxForDayUseRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostRoomAndTaxForDayUseRequest) XAppKey(xAppKey string) CashieringAPIPostRoomAndTaxForDayUseRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostRoomAndTaxForDayUseRequest) XHotelid(xHotelid string) CashieringAPIPostRoomAndTaxForDayUseRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to calculate room and tax.
func (r CashieringAPIPostRoomAndTaxForDayUseRequest) PostRoomAndTaxForDayUse(postRoomAndTaxForDayUse PostRoomAndTaxForDayUse) CashieringAPIPostRoomAndTaxForDayUseRequest {
	r.postRoomAndTaxForDayUse = &postRoomAndTaxForDayUse
	return r
}

// External system code.
func (r CashieringAPIPostRoomAndTaxForDayUseRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostRoomAndTaxForDayUseRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostRoomAndTaxForDayUseRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostRoomAndTaxForDayUseRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostRoomAndTaxForDayUseRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomAndTaxForDayUseExecute(r)
}

/*
PostRoomAndTaxForDayUse Operation to post room and tax for day use.

You can use this API to post post Room And Tax For DayUse <p><strong>OperationId:</strong>postRoomAndTaxForDayUse</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @return CashieringAPIPostRoomAndTaxForDayUseRequest
*/
func (a *CashieringAPIService) PostRoomAndTaxForDayUse(ctx context.Context, reservationId string) CashieringAPIPostRoomAndTaxForDayUseRequest {
	return CashieringAPIPostRoomAndTaxForDayUseRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostRoomAndTaxForDayUseExecute(r CashieringAPIPostRoomAndTaxForDayUseRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostRoomAndTaxForDayUse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reservations/{reservationId}/postRoomAndTaxForDayUse"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postRoomAndTaxForDayUse
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostStoredFolioDetailsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	storedFolioDetails *StoredFolioDetails
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostStoredFolioDetailsRequest) Authorization(authorization string) CashieringAPIPostStoredFolioDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostStoredFolioDetailsRequest) XAppKey(xAppKey string) CashieringAPIPostStoredFolioDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostStoredFolioDetailsRequest) XHotelid(xHotelid string) CashieringAPIPostStoredFolioDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to update stored folio details.
func (r CashieringAPIPostStoredFolioDetailsRequest) StoredFolioDetails(storedFolioDetails StoredFolioDetails) CashieringAPIPostStoredFolioDetailsRequest {
	r.storedFolioDetails = &storedFolioDetails
	return r
}

// External system code.
func (r CashieringAPIPostStoredFolioDetailsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostStoredFolioDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostStoredFolioDetailsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostStoredFolioDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostStoredFolioDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostStoredFolioDetailsExecute(r)
}

/*
PostStoredFolioDetails Create Stored Folio Details

You can use this API to create Stored Folio Details. <p><strong>OperationId:</strong>postStoredFolioDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostStoredFolioDetailsRequest
*/
func (a *CashieringAPIService) PostStoredFolioDetails(ctx context.Context, folioId string, hotelId string) CashieringAPIPostStoredFolioDetailsRequest {
	return CashieringAPIPostStoredFolioDetailsRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PostStoredFolioDetailsExecute(r CashieringAPIPostStoredFolioDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostStoredFolioDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/storedFolios/{folioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.storedFolioDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostSupplementalFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	postSupplementalFolio *PostSupplementalFolio
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostSupplementalFolioRequest) Authorization(authorization string) CashieringAPIPostSupplementalFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostSupplementalFolioRequest) XAppKey(xAppKey string) CashieringAPIPostSupplementalFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostSupplementalFolioRequest) XHotelid(xHotelid string) CashieringAPIPostSupplementalFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a Supplemental Folio for an existing Folio. Debit Bill ( Supplemental Folio ) Functionality parameter is required
func (r CashieringAPIPostSupplementalFolioRequest) PostSupplementalFolio(postSupplementalFolio PostSupplementalFolio) CashieringAPIPostSupplementalFolioRequest {
	r.postSupplementalFolio = &postSupplementalFolio
	return r
}

// External system code.
func (r CashieringAPIPostSupplementalFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostSupplementalFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostSupplementalFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostSupplementalFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostSupplementalFolioRequest) Execute() (*PostSupplementalFolioStatus, *http.Response, error) {
	return r.ApiService.PostSupplementalFolioExecute(r)
}

/*
PostSupplementalFolio Post supplemental folio

You can use this API to post supplemental folio. <p><strong>OperationId:</strong>postSupplementalFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostSupplementalFolioRequest
*/
func (a *CashieringAPIService) PostSupplementalFolio(ctx context.Context, hotelId string) CashieringAPIPostSupplementalFolioRequest {
	return CashieringAPIPostSupplementalFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PostSupplementalFolioStatus
func (a *CashieringAPIService) PostSupplementalFolioExecute(r CashieringAPIPostSupplementalFolioRequest) (*PostSupplementalFolioStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostSupplementalFolioStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostSupplementalFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/supplementFolios"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.postSupplementalFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPostZeroBalanceCheckoutReservationsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchZeroBalanceCheckoutReservation *BatchZeroBalanceCheckoutReservation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) Authorization(authorization string) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) XAppKey(xAppKey string) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) XHotelid(xHotelid string) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for batch zero balance checkout
func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) BatchZeroBalanceCheckoutReservation(batchZeroBalanceCheckoutReservation BatchZeroBalanceCheckoutReservation) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	r.batchZeroBalanceCheckoutReservation = &batchZeroBalanceCheckoutReservation
	return r
}

// External system code.
func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) Execute() (*BatchZeroBalanceCheckoutDetails, *http.Response, error) {
	return r.ApiService.PostZeroBalanceCheckoutReservationsExecute(r)
}

/*
PostZeroBalanceCheckoutReservations Create Zero Balance Checkout Reservation Batch 

You can use this API to create Zero Balance Checkout Reservation Batch. <p><strong>OperationId:</strong>postZeroBalanceCheckoutReservations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPostZeroBalanceCheckoutReservationsRequest
*/
func (a *CashieringAPIService) PostZeroBalanceCheckoutReservations(ctx context.Context, hotelId string) CashieringAPIPostZeroBalanceCheckoutReservationsRequest {
	return CashieringAPIPostZeroBalanceCheckoutReservationsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BatchZeroBalanceCheckoutDetails
func (a *CashieringAPIService) PostZeroBalanceCheckoutReservationsExecute(r CashieringAPIPostZeroBalanceCheckoutReservationsRequest) (*BatchZeroBalanceCheckoutDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchZeroBalanceCheckoutDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PostZeroBalanceCheckoutReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/zeroBalanceCheckoutReservations/batchJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchZeroBalanceCheckoutReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIProcessFiscalRetryRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	processFiscalRetry *ProcessFiscalRetry
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIProcessFiscalRetryRequest) Authorization(authorization string) CashieringAPIProcessFiscalRetryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIProcessFiscalRetryRequest) XAppKey(xAppKey string) CashieringAPIProcessFiscalRetryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIProcessFiscalRetryRequest) XHotelid(xHotelid string) CashieringAPIProcessFiscalRetryRequest {
	r.xHotelid = &xHotelid
	return r
}

// The request object to process fiscal retry functionality.
func (r CashieringAPIProcessFiscalRetryRequest) ProcessFiscalRetry(processFiscalRetry ProcessFiscalRetry) CashieringAPIProcessFiscalRetryRequest {
	r.processFiscalRetry = &processFiscalRetry
	return r
}

// External system code.
func (r CashieringAPIProcessFiscalRetryRequest) XExternalsystem(xExternalsystem string) CashieringAPIProcessFiscalRetryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIProcessFiscalRetryRequest) AcceptLanguage(acceptLanguage string) CashieringAPIProcessFiscalRetryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIProcessFiscalRetryRequest) Execute() (*ProcessFiscalRetryStatus, *http.Response, error) {
	return r.ApiService.ProcessFiscalRetryExecute(r)
}

/*
ProcessFiscalRetry Process Fiscal retry

You can use this API to process fiscal retry status. <p><strong>OperationId:</strong>processFiscalRetry</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIProcessFiscalRetryRequest
*/
func (a *CashieringAPIService) ProcessFiscalRetry(ctx context.Context, folioId string, hotelId string) CashieringAPIProcessFiscalRetryRequest {
	return CashieringAPIProcessFiscalRetryRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ProcessFiscalRetryStatus
func (a *CashieringAPIService) ProcessFiscalRetryExecute(r CashieringAPIProcessFiscalRetryRequest) (*ProcessFiscalRetryStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessFiscalRetryStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ProcessFiscalRetry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/folios/{folioId}/fiscal"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.processFiscalRetry
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIProcessReservationDepositRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationDepositCriteria *ReservationDepositCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIProcessReservationDepositRequest) Authorization(authorization string) CashieringAPIProcessReservationDepositRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIProcessReservationDepositRequest) XAppKey(xAppKey string) CashieringAPIProcessReservationDepositRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIProcessReservationDepositRequest) XHotelid(xHotelid string) CashieringAPIProcessReservationDepositRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to process reservation deposit.
func (r CashieringAPIProcessReservationDepositRequest) ReservationDepositCriteria(reservationDepositCriteria ReservationDepositCriteria) CashieringAPIProcessReservationDepositRequest {
	r.reservationDepositCriteria = &reservationDepositCriteria
	return r
}

// External system code.
func (r CashieringAPIProcessReservationDepositRequest) XExternalsystem(xExternalsystem string) CashieringAPIProcessReservationDepositRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIProcessReservationDepositRequest) AcceptLanguage(acceptLanguage string) CashieringAPIProcessReservationDepositRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIProcessReservationDepositRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ProcessReservationDepositExecute(r)
}

/*
ProcessReservationDeposit Process Reservations deposit

You can use this API to Process reservations deposit. <p><strong>OperationId:</strong>processReservationDeposit</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIProcessReservationDepositRequest
*/
func (a *CashieringAPIService) ProcessReservationDeposit(ctx context.Context, reservationId string, hotelId string) CashieringAPIProcessReservationDepositRequest {
	return CashieringAPIProcessReservationDepositRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ProcessReservationDepositExecute(r CashieringAPIProcessReservationDepositRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ProcessReservationDeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationDepositCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIProcessRoomRoutingRefreshRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	targetReservationId string
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRoutingRefresh *RoomRoutingRefresh
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIProcessRoomRoutingRefreshRequest) Authorization(authorization string) CashieringAPIProcessRoomRoutingRefreshRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIProcessRoomRoutingRefreshRequest) XAppKey(xAppKey string) CashieringAPIProcessRoomRoutingRefreshRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIProcessRoomRoutingRefreshRequest) XHotelid(xHotelid string) CashieringAPIProcessRoomRoutingRefreshRequest {
	r.xHotelid = &xHotelid
	return r
}

// The request object for processing refreshing of a routing instruction set. This operation transfers the postings to the respective reservation as per the routing instruction set which is created, edited, deleted or refreshed.
func (r CashieringAPIProcessRoomRoutingRefreshRequest) RoomRoutingRefresh(roomRoutingRefresh RoomRoutingRefresh) CashieringAPIProcessRoomRoutingRefreshRequest {
	r.roomRoutingRefresh = &roomRoutingRefresh
	return r
}

// External system code.
func (r CashieringAPIProcessRoomRoutingRefreshRequest) XExternalsystem(xExternalsystem string) CashieringAPIProcessRoomRoutingRefreshRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIProcessRoomRoutingRefreshRequest) AcceptLanguage(acceptLanguage string) CashieringAPIProcessRoomRoutingRefreshRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIProcessRoomRoutingRefreshRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ProcessRoomRoutingRefreshExecute(r)
}

/*
ProcessRoomRoutingRefresh Process Room Routing Refresh

You can use this API to change Room Routing Refresh. <p><strong>OperationId:</strong>processRoomRoutingRefresh</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetReservationId Unique ID of the target reservation
 @param sourceReservationId Unique ID of the source reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIProcessRoomRoutingRefreshRequest
*/
func (a *CashieringAPIService) ProcessRoomRoutingRefresh(ctx context.Context, targetReservationId string, sourceReservationId string, hotelId string) CashieringAPIProcessRoomRoutingRefreshRequest {
	return CashieringAPIProcessRoomRoutingRefreshRequest{
		ApiService: a,
		ctx: ctx,
		targetReservationId: targetReservationId,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ProcessRoomRoutingRefreshExecute(r CashieringAPIProcessRoomRoutingRefreshRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ProcessRoomRoutingRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sourceReservations/{sourceReservationId}/targetReservations/{targetReservationId}/roomRouting"
	localVarPath = strings.Replace(localVarPath, "{"+"targetReservationId"+"}", url.PathEscape(parameterValueToString(r.targetReservationId, "targetReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetReservationId) < 1 {
		return localVarReturnValue, nil, reportError("targetReservationId must have at least 1 elements")
	}
	if strlen(r.targetReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("targetReservationId must have less than 2000 elements")
	}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRoutingRefresh
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	taxRegistraitionNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	bedTaxCriteria *BedTaxCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutBedTaxInfoRequest) Authorization(authorization string) CashieringAPIPutBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutBedTaxInfoRequest) XAppKey(xAppKey string) CashieringAPIPutBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutBedTaxInfoRequest) XHotelid(xHotelid string) CashieringAPIPutBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for change bed transaction info
func (r CashieringAPIPutBedTaxInfoRequest) BedTaxCriteria(bedTaxCriteria BedTaxCriteria) CashieringAPIPutBedTaxInfoRequest {
	r.bedTaxCriteria = &bedTaxCriteria
	return r
}

// External system code.
func (r CashieringAPIPutBedTaxInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutBedTaxInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutBedTaxInfoExecute(r)
}

/*
PutBedTaxInfo Change bed tax information

You can use this API to Update bed tax information for a property. <p><strong>OperationId:</strong>putBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxRegistraitionNo Unique number of the tax registration.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutBedTaxInfoRequest

Deprecated
*/
func (a *CashieringAPIService) PutBedTaxInfo(ctx context.Context, taxRegistraitionNo string, hotelId string) CashieringAPIPutBedTaxInfoRequest {
	return CashieringAPIPutBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		taxRegistraitionNo: taxRegistraitionNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringAPIService) PutBedTaxInfoExecute(r CashieringAPIPutBedTaxInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax/{taxRegistraitionNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxRegistraitionNo"+"}", url.PathEscape(parameterValueToString(r.taxRegistraitionNo, "taxRegistraitionNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxRegistraitionNo) < 1 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have at least 1 elements")
	}
	if strlen(r.taxRegistraitionNo) > 2000 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.bedTaxCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutBillingChargeRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	billingCharge *BillingCharge
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutBillingChargeRequest) Authorization(authorization string) CashieringAPIPutBillingChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutBillingChargeRequest) XAppKey(xAppKey string) CashieringAPIPutBillingChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutBillingChargeRequest) XHotelid(xHotelid string) CashieringAPIPutBillingChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to edit a billing charge information.
func (r CashieringAPIPutBillingChargeRequest) BillingCharge(billingCharge BillingCharge) CashieringAPIPutBillingChargeRequest {
	r.billingCharge = &billingCharge
	return r
}

// External system code.
func (r CashieringAPIPutBillingChargeRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutBillingChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutBillingChargeRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutBillingChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutBillingChargeRequest) Execute() (*BillingChargeStatus, *http.Response, error) {
	return r.ApiService.PutBillingChargeExecute(r)
}

/*
PutBillingCharge Change Billing Charge

You can use this API to change Billing Charges. <p><strong>OperationId:</strong>putBillingCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutBillingChargeRequest
*/
func (a *CashieringAPIService) PutBillingCharge(ctx context.Context, transactionId string, hotelId string) CashieringAPIPutBillingChargeRequest {
	return CashieringAPIPutBillingChargeRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BillingChargeStatus
func (a *CashieringAPIService) PutBillingChargeExecute(r CashieringAPIPutBillingChargeRequest) (*BillingChargeStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillingChargeStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutBillingCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.billingCharge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutBillingChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	putBillingCharges *PutBillingCharges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutBillingChargesRequest) Authorization(authorization string) CashieringAPIPutBillingChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutBillingChargesRequest) XAppKey(xAppKey string) CashieringAPIPutBillingChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutBillingChargesRequest) XHotelid(xHotelid string) CashieringAPIPutBillingChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to edit multiple billing charge information.
func (r CashieringAPIPutBillingChargesRequest) PutBillingCharges(putBillingCharges PutBillingCharges) CashieringAPIPutBillingChargesRequest {
	r.putBillingCharges = &putBillingCharges
	return r
}

// External system code.
func (r CashieringAPIPutBillingChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutBillingChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutBillingChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutBillingChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutBillingChargesRequest) Execute() (*PutBillingChargesStatus, *http.Response, error) {
	return r.ApiService.PutBillingChargesExecute(r)
}

/*
PutBillingCharges Change Billing Charges

You can use this API to change Billing Charges. <p><strong>OperationId:</strong>putBillingCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutBillingChargesRequest
*/
func (a *CashieringAPIService) PutBillingCharges(ctx context.Context, hotelId string) CashieringAPIPutBillingChargesRequest {
	return CashieringAPIPutBillingChargesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PutBillingChargesStatus
func (a *CashieringAPIService) PutBillingChargesExecute(r CashieringAPIPutBillingChargesRequest) (*PutBillingChargesStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PutBillingChargesStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutBillingCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/billingCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.putBillingCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutCashierRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierClosure *CashierClosure
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutCashierRequest) Authorization(authorization string) CashieringAPIPutCashierRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutCashierRequest) XAppKey(xAppKey string) CashieringAPIPutCashierRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutCashierRequest) XHotelid(xHotelid string) CashieringAPIPutCashierRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to close cashier&#39;s shift.
func (r CashieringAPIPutCashierRequest) CashierClosure(cashierClosure CashierClosure) CashieringAPIPutCashierRequest {
	r.cashierClosure = &cashierClosure
	return r
}

// External system code.
func (r CashieringAPIPutCashierRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutCashierRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutCashierRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutCashierRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutCashierRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutCashierExecute(r)
}

/*
PutCashier Close Cashier

You can use this API to change Cashier Closure. <p><strong>OperationId:</strong>putCashier</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @return CashieringAPIPutCashierRequest
*/
func (a *CashieringAPIService) PutCashier(ctx context.Context, cashierId string) CashieringAPIPutCashierRequest {
	return CashieringAPIPutCashierRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PutCashierExecute(r CashieringAPIPutCashierRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutCashier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiers/{cashierId}/closure"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashierClosure
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	lockId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierLockCriteriaToExtend *CashierLockCriteriaToExtend
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutCashierLockRequest) Authorization(authorization string) CashieringAPIPutCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutCashierLockRequest) XAppKey(xAppKey string) CashieringAPIPutCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutCashierLockRequest) XHotelid(xHotelid string) CashieringAPIPutCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation for extending the lifetime of a lock on a cashier.
func (r CashieringAPIPutCashierLockRequest) CashierLockCriteriaToExtend(cashierLockCriteriaToExtend CashierLockCriteriaToExtend) CashieringAPIPutCashierLockRequest {
	r.cashierLockCriteriaToExtend = &cashierLockCriteriaToExtend
	return r
}

// External system code.
func (r CashieringAPIPutCashierLockRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutCashierLockRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutCashierLockRequest) Execute() (*ExtendedCashierLock, *http.Response, error) {
	return r.ApiService.PutCashierLockExecute(r)
}

/*
PutCashierLock Extend Cashier Lock

You can use this API to Extend cashiers lock. <p><strong>OperationId:</strong>putCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lockId Unique ID of the lock.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutCashierLockRequest
*/
func (a *CashieringAPIService) PutCashierLock(ctx context.Context, lockId string, hotelId string) CashieringAPIPutCashierLockRequest {
	return CashieringAPIPutCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		lockId: lockId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ExtendedCashierLock
func (a *CashieringAPIService) PutCashierLockExecute(r CashieringAPIPutCashierLockRequest) (*ExtendedCashierLock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedCashierLock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashierslock/{lockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockId"+"}", url.PathEscape(parameterValueToString(r.lockId, "lockId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lockId) < 1 {
		return localVarReturnValue, nil, reportError("lockId must have at least 1 elements")
	}
	if strlen(r.lockId) > 2000 {
		return localVarReturnValue, nil, reportError("lockId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cashierLockCriteriaToExtend
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutForEarlyDepartureRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	earlyDeparture *EarlyDeparture
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutForEarlyDepartureRequest) Authorization(authorization string) CashieringAPIPutForEarlyDepartureRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutForEarlyDepartureRequest) XAppKey(xAppKey string) CashieringAPIPutForEarlyDepartureRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutForEarlyDepartureRequest) XHotelid(xHotelid string) CashieringAPIPutForEarlyDepartureRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change a reservation to an Early Departure. As part of this process the reservation will be changed to a Due Out status with the departure date being the current business date. Only Inhouse reservations can be changed to Early Departure. Before changing the reservation to early departure, rate restrictions on the rate code used and any allowances consumed by the guest for today will be checked. If there is a penalty applicable this can be posted to the reservation.
func (r CashieringAPIPutForEarlyDepartureRequest) EarlyDeparture(earlyDeparture EarlyDeparture) CashieringAPIPutForEarlyDepartureRequest {
	r.earlyDeparture = &earlyDeparture
	return r
}

// External system code.
func (r CashieringAPIPutForEarlyDepartureRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutForEarlyDepartureRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutForEarlyDepartureRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutForEarlyDepartureRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutForEarlyDepartureRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutForEarlyDepartureExecute(r)
}

/*
PutForEarlyDeparture Change early Departure

You can use this API to change early Departure. <p><strong>OperationId:</strong>putForEarlyDeparture</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutForEarlyDepartureRequest
*/
func (a *CashieringAPIService) PutForEarlyDeparture(ctx context.Context, reservationId string, hotelId string) CashieringAPIPutForEarlyDepartureRequest {
	return CashieringAPIPutForEarlyDepartureRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PutForEarlyDepartureExecute(r CashieringAPIPutForEarlyDepartureRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutForEarlyDeparture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/earlyDeparture"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.earlyDeparture
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutPayeeTaxNumberRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	payeeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	payeeTaxNumber *PayeeTaxNumber
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutPayeeTaxNumberRequest) Authorization(authorization string) CashieringAPIPutPayeeTaxNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutPayeeTaxNumberRequest) XAppKey(xAppKey string) CashieringAPIPutPayeeTaxNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutPayeeTaxNumberRequest) XHotelid(xHotelid string) CashieringAPIPutPayeeTaxNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate and change Payee Tax Number.
func (r CashieringAPIPutPayeeTaxNumberRequest) PayeeTaxNumber(payeeTaxNumber PayeeTaxNumber) CashieringAPIPutPayeeTaxNumberRequest {
	r.payeeTaxNumber = &payeeTaxNumber
	return r
}

// External system code.
func (r CashieringAPIPutPayeeTaxNumberRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutPayeeTaxNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutPayeeTaxNumberRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutPayeeTaxNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutPayeeTaxNumberRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPayeeTaxNumberExecute(r)
}

/*
PutPayeeTaxNumber Change Payee Tax Number

You can use this API to change Payee Tax Number. <p><strong>OperationId:</strong>putPayeeTaxNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payeeId Unique ID of the payee
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutPayeeTaxNumberRequest
*/
func (a *CashieringAPIService) PutPayeeTaxNumber(ctx context.Context, payeeId string, hotelId string) CashieringAPIPutPayeeTaxNumberRequest {
	return CashieringAPIPutPayeeTaxNumberRequest{
		ApiService: a,
		ctx: ctx,
		payeeId: payeeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PutPayeeTaxNumberExecute(r CashieringAPIPutPayeeTaxNumberRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutPayeeTaxNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/payees/{payeeId}/taxNumber"
	localVarPath = strings.Replace(localVarPath, "{"+"payeeId"+"}", url.PathEscape(parameterValueToString(r.payeeId, "payeeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.payeeId) < 1 {
		return localVarReturnValue, nil, reportError("payeeId must have at least 1 elements")
	}
	if strlen(r.payeeId) > 2000 {
		return localVarReturnValue, nil, reportError("payeeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.payeeTaxNumber
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutReservationDepositTransferRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	sourceReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositTransferCriteria *DepositTransferCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutReservationDepositTransferRequest) Authorization(authorization string) CashieringAPIPutReservationDepositTransferRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutReservationDepositTransferRequest) XAppKey(xAppKey string) CashieringAPIPutReservationDepositTransferRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutReservationDepositTransferRequest) XHotelid(xHotelid string) CashieringAPIPutReservationDepositTransferRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to transfer a deposit amount from one reservation to one or more reservations.
func (r CashieringAPIPutReservationDepositTransferRequest) DepositTransferCriteria(depositTransferCriteria DepositTransferCriteria) CashieringAPIPutReservationDepositTransferRequest {
	r.depositTransferCriteria = &depositTransferCriteria
	return r
}

// External system code.
func (r CashieringAPIPutReservationDepositTransferRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutReservationDepositTransferRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutReservationDepositTransferRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutReservationDepositTransferRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutReservationDepositTransferRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutReservationDepositTransferExecute(r)
}

/*
PutReservationDepositTransfer Change Reservation Deposit Transfer.

You can use this API to change Reservation Deposit Transfer. <p><strong>OperationId:</strong>putReservationDepositTransfer</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceReservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutReservationDepositTransferRequest
*/
func (a *CashieringAPIService) PutReservationDepositTransfer(ctx context.Context, sourceReservationId string, hotelId string) CashieringAPIPutReservationDepositTransferRequest {
	return CashieringAPIPutReservationDepositTransferRequest{
		ApiService: a,
		ctx: ctx,
		sourceReservationId: sourceReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) PutReservationDepositTransferExecute(r CashieringAPIPutReservationDepositTransferRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutReservationDepositTransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{sourceReservationId}/deposit/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceReservationId"+"}", url.PathEscape(parameterValueToString(r.sourceReservationId, "sourceReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceReservationId) < 1 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have at least 1 elements")
	}
	if strlen(r.sourceReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositTransferCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIPutRoutingInstructionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	routingInstructions *RoutingInstructions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIPutRoutingInstructionsRequest) Authorization(authorization string) CashieringAPIPutRoutingInstructionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIPutRoutingInstructionsRequest) XAppKey(xAppKey string) CashieringAPIPutRoutingInstructionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIPutRoutingInstructionsRequest) XHotelid(xHotelid string) CashieringAPIPutRoutingInstructionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a routing instruction.
func (r CashieringAPIPutRoutingInstructionsRequest) RoutingInstructions(routingInstructions RoutingInstructions) CashieringAPIPutRoutingInstructionsRequest {
	r.routingInstructions = &routingInstructions
	return r
}

// External system code.
func (r CashieringAPIPutRoutingInstructionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIPutRoutingInstructionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIPutRoutingInstructionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIPutRoutingInstructionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIPutRoutingInstructionsRequest) Execute() (*CreatedRoutingInstructions, *http.Response, error) {
	return r.ApiService.PutRoutingInstructionsExecute(r)
}

/*
PutRoutingInstructions Create routing instructions

You can use this API to add routing instructions to a reservation. <p><strong>OperationId:</strong>putRoutingInstructions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIPutRoutingInstructionsRequest
*/
func (a *CashieringAPIService) PutRoutingInstructions(ctx context.Context, reservationId string, hotelId string) CashieringAPIPutRoutingInstructionsRequest {
	return CashieringAPIPutRoutingInstructionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreatedRoutingInstructions
func (a *CashieringAPIService) PutRoutingInstructionsExecute(r CashieringAPIPutRoutingInstructionsRequest) (*CreatedRoutingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatedRoutingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.PutRoutingInstructions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/routingInstructions/create"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.routingInstructions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIRedeemPrepaidCardsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	redeemPrepaidCards *RedeemPrepaidCards
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIRedeemPrepaidCardsRequest) Authorization(authorization string) CashieringAPIRedeemPrepaidCardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIRedeemPrepaidCardsRequest) XAppKey(xAppKey string) CashieringAPIRedeemPrepaidCardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIRedeemPrepaidCardsRequest) XHotelid(xHotelid string) CashieringAPIRedeemPrepaidCardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for Prepaid card redeem amount request.
func (r CashieringAPIRedeemPrepaidCardsRequest) RedeemPrepaidCards(redeemPrepaidCards RedeemPrepaidCards) CashieringAPIRedeemPrepaidCardsRequest {
	r.redeemPrepaidCards = &redeemPrepaidCards
	return r
}

// External system code.
func (r CashieringAPIRedeemPrepaidCardsRequest) XExternalsystem(xExternalsystem string) CashieringAPIRedeemPrepaidCardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIRedeemPrepaidCardsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIRedeemPrepaidCardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIRedeemPrepaidCardsRequest) Execute() (*RedeemPrepaidCardsStatus, *http.Response, error) {
	return r.ApiService.RedeemPrepaidCardsExecute(r)
}

/*
RedeemPrepaidCards Operation to redeem prepaid cards.

You can use this API to redeem Prepaid Cards <p><strong>OperationId:</strong>redeemPrepaidCards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIRedeemPrepaidCardsRequest
*/
func (a *CashieringAPIService) RedeemPrepaidCards(ctx context.Context, reservationId string, hotelId string) CashieringAPIRedeemPrepaidCardsRequest {
	return CashieringAPIRedeemPrepaidCardsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RedeemPrepaidCardsStatus
func (a *CashieringAPIService) RedeemPrepaidCardsExecute(r CashieringAPIRedeemPrepaidCardsRequest) (*RedeemPrepaidCardsStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RedeemPrepaidCardsStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.RedeemPrepaidCards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/prepaidCards/redemptions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.redeemPrepaidCards
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIRegisterManualAuthorizationRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ccManualAuthorizationCriteria *CcManualAuthorizationCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIRegisterManualAuthorizationRequest) Authorization(authorization string) CashieringAPIRegisterManualAuthorizationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIRegisterManualAuthorizationRequest) XAppKey(xAppKey string) CashieringAPIRegisterManualAuthorizationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIRegisterManualAuthorizationRequest) XHotelid(xHotelid string) CashieringAPIRegisterManualAuthorizationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for registering a Manual Authorization.
func (r CashieringAPIRegisterManualAuthorizationRequest) CcManualAuthorizationCriteria(ccManualAuthorizationCriteria CcManualAuthorizationCriteria) CashieringAPIRegisterManualAuthorizationRequest {
	r.ccManualAuthorizationCriteria = &ccManualAuthorizationCriteria
	return r
}

// External system code.
func (r CashieringAPIRegisterManualAuthorizationRequest) XExternalsystem(xExternalsystem string) CashieringAPIRegisterManualAuthorizationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIRegisterManualAuthorizationRequest) AcceptLanguage(acceptLanguage string) CashieringAPIRegisterManualAuthorizationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIRegisterManualAuthorizationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RegisterManualAuthorizationExecute(r)
}

/*
RegisterManualAuthorization Register Manual Authorization

You can use this API to register Manual Authorization. <p><strong>OperationId:</strong>registerManualAuthorization</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIRegisterManualAuthorizationRequest
*/
func (a *CashieringAPIService) RegisterManualAuthorization(ctx context.Context, reservationId string, hotelId string) CashieringAPIRegisterManualAuthorizationRequest {
	return CashieringAPIRegisterManualAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) RegisterManualAuthorizationExecute(r CashieringAPIRegisterManualAuthorizationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.RegisterManualAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/paymentMethods/creditCard/authorize/manual"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ccManualAuthorizationCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIRegisterVaultTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	vaultTransaction *VaultTransaction
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIRegisterVaultTransactionRequest) Authorization(authorization string) CashieringAPIRegisterVaultTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIRegisterVaultTransactionRequest) XAppKey(xAppKey string) CashieringAPIRegisterVaultTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIRegisterVaultTransactionRequest) XHotelid(xHotelid string) CashieringAPIRegisterVaultTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to register the vault HTTP transaction.
func (r CashieringAPIRegisterVaultTransactionRequest) VaultTransaction(vaultTransaction VaultTransaction) CashieringAPIRegisterVaultTransactionRequest {
	r.vaultTransaction = &vaultTransaction
	return r
}

// External system code.
func (r CashieringAPIRegisterVaultTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPIRegisterVaultTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIRegisterVaultTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPIRegisterVaultTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIRegisterVaultTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RegisterVaultTransactionExecute(r)
}

/*
RegisterVaultTransaction Register Vault Transaction

You can use this API to create vault transaction. <p><strong>OperationId:</strong>registerVaultTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIRegisterVaultTransactionRequest
*/
func (a *CashieringAPIService) RegisterVaultTransaction(ctx context.Context, hotelId string) CashieringAPIRegisterVaultTransactionRequest {
	return CashieringAPIRegisterVaultTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) RegisterVaultTransactionExecute(r CashieringAPIRegisterVaultTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.RegisterVaultTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditcardTransaction/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.vaultTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReinstateCheckOutRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reinstateCheckedOutReservation *ReinstateCheckedOutReservation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReinstateCheckOutRequest) Authorization(authorization string) CashieringAPIReinstateCheckOutRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReinstateCheckOutRequest) XAppKey(xAppKey string) CashieringAPIReinstateCheckOutRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReinstateCheckOutRequest) XHotelid(xHotelid string) CashieringAPIReinstateCheckOutRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to reinstate checkout reservation in order to post additional transactions, etc.
func (r CashieringAPIReinstateCheckOutRequest) ReinstateCheckedOutReservation(reinstateCheckedOutReservation ReinstateCheckedOutReservation) CashieringAPIReinstateCheckOutRequest {
	r.reinstateCheckedOutReservation = &reinstateCheckedOutReservation
	return r
}

// External system code.
func (r CashieringAPIReinstateCheckOutRequest) XExternalsystem(xExternalsystem string) CashieringAPIReinstateCheckOutRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReinstateCheckOutRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReinstateCheckOutRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReinstateCheckOutRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReinstateCheckOutExecute(r)
}

/*
ReinstateCheckOut Reinstate Checked Out Reservation

You can use this API to reinstate Checked Out Reservation. <p><strong>OperationId:</strong>reinstateCheckOut</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReinstateCheckOutRequest
*/
func (a *CashieringAPIService) ReinstateCheckOut(ctx context.Context, reservationId string, hotelId string) CashieringAPIReinstateCheckOutRequest {
	return CashieringAPIReinstateCheckOutRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ReinstateCheckOutExecute(r CashieringAPIReinstateCheckOutRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReinstateCheckOut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/checkOuts/reinstate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reinstateCheckedOutReservation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReleaseCashierLockRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	lockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReleaseCashierLockRequest) Authorization(authorization string) CashieringAPIReleaseCashierLockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReleaseCashierLockRequest) XAppKey(xAppKey string) CashieringAPIReleaseCashierLockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReleaseCashierLockRequest) XHotelid(xHotelid string) CashieringAPIReleaseCashierLockRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIReleaseCashierLockRequest) XExternalsystem(xExternalsystem string) CashieringAPIReleaseCashierLockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReleaseCashierLockRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReleaseCashierLockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReleaseCashierLockRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReleaseCashierLockExecute(r)
}

/*
ReleaseCashierLock Release Cashier Lock

You can use this API to Release Cashier Lock. <p><strong>OperationId:</strong>releaseCashierLock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lockId Unique ID of the lock.
 @return CashieringAPIReleaseCashierLockRequest
*/
func (a *CashieringAPIService) ReleaseCashierLock(ctx context.Context, lockId string) CashieringAPIReleaseCashierLockRequest {
	return CashieringAPIReleaseCashierLockRequest{
		ApiService: a,
		ctx: ctx,
		lockId: lockId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ReleaseCashierLockExecute(r CashieringAPIReleaseCashierLockRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReleaseCashierLock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cashiersLock/{lockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"lockId"+"}", url.PathEscape(parameterValueToString(r.lockId, "lockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.lockId) < 1 {
		return localVarReturnValue, nil, reportError("lockId must have at least 1 elements")
	}
	if strlen(r.lockId) > 2000 {
		return localVarReturnValue, nil, reportError("lockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReloadPrepaidCardRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reloadPrepaidCard *ReloadPrepaidCard
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReloadPrepaidCardRequest) Authorization(authorization string) CashieringAPIReloadPrepaidCardRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReloadPrepaidCardRequest) XAppKey(xAppKey string) CashieringAPIReloadPrepaidCardRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReloadPrepaidCardRequest) XHotelid(xHotelid string) CashieringAPIReloadPrepaidCardRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type for reload prepaid card.
func (r CashieringAPIReloadPrepaidCardRequest) ReloadPrepaidCard(reloadPrepaidCard ReloadPrepaidCard) CashieringAPIReloadPrepaidCardRequest {
	r.reloadPrepaidCard = &reloadPrepaidCard
	return r
}

// External system code.
func (r CashieringAPIReloadPrepaidCardRequest) XExternalsystem(xExternalsystem string) CashieringAPIReloadPrepaidCardRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReloadPrepaidCardRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReloadPrepaidCardRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReloadPrepaidCardRequest) Execute() (*ReloadPrepaidCardStatus, *http.Response, error) {
	return r.ApiService.ReloadPrepaidCardExecute(r)
}

/*
ReloadPrepaidCard Operation to reload prepaid card.

You can use this API to reload Prepaid Card. <p><strong>OperationId:</strong>reloadPrepaidCard</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReloadPrepaidCardRequest
*/
func (a *CashieringAPIService) ReloadPrepaidCard(ctx context.Context, hotelId string) CashieringAPIReloadPrepaidCardRequest {
	return CashieringAPIReloadPrepaidCardRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReloadPrepaidCardStatus
func (a *CashieringAPIService) ReloadPrepaidCardExecute(r CashieringAPIReloadPrepaidCardRequest) (*ReloadPrepaidCardStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReloadPrepaidCardStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReloadPrepaidCard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/prepaidCards/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reloadPrepaidCard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIRemoveBedTaxInfoRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	taxRegistraitionNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIRemoveBedTaxInfoRequest) Authorization(authorization string) CashieringAPIRemoveBedTaxInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIRemoveBedTaxInfoRequest) XAppKey(xAppKey string) CashieringAPIRemoveBedTaxInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIRemoveBedTaxInfoRequest) XHotelid(xHotelid string) CashieringAPIRemoveBedTaxInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIRemoveBedTaxInfoRequest) XExternalsystem(xExternalsystem string) CashieringAPIRemoveBedTaxInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIRemoveBedTaxInfoRequest) AcceptLanguage(acceptLanguage string) CashieringAPIRemoveBedTaxInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIRemoveBedTaxInfoRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveBedTaxInfoExecute(r)
}

/*
RemoveBedTaxInfo Delete bed tax information

You can use this API to delete bed tax information for a property. <p><strong>OperationId:</strong>removeBedTaxInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxRegistraitionNo Unique number of the tax registration.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIRemoveBedTaxInfoRequest

Deprecated
*/
func (a *CashieringAPIService) RemoveBedTaxInfo(ctx context.Context, taxRegistraitionNo string, hotelId string) CashieringAPIRemoveBedTaxInfoRequest {
	return CashieringAPIRemoveBedTaxInfoRequest{
		ApiService: a,
		ctx: ctx,
		taxRegistraitionNo: taxRegistraitionNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *CashieringAPIService) RemoveBedTaxInfoExecute(r CashieringAPIRemoveBedTaxInfoRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.RemoveBedTaxInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bedTax/{taxRegistraitionNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxRegistraitionNo"+"}", url.PathEscape(parameterValueToString(r.taxRegistraitionNo, "taxRegistraitionNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taxRegistraitionNo) < 1 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have at least 1 elements")
	}
	if strlen(r.taxRegistraitionNo) > 2000 {
		return localVarReturnValue, nil, reportError("taxRegistraitionNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIRemoveFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fixedChargeID *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIRemoveFixedChargesRequest) Authorization(authorization string) CashieringAPIRemoveFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIRemoveFixedChargesRequest) XAppKey(xAppKey string) CashieringAPIRemoveFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIRemoveFixedChargesRequest) XHotelid(xHotelid string) CashieringAPIRemoveFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIRemoveFixedChargesRequest) FixedChargeID(fixedChargeID []string) CashieringAPIRemoveFixedChargesRequest {
	r.fixedChargeID = &fixedChargeID
	return r
}

// External system code.
func (r CashieringAPIRemoveFixedChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIRemoveFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIRemoveFixedChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIRemoveFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIRemoveFixedChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFixedChargesExecute(r)
}

/*
RemoveFixedCharges Delete Fixed Charges 

You can use this API to remove fixed Charges for a reservation. <p><strong>OperationId:</strong>removeFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIRemoveFixedChargesRequest
*/
func (a *CashieringAPIService) RemoveFixedCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIRemoveFixedChargesRequest {
	return CashieringAPIRemoveFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) RemoveFixedChargesExecute(r CashieringAPIRemoveFixedChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.RemoveFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fixedChargeID != nil {
		t := *r.fixedChargeID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fixedChargeID", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fixedChargeID", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIResendSupportingDocumentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fiscalSupportingDocumentCriteria *FiscalSupportingDocumentCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIResendSupportingDocumentRequest) Authorization(authorization string) CashieringAPIResendSupportingDocumentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIResendSupportingDocumentRequest) XAppKey(xAppKey string) CashieringAPIResendSupportingDocumentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIResendSupportingDocumentRequest) XHotelid(xHotelid string) CashieringAPIResendSupportingDocumentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to send supporting document.
func (r CashieringAPIResendSupportingDocumentRequest) FiscalSupportingDocumentCriteria(fiscalSupportingDocumentCriteria FiscalSupportingDocumentCriteria) CashieringAPIResendSupportingDocumentRequest {
	r.fiscalSupportingDocumentCriteria = &fiscalSupportingDocumentCriteria
	return r
}

// External system code.
func (r CashieringAPIResendSupportingDocumentRequest) XExternalsystem(xExternalsystem string) CashieringAPIResendSupportingDocumentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIResendSupportingDocumentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIResendSupportingDocumentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIResendSupportingDocumentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ResendSupportingDocumentExecute(r)
}

/*
ResendSupportingDocument Operation to resend the failed supporting documents to fiscal partner.

This API is used to resend the failed supporting documents. <p><strong>OperationId:</strong>resendSupportingDocument</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIResendSupportingDocumentRequest
*/
func (a *CashieringAPIService) ResendSupportingDocument(ctx context.Context, hotelId string) CashieringAPIResendSupportingDocumentRequest {
	return CashieringAPIResendSupportingDocumentRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ResendSupportingDocumentExecute(r CashieringAPIResendSupportingDocumentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ResendSupportingDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/fiscalSupportingDocuments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fiscalSupportingDocumentCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReverseARInvoiceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reasonCode *string
	cashierId *float32
	transactionCodes *[]float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReverseARInvoiceRequest) Authorization(authorization string) CashieringAPIReverseARInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReverseARInvoiceRequest) XAppKey(xAppKey string) CashieringAPIReverseARInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReverseARInvoiceRequest) XHotelid(xHotelid string) CashieringAPIReverseARInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The reason code for the deletion.
func (r CashieringAPIReverseARInvoiceRequest) ReasonCode(reasonCode string) CashieringAPIReverseARInvoiceRequest {
	r.reasonCode = &reasonCode
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIReverseARInvoiceRequest) CashierId(cashierId float32) CashieringAPIReverseARInvoiceRequest {
	r.cashierId = &cashierId
	return r
}

// The unique transaction number of this transaction.
func (r CashieringAPIReverseARInvoiceRequest) TransactionCodes(transactionCodes []float32) CashieringAPIReverseARInvoiceRequest {
	r.transactionCodes = &transactionCodes
	return r
}

// External system code.
func (r CashieringAPIReverseARInvoiceRequest) XExternalsystem(xExternalsystem string) CashieringAPIReverseARInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReverseARInvoiceRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReverseARInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReverseARInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseARInvoiceExecute(r)
}

/*
ReverseARInvoice Reverse AR Invoice

You can use this API to reverse an AR Invoice. <p><strong>OperationId:</strong>reverseARInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReverseARInvoiceRequest
*/
func (a *CashieringAPIService) ReverseARInvoice(ctx context.Context, hotelId string) CashieringAPIReverseARInvoiceRequest {
	return CashieringAPIReverseARInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ReverseARInvoiceExecute(r CashieringAPIReverseARInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReverseARInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/arInvoices/reverse"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reasonCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reasonCode", r.reasonCode, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.transactionCodes != nil {
		t := *r.transactionCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReverseCertificatePostingsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reverseCertificatePostingsCriteria *ReverseCertificatePostingsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReverseCertificatePostingsRequest) Authorization(authorization string) CashieringAPIReverseCertificatePostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReverseCertificatePostingsRequest) XAppKey(xAppKey string) CashieringAPIReverseCertificatePostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReverseCertificatePostingsRequest) XHotelid(xHotelid string) CashieringAPIReverseCertificatePostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to reverse the certificate postings of transactions.
func (r CashieringAPIReverseCertificatePostingsRequest) ReverseCertificatePostingsCriteria(reverseCertificatePostingsCriteria ReverseCertificatePostingsCriteria) CashieringAPIReverseCertificatePostingsRequest {
	r.reverseCertificatePostingsCriteria = &reverseCertificatePostingsCriteria
	return r
}

// External system code.
func (r CashieringAPIReverseCertificatePostingsRequest) XExternalsystem(xExternalsystem string) CashieringAPIReverseCertificatePostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReverseCertificatePostingsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReverseCertificatePostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReverseCertificatePostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCertificatePostingsExecute(r)
}

/*
ReverseCertificatePostings Reverse certificate postings

You can use this API to Reverse certificate postings. <p><strong>OperationId:</strong>reverseCertificatePostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReverseCertificatePostingsRequest
*/
func (a *CashieringAPIService) ReverseCertificatePostings(ctx context.Context, reservationId string, hotelId string) CashieringAPIReverseCertificatePostingsRequest {
	return CashieringAPIReverseCertificatePostingsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ReverseCertificatePostingsExecute(r CashieringAPIReverseCertificatePostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReverseCertificatePostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/reverseCertificate"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseCertificatePostingsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReverseCompRedemptionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reverseCompRedemptions *ReverseCompRedemptions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReverseCompRedemptionsRequest) Authorization(authorization string) CashieringAPIReverseCompRedemptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReverseCompRedemptionsRequest) XAppKey(xAppKey string) CashieringAPIReverseCompRedemptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReverseCompRedemptionsRequest) XHotelid(xHotelid string) CashieringAPIReverseCompRedemptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request type of Complimentary Bucket Redemptions reversal.
func (r CashieringAPIReverseCompRedemptionsRequest) ReverseCompRedemptions(reverseCompRedemptions ReverseCompRedemptions) CashieringAPIReverseCompRedemptionsRequest {
	r.reverseCompRedemptions = &reverseCompRedemptions
	return r
}

// External system code.
func (r CashieringAPIReverseCompRedemptionsRequest) XExternalsystem(xExternalsystem string) CashieringAPIReverseCompRedemptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReverseCompRedemptionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReverseCompRedemptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReverseCompRedemptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseCompRedemptionsExecute(r)
}

/*
ReverseCompRedemptions Operation to reverse complimentary bucket redemptions for a guest having PTS Membership Type

You can use this API to reverse complimentary bucket redemptions for a guest having PTS Membership Type <p><strong>OperationId:</strong>reverseCompRedemptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReverseCompRedemptionsRequest
*/
func (a *CashieringAPIService) ReverseCompRedemptions(ctx context.Context, reservationId string, hotelId string) CashieringAPIReverseCompRedemptionsRequest {
	return CashieringAPIReverseCompRedemptionsRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ReverseCompRedemptionsExecute(r CashieringAPIReverseCompRedemptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReverseCompRedemptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/compRedemptionReversals"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reverseCompRedemptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReverseFlexibleBenefitPostingRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReverseFlexibleBenefitPostingRequest) Authorization(authorization string) CashieringAPIReverseFlexibleBenefitPostingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReverseFlexibleBenefitPostingRequest) XAppKey(xAppKey string) CashieringAPIReverseFlexibleBenefitPostingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReverseFlexibleBenefitPostingRequest) XHotelid(xHotelid string) CashieringAPIReverseFlexibleBenefitPostingRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIReverseFlexibleBenefitPostingRequest) XExternalsystem(xExternalsystem string) CashieringAPIReverseFlexibleBenefitPostingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReverseFlexibleBenefitPostingRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReverseFlexibleBenefitPostingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReverseFlexibleBenefitPostingRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReverseFlexibleBenefitPostingExecute(r)
}

/*
ReverseFlexibleBenefitPosting Delete flexible benefit postings

You can use this API to delete flexible benefit postings. <p><strong>OperationId:</strong>reverseFlexibleBenefitPosting</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReverseFlexibleBenefitPostingRequest
*/
func (a *CashieringAPIService) ReverseFlexibleBenefitPosting(ctx context.Context, transactionId string, hotelId string) CashieringAPIReverseFlexibleBenefitPostingRequest {
	return CashieringAPIReverseFlexibleBenefitPostingRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) ReverseFlexibleBenefitPostingExecute(r CashieringAPIReverseFlexibleBenefitPostingRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReverseFlexibleBenefitPosting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/flexibleBenefitPostings"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIReverseFolioTaxPaymentRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	cashierId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionReversal *TransactionReversal
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIReverseFolioTaxPaymentRequest) Authorization(authorization string) CashieringAPIReverseFolioTaxPaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIReverseFolioTaxPaymentRequest) XAppKey(xAppKey string) CashieringAPIReverseFolioTaxPaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIReverseFolioTaxPaymentRequest) XHotelid(xHotelid string) CashieringAPIReverseFolioTaxPaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to reverse a Payment Tax record for Thailand Tax requirement.
func (r CashieringAPIReverseFolioTaxPaymentRequest) TransactionReversal(transactionReversal TransactionReversal) CashieringAPIReverseFolioTaxPaymentRequest {
	r.transactionReversal = &transactionReversal
	return r
}

// External system code.
func (r CashieringAPIReverseFolioTaxPaymentRequest) XExternalsystem(xExternalsystem string) CashieringAPIReverseFolioTaxPaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIReverseFolioTaxPaymentRequest) AcceptLanguage(acceptLanguage string) CashieringAPIReverseFolioTaxPaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIReverseFolioTaxPaymentRequest) Execute() (*FolioTaxPaymentReversal, *http.Response, error) {
	return r.ApiService.ReverseFolioTaxPaymentExecute(r)
}

/*
ReverseFolioTaxPayment Change folio tax payments

You can use this API to change folio tax payments. <p><strong>OperationId:</strong>reverseFolioTaxPayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cashierId Unique ID of the cashier.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIReverseFolioTaxPaymentRequest
*/
func (a *CashieringAPIService) ReverseFolioTaxPayment(ctx context.Context, cashierId string, hotelId string) CashieringAPIReverseFolioTaxPaymentRequest {
	return CashieringAPIReverseFolioTaxPaymentRequest{
		ApiService: a,
		ctx: ctx,
		cashierId: cashierId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FolioTaxPaymentReversal
func (a *CashieringAPIService) ReverseFolioTaxPaymentExecute(r CashieringAPIReverseFolioTaxPaymentRequest) (*FolioTaxPaymentReversal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FolioTaxPaymentReversal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ReverseFolioTaxPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/cashiers/{cashierId}/folioTaxPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"cashierId"+"}", url.PathEscape(parameterValueToString(r.cashierId, "cashierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cashierId) < 1 {
		return localVarReturnValue, nil, reportError("cashierId must have at least 1 elements")
	}
	if strlen(r.cashierId) > 2000 {
		return localVarReturnValue, nil, reportError("cashierId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionReversal
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPISplitAndTransferTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionToSplitAndTransfer *TransactionToSplitAndTransfer
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPISplitAndTransferTransactionRequest) Authorization(authorization string) CashieringAPISplitAndTransferTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPISplitAndTransferTransactionRequest) XAppKey(xAppKey string) CashieringAPISplitAndTransferTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPISplitAndTransferTransactionRequest) XHotelid(xHotelid string) CashieringAPISplitAndTransferTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split a transaction on a reservation and transfer the new transaction to a different reservation or a different window on the same reservation. Splitting of transactions requires a Inhouse target reservation, a list of transactions for a Inhouse reservation and a valid amount or a percentage by which the amount can be split. Based on parameters, certain transactions cannot be split. Transaction which are included in an invoice cannot be split Transactions where the generates resides elsewhere(reservation or window) cannot be split. Automatically generated transactions such as taxes, cannot be split by itself. Deposits which were part of a deposit folio cannot be split. After the split is done the transaction is transferred to the target reservation/window.
func (r CashieringAPISplitAndTransferTransactionRequest) TransactionToSplitAndTransfer(transactionToSplitAndTransfer TransactionToSplitAndTransfer) CashieringAPISplitAndTransferTransactionRequest {
	r.transactionToSplitAndTransfer = &transactionToSplitAndTransfer
	return r
}

// External system code.
func (r CashieringAPISplitAndTransferTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPISplitAndTransferTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPISplitAndTransferTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPISplitAndTransferTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPISplitAndTransferTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SplitAndTransferTransactionExecute(r)
}

/*
SplitAndTransferTransaction Split and transfer transactions

You can use this API to split and transfer transactions. <p><strong>OperationId:</strong>splitAndTransferTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPISplitAndTransferTransactionRequest
*/
func (a *CashieringAPIService) SplitAndTransferTransaction(ctx context.Context, hotelId string) CashieringAPISplitAndTransferTransactionRequest {
	return CashieringAPISplitAndTransferTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) SplitAndTransferTransactionExecute(r CashieringAPISplitAndTransferTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.SplitAndTransferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/splitAndTransfer"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionToSplitAndTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPISplitDepositTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	splitDepositTransaction *SplitDepositTransaction
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPISplitDepositTransactionRequest) Authorization(authorization string) CashieringAPISplitDepositTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPISplitDepositTransactionRequest) XAppKey(xAppKey string) CashieringAPISplitDepositTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPISplitDepositTransactionRequest) XHotelid(xHotelid string) CashieringAPISplitDepositTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split deposit transaction for a reservation.
func (r CashieringAPISplitDepositTransactionRequest) SplitDepositTransaction(splitDepositTransaction SplitDepositTransaction) CashieringAPISplitDepositTransactionRequest {
	r.splitDepositTransaction = &splitDepositTransaction
	return r
}

// External system code.
func (r CashieringAPISplitDepositTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPISplitDepositTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPISplitDepositTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPISplitDepositTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPISplitDepositTransactionRequest) Execute() (*SplitDepositTransactionStatus, *http.Response, error) {
	return r.ApiService.SplitDepositTransactionExecute(r)
}

/*
SplitDepositTransaction Split deposit transaction

You can use this API to Split deposit transaction. <p><strong>OperationId:</strong>splitDepositTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPISplitDepositTransactionRequest
*/
func (a *CashieringAPIService) SplitDepositTransaction(ctx context.Context, transactionId string, reservationId string, hotelId string) CashieringAPISplitDepositTransactionRequest {
	return CashieringAPISplitDepositTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SplitDepositTransactionStatus
func (a *CashieringAPIService) SplitDepositTransactionExecute(r CashieringAPISplitDepositTransactionRequest) (*SplitDepositTransactionStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SplitDepositTransactionStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.SplitDepositTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.splitDepositTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPISplitTransactionRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionToSplit *TransactionToSplit
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPISplitTransactionRequest) Authorization(authorization string) CashieringAPISplitTransactionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPISplitTransactionRequest) XAppKey(xAppKey string) CashieringAPISplitTransactionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPISplitTransactionRequest) XHotelid(xHotelid string) CashieringAPISplitTransactionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to split a transaction on a reservation. Splitting of transactions requires a list of transactions and a valid amount or a percentage by which the amount can be split. Based on parameters, certain transactions cannot be split. Transaction which are included in an invoice cannot be split Transactions where the generates resides elsewhere(reservation or window) cannot be split. Automatically generated transactions such as taxes, cannot be split by itself. Deposits which were part of a deposit folio cannot be split. After the split is done the transaction resides on the same folio window as the original transaction.
func (r CashieringAPISplitTransactionRequest) TransactionToSplit(transactionToSplit TransactionToSplit) CashieringAPISplitTransactionRequest {
	r.transactionToSplit = &transactionToSplit
	return r
}

// External system code.
func (r CashieringAPISplitTransactionRequest) XExternalsystem(xExternalsystem string) CashieringAPISplitTransactionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPISplitTransactionRequest) AcceptLanguage(acceptLanguage string) CashieringAPISplitTransactionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPISplitTransactionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SplitTransactionExecute(r)
}

/*
SplitTransaction Split transactions

You can use this API to Split transactions. <p><strong>OperationId:</strong>splitTransaction</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPISplitTransactionRequest
*/
func (a *CashieringAPIService) SplitTransaction(ctx context.Context, hotelId string) CashieringAPISplitTransactionRequest {
	return CashieringAPISplitTransactionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) SplitTransactionExecute(r CashieringAPISplitTransactionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.SplitTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/split"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionToSplit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPITransferCompTransactionsRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transferCompTransactions *TransferCompTransactions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPITransferCompTransactionsRequest) Authorization(authorization string) CashieringAPITransferCompTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPITransferCompTransactionsRequest) XAppKey(xAppKey string) CashieringAPITransferCompTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPITransferCompTransactionsRequest) XHotelid(xHotelid string) CashieringAPITransferCompTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object of comp transactions transfer.
func (r CashieringAPITransferCompTransactionsRequest) TransferCompTransactions(transferCompTransactions TransferCompTransactions) CashieringAPITransferCompTransactionsRequest {
	r.transferCompTransactions = &transferCompTransactions
	return r
}

// External system code.
func (r CashieringAPITransferCompTransactionsRequest) XExternalsystem(xExternalsystem string) CashieringAPITransferCompTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPITransferCompTransactionsRequest) AcceptLanguage(acceptLanguage string) CashieringAPITransferCompTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPITransferCompTransactionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferCompTransactionsExecute(r)
}

/*
TransferCompTransactions Transfer comp transactions to window

You can use this API to transfer comp transactions to window <p><strong>OperationId:</strong>transferCompTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPITransferCompTransactionsRequest
*/
func (a *CashieringAPIService) TransferCompTransactions(ctx context.Context, hotelId string) CashieringAPITransferCompTransactionsRequest {
	return CashieringAPITransferCompTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) TransferCompTransactionsExecute(r CashieringAPITransferCompTransactionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.TransferCompTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transferCompTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transferCompTransactions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPITransferFolioToWindowRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioToWindow *FolioToWindow
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPITransferFolioToWindowRequest) Authorization(authorization string) CashieringAPITransferFolioToWindowRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPITransferFolioToWindowRequest) XAppKey(xAppKey string) CashieringAPITransferFolioToWindowRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPITransferFolioToWindowRequest) XHotelid(xHotelid string) CashieringAPITransferFolioToWindowRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transaction folio(s) to specific window
func (r CashieringAPITransferFolioToWindowRequest) FolioToWindow(folioToWindow FolioToWindow) CashieringAPITransferFolioToWindowRequest {
	r.folioToWindow = &folioToWindow
	return r
}

// External system code.
func (r CashieringAPITransferFolioToWindowRequest) XExternalsystem(xExternalsystem string) CashieringAPITransferFolioToWindowRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPITransferFolioToWindowRequest) AcceptLanguage(acceptLanguage string) CashieringAPITransferFolioToWindowRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPITransferFolioToWindowRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferFolioToWindowExecute(r)
}

/*
TransferFolioToWindow Transfer Folio to Window.

You can use this API to transfer Folio to Window. <p><strong>OperationId:</strong>transferFolioToWindow</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPITransferFolioToWindowRequest
*/
func (a *CashieringAPIService) TransferFolioToWindow(ctx context.Context, reservationId string, hotelId string) CashieringAPITransferFolioToWindowRequest {
	return CashieringAPITransferFolioToWindowRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) TransferFolioToWindowExecute(r CashieringAPITransferFolioToWindowRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.TransferFolioToWindow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transferFolioTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioToWindow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPITransferTransactionToReservationRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	toReservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationTransaction *ReservationTransaction
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPITransferTransactionToReservationRequest) Authorization(authorization string) CashieringAPITransferTransactionToReservationRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPITransferTransactionToReservationRequest) XAppKey(xAppKey string) CashieringAPITransferTransactionToReservationRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPITransferTransactionToReservationRequest) XHotelid(xHotelid string) CashieringAPITransferTransactionToReservationRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to transfer a transaction(s) to a reservation. In the criteria, the target Reservation Id is required for the transfer.
func (r CashieringAPITransferTransactionToReservationRequest) ReservationTransaction(reservationTransaction ReservationTransaction) CashieringAPITransferTransactionToReservationRequest {
	r.reservationTransaction = &reservationTransaction
	return r
}

// External system code.
func (r CashieringAPITransferTransactionToReservationRequest) XExternalsystem(xExternalsystem string) CashieringAPITransferTransactionToReservationRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPITransferTransactionToReservationRequest) AcceptLanguage(acceptLanguage string) CashieringAPITransferTransactionToReservationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPITransferTransactionToReservationRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferTransactionToReservationExecute(r)
}

/*
TransferTransactionToReservation Transfer Transaction to Reservation

You can use this API to Transfer Transaction to Reservation. <p><strong>OperationId:</strong>transferTransactionToReservation</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param toReservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPITransferTransactionToReservationRequest
*/
func (a *CashieringAPIService) TransferTransactionToReservation(ctx context.Context, toReservationId string, hotelId string) CashieringAPITransferTransactionToReservationRequest {
	return CashieringAPITransferTransactionToReservationRequest{
		ApiService: a,
		ctx: ctx,
		toReservationId: toReservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) TransferTransactionToReservationExecute(r CashieringAPITransferTransactionToReservationRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.TransferTransactionToReservation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{toReservationId}/transferTransaction"
	localVarPath = strings.Replace(localVarPath, "{"+"toReservationId"+"}", url.PathEscape(parameterValueToString(r.toReservationId, "toReservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.toReservationId) < 1 {
		return localVarReturnValue, nil, reportError("toReservationId must have at least 1 elements")
	}
	if strlen(r.toReservationId) > 2000 {
		return localVarReturnValue, nil, reportError("toReservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reservationTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPITransferTransactionToWindowRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transactionToWindow *TransactionToWindow
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPITransferTransactionToWindowRequest) Authorization(authorization string) CashieringAPITransferTransactionToWindowRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPITransferTransactionToWindowRequest) XAppKey(xAppKey string) CashieringAPITransferTransactionToWindowRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPITransferTransactionToWindowRequest) XHotelid(xHotelid string) CashieringAPITransferTransactionToWindowRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transaction transfer
func (r CashieringAPITransferTransactionToWindowRequest) TransactionToWindow(transactionToWindow TransactionToWindow) CashieringAPITransferTransactionToWindowRequest {
	r.transactionToWindow = &transactionToWindow
	return r
}

// External system code.
func (r CashieringAPITransferTransactionToWindowRequest) XExternalsystem(xExternalsystem string) CashieringAPITransferTransactionToWindowRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPITransferTransactionToWindowRequest) AcceptLanguage(acceptLanguage string) CashieringAPITransferTransactionToWindowRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPITransferTransactionToWindowRequest) Execute() (*TransferTransactionToWindow, *http.Response, error) {
	return r.ApiService.TransferTransactionToWindowExecute(r)
}

/*
TransferTransactionToWindow Transfer Transaction to Window

You can use this API to transfer Transaction to Window. <p><strong>OperationId:</strong>transferTransactionToWindow</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPITransferTransactionToWindowRequest
*/
func (a *CashieringAPIService) TransferTransactionToWindow(ctx context.Context, reservationId string, hotelId string) CashieringAPITransferTransactionToWindowRequest {
	return CashieringAPITransferTransactionToWindowRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TransferTransactionToWindow
func (a *CashieringAPIService) TransferTransactionToWindowExecute(r CashieringAPITransferTransactionToWindowRequest) (*TransferTransactionToWindow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransferTransactionToWindow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.TransferTransactionToWindow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/transferTransactions"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transactionToWindow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPITransitionDepositToGuestFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositToGuestFolio *DepositToGuestFolio
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPITransitionDepositToGuestFolioRequest) Authorization(authorization string) CashieringAPITransitionDepositToGuestFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPITransitionDepositToGuestFolioRequest) XAppKey(xAppKey string) CashieringAPITransitionDepositToGuestFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPITransitionDepositToGuestFolioRequest) XHotelid(xHotelid string) CashieringAPITransitionDepositToGuestFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post an existing deposit on a reservation to the Guest Folio for No Show or Cancelled Reservations. Deposits remain in the deposit ledger until Checkin/Checkout. In the case of No Show or Cancelled reservations they remain in the deposit ledger until this request is done.
func (r CashieringAPITransitionDepositToGuestFolioRequest) DepositToGuestFolio(depositToGuestFolio DepositToGuestFolio) CashieringAPITransitionDepositToGuestFolioRequest {
	r.depositToGuestFolio = &depositToGuestFolio
	return r
}

// External system code.
func (r CashieringAPITransitionDepositToGuestFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPITransitionDepositToGuestFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPITransitionDepositToGuestFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPITransitionDepositToGuestFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPITransitionDepositToGuestFolioRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransitionDepositToGuestFolioExecute(r)
}

/*
TransitionDepositToGuestFolio Transition Deposit to Guest Folio

You can use this API to Transfer Deposit to Guest Folio. <p><strong>OperationId:</strong>transitionDepositToGuestFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPITransitionDepositToGuestFolioRequest
*/
func (a *CashieringAPIService) TransitionDepositToGuestFolio(ctx context.Context, reservationId string, hotelId string) CashieringAPITransitionDepositToGuestFolioRequest {
	return CashieringAPITransitionDepositToGuestFolioRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) TransitionDepositToGuestFolioExecute(r CashieringAPITransitionDepositToGuestFolioRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.TransitionDepositToGuestFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/depositTransition"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositToGuestFolio
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIUnlinkReservationPackageAllowanceRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIUnlinkReservationPackageAllowanceRequest) Authorization(authorization string) CashieringAPIUnlinkReservationPackageAllowanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIUnlinkReservationPackageAllowanceRequest) XAppKey(xAppKey string) CashieringAPIUnlinkReservationPackageAllowanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIUnlinkReservationPackageAllowanceRequest) XHotelid(xHotelid string) CashieringAPIUnlinkReservationPackageAllowanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r CashieringAPIUnlinkReservationPackageAllowanceRequest) XExternalsystem(xExternalsystem string) CashieringAPIUnlinkReservationPackageAllowanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIUnlinkReservationPackageAllowanceRequest) AcceptLanguage(acceptLanguage string) CashieringAPIUnlinkReservationPackageAllowanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIUnlinkReservationPackageAllowanceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UnlinkReservationPackageAllowanceExecute(r)
}

/*
UnlinkReservationPackageAllowance Unlink reservation package allowance

You can use this API to unlink reservation package allowance. <p><strong>OperationId:</strong>unlinkReservationPackageAllowance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIUnlinkReservationPackageAllowanceRequest
*/
func (a *CashieringAPIService) UnlinkReservationPackageAllowance(ctx context.Context, reservationId string, hotelId string) CashieringAPIUnlinkReservationPackageAllowanceRequest {
	return CashieringAPIUnlinkReservationPackageAllowanceRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) UnlinkReservationPackageAllowanceExecute(r CashieringAPIUnlinkReservationPackageAllowanceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.UnlinkReservationPackageAllowance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/packageAllowance/links"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIUpdateFixedChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fixedCharges *FixedCharges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIUpdateFixedChargesRequest) Authorization(authorization string) CashieringAPIUpdateFixedChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIUpdateFixedChargesRequest) XAppKey(xAppKey string) CashieringAPIUpdateFixedChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIUpdateFixedChargesRequest) XHotelid(xHotelid string) CashieringAPIUpdateFixedChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Method to update fixed charges of a reservation.
func (r CashieringAPIUpdateFixedChargesRequest) FixedCharges(fixedCharges FixedCharges) CashieringAPIUpdateFixedChargesRequest {
	r.fixedCharges = &fixedCharges
	return r
}

// External system code.
func (r CashieringAPIUpdateFixedChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIUpdateFixedChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIUpdateFixedChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIUpdateFixedChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIUpdateFixedChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UpdateFixedChargesExecute(r)
}

/*
UpdateFixedCharges Updates Fixed Charges 

You can use this API to update fixed Charges for a reservation. <p><strong>OperationId:</strong>updateFixedCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIUpdateFixedChargesRequest
*/
func (a *CashieringAPIService) UpdateFixedCharges(ctx context.Context, reservationId string, hotelId string) CashieringAPIUpdateFixedChargesRequest {
	return CashieringAPIUpdateFixedChargesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) UpdateFixedChargesExecute(r CashieringAPIUpdateFixedChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.UpdateFixedCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.fixedCharges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIValidateCreditBillRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditBillCriteria *CreditBillCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIValidateCreditBillRequest) Authorization(authorization string) CashieringAPIValidateCreditBillRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIValidateCreditBillRequest) XAppKey(xAppKey string) CashieringAPIValidateCreditBillRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIValidateCreditBillRequest) XHotelid(xHotelid string) CashieringAPIValidateCreditBillRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to check if a Folio is valid for Credit Bill.
func (r CashieringAPIValidateCreditBillRequest) CreditBillCriteria(creditBillCriteria CreditBillCriteria) CashieringAPIValidateCreditBillRequest {
	r.creditBillCriteria = &creditBillCriteria
	return r
}

// External system code.
func (r CashieringAPIValidateCreditBillRequest) XExternalsystem(xExternalsystem string) CashieringAPIValidateCreditBillRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIValidateCreditBillRequest) AcceptLanguage(acceptLanguage string) CashieringAPIValidateCreditBillRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIValidateCreditBillRequest) Execute() (*ValidatedCreditBill, *http.Response, error) {
	return r.ApiService.ValidateCreditBillExecute(r)
}

/*
ValidateCreditBill Validate Credit Bill

You can use this API to validate credit Bill. <p><strong>OperationId:</strong>validateCreditBill</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIValidateCreditBillRequest
*/
func (a *CashieringAPIService) ValidateCreditBill(ctx context.Context, hotelId string) CashieringAPIValidateCreditBillRequest {
	return CashieringAPIValidateCreditBillRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidatedCreditBill
func (a *CashieringAPIService) ValidateCreditBillExecute(r CashieringAPIValidateCreditBillRequest) (*ValidatedCreditBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedCreditBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ValidateCreditBill")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/creditBill/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditBillCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIValidateDepositFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	depositFolioValidateCriteria *DepositFolioValidateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIValidateDepositFolioRequest) Authorization(authorization string) CashieringAPIValidateDepositFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIValidateDepositFolioRequest) XAppKey(xAppKey string) CashieringAPIValidateDepositFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIValidateDepositFolioRequest) XHotelid(xHotelid string) CashieringAPIValidateDepositFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to validate a Deposit Folio for a reservation.
func (r CashieringAPIValidateDepositFolioRequest) DepositFolioValidateCriteria(depositFolioValidateCriteria DepositFolioValidateCriteria) CashieringAPIValidateDepositFolioRequest {
	r.depositFolioValidateCriteria = &depositFolioValidateCriteria
	return r
}

// External system code.
func (r CashieringAPIValidateDepositFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIValidateDepositFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIValidateDepositFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIValidateDepositFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIValidateDepositFolioRequest) Execute() (*DepositedFolioValidate, *http.Response, error) {
	return r.ApiService.ValidateDepositFolioExecute(r)
}

/*
ValidateDepositFolio Validate Deposit Folio

You can use this API to validate Deposit Folio. <p><strong>OperationId:</strong>validateDepositFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return CashieringAPIValidateDepositFolioRequest
*/
func (a *CashieringAPIService) ValidateDepositFolio(ctx context.Context, hotelId string) CashieringAPIValidateDepositFolioRequest {
	return CashieringAPIValidateDepositFolioRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return DepositedFolioValidate
func (a *CashieringAPIService) ValidateDepositFolioExecute(r CashieringAPIValidateDepositFolioRequest) (*DepositedFolioValidate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DepositedFolioValidate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ValidateDepositFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/depositfolios/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.depositFolioValidateCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIValidateTransactionCodesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	event *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIValidateTransactionCodesRequest) Authorization(authorization string) CashieringAPIValidateTransactionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIValidateTransactionCodesRequest) XAppKey(xAppKey string) CashieringAPIValidateTransactionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIValidateTransactionCodesRequest) XHotelid(xHotelid string) CashieringAPIValidateTransactionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Event being generated by a Supplemental Folio.
func (r CashieringAPIValidateTransactionCodesRequest) Event(event string) CashieringAPIValidateTransactionCodesRequest {
	r.event = &event
	return r
}

// The Fiscal Bill number of this posting
func (r CashieringAPIValidateTransactionCodesRequest) FiscalBillNo(fiscalBillNo string) CashieringAPIValidateTransactionCodesRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r CashieringAPIValidateTransactionCodesRequest) FolioDate(folioDate string) CashieringAPIValidateTransactionCodesRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r CashieringAPIValidateTransactionCodesRequest) FolioNo(folioNo float32) CashieringAPIValidateTransactionCodesRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r CashieringAPIValidateTransactionCodesRequest) FolioStatus(folioStatus string) CashieringAPIValidateTransactionCodesRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r CashieringAPIValidateTransactionCodesRequest) FolioTypeName(folioTypeName string) CashieringAPIValidateTransactionCodesRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r CashieringAPIValidateTransactionCodesRequest) InternalFolioWindowID(internalFolioWindowID string) CashieringAPIValidateTransactionCodesRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r CashieringAPIValidateTransactionCodesRequest) InvoiceNo(invoiceNo float32) CashieringAPIValidateTransactionCodesRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r CashieringAPIValidateTransactionCodesRequest) XExternalsystem(xExternalsystem string) CashieringAPIValidateTransactionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIValidateTransactionCodesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIValidateTransactionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIValidateTransactionCodesRequest) Execute() (*ValidatedTransactionCode, *http.Response, error) {
	return r.ApiService.ValidateTransactionCodesExecute(r)
}

/*
ValidateTransactionCodes Validate Transaction Codes

You can use this API to validate Transaction Codes. <p><strong>OperationId:</strong>validateTransactionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return CashieringAPIValidateTransactionCodesRequest
*/
func (a *CashieringAPIService) ValidateTransactionCodes(ctx context.Context, transactionId string, hotelId string) CashieringAPIValidateTransactionCodesRequest {
	return CashieringAPIValidateTransactionCodesRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidatedTransactionCode
func (a *CashieringAPIService) ValidateTransactionCodesExecute(r CashieringAPIValidateTransactionCodesRequest) (*ValidatedTransactionCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedTransactionCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.ValidateTransactionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
  }
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
  }
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
  }
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
  }
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIVerifyForEarlyDepartureRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ignoreCheckOnTieredRate *bool
	ignoreRateRestriction *bool
	postConsumedAllowanceToGuest *bool
	postEarlyDeparturePenalty *bool
	cashierId *float32
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIVerifyForEarlyDepartureRequest) Authorization(authorization string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIVerifyForEarlyDepartureRequest) XAppKey(xAppKey string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIVerifyForEarlyDepartureRequest) XHotelid(xHotelid string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if check has to be done for Rate Tiers.
func (r CashieringAPIVerifyForEarlyDepartureRequest) IgnoreCheckOnTieredRate(ignoreCheckOnTieredRate bool) CashieringAPIVerifyForEarlyDepartureRequest {
	r.ignoreCheckOnTieredRate = &ignoreCheckOnTieredRate
	return r
}

// Indicates if Rate Restriction check should be overridden.
func (r CashieringAPIVerifyForEarlyDepartureRequest) IgnoreRateRestriction(ignoreRateRestriction bool) CashieringAPIVerifyForEarlyDepartureRequest {
	r.ignoreRateRestriction = &ignoreRateRestriction
	return r
}

// Indicates if any allowance consumed by the guest for today can be posted to the Guest Folio. If this cannot be done then the Early Departure cannot proceed.
func (r CashieringAPIVerifyForEarlyDepartureRequest) PostConsumedAllowanceToGuest(postConsumedAllowanceToGuest bool) CashieringAPIVerifyForEarlyDepartureRequest {
	r.postConsumedAllowanceToGuest = &postConsumedAllowanceToGuest
	return r
}

// Indicates if the early departure penalty should be posted .
func (r CashieringAPIVerifyForEarlyDepartureRequest) PostEarlyDeparturePenalty(postEarlyDeparturePenalty bool) CashieringAPIVerifyForEarlyDepartureRequest {
	r.postEarlyDeparturePenalty = &postEarlyDeparturePenalty
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r CashieringAPIVerifyForEarlyDepartureRequest) CashierId(cashierId float32) CashieringAPIVerifyForEarlyDepartureRequest {
	r.cashierId = &cashierId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIVerifyForEarlyDepartureRequest) IdContext(idContext []string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIVerifyForEarlyDepartureRequest) Type_(type_ []string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r CashieringAPIVerifyForEarlyDepartureRequest) XExternalsystem(xExternalsystem string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIVerifyForEarlyDepartureRequest) AcceptLanguage(acceptLanguage string) CashieringAPIVerifyForEarlyDepartureRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIVerifyForEarlyDepartureRequest) Execute() (*EarlyDepartureInfo, *http.Response, error) {
	return r.ApiService.VerifyForEarlyDepartureExecute(r)
}

/*
VerifyForEarlyDeparture Verify for early Departure

You can use this API to verify early Departure. <p><strong>OperationId:</strong>verifyForEarlyDeparture</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId Unique ID of the reservation
 @param hotelId Unique ID of the hotel
 @return CashieringAPIVerifyForEarlyDepartureRequest
*/
func (a *CashieringAPIService) VerifyForEarlyDeparture(ctx context.Context, reservationId string, hotelId string) CashieringAPIVerifyForEarlyDepartureRequest {
	return CashieringAPIVerifyForEarlyDepartureRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EarlyDepartureInfo
func (a *CashieringAPIService) VerifyForEarlyDepartureExecute(r CashieringAPIVerifyForEarlyDepartureRequest) (*EarlyDepartureInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EarlyDepartureInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.VerifyForEarlyDeparture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/earlyDeparture/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ignoreCheckOnTieredRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreCheckOnTieredRate", r.ignoreCheckOnTieredRate, "")
  }
	if r.ignoreRateRestriction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreRateRestriction", r.ignoreRateRestriction, "")
  }
	if r.postConsumedAllowanceToGuest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postConsumedAllowanceToGuest", r.postConsumedAllowanceToGuest, "")
  }
	if r.postEarlyDeparturePenalty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postEarlyDeparturePenalty", r.postEarlyDeparturePenalty, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIVoidBillingCheckChargesRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	checkNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	revenueDate *string
	amount *float32
	currencyCode *string
	reservationId *string
	reservationIdContext *string
	reservationIdType *string
	checkId *string
	checkIdContext *string
	checkIdType *string
	cashierId *float32
	postingRemark *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIVoidBillingCheckChargesRequest) Authorization(authorization string) CashieringAPIVoidBillingCheckChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIVoidBillingCheckChargesRequest) XAppKey(xAppKey string) CashieringAPIVoidBillingCheckChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIVoidBillingCheckChargesRequest) XHotelid(xHotelid string) CashieringAPIVoidBillingCheckChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// The date against which void (reverse) charges are posted.
func (r CashieringAPIVoidBillingCheckChargesRequest) RevenueDate(revenueDate string) CashieringAPIVoidBillingCheckChargesRequest {
	r.revenueDate = &revenueDate
	return r
}

// A monetary amount.
func (r CashieringAPIVoidBillingCheckChargesRequest) Amount(amount float32) CashieringAPIVoidBillingCheckChargesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r CashieringAPIVoidBillingCheckChargesRequest) CurrencyCode(currencyCode string) CashieringAPIVoidBillingCheckChargesRequest {
	r.currencyCode = &currencyCode
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIVoidBillingCheckChargesRequest) ReservationId(reservationId string) CashieringAPIVoidBillingCheckChargesRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIVoidBillingCheckChargesRequest) ReservationIdContext(reservationIdContext string) CashieringAPIVoidBillingCheckChargesRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIVoidBillingCheckChargesRequest) ReservationIdType(reservationIdType string) CashieringAPIVoidBillingCheckChargesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r CashieringAPIVoidBillingCheckChargesRequest) CheckId(checkId string) CashieringAPIVoidBillingCheckChargesRequest {
	r.checkId = &checkId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r CashieringAPIVoidBillingCheckChargesRequest) CheckIdContext(checkIdContext string) CashieringAPIVoidBillingCheckChargesRequest {
	r.checkIdContext = &checkIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r CashieringAPIVoidBillingCheckChargesRequest) CheckIdType(checkIdType string) CashieringAPIVoidBillingCheckChargesRequest {
	r.checkIdType = &checkIdType
	return r
}

// Cashier Id of the Cashier.
func (r CashieringAPIVoidBillingCheckChargesRequest) CashierId(cashierId float32) CashieringAPIVoidBillingCheckChargesRequest {
	r.cashierId = &cashierId
	return r
}

// Text describing any applicable detail of the posting.
func (r CashieringAPIVoidBillingCheckChargesRequest) PostingRemark(postingRemark string) CashieringAPIVoidBillingCheckChargesRequest {
	r.postingRemark = &postingRemark
	return r
}

// External system code.
func (r CashieringAPIVoidBillingCheckChargesRequest) XExternalsystem(xExternalsystem string) CashieringAPIVoidBillingCheckChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIVoidBillingCheckChargesRequest) AcceptLanguage(acceptLanguage string) CashieringAPIVoidBillingCheckChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIVoidBillingCheckChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.VoidBillingCheckChargesExecute(r)
}

/*
VoidBillingCheckCharges Delete Billing Check Charges

You can use this API to delete (void) Billing Check Charges. <p><strong>OperationId:</strong>voidBillingCheckCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param checkNumber Unique number of the check.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIVoidBillingCheckChargesRequest
*/
func (a *CashieringAPIService) VoidBillingCheckCharges(ctx context.Context, checkNumber string, hotelId string) CashieringAPIVoidBillingCheckChargesRequest {
	return CashieringAPIVoidBillingCheckChargesRequest{
		ApiService: a,
		ctx: ctx,
		checkNumber: checkNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *CashieringAPIService) VoidBillingCheckChargesExecute(r CashieringAPIVoidBillingCheckChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.VoidBillingCheckCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/check/{checkNumber}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"checkNumber"+"}", url.PathEscape(parameterValueToString(r.checkNumber, "checkNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.checkNumber) < 1 {
		return localVarReturnValue, nil, reportError("checkNumber must have at least 1 elements")
	}
	if strlen(r.checkNumber) > 2000 {
		return localVarReturnValue, nil, reportError("checkNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.revenueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", r.revenueDate, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
  }
	if r.checkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkId", r.checkId, "")
  }
	if r.checkIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkIdContext", r.checkIdContext, "")
  }
	if r.checkIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkIdType", r.checkIdType, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.postingRemark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", r.postingRemark, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CashieringAPIVoidFolioRequest struct {
	ctx context.Context
	ApiService *CashieringAPIService
	folioId string
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	folioToVoid *FolioToVoid
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r CashieringAPIVoidFolioRequest) Authorization(authorization string) CashieringAPIVoidFolioRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r CashieringAPIVoidFolioRequest) XAppKey(xAppKey string) CashieringAPIVoidFolioRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r CashieringAPIVoidFolioRequest) XHotelid(xHotelid string) CashieringAPIVoidFolioRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Void a Guest Folio when the Void Functionality is active.
func (r CashieringAPIVoidFolioRequest) FolioToVoid(folioToVoid FolioToVoid) CashieringAPIVoidFolioRequest {
	r.folioToVoid = &folioToVoid
	return r
}

// External system code.
func (r CashieringAPIVoidFolioRequest) XExternalsystem(xExternalsystem string) CashieringAPIVoidFolioRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r CashieringAPIVoidFolioRequest) AcceptLanguage(acceptLanguage string) CashieringAPIVoidFolioRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r CashieringAPIVoidFolioRequest) Execute() (*VoidedFolio, *http.Response, error) {
	return r.ApiService.VoidFolioExecute(r)
}

/*
VoidFolio Void folio

You can use this API to void a folio. <p><strong>OperationId:</strong>voidFolio</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folioId Unique ID of the folio.
 @param reservationId Unique ID of the reservation.
 @param hotelId Unique ID of the hotel
 @return CashieringAPIVoidFolioRequest
*/
func (a *CashieringAPIService) VoidFolio(ctx context.Context, folioId string, reservationId string, hotelId string) CashieringAPIVoidFolioRequest {
	return CashieringAPIVoidFolioRequest{
		ApiService: a,
		ctx: ctx,
		folioId: folioId,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return VoidedFolio
func (a *CashieringAPIService) VoidFolioExecute(r CashieringAPIVoidFolioRequest) (*VoidedFolio, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VoidedFolio
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CashieringAPIService.VoidFolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/voidfolios/{folioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"folioId"+"}", url.PathEscape(parameterValueToString(r.folioId, "folioId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.folioId) < 1 {
		return localVarReturnValue, nil, reportError("folioId must have at least 1 elements")
	}
	if strlen(r.folioId) > 2000 {
		return localVarReturnValue, nil, reportError("folioId must have less than 2000 elements")
	}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.folioToVoid
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
