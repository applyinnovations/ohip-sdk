/*
OPERA Cloud Rate API

APIs to cater for Rate Availability functionality in OPERA Cloud. <br /><br /> Rate Management provides all the tools you need to effectively define and manage the rate structures for a property in OPERA Cloud. Some of the things you can do include creating and managing rate codes, rate classes, rate categories, display sets, rate strategies, as well as managing promotion groups and codes.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rtp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// RatePlanApiService RatePlanApi service
type RatePlanApiService service

type RatePlanApiDeleteBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	code *[]string
	end *string
	start *string
	authorization *string
	xAppKey *string
	xHotelid *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	lOS1 *bool
	lOS2 *bool
	lOS3 *bool
	lOS4 *bool
	lOS5 *bool
	lOS6 *bool
	lOS7 *bool
	lOS8 *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Code(code []string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.code = &code
	return r
}

// The ending value of the date range.
func (r RatePlanApiDeleteBestAvailableRatesRequest) End(end string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r RatePlanApiDeleteBestAvailableRatesRequest) Start(start string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.start = &start
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiDeleteBestAvailableRatesRequest) Authorization(authorization string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiDeleteBestAvailableRatesRequest) XAppKey(xAppKey string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiDeleteBestAvailableRatesRequest) XHotelid(xHotelid string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Friday(friday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.friday = &friday
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Monday(monday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.monday = &monday
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Saturday(saturday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.saturday = &saturday
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Sunday(sunday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.sunday = &sunday
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Thursday(thursday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.thursday = &thursday
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Tuesday(tuesday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.tuesday = &tuesday
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Wednesday(wednesday bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.wednesday = &wednesday
	return r
}

// Indicates Length of Stay 1 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS1(lOS1 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS1 = &lOS1
	return r
}

// Indicates Length of Stay 2 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS2(lOS2 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS2 = &lOS2
	return r
}

// Indicates Length of Stay 3 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS3(lOS3 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS3 = &lOS3
	return r
}

// Indicates Length of Stay 4 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS4(lOS4 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS4 = &lOS4
	return r
}

// Indicates Length of Stay 5 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS5(lOS5 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS5 = &lOS5
	return r
}

// Indicates Length of Stay 6 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS6(lOS6 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS6 = &lOS6
	return r
}

// Indicates Length of Stay 7 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS7(lOS7 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS7 = &lOS7
	return r
}

// Indicates Length of Stay 8 configuration.
func (r RatePlanApiDeleteBestAvailableRatesRequest) LOS8(lOS8 bool) RatePlanApiDeleteBestAvailableRatesRequest {
	r.lOS8 = &lOS8
	return r
}

// External system code.
func (r RatePlanApiDeleteBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiDeleteBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiDeleteBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiDeleteBestAvailableRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBestAvailableRatesExecute(r)
}

/*
DeleteBestAvailableRates Delete Best Available Rates

This API allows to fetch Best Available rates for rate code(s). <p><strong>OperationId:</strong>deleteBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiDeleteBestAvailableRatesRequest
*/
func (a *RatePlanApiService) DeleteBestAvailableRates(ctx context.Context, hotelId string) RatePlanApiDeleteBestAvailableRatesRequest {
	return RatePlanApiDeleteBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) DeleteBestAvailableRatesExecute(r RatePlanApiDeleteBestAvailableRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.DeleteBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
	}
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
	}
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
	}
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
	}
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
	}
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
	}
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
	}
	if r.lOS1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS1", r.lOS1, "")
	}
	if r.lOS2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS2", r.lOS2, "")
	}
	if r.lOS3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS3", r.lOS3, "")
	}
	if r.lOS4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS4", r.lOS4, "")
	}
	if r.lOS5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS5", r.lOS5, "")
	}
	if r.lOS6 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS6", r.lOS6, "")
	}
	if r.lOS7 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS7", r.lOS7, "")
	}
	if r.lOS8 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS8", r.lOS8, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiDeleteRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	ratePlanScheduleIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanApiDeleteRatePlanSchedulesRequest) RatePlanScheduleIds(ratePlanScheduleIds []string) RatePlanApiDeleteRatePlanSchedulesRequest {
	r.ratePlanScheduleIds = &ratePlanScheduleIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiDeleteRatePlanSchedulesRequest) Authorization(authorization string) RatePlanApiDeleteRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiDeleteRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanApiDeleteRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiDeleteRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanApiDeleteRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanApiDeleteRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanApiDeleteRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiDeleteRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiDeleteRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiDeleteRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanSchedulesExecute(r)
}

/*
DeleteRatePlanSchedules Delete rate plan schedule

Use this API to delete Rate Plan schedules.<p><strong>OperationId:</strong>deleteRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiDeleteRatePlanSchedulesRequest
*/
func (a *RatePlanApiService) DeleteRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanApiDeleteRatePlanSchedulesRequest {
	return RatePlanApiDeleteRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) DeleteRatePlanSchedulesExecute(r RatePlanApiDeleteRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.DeleteRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.ratePlanScheduleIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	startDay *string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	rateCode *[]string
	endDay *string
	daysOfWeek *[]string
	lengthOfStay *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The starting value of the date range.
func (r RatePlanApiGetBestAvailableRatesRequest) StartDay(startDay string) RatePlanApiGetBestAvailableRatesRequest {
	r.startDay = &startDay
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetBestAvailableRatesRequest) Authorization(authorization string) RatePlanApiGetBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetBestAvailableRatesRequest) XAppKey(xAppKey string) RatePlanApiGetBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetBestAvailableRatesRequest) XHotelid(xHotelid string) RatePlanApiGetBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetBestAvailableRatesRequest) Limit(limit int32) RatePlanApiGetBestAvailableRatesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanApiGetBestAvailableRatesRequest) Offset(offset int32) RatePlanApiGetBestAvailableRatesRequest {
	r.offset = &offset
	return r
}

func (r RatePlanApiGetBestAvailableRatesRequest) RateCode(rateCode []string) RatePlanApiGetBestAvailableRatesRequest {
	r.rateCode = &rateCode
	return r
}

// The ending value of the date range.
func (r RatePlanApiGetBestAvailableRatesRequest) EndDay(endDay string) RatePlanApiGetBestAvailableRatesRequest {
	r.endDay = &endDay
	return r
}

// Allowed values for the days of week type.
func (r RatePlanApiGetBestAvailableRatesRequest) DaysOfWeek(daysOfWeek []string) RatePlanApiGetBestAvailableRatesRequest {
	r.daysOfWeek = &daysOfWeek
	return r
}

// Allowed values for length stay type.
func (r RatePlanApiGetBestAvailableRatesRequest) LengthOfStay(lengthOfStay []string) RatePlanApiGetBestAvailableRatesRequest {
	r.lengthOfStay = &lengthOfStay
	return r
}

// External system code.
func (r RatePlanApiGetBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetBestAvailableRatesRequest) Execute() (*GetBestAvailableRatesDetails, *http.Response, error) {
	return r.ApiService.GetBestAvailableRatesExecute(r)
}

/*
GetBestAvailableRates Fetch Best Available Rates

This API allows to fetch Best Available rates for rate code(s). <p><strong>OperationId:</strong>getBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetBestAvailableRatesRequest
*/
func (a *RatePlanApiService) GetBestAvailableRates(ctx context.Context, hotelId string) RatePlanApiGetBestAvailableRatesRequest {
	return RatePlanApiGetBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GetBestAvailableRatesDetails
func (a *RatePlanApiService) GetBestAvailableRatesExecute(r RatePlanApiGetBestAvailableRatesRequest) (*GetBestAvailableRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBestAvailableRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDay", r.startDay, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
	}
	if r.endDay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDay", r.endDay, "")
	}
	if r.daysOfWeek != nil {
		t := *r.daysOfWeek
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daysOfWeek", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daysOfWeek", t, "multi")
		}
	}
	if r.lengthOfStay != nil {
		t := *r.lengthOfStay
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetNegotiatedRatesRequest) Authorization(authorization string) RatePlanApiGetNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanApiGetNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanApiGetNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetNegotiatedRatesRequest) Limit(limit int32) RatePlanApiGetNegotiatedRatesRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r RatePlanApiGetNegotiatedRatesRequest) StartDate(startDate string) RatePlanApiGetNegotiatedRatesRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r RatePlanApiGetNegotiatedRatesRequest) EndDate(endDate string) RatePlanApiGetNegotiatedRatesRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r RatePlanApiGetNegotiatedRatesRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) RatePlanApiGetNegotiatedRatesRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetNegotiatedRatesRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) RatePlanApiGetNegotiatedRatesRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r RatePlanApiGetNegotiatedRatesRequest) FetchInstructions(fetchInstructions []string) RatePlanApiGetNegotiatedRatesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanApiGetNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetNegotiatedRatesRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesExecute(r)
}

/*
GetNegotiatedRates Get negotiated rates and profiles 

This API allows you to fetch negotiated rates and profile for a given hotel id. <p><strong>OperationId:</strong>getNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetNegotiatedRatesRequest
*/
func (a *RatePlanApiService) GetNegotiatedRates(ctx context.Context, hotelId string) RatePlanApiGetNegotiatedRatesRequest {
	return RatePlanApiGetNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanApiService) GetNegotiatedRatesExecute(r RatePlanApiGetNegotiatedRatesRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
	}
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) Authorization(authorization string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) XAppKey(xAppKey string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) XHotelid(xHotelid string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) Limit(limit int32) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) StartDate(startDate string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) EndDate(endDate string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) FetchInstructions(fetchInstructions []string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesForGivenHotelAndRateExecute(r)
}

/*
GetNegotiatedRatesForGivenHotelAndRate Fetch Negotiated Rates

This API allows you to fetch a Rate Plan and Profile for given hotel id and negotiated rate code. <p><strong>OperationId:</strong>getNegotiatedRatesForGivenHotelAndRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest
*/
func (a *RatePlanApiService) GetNegotiatedRatesForGivenHotelAndRate(ctx context.Context, rateCode string, hotelId string) RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest {
	return RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanApiService) GetNegotiatedRatesForGivenHotelAndRateExecute(r RatePlanApiGetNegotiatedRatesForGivenHotelAndRateRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetNegotiatedRatesForGivenHotelAndRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/{rateCode}/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
	}
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetNegotiatedRatesForGivenProfileRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	hotelCode *string
	ratePlanCode *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) Authorization(authorization string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) XAppKey(xAppKey string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) XHotelid(xHotelid string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) Limit(limit int32) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) StartDate(startDate string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) EndDate(endDate string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.endDate = &endDate
	return r
}

// Hotel code associated to the hotel
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) HotelCode(hotelCode string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.hotelCode = &hotelCode
	return r
}

// Rate Plan Code associated with the rate
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) RatePlanCode(ratePlanCode string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Inactive negotiated rates.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) FetchInstructions(fetchInstructions []string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesForGivenProfileExecute(r)
}

/*
GetNegotiatedRatesForGivenProfile Get negotiated rate details for given profile

This API allows you to fetch negotiated Rates for a given profile. <p><strong>OperationId:</strong>getNegotiatedRatesForGivenProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetNegotiatedRatesForGivenProfileRequest
*/
func (a *RatePlanApiService) GetNegotiatedRatesForGivenProfile(ctx context.Context, profileId string) RatePlanApiGetNegotiatedRatesForGivenProfileRequest {
	return RatePlanApiGetNegotiatedRatesForGivenProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanApiService) GetNegotiatedRatesForGivenProfileExecute(r RatePlanApiGetNegotiatedRatesForGivenProfileRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetNegotiatedRatesForGivenProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.hotelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelCode", r.hotelCode, "")
	}
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
	}
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
	}
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetPackageRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetPackageRequest) Authorization(authorization string) RatePlanApiGetPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetPackageRequest) XAppKey(xAppKey string) RatePlanApiGetPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetPackageRequest) XHotelid(xHotelid string) RatePlanApiGetPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for package instructions that can be used in requests for partial operations.
func (r RatePlanApiGetPackageRequest) FetchInstructions(fetchInstructions []string) RatePlanApiGetPackageRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanApiGetPackageRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetPackageRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetPackageRequest) Execute() (*PackageInfo, *http.Response, error) {
	return r.ApiService.GetPackageExecute(r)
}

/*
GetPackage Get package for given package

This API allows you to fetch package details for a given package. <p><strong>OperationId:</strong>getPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetPackageRequest
*/
func (a *RatePlanApiService) GetPackage(ctx context.Context, packageCode string, hotelId string) RatePlanApiGetPackageRequest {
	return RatePlanApiGetPackageRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageInfo
func (a *RatePlanApiService) GetPackageExecute(r RatePlanApiGetPackageRequest) (*PackageInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetPackageGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	code *string
	descriptionWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetPackageGroupsRequest) Authorization(authorization string) RatePlanApiGetPackageGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetPackageGroupsRequest) XAppKey(xAppKey string) RatePlanApiGetPackageGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetPackageGroupsRequest) XHotelid(xHotelid string) RatePlanApiGetPackageGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetPackageGroupsRequest) Limit(limit int32) RatePlanApiGetPackageGroupsRequest {
	r.limit = &limit
	return r
}

// Package code or group to be searched.
func (r RatePlanApiGetPackageGroupsRequest) Code(code string) RatePlanApiGetPackageGroupsRequest {
	r.code = &code
	return r
}

// The description or a part of the description based on which results should be filtered.
func (r RatePlanApiGetPackageGroupsRequest) DescriptionWildCard(descriptionWildCard string) RatePlanApiGetPackageGroupsRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// External system code.
func (r RatePlanApiGetPackageGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetPackageGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetPackageGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetPackageGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetPackageGroupsRequest) Execute() (*PackageGroupsInfo, *http.Response, error) {
	return r.ApiService.GetPackageGroupsExecute(r)
}

/*
GetPackageGroups Get package groups

This API allows you to fetch package group. <p><strong>OperationId:</strong>getPackageGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetPackageGroupsRequest
*/
func (a *RatePlanApiService) GetPackageGroups(ctx context.Context, hotelId string) RatePlanApiGetPackageGroupsRequest {
	return RatePlanApiGetPackageGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageGroupsInfo
func (a *RatePlanApiService) GetPackageGroupsExecute(r RatePlanApiGetPackageGroupsRequest) (*PackageGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetPackageGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetPackageRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetPackageRatesRequest) Authorization(authorization string) RatePlanApiGetPackageRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetPackageRatesRequest) XAppKey(xAppKey string) RatePlanApiGetPackageRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetPackageRatesRequest) XHotelid(xHotelid string) RatePlanApiGetPackageRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetPackageRatesRequest) Limit(limit int32) RatePlanApiGetPackageRatesRequest {
	r.limit = &limit
	return r
}

// External system code.
func (r RatePlanApiGetPackageRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetPackageRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetPackageRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetPackageRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetPackageRatesRequest) Execute() (*PackageRates, *http.Response, error) {
	return r.ApiService.GetPackageRatesExecute(r)
}

/*
GetPackageRates Get package rates

This API allows you to fetch rate plan codes associated for a package. <p><strong>OperationId:</strong>getPackageRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetPackageRatesRequest
*/
func (a *RatePlanApiService) GetPackageRates(ctx context.Context, packageCode string, hotelId string) RatePlanApiGetPackageRatesRequest {
	return RatePlanApiGetPackageRatesRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageRates
func (a *RatePlanApiService) GetPackageRatesExecute(r RatePlanApiGetPackageRatesRequest) (*PackageRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetPackageRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	hotelId *[]string
	packageCode *[]string
	descriptionWildCard *string
	startDate *string
	endDate *string
	adults *int32
	children *int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	includeGroup *bool
	sellSeparate *bool
	ticketPostingRhythm *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetPackagesRequest) Authorization(authorization string) RatePlanApiGetPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetPackagesRequest) XAppKey(xAppKey string) RatePlanApiGetPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetPackagesRequest) XHotelid(xHotelid string) RatePlanApiGetPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetPackagesRequest) Limit(limit int32) RatePlanApiGetPackagesRequest {
	r.limit = &limit
	return r
}

// Hotel code.
func (r RatePlanApiGetPackagesRequest) HotelId(hotelId []string) RatePlanApiGetPackagesRequest {
	r.hotelId = &hotelId
	return r
}

func (r RatePlanApiGetPackagesRequest) PackageCode(packageCode []string) RatePlanApiGetPackagesRequest {
	r.packageCode = &packageCode
	return r
}

// The description or a part of the description based on which results should be filtered.
func (r RatePlanApiGetPackagesRequest) DescriptionWildCard(descriptionWildCard string) RatePlanApiGetPackagesRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// Start Date for pricing schedule.
func (r RatePlanApiGetPackagesRequest) StartDate(startDate string) RatePlanApiGetPackagesRequest {
	r.startDate = &startDate
	return r
}

// End Date for pricing schedule.
func (r RatePlanApiGetPackagesRequest) EndDate(endDate string) RatePlanApiGetPackagesRequest {
	r.endDate = &endDate
	return r
}

// Number of adults for pricing schedule calculation.
func (r RatePlanApiGetPackagesRequest) Adults(adults int32) RatePlanApiGetPackagesRequest {
	r.adults = &adults
	return r
}

// Number of children for pricing schedule calculation.
func (r RatePlanApiGetPackagesRequest) Children(children int32) RatePlanApiGetPackagesRequest {
	r.children = &children
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r RatePlanApiGetPackagesRequest) Bucket1Count(bucket1Count int32) RatePlanApiGetPackagesRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r RatePlanApiGetPackagesRequest) Bucket2Count(bucket2Count int32) RatePlanApiGetPackagesRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r RatePlanApiGetPackagesRequest) Bucket3Count(bucket3Count int32) RatePlanApiGetPackagesRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r RatePlanApiGetPackagesRequest) Bucket4Count(bucket4Count int32) RatePlanApiGetPackagesRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r RatePlanApiGetPackagesRequest) Bucket5Count(bucket5Count int32) RatePlanApiGetPackagesRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// Indicates if Group Packages will be fetched.
func (r RatePlanApiGetPackagesRequest) IncludeGroup(includeGroup bool) RatePlanApiGetPackagesRequest {
	r.includeGroup = &includeGroup
	return r
}

// Indicates if Only Sell Separate Packages will be fetched, if not specified, it will ignore the criteria.
func (r RatePlanApiGetPackagesRequest) SellSeparate(sellSeparate bool) RatePlanApiGetPackagesRequest {
	r.sellSeparate = &sellSeparate
	return r
}

// Indicates if Only Ticket Posting Rhythm will be fetched, if not specified, it will ignore the criteria.
func (r RatePlanApiGetPackagesRequest) TicketPostingRhythm(ticketPostingRhythm bool) RatePlanApiGetPackagesRequest {
	r.ticketPostingRhythm = &ticketPostingRhythm
	return r
}

// Simple type for package instructions that can be used in requests for partial operations.
func (r RatePlanApiGetPackagesRequest) FetchInstructions(fetchInstructions []string) RatePlanApiGetPackagesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanApiGetPackagesRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetPackagesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetPackagesRequest) Execute() (*PackagesInfo, *http.Response, error) {
	return r.ApiService.GetPackagesExecute(r)
}

/*
GetPackages Get Packages

Use this API you to get configured packages for a hotel.<p><strong>OperationId:</strong>getPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanApiGetPackagesRequest
*/
func (a *RatePlanApiService) GetPackages(ctx context.Context) RatePlanApiGetPackagesRequest {
	return RatePlanApiGetPackagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackagesInfo
func (a *RatePlanApiService) GetPackagesExecute(r RatePlanApiGetPackagesRequest) (*PackagesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackagesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.packageCode != nil {
		t := *r.packageCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", t, "multi")
		}
	}
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
	}
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
	}
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
	}
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
	}
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
	}
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
	}
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
	}
	if r.includeGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGroup", r.includeGroup, "")
	}
	if r.sellSeparate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellSeparate", r.sellSeparate, "")
	}
	if r.ticketPostingRhythm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPostingRhythm", r.ticketPostingRhythm, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetRatePlanRequest) Authorization(authorization string) RatePlanApiGetRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetRatePlanRequest) XAppKey(xAppKey string) RatePlanApiGetRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetRatePlanRequest) XHotelid(xHotelid string) RatePlanApiGetRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for Rate plan codes instructions that can be used in requests for partial operations.
func (r RatePlanApiGetRatePlanRequest) FetchInstructions(fetchInstructions []string) RatePlanApiGetRatePlanRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanApiGetRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetRatePlanRequest) Execute() (*RatePlanInfo, *http.Response, error) {
	return r.ApiService.GetRatePlanExecute(r)
}

/*
GetRatePlan Get rate plan

This API allows you to fetch Rate Plan for a given hotel id and Rate Plan Code. <p><strong>OperationId:</strong>getRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetRatePlanRequest
*/
func (a *RatePlanApiService) GetRatePlan(ctx context.Context, ratePlanCode string, hotelId string) RatePlanApiGetRatePlanRequest {
	return RatePlanApiGetRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanInfo
func (a *RatePlanApiService) GetRatePlanExecute(r RatePlanApiGetRatePlanRequest) (*RatePlanInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeRatePlanPackage *bool
	limit *int32
	tierId *int32
	ratePlanScheduleId *string
	ratePlanScheduleIdType *string
	startDate *string
	endDate *string
	duration *string
	roomType *[]string
	roomClass *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetRatePlanSchedulesRequest) Authorization(authorization string) RatePlanApiGetRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanApiGetRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanApiGetRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Exclude the List of Pricing Schedule Packages from the response.
func (r RatePlanApiGetRatePlanSchedulesRequest) ExcludeRatePlanPackage(excludeRatePlanPackage bool) RatePlanApiGetRatePlanSchedulesRequest {
	r.excludeRatePlanPackage = &excludeRatePlanPackage
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetRatePlanSchedulesRequest) Limit(limit int32) RatePlanApiGetRatePlanSchedulesRequest {
	r.limit = &limit
	return r
}

func (r RatePlanApiGetRatePlanSchedulesRequest) TierId(tierId int32) RatePlanApiGetRatePlanSchedulesRequest {
	r.tierId = &tierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanApiGetRatePlanSchedulesRequest) RatePlanScheduleId(ratePlanScheduleId string) RatePlanApiGetRatePlanSchedulesRequest {
	r.ratePlanScheduleId = &ratePlanScheduleId
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanApiGetRatePlanSchedulesRequest) RatePlanScheduleIdType(ratePlanScheduleIdType string) RatePlanApiGetRatePlanSchedulesRequest {
	r.ratePlanScheduleIdType = &ratePlanScheduleIdType
	return r
}

func (r RatePlanApiGetRatePlanSchedulesRequest) StartDate(startDate string) RatePlanApiGetRatePlanSchedulesRequest {
	r.startDate = &startDate
	return r
}

func (r RatePlanApiGetRatePlanSchedulesRequest) EndDate(endDate string) RatePlanApiGetRatePlanSchedulesRequest {
	r.endDate = &endDate
	return r
}

func (r RatePlanApiGetRatePlanSchedulesRequest) Duration(duration string) RatePlanApiGetRatePlanSchedulesRequest {
	r.duration = &duration
	return r
}

// Room Type.
func (r RatePlanApiGetRatePlanSchedulesRequest) RoomType(roomType []string) RatePlanApiGetRatePlanSchedulesRequest {
	r.roomType = &roomType
	return r
}

// Room Class.
func (r RatePlanApiGetRatePlanSchedulesRequest) RoomClass(roomClass []string) RatePlanApiGetRatePlanSchedulesRequest {
	r.roomClass = &roomClass
	return r
}

// Include inactive rate schedules in the fetch result.
func (r RatePlanApiGetRatePlanSchedulesRequest) IncludeInactive(includeInactive bool) RatePlanApiGetRatePlanSchedulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r RatePlanApiGetRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetRatePlanSchedulesRequest) Execute() (*RatePlanSchedulesInfo, *http.Response, error) {
	return r.ApiService.GetRatePlanSchedulesExecute(r)
}

/*
GetRatePlanSchedules Get rate plan schedules

Use this API to get a rate plan&apos;s pricing schedules. The information includes the date range and room types for which the price is valid, rate amounts for multiple persons, and associated packages.<p><strong>OperationId:</strong>getRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiGetRatePlanSchedulesRequest
*/
func (a *RatePlanApiService) GetRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanApiGetRatePlanSchedulesRequest {
	return RatePlanApiGetRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanSchedulesInfo
func (a *RatePlanApiService) GetRatePlanSchedulesExecute(r RatePlanApiGetRatePlanSchedulesRequest) (*RatePlanSchedulesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanSchedulesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.excludeRatePlanPackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRatePlanPackage", r.excludeRatePlanPackage, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.tierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tierId", r.tierId, "")
	}
	if r.ratePlanScheduleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleId", r.ratePlanScheduleId, "")
	}
	if r.ratePlanScheduleIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIdType", r.ratePlanScheduleIdType, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiGetRatePlansRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeRateInformation *bool
	limit *int32
	offset *int32
	ratePlanCode *[]string
	rateCategory *[]string
	sellDate *string
	displaySet *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	attributeName *[]string
	orderType *[]string
	includeInactive *bool
	dayUseOnly *bool
	approvalStatus *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code.
func (r RatePlanApiGetRatePlansRequest) HotelId(hotelId []string) RatePlanApiGetRatePlansRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiGetRatePlansRequest) Authorization(authorization string) RatePlanApiGetRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiGetRatePlansRequest) XAppKey(xAppKey string) RatePlanApiGetRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiGetRatePlansRequest) XHotelid(xHotelid string) RatePlanApiGetRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether rate plan short and long information should be included in the fetched results.
func (r RatePlanApiGetRatePlansRequest) IncludeRateInformation(includeRateInformation bool) RatePlanApiGetRatePlansRequest {
	r.includeRateInformation = &includeRateInformation
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanApiGetRatePlansRequest) Limit(limit int32) RatePlanApiGetRatePlansRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanApiGetRatePlansRequest) Offset(offset int32) RatePlanApiGetRatePlansRequest {
	r.offset = &offset
	return r
}

// Rate Plan code.
func (r RatePlanApiGetRatePlansRequest) RatePlanCode(ratePlanCode []string) RatePlanApiGetRatePlansRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Rate category of the rate plan.
func (r RatePlanApiGetRatePlansRequest) RateCategory(rateCategory []string) RatePlanApiGetRatePlansRequest {
	r.rateCategory = &rateCategory
	return r
}

// Sell date of the rate plan.
func (r RatePlanApiGetRatePlansRequest) SellDate(sellDate string) RatePlanApiGetRatePlansRequest {
	r.sellDate = &sellDate
	return r
}

// Display set for the rate plan.
func (r RatePlanApiGetRatePlansRequest) DisplaySet(displaySet string) RatePlanApiGetRatePlansRequest {
	r.displaySet = &displaySet
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanApiGetRatePlansRequest) Id(id string) RatePlanApiGetRatePlansRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r RatePlanApiGetRatePlansRequest) IdExtension(idExtension int32) RatePlanApiGetRatePlansRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r RatePlanApiGetRatePlansRequest) IdContext(idContext string) RatePlanApiGetRatePlansRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanApiGetRatePlansRequest) Type_(type_ string) RatePlanApiGetRatePlansRequest {
	r.type_ = &type_
	return r
}

func (r RatePlanApiGetRatePlansRequest) AttributeName(attributeName []string) RatePlanApiGetRatePlansRequest {
	r.attributeName = &attributeName
	return r
}

func (r RatePlanApiGetRatePlansRequest) OrderType(orderType []string) RatePlanApiGetRatePlansRequest {
	r.orderType = &orderType
	return r
}

// Include or not include inactive rate codes.
func (r RatePlanApiGetRatePlansRequest) IncludeInactive(includeInactive bool) RatePlanApiGetRatePlansRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates to only fetch rate plans flagged as Day Use.
func (r RatePlanApiGetRatePlansRequest) DayUseOnly(dayUseOnly bool) RatePlanApiGetRatePlansRequest {
	r.dayUseOnly = &dayUseOnly
	return r
}

// Indicates that the Rate Plan is approved for selling.
func (r RatePlanApiGetRatePlansRequest) ApprovalStatus(approvalStatus string) RatePlanApiGetRatePlansRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// External system code.
func (r RatePlanApiGetRatePlansRequest) XExternalsystem(xExternalsystem string) RatePlanApiGetRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiGetRatePlansRequest) AcceptLanguage(acceptLanguage string) RatePlanApiGetRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiGetRatePlansRequest) Execute() (*RatePlansSummary, *http.Response, error) {
	return r.ApiService.GetRatePlansExecute(r)
}

/*
GetRatePlans Get rate plans

Use this API to get configured Rate Plans for a property and filter this by search criteria.<p><strong>OperationId:</strong>getRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanApiGetRatePlansRequest
*/
func (a *RatePlanApiService) GetRatePlans(ctx context.Context) RatePlanApiGetRatePlansRequest {
	return RatePlanApiGetRatePlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RatePlansSummary
func (a *RatePlanApiService) GetRatePlansExecute(r RatePlanApiGetRatePlansRequest) (*RatePlansSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlansSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.GetRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ratePlans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.includeRateInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRateInformation", r.includeRateInformation, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
	}
	if r.rateCategory != nil {
		t := *r.rateCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", t, "multi")
		}
	}
	if r.sellDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellDate", r.sellDate, "")
	}
	if r.displaySet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "displaySet", r.displaySet, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
	}
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.dayUseOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUseOnly", r.dayUseOnly, "")
	}
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiPostBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createBestAvailableRates *PostBestAvailableRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiPostBestAvailableRatesRequest) Authorization(authorization string) RatePlanApiPostBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiPostBestAvailableRatesRequest) XAppKey(xAppKey string) RatePlanApiPostBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiPostBestAvailableRatesRequest) XHotelid(xHotelid string) RatePlanApiPostBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create best available rates for rate code(s)
func (r RatePlanApiPostBestAvailableRatesRequest) CreateBestAvailableRates(createBestAvailableRates PostBestAvailableRatesRequest) RatePlanApiPostBestAvailableRatesRequest {
	r.createBestAvailableRates = &createBestAvailableRates
	return r
}

// External system code.
func (r RatePlanApiPostBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiPostBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiPostBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiPostBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiPostBestAvailableRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBestAvailableRatesExecute(r)
}

/*
PostBestAvailableRates Create a Best Available Rates

This API allows to create Best Available rates for rate code(s). <p><strong>OperationId:</strong>postBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiPostBestAvailableRatesRequest
*/
func (a *RatePlanApiService) PostBestAvailableRates(ctx context.Context, hotelId string) RatePlanApiPostBestAvailableRatesRequest {
	return RatePlanApiPostBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PostBestAvailableRatesExecute(r RatePlanApiPostBestAvailableRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PostBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createBestAvailableRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiPostNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	negotiatedRates *PostNegotiatedRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiPostNegotiatedRatesRequest) Authorization(authorization string) RatePlanApiPostNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiPostNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanApiPostNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiPostNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanApiPostNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating negotiated rates. Also this object creates new profile discounts for given negotiated rates.
func (r RatePlanApiPostNegotiatedRatesRequest) NegotiatedRates(negotiatedRates PostNegotiatedRatesRequest) RatePlanApiPostNegotiatedRatesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// External system code.
func (r RatePlanApiPostNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiPostNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiPostNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiPostNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiPostNegotiatedRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostNegotiatedRatesExecute(r)
}

/*
PostNegotiatedRates Create negotiated rates 

This API allows you to create negotiated rate for a given profile. <p><strong>OperationId:</strong>postNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiPostNegotiatedRatesRequest
*/
func (a *RatePlanApiService) PostNegotiatedRates(ctx context.Context, hotelId string) RatePlanApiPostNegotiatedRatesRequest {
	return RatePlanApiPostNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PostNegotiatedRatesExecute(r RatePlanApiPostNegotiatedRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PostNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.negotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiPostRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlan *PostRatePlanRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiPostRatePlanRequest) Authorization(authorization string) RatePlanApiPostRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiPostRatePlanRequest) XAppKey(xAppKey string) RatePlanApiPostRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiPostRatePlanRequest) XHotelid(xHotelid string) RatePlanApiPostRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create rate plan.
func (r RatePlanApiPostRatePlanRequest) RatePlan(ratePlan PostRatePlanRequest) RatePlanApiPostRatePlanRequest {
	r.ratePlan = &ratePlan
	return r
}

// External system code.
func (r RatePlanApiPostRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanApiPostRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiPostRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanApiPostRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiPostRatePlanRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRatePlanExecute(r)
}

/*
PostRatePlan Create rate plans

Use this API you to get Rate Plans for a given hotel.<p><strong>OperationId:</strong>postRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiPostRatePlanRequest
*/
func (a *RatePlanApiService) PostRatePlan(ctx context.Context, hotelId string) RatePlanApiPostRatePlanRequest {
	return RatePlanApiPostRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PostRatePlanExecute(r RatePlanApiPostRatePlanRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PostRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiPostRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanSchedulesToCreate *PostRatePlanSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiPostRatePlanSchedulesRequest) Authorization(authorization string) RatePlanApiPostRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiPostRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanApiPostRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiPostRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanApiPostRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create rate plan schedules.
func (r RatePlanApiPostRatePlanSchedulesRequest) RatePlanSchedulesToCreate(ratePlanSchedulesToCreate PostRatePlanSchedulesRequest) RatePlanApiPostRatePlanSchedulesRequest {
	r.ratePlanSchedulesToCreate = &ratePlanSchedulesToCreate
	return r
}

// External system code.
func (r RatePlanApiPostRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanApiPostRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiPostRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiPostRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiPostRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRatePlanSchedulesExecute(r)
}

/*
PostRatePlanSchedules Create rate plan schedules

This API allows you to create Rate Plan schedules. <p><strong>OperationId:</strong>postRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiPostRatePlanSchedulesRequest
*/
func (a *RatePlanApiService) PostRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanApiPostRatePlanSchedulesRequest {
	return RatePlanApiPostRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PostRatePlanSchedulesExecute(r RatePlanApiPostRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PostRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanSchedulesToCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiPutNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	negotiatedRates *PostNegotiatedRatesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiPutNegotiatedRatesRequest) Authorization(authorization string) RatePlanApiPutNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiPutNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanApiPutNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiPutNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanApiPutNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing negotiated rates. This object can be used to manage the negotiated rates and profile discounts. Profile discounts can be created/updated/deleted.
func (r RatePlanApiPutNegotiatedRatesRequest) NegotiatedRates(negotiatedRates PostNegotiatedRatesRequest) RatePlanApiPutNegotiatedRatesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// External system code.
func (r RatePlanApiPutNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanApiPutNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiPutNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiPutNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiPutNegotiatedRatesRequest) Execute() (*NegotiatedRatesDetails, *http.Response, error) {
	return r.ApiService.PutNegotiatedRatesExecute(r)
}

/*
PutNegotiatedRates Change negotiated rates 

This API allows you to update negotiated rate for a given profile. <p><strong>OperationId:</strong>putNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiPutNegotiatedRatesRequest
*/
func (a *RatePlanApiService) PutNegotiatedRates(ctx context.Context, rateCode string, hotelId string) RatePlanApiPutNegotiatedRatesRequest {
	return RatePlanApiPutNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRatesDetails
func (a *RatePlanApiService) PutNegotiatedRatesExecute(r RatePlanApiPutNegotiatedRatesRequest) (*NegotiatedRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PutNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/{rateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.negotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanApiPutRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanApiService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanSchedules *PutRatePlanSchedulesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanApiPutRatePlanSchedulesRequest) Authorization(authorization string) RatePlanApiPutRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partnerâ€™s Application Key
func (r RatePlanApiPutRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanApiPutRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanApiPutRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanApiPutRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change rate plan schedules.
func (r RatePlanApiPutRatePlanSchedulesRequest) RatePlanSchedules(ratePlanSchedules PutRatePlanSchedulesRequest) RatePlanApiPutRatePlanSchedulesRequest {
	r.ratePlanSchedules = &ratePlanSchedules
	return r
}

// External system code.
func (r RatePlanApiPutRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanApiPutRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanApiPutRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanApiPutRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanApiPutRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRatePlanSchedulesExecute(r)
}

/*
PutRatePlanSchedules Change rate plan schedules

Use this API to  update Rate Plan pricing schedules.<p><strong>OperationId:</strong>putRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanApiPutRatePlanSchedulesRequest
*/
func (a *RatePlanApiService) PutRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanApiPutRatePlanSchedulesRequest {
	return RatePlanApiPutRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanApiService) PutRatePlanSchedulesExecute(r RatePlanApiPutRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanApiService.PutRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanSchedules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
