/*
OPERA Cloud Rate API

APIs to cater for Rate Availability functionality in OPERA Cloud. <br /><br /> Rate Management provides all the tools you need to effectively define and manage the rate structures for a property in OPERA Cloud. Some of the things you can do include creating and managing rate codes, rate classes, rate categories, display sets, rate strategies, as well as managing promotion groups and codes.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rtp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// RatePlanAPIService RatePlanAPI service
type RatePlanAPIService service

type RatePlanAPICopyPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	packagesCopy *[]CopyPackageCodesType
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPICopyPackagesRequest) Authorization(authorization string) RatePlanAPICopyPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPICopyPackagesRequest) XAppKey(xAppKey string) RatePlanAPICopyPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPICopyPackagesRequest) XHotelid(xHotelid string) RatePlanAPICopyPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of the package codes to be copied to other hotel code(s).
func (r RatePlanAPICopyPackagesRequest) PackagesCopy(packagesCopy []CopyPackageCodesType) RatePlanAPICopyPackagesRequest {
	r.packagesCopy = &packagesCopy
	return r
}

// External system code.
func (r RatePlanAPICopyPackagesRequest) XExternalsystem(xExternalsystem string) RatePlanAPICopyPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPICopyPackagesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPICopyPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPICopyPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyPackagesExecute(r)
}

/*
CopyPackages Copy package code(s) 

This API allows you to copy package codes(s) from one hotel to another. <p><strong>OperationId:</strong>copyPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPICopyPackagesRequest
*/
func (a *RatePlanAPIService) CopyPackages(ctx context.Context) RatePlanAPICopyPackagesRequest {
	return RatePlanAPICopyPackagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) CopyPackagesExecute(r RatePlanAPICopyPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.CopyPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packages/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packagesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPICopyPromotionGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	promotionGroupsCopy *PromotionGroupsCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPICopyPromotionGroupsRequest) Authorization(authorization string) RatePlanAPICopyPromotionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPICopyPromotionGroupsRequest) XAppKey(xAppKey string) RatePlanAPICopyPromotionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPICopyPromotionGroupsRequest) XHotelid(xHotelid string) RatePlanAPICopyPromotionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPICopyPromotionGroupsRequest) PromotionGroupsCopy(promotionGroupsCopy PromotionGroupsCopy) RatePlanAPICopyPromotionGroupsRequest {
	r.promotionGroupsCopy = &promotionGroupsCopy
	return r
}

// External system code.
func (r RatePlanAPICopyPromotionGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPICopyPromotionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPICopyPromotionGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPICopyPromotionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPICopyPromotionGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyPromotionGroupsExecute(r)
}

/*
CopyPromotionGroups Copy promotion groups

This API allows you to copy promotions groups. <p><strong>OperationId:</strong>copyPromotionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPICopyPromotionGroupsRequest
*/
func (a *RatePlanAPIService) CopyPromotionGroups(ctx context.Context, hotelId string) RatePlanAPICopyPromotionGroupsRequest {
	return RatePlanAPICopyPromotionGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) CopyPromotionGroupsExecute(r RatePlanAPICopyPromotionGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.CopyPromotionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionGroups/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.promotionGroupsCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPICopyRatePlansRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlansCopy *RatePlansCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPICopyRatePlansRequest) Authorization(authorization string) RatePlanAPICopyRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPICopyRatePlansRequest) XAppKey(xAppKey string) RatePlanAPICopyRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPICopyRatePlansRequest) XHotelid(xHotelid string) RatePlanAPICopyRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Copying rate plans to multiple hotels.
func (r RatePlanAPICopyRatePlansRequest) RatePlansCopy(ratePlansCopy RatePlansCopy) RatePlanAPICopyRatePlansRequest {
	r.ratePlansCopy = &ratePlansCopy
	return r
}

// External system code.
func (r RatePlanAPICopyRatePlansRequest) XExternalsystem(xExternalsystem string) RatePlanAPICopyRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPICopyRatePlansRequest) AcceptLanguage(acceptLanguage string) RatePlanAPICopyRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPICopyRatePlansRequest) Execute() (*RatePlansCopyDetails, *http.Response, error) {
	return r.ApiService.CopyRatePlansExecute(r)
}

/*
CopyRatePlans Copy rate plans

This API allows you to copy Rate Plans. <p><strong>OperationId:</strong>copyRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPICopyRatePlansRequest
*/
func (a *RatePlanAPIService) CopyRatePlans(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPICopyRatePlansRequest {
	return RatePlanAPICopyRatePlansRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlansCopyDetails
func (a *RatePlanAPIService) CopyRatePlansExecute(r RatePlanAPICopyRatePlansRequest) (*RatePlansCopyDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlansCopyDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.CopyRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlansCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPICopyTieredRateSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	destinationTierId string
	sourceTierId string
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	tieredRateSchedulesCopy *TieredRateSchedulesCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPICopyTieredRateSchedulesRequest) Authorization(authorization string) RatePlanAPICopyTieredRateSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPICopyTieredRateSchedulesRequest) XAppKey(xAppKey string) RatePlanAPICopyTieredRateSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPICopyTieredRateSchedulesRequest) XHotelid(xHotelid string) RatePlanAPICopyTieredRateSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to copy the specified tier 1 rate schedules into the specified tiers.
func (r RatePlanAPICopyTieredRateSchedulesRequest) TieredRateSchedulesCopy(tieredRateSchedulesCopy TieredRateSchedulesCopy) RatePlanAPICopyTieredRateSchedulesRequest {
	r.tieredRateSchedulesCopy = &tieredRateSchedulesCopy
	return r
}

// External system code.
func (r RatePlanAPICopyTieredRateSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPICopyTieredRateSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPICopyTieredRateSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPICopyTieredRateSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPICopyTieredRateSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyTieredRateSchedulesExecute(r)
}

/*
CopyTieredRateSchedules Copy tiered rate schedules

This API allows you to copy tiered rate schedules. <p><strong>OperationId:</strong>copyTieredRateSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param destinationTierId Destination Tier Id.
 @param sourceTierId Source Tier Id.
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPICopyTieredRateSchedulesRequest
*/
func (a *RatePlanAPIService) CopyTieredRateSchedules(ctx context.Context, destinationTierId string, sourceTierId string, ratePlanCode string, hotelId string) RatePlanAPICopyTieredRateSchedulesRequest {
	return RatePlanAPICopyTieredRateSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		destinationTierId: destinationTierId,
		sourceTierId: sourceTierId,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) CopyTieredRateSchedulesExecute(r RatePlanAPICopyTieredRateSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.CopyTieredRateSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/sourceTiers/{sourceTierId}/destinationTiers/{destinationTierId}/schedules/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"destinationTierId"+"}", url.PathEscape(parameterValueToString(r.destinationTierId, "destinationTierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceTierId"+"}", url.PathEscape(parameterValueToString(r.sourceTierId, "sourceTierId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.destinationTierId) < 1 {
		return localVarReturnValue, nil, reportError("destinationTierId must have at least 1 elements")
	}
	if strlen(r.destinationTierId) > 2000 {
		return localVarReturnValue, nil, reportError("destinationTierId must have less than 2000 elements")
	}
	if strlen(r.sourceTierId) < 1 {
		return localVarReturnValue, nil, reportError("sourceTierId must have at least 1 elements")
	}
	if strlen(r.sourceTierId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceTierId must have less than 2000 elements")
	}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.tieredRateSchedulesCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	code *[]string
	end *string
	start *string
	authorization *string
	xAppKey *string
	xHotelid *string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	lOS1 *bool
	lOS2 *bool
	lOS3 *bool
	lOS4 *bool
	lOS5 *bool
	lOS6 *bool
	lOS7 *bool
	lOS8 *bool
	xExternalsystem *string
	acceptLanguage *string
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Code(code []string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.code = &code
	return r
}

// The ending value of the date range.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) End(end string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) Start(start string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.start = &start
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteBestAvailableRatesRequest) Authorization(authorization string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteBestAvailableRatesRequest) XAppKey(xAppKey string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteBestAvailableRatesRequest) XHotelid(xHotelid string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Friday(friday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.friday = &friday
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Monday(monday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.monday = &monday
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Saturday(saturday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.saturday = &saturday
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Sunday(sunday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.sunday = &sunday
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Thursday(thursday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.thursday = &thursday
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Tuesday(tuesday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.tuesday = &tuesday
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Wednesday(wednesday bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.wednesday = &wednesday
	return r
}

// Indicates Length of Stay 1 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS1(lOS1 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS1 = &lOS1
	return r
}

// Indicates Length of Stay 2 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS2(lOS2 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS2 = &lOS2
	return r
}

// Indicates Length of Stay 3 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS3(lOS3 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS3 = &lOS3
	return r
}

// Indicates Length of Stay 4 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS4(lOS4 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS4 = &lOS4
	return r
}

// Indicates Length of Stay 5 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS5(lOS5 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS5 = &lOS5
	return r
}

// Indicates Length of Stay 6 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS6(lOS6 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS6 = &lOS6
	return r
}

// Indicates Length of Stay 7 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS7(lOS7 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS7 = &lOS7
	return r
}

// Indicates Length of Stay 8 configuration.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) LOS8(lOS8 bool) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.lOS8 = &lOS8
	return r
}

// External system code.
func (r RatePlanAPIDeleteBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteBestAvailableRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteBestAvailableRatesExecute(r)
}

/*
DeleteBestAvailableRates Delete Best Available Rates

This API allows to fetch Best Available rates for rate code(s). <p><strong>OperationId:</strong>deleteBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteBestAvailableRatesRequest
*/
func (a *RatePlanAPIService) DeleteBestAvailableRates(ctx context.Context, hotelId string) RatePlanAPIDeleteBestAvailableRatesRequest {
	return RatePlanAPIDeleteBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteBestAvailableRatesExecute(r RatePlanAPIDeleteBestAvailableRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.lOS1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS1", r.lOS1, "")
  }
	if r.lOS2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS2", r.lOS2, "")
  }
	if r.lOS3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS3", r.lOS3, "")
  }
	if r.lOS4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS4", r.lOS4, "")
  }
	if r.lOS5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS5", r.lOS5, "")
  }
	if r.lOS6 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS6", r.lOS6, "")
  }
	if r.lOS7 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS7", r.lOS7, "")
  }
	if r.lOS8 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lOS8", r.lOS8, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	startDate *string
	endDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomType *[]string
	roomClass *[]string
	friday *bool
	monday *bool
	saturday *bool
	sunday *bool
	thursday *bool
	tuesday *bool
	wednesday *bool
	duration *string
	advancedDailyBaseRatePlanCode *string
	xExternalsystem *string
	acceptLanguage *string
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) StartDate(startDate string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.startDate = &startDate
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) EndDate(endDate string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.endDate = &endDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Authorization(authorization string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) XAppKey(xAppKey string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) XHotelid(xHotelid string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room Type.
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) RoomType(roomType []string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.roomType = &roomType
	return r
}

// Room Class.
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) RoomClass(roomClass []string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.roomClass = &roomClass
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Friday(friday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.friday = &friday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Monday(monday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.monday = &monday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Saturday(saturday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.saturday = &saturday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Sunday(sunday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.sunday = &sunday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Thursday(thursday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.thursday = &thursday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Tuesday(tuesday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.tuesday = &tuesday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Wednesday(wednesday bool) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.wednesday = &wednesday
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Duration(duration string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.duration = &duration
	return r
}

// The Base Rate Plan Code which will be used to look up for and configure the Pricing Schedule for the main Rate Plan Code
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) AdvancedDailyBaseRatePlanCode(advancedDailyBaseRatePlanCode string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.advancedDailyBaseRatePlanCode = &advancedDailyBaseRatePlanCode
	return r
}

// External system code.
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteDailyRatePlanScheduleRangeExecute(r)
}

/*
DeleteDailyRatePlanScheduleRange Delete daily rate plan schedule range

This API allows you to delete daily Rate Plan schedules. <p><strong>OperationId:</strong>deleteDailyRatePlanScheduleRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest
*/
func (a *RatePlanAPIService) DeleteDailyRatePlanScheduleRange(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest {
	return RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteDailyRatePlanScheduleRangeExecute(r RatePlanAPIDeleteDailyRatePlanScheduleRangeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteDailyRatePlanScheduleRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/dailySchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "csv")
  }
	if r.roomClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", r.roomClass, "csv")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.advancedDailyBaseRatePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advancedDailyBaseRatePlanCode", r.advancedDailyBaseRatePlanCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteHotelPackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) Code(code []string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	r.code = &code
	return r
}

// External system code.
func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHotelPackageForecastGroupsExecute(r)
}

/*
DeleteHotelPackageForecastGroups Delete Hotel Package Forecast Groups

This API allows you to delete package forecast groups. <p><strong>OperationId:</strong>deleteHotelPackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteHotelPackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) DeleteHotelPackageForecastGroups(ctx context.Context, hotelId string) RatePlanAPIDeleteHotelPackageForecastGroupsRequest {
	return RatePlanAPIDeleteHotelPackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteHotelPackageForecastGroupsExecute(r RatePlanAPIDeleteHotelPackageForecastGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteHotelPackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageForecastGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteMassRateChangeLogRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteMassRateChangeLogRequest) Authorization(authorization string) RatePlanAPIDeleteMassRateChangeLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteMassRateChangeLogRequest) XAppKey(xAppKey string) RatePlanAPIDeleteMassRateChangeLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteMassRateChangeLogRequest) XHotelid(xHotelid string) RatePlanAPIDeleteMassRateChangeLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteMassRateChangeLogRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteMassRateChangeLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteMassRateChangeLogRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteMassRateChangeLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteMassRateChangeLogRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMassRateChangeLogExecute(r)
}

/*
DeleteMassRateChangeLog Delete mass rate change log

This API allows you to delete mass rate change log. <p><strong>OperationId:</strong>deleteMassRateChangeLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteMassRateChangeLogRequest
*/
func (a *RatePlanAPIService) DeleteMassRateChangeLog(ctx context.Context, hotelId string) RatePlanAPIDeleteMassRateChangeLogRequest {
	return RatePlanAPIDeleteMassRateChangeLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteMassRateChangeLogExecute(r RatePlanAPIDeleteMassRateChangeLogRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteMassRateChangeLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/massRateChangeLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanId string
	startDate string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteNegotiatedRatesRequest) Authorization(authorization string) RatePlanAPIDeleteNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanAPIDeleteNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanAPIDeleteNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteNegotiatedRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteNegotiatedRatesExecute(r)
}

/*
DeleteNegotiatedRates Delete negotiated rates

This API allows you to delete negotiated rate. <p><strong>OperationId:</strong>deleteNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanId Rate Plan ID.
 @param startDate Start Date.
 @param profileId Unique ID that identifies a profile.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteNegotiatedRatesRequest
*/
func (a *RatePlanAPIService) DeleteNegotiatedRates(ctx context.Context, ratePlanId string, startDate string, profileId string, hotelId string) RatePlanAPIDeleteNegotiatedRatesRequest {
	return RatePlanAPIDeleteNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanId: ratePlanId,
		startDate: startDate,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteNegotiatedRatesExecute(r RatePlanAPIDeleteNegotiatedRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/startDate/{startDate}/negotiatedRates/{ratePlanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanId"+"}", url.PathEscape(parameterValueToString(r.ratePlanId, "ratePlanId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"startDate"+"}", url.PathEscape(parameterValueToString(r.startDate, "startDate")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanId) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanId must have at least 1 elements")
	}
	if strlen(r.ratePlanId) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanId must have less than 2000 elements")
	}
	if strlen(r.startDate) < 1 {
		return localVarReturnValue, nil, reportError("startDate must have at least 1 elements")
	}
	if strlen(r.startDate) > 2000 {
		return localVarReturnValue, nil, reportError("startDate must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeletePackageRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeletePackageRequest) Authorization(authorization string) RatePlanAPIDeletePackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeletePackageRequest) XAppKey(xAppKey string) RatePlanAPIDeletePackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeletePackageRequest) XHotelid(xHotelid string) RatePlanAPIDeletePackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeletePackageRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeletePackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeletePackageRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeletePackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeletePackageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePackageExecute(r)
}

/*
DeletePackage Delete the package

This API allows you to delete a package. <p><strong>OperationId:</strong>deletePackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeletePackageRequest
*/
func (a *RatePlanAPIService) DeletePackage(ctx context.Context, packageCode string, hotelId string) RatePlanAPIDeletePackageRequest {
	return RatePlanAPIDeletePackageRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeletePackageExecute(r RatePlanAPIDeletePackageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeletePackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeletePackageFormulaRangesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageFormulaRangeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	amount *float32
	currencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeletePackageFormulaRangesRequest) Authorization(authorization string) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeletePackageFormulaRangesRequest) XAppKey(xAppKey string) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeletePackageFormulaRangesRequest) XHotelid(xHotelid string) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A monetary amount.
func (r RatePlanAPIDeletePackageFormulaRangesRequest) Amount(amount float32) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r RatePlanAPIDeletePackageFormulaRangesRequest) CurrencyCode(currencyCode string) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.currencyCode = &currencyCode
	return r
}

// External system code.
func (r RatePlanAPIDeletePackageFormulaRangesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeletePackageFormulaRangesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeletePackageFormulaRangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeletePackageFormulaRangesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePackageFormulaRangesExecute(r)
}

/*
DeletePackageFormulaRanges Delete package formula ranges

This API allows you to delete package formula ranges. <p><strong>OperationId:</strong>deletePackageFormulaRanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageFormulaRangeId Package Formula Range Id.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeletePackageFormulaRangesRequest
*/
func (a *RatePlanAPIService) DeletePackageFormulaRanges(ctx context.Context, packageFormulaRangeId string, hotelId string) RatePlanAPIDeletePackageFormulaRangesRequest {
	return RatePlanAPIDeletePackageFormulaRangesRequest{
		ApiService: a,
		ctx: ctx,
		packageFormulaRangeId: packageFormulaRangeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeletePackageFormulaRangesExecute(r RatePlanAPIDeletePackageFormulaRangesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeletePackageFormulaRanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageFormulaRanges/{packageFormulaRangeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageFormulaRangeId"+"}", url.PathEscape(parameterValueToString(r.packageFormulaRangeId, "packageFormulaRangeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageFormulaRangeId) < 1 {
		return localVarReturnValue, nil, reportError("packageFormulaRangeId must have at least 1 elements")
	}
	if strlen(r.packageFormulaRangeId) > 2000 {
		return localVarReturnValue, nil, reportError("packageFormulaRangeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeletePackageGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeletePackageGroupsRequest) Authorization(authorization string) RatePlanAPIDeletePackageGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeletePackageGroupsRequest) XAppKey(xAppKey string) RatePlanAPIDeletePackageGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeletePackageGroupsRequest) XHotelid(xHotelid string) RatePlanAPIDeletePackageGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeletePackageGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeletePackageGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeletePackageGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeletePackageGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeletePackageGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePackageGroupsExecute(r)
}

/*
DeletePackageGroups Delete package group

This API allows you to delete package group. <p><strong>OperationId:</strong>deletePackageGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeletePackageGroupsRequest
*/
func (a *RatePlanAPIService) DeletePackageGroups(ctx context.Context, packageCode string, hotelId string) RatePlanAPIDeletePackageGroupsRequest {
	return RatePlanAPIDeletePackageGroupsRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeletePackageGroupsExecute(r RatePlanAPIDeletePackageGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeletePackageGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageGroups/{packageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeletePromotionGroupRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	groupCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeletePromotionGroupRequest) Authorization(authorization string) RatePlanAPIDeletePromotionGroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeletePromotionGroupRequest) XAppKey(xAppKey string) RatePlanAPIDeletePromotionGroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeletePromotionGroupRequest) XHotelid(xHotelid string) RatePlanAPIDeletePromotionGroupRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeletePromotionGroupRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeletePromotionGroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeletePromotionGroupRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeletePromotionGroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeletePromotionGroupRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePromotionGroupExecute(r)
}

/*
DeletePromotionGroup Delete promotion groups

This API allows you to delete promotion groups. <p><strong>OperationId:</strong>deletePromotionGroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupCode Promotion Group Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeletePromotionGroupRequest
*/
func (a *RatePlanAPIService) DeletePromotionGroup(ctx context.Context, groupCode string, hotelId string) RatePlanAPIDeletePromotionGroupRequest {
	return RatePlanAPIDeletePromotionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupCode: groupCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeletePromotionGroupExecute(r RatePlanAPIDeletePromotionGroupRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeletePromotionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionGroups/{groupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupCode"+"}", url.PathEscape(parameterValueToString(r.groupCode, "groupCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupCode) < 1 {
		return localVarReturnValue, nil, reportError("groupCode must have at least 1 elements")
	}
	if strlen(r.groupCode) > 2000 {
		return localVarReturnValue, nil, reportError("groupCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRateAccessExclusionsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateCode *string
	allowCancelReservation *[]bool
	allowCreateReservation *[]bool
	allowModifyReservation *[]bool
	excludeFromAvailability *[]bool
	inactive *[]bool
	sourceType *[]string
	sourceValue *[]string
	end *string
	start *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) Authorization(authorization string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate code
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) RateCode(rateCode string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.rateCode = &rateCode
	return r
}

// Allow to cancel a reservation under this access exclusion.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) AllowCancelReservation(allowCancelReservation []bool) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.allowCancelReservation = &allowCancelReservation
	return r
}

// Allow to create a reservation under this access exclusion.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) AllowCreateReservation(allowCreateReservation []bool) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.allowCreateReservation = &allowCreateReservation
	return r
}

// Allow to modify a reservation under this access exclusion.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) AllowModifyReservation(allowModifyReservation []bool) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.allowModifyReservation = &allowModifyReservation
	return r
}

// Exclude a specific rate from availability
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) ExcludeFromAvailability(excludeFromAvailability []bool) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.excludeFromAvailability = &excludeFromAvailability
	return r
}

// The rate access exclusion is inactive
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) Inactive(inactive []bool) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.inactive = &inactive
	return r
}

// The type of source (CRO or Hotel code) for which the rate access exclusion is set.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) SourceType(sourceType []string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.sourceType = &sourceType
	return r
}

// CRO or Hotel code value.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) SourceValue(sourceValue []string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.sourceValue = &sourceValue
	return r
}

// The ending value of the date range.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) End(end string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) Start(start string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.start = &start
	return r
}

// External system code.
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRateAccessExclusionsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRateAccessExclusionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRateAccessExclusionsExecute(r)
}

/*
DeleteRateAccessExclusions Delete rate access exclusions

This API allows you to delete rate access exclusions. <p><strong>OperationId:</strong>deleteRateAccessExclusions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRateAccessExclusionsRequest
*/
func (a *RatePlanAPIService) DeleteRateAccessExclusions(ctx context.Context, hotelId string) RatePlanAPIDeleteRateAccessExclusionsRequest {
	return RatePlanAPIDeleteRateAccessExclusionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRateAccessExclusionsExecute(r RatePlanAPIDeleteRateAccessExclusionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRateAccessExclusions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateAccessExclusions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.rateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", r.rateCode, "")
  }
	if r.allowCancelReservation != nil {
		t := *r.allowCancelReservation
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowCancelReservation", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowCancelReservation", t, "multi")
		}
  }
	if r.allowCreateReservation != nil {
		t := *r.allowCreateReservation
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowCreateReservation", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowCreateReservation", t, "multi")
		}
  }
	if r.allowModifyReservation != nil {
		t := *r.allowModifyReservation
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowModifyReservation", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowModifyReservation", t, "multi")
		}
  }
	if r.excludeFromAvailability != nil {
		t := *r.excludeFromAvailability
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFromAvailability", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeFromAvailability", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.sourceType != nil {
		t := *r.sourceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceType", t, "multi")
		}
  }
	if r.sourceValue != nil {
		t := *r.sourceValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sourceValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sourceValue", t, "multi")
		}
  }
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
  }
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRateGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRateGroupsRequest) Authorization(authorization string) RatePlanAPIDeleteRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRateGroupsRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRateGroupsRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteRateGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRateGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRateGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRateGroupsExecute(r)
}

/*
DeleteRateGroups Delete rate groups

This API allows you to delete rate groups. <p><strong>OperationId:</strong>deleteRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRateGroupsRequest
*/
func (a *RatePlanAPIService) DeleteRateGroups(ctx context.Context, hotelId string) RatePlanAPIDeleteRateGroupsRequest {
	return RatePlanAPIDeleteRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRateGroupsExecute(r RatePlanAPIDeleteRateGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRatePlanRequest) Authorization(authorization string) RatePlanAPIDeleteRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRatePlanRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRatePlanRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRatePlanRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanExecute(r)
}

/*
DeleteRatePlan Delete rate plan 

This API allows you to delete Rate Plan for a given hotel id. <p><strong>OperationId:</strong>deleteRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRatePlanRequest
*/
func (a *RatePlanAPIService) DeleteRatePlan(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIDeleteRatePlanRequest {
	return RatePlanAPIDeleteRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRatePlanExecute(r RatePlanAPIDeleteRatePlanRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRatePlanPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageCode *[]string
	packageGroup *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRatePlanPackagesRequest) Authorization(authorization string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRatePlanPackagesRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRatePlanPackagesRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r RatePlanAPIDeleteRatePlanPackagesRequest) PackageCode(packageCode []string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.packageCode = &packageCode
	return r
}

// Configuration code.
func (r RatePlanAPIDeleteRatePlanPackagesRequest) PackageGroup(packageGroup []string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.packageGroup = &packageGroup
	return r
}

// External system code.
func (r RatePlanAPIDeleteRatePlanPackagesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRatePlanPackagesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRatePlanPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRatePlanPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanPackagesExecute(r)
}

/*
DeleteRatePlanPackages Delete rate plan packages

This API allows you to delete Rate Plan package. <p><strong>OperationId:</strong>deleteRatePlanPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRatePlanPackagesRequest
*/
func (a *RatePlanAPIService) DeleteRatePlanPackages(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIDeleteRatePlanPackagesRequest {
	return RatePlanAPIDeleteRatePlanPackagesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRatePlanPackagesExecute(r RatePlanAPIDeleteRatePlanPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRatePlanPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.packageCode != nil {
		t := *r.packageCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", t, "multi")
		}
  }
	if r.packageGroup != nil {
		t := *r.packageGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageGroup", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRatePlanPostingRhythmsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	code *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) Authorization(authorization string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) Code(code []string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	r.code = &code
	return r
}

// External system code.
func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanPostingRhythmsExecute(r)
}

/*
DeleteRatePlanPostingRhythms Delete rate plan posting rhythms

This API allows you to delete Rate Plan posting rhythms. <p><strong>OperationId:</strong>deleteRatePlanPostingRhythms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRatePlanPostingRhythmsRequest
*/
func (a *RatePlanAPIService) DeleteRatePlanPostingRhythms(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIDeleteRatePlanPostingRhythmsRequest {
	return RatePlanAPIDeleteRatePlanPostingRhythmsRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRatePlanPostingRhythmsExecute(r RatePlanAPIDeleteRatePlanPostingRhythmsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRatePlanPostingRhythms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/postingRhythms"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	ratePlanScheduleIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	tierID *int32
	seasonCode *string
	start *string
	end *string
	roomType *[]string
	sunday *bool
	monday *bool
	tuesday *bool
	wednesday *bool
	thursday *bool
	friday *bool
	saturday *bool
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) RatePlanScheduleIds(ratePlanScheduleIds []string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.ratePlanScheduleIds = &ratePlanScheduleIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Authorization(authorization string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Tier that the rate plan schedule belongs to.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) TierID(tierID int32) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.tierID = &tierID
	return r
}

// Season code attached to the rate plan schedule that defines the start and end dates. When creating a rate plan schedule, if a season code is provided the start and end dates will be ignored. These values will be pulled from the season code record.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) SeasonCode(seasonCode string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.seasonCode = &seasonCode
	return r
}

// The starting value of the date range.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Start(start string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.start = &start
	return r
}

// The ending value of the date range.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) End(end string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.end = &end
	return r
}

// List of room types that are for the rate plan schedule.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) RoomType(roomType []string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.roomType = &roomType
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Sunday(sunday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.sunday = &sunday
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Monday(monday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.monday = &monday
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Tuesday(tuesday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.tuesday = &tuesday
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Wednesday(wednesday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.wednesday = &wednesday
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Thursday(thursday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.thursday = &thursday
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Friday(friday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.friday = &friday
	return r
}

// Day Of The Week Schedule Should Be Applicable.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Saturday(saturday bool) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.saturday = &saturday
	return r
}

// External system code.
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanSchedulesExecute(r)
}

/*
DeleteRatePlanSchedules Delete rate plan schedule

Use this API to delete Rate Plan schedules.<p><strong>OperationId:</strong>deleteRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRatePlanSchedulesRequest
*/
func (a *RatePlanAPIService) DeleteRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIDeleteRatePlanSchedulesRequest {
	return RatePlanAPIDeleteRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRatePlanSchedulesExecute(r RatePlanAPIDeleteRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.ratePlanScheduleIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIds", t, "multi")
		}
	}
	if r.tierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tierID", r.tierID, "")
  }
	if r.seasonCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seasonCode", r.seasonCode, "")
  }
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
  }
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
  }
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.sunday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sunday", r.sunday, "")
  }
	if r.monday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "monday", r.monday, "")
  }
	if r.tuesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tuesday", r.tuesday, "")
  }
	if r.wednesday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wednesday", r.wednesday, "")
  }
	if r.thursday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thursday", r.thursday, "")
  }
	if r.friday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friday", r.friday, "")
  }
	if r.saturday != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saturday", r.saturday, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRatePlanServiceCacheRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRatePlanServiceCacheRequest) Authorization(authorization string) RatePlanAPIDeleteRatePlanServiceCacheRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRatePlanServiceCacheRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRatePlanServiceCacheRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRatePlanServiceCacheRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRatePlanServiceCacheRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteRatePlanServiceCacheRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRatePlanServiceCacheRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRatePlanServiceCacheRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRatePlanServiceCacheRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRatePlanServiceCacheRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRatePlanServiceCacheExecute(r)
}

/*
DeleteRatePlanServiceCache Delete the Rate plan service cache

This API allows you to delete Rate Plan service cache. <p><strong>OperationId:</strong>deleteRatePlanServiceCache</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIDeleteRatePlanServiceCacheRequest
*/
func (a *RatePlanAPIService) DeleteRatePlanServiceCache(ctx context.Context) RatePlanAPIDeleteRatePlanServiceCacheRequest {
	return RatePlanAPIDeleteRatePlanServiceCacheRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRatePlanServiceCacheExecute(r RatePlanAPIDeleteRatePlanServiceCacheRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRatePlanServiceCache")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/rateplan/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteRateStrategyRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	rateStrategyId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteRateStrategyRequest) Authorization(authorization string) RatePlanAPIDeleteRateStrategyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteRateStrategyRequest) XAppKey(xAppKey string) RatePlanAPIDeleteRateStrategyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteRateStrategyRequest) XHotelid(xHotelid string) RatePlanAPIDeleteRateStrategyRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteRateStrategyRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteRateStrategyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteRateStrategyRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteRateStrategyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteRateStrategyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRateStrategyExecute(r)
}

/*
DeleteRateStrategy Delete rate strategies

This API allows you to delete rate strategies. <p><strong>OperationId:</strong>deleteRateStrategy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateStrategyId Strategy Id
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDeleteRateStrategyRequest
*/
func (a *RatePlanAPIService) DeleteRateStrategy(ctx context.Context, rateStrategyId string, hotelId string) RatePlanAPIDeleteRateStrategyRequest {
	return RatePlanAPIDeleteRateStrategyRequest{
		ApiService: a,
		ctx: ctx,
		rateStrategyId: rateStrategyId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteRateStrategyExecute(r RatePlanAPIDeleteRateStrategyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteRateStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateStrategies/{rateStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateStrategyId"+"}", url.PathEscape(parameterValueToString(r.rateStrategyId, "rateStrategyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateStrategyId) < 1 {
		return localVarReturnValue, nil, reportError("rateStrategyId must have at least 1 elements")
	}
	if strlen(r.rateStrategyId) > 2000 {
		return localVarReturnValue, nil, reportError("rateStrategyId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDeleteTemplatePackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageForecastGroupCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIDeleteTemplatePackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIDeleteTemplatePackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIDeleteTemplatePackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDeleteTemplatePackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDeleteTemplatePackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTemplatePackageForecastGroupsExecute(r)
}

/*
DeleteTemplatePackageForecastGroups Delete Template Package Forecast Groups

This API allows you to delete Package Forecast groups template. <p><strong>OperationId:</strong>deleteTemplatePackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageForecastGroupCode Code.
 @return RatePlanAPIDeleteTemplatePackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) DeleteTemplatePackageForecastGroups(ctx context.Context, packageForecastGroupCode string) RatePlanAPIDeleteTemplatePackageForecastGroupsRequest {
	return RatePlanAPIDeleteTemplatePackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
		packageForecastGroupCode: packageForecastGroupCode,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DeleteTemplatePackageForecastGroupsExecute(r RatePlanAPIDeleteTemplatePackageForecastGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DeleteTemplatePackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageForecastGroups/{packageForecastGroupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageForecastGroupCode"+"}", url.PathEscape(parameterValueToString(r.packageForecastGroupCode, "packageForecastGroupCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageForecastGroupCode) < 1 {
		return localVarReturnValue, nil, reportError("packageForecastGroupCode must have at least 1 elements")
	}
	if strlen(r.packageForecastGroupCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageForecastGroupCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDistributeNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	distributedNegotiatedRates *DistributedNegotiatedRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDistributeNegotiatedRatesRequest) Authorization(authorization string) RatePlanAPIDistributeNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDistributeNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanAPIDistributeNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDistributeNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanAPIDistributeNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for distribute negotiated rates. This object contains a list of negotiated rates that are to be distributed and a list of properties to which to distribute to.
func (r RatePlanAPIDistributeNegotiatedRatesRequest) DistributedNegotiatedRates(distributedNegotiatedRates DistributedNegotiatedRates) RatePlanAPIDistributeNegotiatedRatesRequest {
	r.distributedNegotiatedRates = &distributedNegotiatedRates
	return r
}

// External system code.
func (r RatePlanAPIDistributeNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDistributeNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDistributeNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDistributeNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDistributeNegotiatedRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DistributeNegotiatedRatesExecute(r)
}

/*
DistributeNegotiatedRates Distribute negotiated rates

This API allows you to distribute negotiated Rate. <p><strong>OperationId:</strong>distributeNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDistributeNegotiatedRatesRequest
*/
func (a *RatePlanAPIService) DistributeNegotiatedRates(ctx context.Context, hotelId string) RatePlanAPIDistributeNegotiatedRatesRequest {
	return RatePlanAPIDistributeNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DistributeNegotiatedRatesExecute(r RatePlanAPIDistributeNegotiatedRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DistributeNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/distributions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.distributedNegotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIDownloadExternalRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIDownloadExternalRatePlanRequest) Authorization(authorization string) RatePlanAPIDownloadExternalRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIDownloadExternalRatePlanRequest) XAppKey(xAppKey string) RatePlanAPIDownloadExternalRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIDownloadExternalRatePlanRequest) XHotelid(xHotelid string) RatePlanAPIDownloadExternalRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIDownloadExternalRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanAPIDownloadExternalRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIDownloadExternalRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIDownloadExternalRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIDownloadExternalRatePlanRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DownloadExternalRatePlanExecute(r)
}

/*
DownloadExternalRatePlan Get external rate plan

This API allows you to fetch external Rate Plan. <p><strong>OperationId:</strong>downloadExternalRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIDownloadExternalRatePlanRequest
*/
func (a *RatePlanAPIService) DownloadExternalRatePlan(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIDownloadExternalRatePlanRequest {
	return RatePlanAPIDownloadExternalRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) DownloadExternalRatePlanExecute(r RatePlanAPIDownloadExternalRatePlanRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.DownloadExternalRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/externalRatePlans/{ratePlanCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	startDay *string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	rateCode *[]string
	endDay *string
	daysOfWeek *[]string
	lengthOfStay *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The starting value of the date range.
func (r RatePlanAPIGetBestAvailableRatesRequest) StartDay(startDay string) RatePlanAPIGetBestAvailableRatesRequest {
	r.startDay = &startDay
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetBestAvailableRatesRequest) Authorization(authorization string) RatePlanAPIGetBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetBestAvailableRatesRequest) XAppKey(xAppKey string) RatePlanAPIGetBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetBestAvailableRatesRequest) XHotelid(xHotelid string) RatePlanAPIGetBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetBestAvailableRatesRequest) Limit(limit int32) RatePlanAPIGetBestAvailableRatesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetBestAvailableRatesRequest) Offset(offset int32) RatePlanAPIGetBestAvailableRatesRequest {
	r.offset = &offset
	return r
}

func (r RatePlanAPIGetBestAvailableRatesRequest) RateCode(rateCode []string) RatePlanAPIGetBestAvailableRatesRequest {
	r.rateCode = &rateCode
	return r
}

// The ending value of the date range.
func (r RatePlanAPIGetBestAvailableRatesRequest) EndDay(endDay string) RatePlanAPIGetBestAvailableRatesRequest {
	r.endDay = &endDay
	return r
}

// Allowed values for the days of week type.
func (r RatePlanAPIGetBestAvailableRatesRequest) DaysOfWeek(daysOfWeek []string) RatePlanAPIGetBestAvailableRatesRequest {
	r.daysOfWeek = &daysOfWeek
	return r
}

// Allowed values for length stay type.
func (r RatePlanAPIGetBestAvailableRatesRequest) LengthOfStay(lengthOfStay []string) RatePlanAPIGetBestAvailableRatesRequest {
	r.lengthOfStay = &lengthOfStay
	return r
}

// External system code.
func (r RatePlanAPIGetBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetBestAvailableRatesRequest) Execute() (*GetBestAvailableRatesDetails, *http.Response, error) {
	return r.ApiService.GetBestAvailableRatesExecute(r)
}

/*
GetBestAvailableRates Fetch Best Available Rates

This API allows to fetch Best Available rates for rate code(s). <p><strong>OperationId:</strong>getBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetBestAvailableRatesRequest
*/
func (a *RatePlanAPIService) GetBestAvailableRates(ctx context.Context, hotelId string) RatePlanAPIGetBestAvailableRatesRequest {
	return RatePlanAPIGetBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GetBestAvailableRatesDetails
func (a *RatePlanAPIService) GetBestAvailableRatesExecute(r RatePlanAPIGetBestAvailableRatesRequest) (*GetBestAvailableRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBestAvailableRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDay", r.startDay, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.rateCode != nil {
		t := *r.rateCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCode", t, "multi")
		}
  }
	if r.endDay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDay", r.endDay, "")
  }
	if r.daysOfWeek != nil {
		t := *r.daysOfWeek
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daysOfWeek", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daysOfWeek", t, "multi")
		}
  }
	if r.lengthOfStay != nil {
		t := *r.lengthOfStay
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lengthOfStay", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetHotelPackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	offset *int32
	packageForecastGroupCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) HotelIds(hotelIds []string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) Limit(limit int32) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) Offset(offset int32) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) PackageForecastGroupCodes(packageForecastGroupCodes []string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.packageForecastGroupCodes = &packageForecastGroupCodes
	return r
}

// Wildcard search on the code.
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) WildCard(wildCard string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Inactive flag - whether or not to display inactive records
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetHotelPackageForecastGroupsRequest) Execute() (*HotelPackageForecastGroups, *http.Response, error) {
	return r.ApiService.GetHotelPackageForecastGroupsExecute(r)
}

/*
GetHotelPackageForecastGroups Get Hotel Package Forecast Groups

This API allows you to fetch package forecast groups. <p><strong>OperationId:</strong>getHotelPackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetHotelPackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) GetHotelPackageForecastGroups(ctx context.Context, hotelId string) RatePlanAPIGetHotelPackageForecastGroupsRequest {
	return RatePlanAPIGetHotelPackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HotelPackageForecastGroups
func (a *RatePlanAPIService) GetHotelPackageForecastGroupsExecute(r RatePlanAPIGetHotelPackageForecastGroupsRequest) (*HotelPackageForecastGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HotelPackageForecastGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetHotelPackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageForecastGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.packageForecastGroupCodes != nil {
		t := *r.packageForecastGroupCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "PackageForecastGroupCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "PackageForecastGroupCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetMassRateChangeStatusRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	detailStatus *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetMassRateChangeStatusRequest) Authorization(authorization string) RatePlanAPIGetMassRateChangeStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetMassRateChangeStatusRequest) XAppKey(xAppKey string) RatePlanAPIGetMassRateChangeStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetMassRateChangeStatusRequest) XHotelid(xHotelid string) RatePlanAPIGetMassRateChangeStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate to include the update process details or not.
func (r RatePlanAPIGetMassRateChangeStatusRequest) DetailStatus(detailStatus bool) RatePlanAPIGetMassRateChangeStatusRequest {
	r.detailStatus = &detailStatus
	return r
}

// External system code.
func (r RatePlanAPIGetMassRateChangeStatusRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetMassRateChangeStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetMassRateChangeStatusRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetMassRateChangeStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetMassRateChangeStatusRequest) Execute() (*MassRateChangeStatus, *http.Response, error) {
	return r.ApiService.GetMassRateChangeStatusExecute(r)
}

/*
GetMassRateChangeStatus Get mass rate change status

This API allows you to fetch mass rate change status. <p><strong>OperationId:</strong>getMassRateChangeStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetMassRateChangeStatusRequest
*/
func (a *RatePlanAPIService) GetMassRateChangeStatus(ctx context.Context, hotelId string) RatePlanAPIGetMassRateChangeStatusRequest {
	return RatePlanAPIGetMassRateChangeStatusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MassRateChangeStatus
func (a *RatePlanAPIService) GetMassRateChangeStatusExecute(r RatePlanAPIGetMassRateChangeStatusRequest) (*MassRateChangeStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MassRateChangeStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetMassRateChangeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/massRateChangeStatus"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.detailStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailStatus", r.detailStatus, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetNegotiatedRatesRequest) Authorization(authorization string) RatePlanAPIGetNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanAPIGetNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanAPIGetNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetNegotiatedRatesRequest) Limit(limit int32) RatePlanAPIGetNegotiatedRatesRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r RatePlanAPIGetNegotiatedRatesRequest) StartDate(startDate string) RatePlanAPIGetNegotiatedRatesRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r RatePlanAPIGetNegotiatedRatesRequest) EndDate(endDate string) RatePlanAPIGetNegotiatedRatesRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r RatePlanAPIGetNegotiatedRatesRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) RatePlanAPIGetNegotiatedRatesRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetNegotiatedRatesRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) RatePlanAPIGetNegotiatedRatesRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetNegotiatedRatesRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetNegotiatedRatesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetNegotiatedRatesRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesExecute(r)
}

/*
GetNegotiatedRates Get negotiated rates and profiles 

This API allows you to fetch negotiated rates and profile for a given hotel id. <p><strong>OperationId:</strong>getNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetNegotiatedRatesRequest
*/
func (a *RatePlanAPIService) GetNegotiatedRates(ctx context.Context, hotelId string) RatePlanAPIGetNegotiatedRatesRequest {
	return RatePlanAPIGetNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanAPIService) GetNegotiatedRatesExecute(r RatePlanAPIGetNegotiatedRatesRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
  }
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) Authorization(authorization string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) XAppKey(xAppKey string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) XHotelid(xHotelid string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) Limit(limit int32) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) StartDate(startDate string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) EndDate(endDate string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.endDate = &endDate
	return r
}

// Inactive negotiated rates.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesForGivenHotelAndRateExecute(r)
}

/*
GetNegotiatedRatesForGivenHotelAndRate Fetch Negotiated Rates

This API allows you to fetch a Rate Plan and Profile for given hotel id and negotiated rate code. <p><strong>OperationId:</strong>getNegotiatedRatesForGivenHotelAndRate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest
*/
func (a *RatePlanAPIService) GetNegotiatedRatesForGivenHotelAndRate(ctx context.Context, rateCode string, hotelId string) RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest {
	return RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanAPIService) GetNegotiatedRatesForGivenHotelAndRateExecute(r RatePlanAPIGetNegotiatedRatesForGivenHotelAndRateRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetNegotiatedRatesForGivenHotelAndRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/{rateCode}/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
  }
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetNegotiatedRatesForGivenProfileRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	startDate *string
	endDate *string
	hotelCode *string
	ratePlanCode *string
	includeInactiveNegotiatedRates *bool
	fetchInstructionsLimit *int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) Authorization(authorization string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) XAppKey(xAppKey string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) XHotelid(xHotelid string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) Limit(limit int32) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.limit = &limit
	return r
}

// Start Date.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) StartDate(startDate string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.startDate = &startDate
	return r
}

// End Date.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) EndDate(endDate string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.endDate = &endDate
	return r
}

// Hotel code associated to the hotel
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) HotelCode(hotelCode string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.hotelCode = &hotelCode
	return r
}

// Rate Plan Code associated with the rate
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) RatePlanCode(ratePlanCode string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Inactive negotiated rates.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) IncludeInactiveNegotiatedRates(includeInactiveNegotiatedRates bool) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.includeInactiveNegotiatedRates = &includeInactiveNegotiatedRates
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) FetchInstructionsLimit(fetchInstructionsLimit int32) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.fetchInstructionsLimit = &fetchInstructionsLimit
	return r
}

// Simple type for negotiated rates instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) Execute() (*NegotiatedRates, *http.Response, error) {
	return r.ApiService.GetNegotiatedRatesForGivenProfileExecute(r)
}

/*
GetNegotiatedRatesForGivenProfile Get negotiated rate details for given profile

This API allows you to fetch negotiated Rates for a given profile. <p><strong>OperationId:</strong>getNegotiatedRatesForGivenProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetNegotiatedRatesForGivenProfileRequest
*/
func (a *RatePlanAPIService) GetNegotiatedRatesForGivenProfile(ctx context.Context, profileId string) RatePlanAPIGetNegotiatedRatesForGivenProfileRequest {
	return RatePlanAPIGetNegotiatedRatesForGivenProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return NegotiatedRates
func (a *RatePlanAPIService) GetNegotiatedRatesForGivenProfileExecute(r RatePlanAPIGetNegotiatedRatesForGivenProfileRequest) (*NegotiatedRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetNegotiatedRatesForGivenProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.hotelCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelCode", r.hotelCode, "")
  }
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
  }
	if r.includeInactiveNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveNegotiatedRates", r.includeInactiveNegotiatedRates, "")
  }
	if r.fetchInstructionsLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructionsLimit", r.fetchInstructionsLimit, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPackageRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPackageRequest) Authorization(authorization string) RatePlanAPIGetPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPackageRequest) XAppKey(xAppKey string) RatePlanAPIGetPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPackageRequest) XHotelid(xHotelid string) RatePlanAPIGetPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for package instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetPackageRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetPackageRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetPackageRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPackageRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPackageRequest) Execute() (*PackageInfo, *http.Response, error) {
	return r.ApiService.GetPackageExecute(r)
}

/*
GetPackage Get package for given package

This API allows you to fetch package details for a given package. <p><strong>OperationId:</strong>getPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetPackageRequest
*/
func (a *RatePlanAPIService) GetPackage(ctx context.Context, packageCode string, hotelId string) RatePlanAPIGetPackageRequest {
	return RatePlanAPIGetPackageRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageInfo
func (a *RatePlanAPIService) GetPackageExecute(r RatePlanAPIGetPackageRequest) (*PackageInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPackageFormulaRangesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taxRangeType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPackageFormulaRangesRequest) Authorization(authorization string) RatePlanAPIGetPackageFormulaRangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPackageFormulaRangesRequest) XAppKey(xAppKey string) RatePlanAPIGetPackageFormulaRangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPackageFormulaRangesRequest) XHotelid(xHotelid string) RatePlanAPIGetPackageFormulaRangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Tax Range Type.
func (r RatePlanAPIGetPackageFormulaRangesRequest) TaxRangeType(taxRangeType string) RatePlanAPIGetPackageFormulaRangesRequest {
	r.taxRangeType = &taxRangeType
	return r
}

// External system code.
func (r RatePlanAPIGetPackageFormulaRangesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPackageFormulaRangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPackageFormulaRangesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPackageFormulaRangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPackageFormulaRangesRequest) Execute() (*PackageFormulaRanges, *http.Response, error) {
	return r.ApiService.GetPackageFormulaRangesExecute(r)
}

/*
GetPackageFormulaRanges Get package formula ranges

This API allows you to fetch package formula ranges. <p><strong>OperationId:</strong>getPackageFormulaRanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetPackageFormulaRangesRequest
*/
func (a *RatePlanAPIService) GetPackageFormulaRanges(ctx context.Context, hotelId string) RatePlanAPIGetPackageFormulaRangesRequest {
	return RatePlanAPIGetPackageFormulaRangesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageFormulaRanges
func (a *RatePlanAPIService) GetPackageFormulaRangesExecute(r RatePlanAPIGetPackageFormulaRangesRequest) (*PackageFormulaRanges, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageFormulaRanges
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPackageFormulaRanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageFormulaRanges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.taxRangeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxRangeType", r.taxRangeType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPackageGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	limit *int32
	code *string
	descriptionWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPackageGroupsRequest) Authorization(authorization string) RatePlanAPIGetPackageGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPackageGroupsRequest) XAppKey(xAppKey string) RatePlanAPIGetPackageGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPackageGroupsRequest) XHotelid(xHotelid string) RatePlanAPIGetPackageGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r RatePlanAPIGetPackageGroupsRequest) HotelIds(hotelIds []string) RatePlanAPIGetPackageGroupsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetPackageGroupsRequest) Limit(limit int32) RatePlanAPIGetPackageGroupsRequest {
	r.limit = &limit
	return r
}

// Package code or group to be searched.
func (r RatePlanAPIGetPackageGroupsRequest) Code(code string) RatePlanAPIGetPackageGroupsRequest {
	r.code = &code
	return r
}

// The description or a part of the description based on which results should be filtered.
func (r RatePlanAPIGetPackageGroupsRequest) DescriptionWildCard(descriptionWildCard string) RatePlanAPIGetPackageGroupsRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// External system code.
func (r RatePlanAPIGetPackageGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPackageGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPackageGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPackageGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPackageGroupsRequest) Execute() (*PackageGroupsInfo, *http.Response, error) {
	return r.ApiService.GetPackageGroupsExecute(r)
}

/*
GetPackageGroups Get package groups

This API allows you to fetch package group. <p><strong>OperationId:</strong>getPackageGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetPackageGroupsRequest
*/
func (a *RatePlanAPIService) GetPackageGroups(ctx context.Context, hotelId string) RatePlanAPIGetPackageGroupsRequest {
	return RatePlanAPIGetPackageGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageGroupsInfo
func (a *RatePlanAPIService) GetPackageGroupsExecute(r RatePlanAPIGetPackageGroupsRequest) (*PackageGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPackageGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPackageRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPackageRatesRequest) Authorization(authorization string) RatePlanAPIGetPackageRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPackageRatesRequest) XAppKey(xAppKey string) RatePlanAPIGetPackageRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPackageRatesRequest) XHotelid(xHotelid string) RatePlanAPIGetPackageRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetPackageRatesRequest) Limit(limit int32) RatePlanAPIGetPackageRatesRequest {
	r.limit = &limit
	return r
}

// External system code.
func (r RatePlanAPIGetPackageRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPackageRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPackageRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPackageRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPackageRatesRequest) Execute() (*PackageRates, *http.Response, error) {
	return r.ApiService.GetPackageRatesExecute(r)
}

/*
GetPackageRates Get package rates

This API allows you to fetch rate plan codes associated for a package. <p><strong>OperationId:</strong>getPackageRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetPackageRatesRequest
*/
func (a *RatePlanAPIService) GetPackageRates(ctx context.Context, packageCode string, hotelId string) RatePlanAPIGetPackageRatesRequest {
	return RatePlanAPIGetPackageRatesRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PackageRates
func (a *RatePlanAPIService) GetPackageRatesExecute(r RatePlanAPIGetPackageRatesRequest) (*PackageRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPackageRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}/rates"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	hotelId *[]string
	packageCode *[]string
	descriptionWildCard *string
	startDate *string
	endDate *string
	adults *int32
	children *int32
	bucket1Count *int32
	bucket2Count *int32
	bucket3Count *int32
	bucket4Count *int32
	bucket5Count *int32
	includeGroup *bool
	sellSeparate *bool
	ticketPostingRhythm *bool
	excludeRedemptionPackages *bool
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPackagesRequest) Authorization(authorization string) RatePlanAPIGetPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPackagesRequest) XAppKey(xAppKey string) RatePlanAPIGetPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPackagesRequest) XHotelid(xHotelid string) RatePlanAPIGetPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetPackagesRequest) Limit(limit int32) RatePlanAPIGetPackagesRequest {
	r.limit = &limit
	return r
}

// Hotel code.
func (r RatePlanAPIGetPackagesRequest) HotelId(hotelId []string) RatePlanAPIGetPackagesRequest {
	r.hotelId = &hotelId
	return r
}

func (r RatePlanAPIGetPackagesRequest) PackageCode(packageCode []string) RatePlanAPIGetPackagesRequest {
	r.packageCode = &packageCode
	return r
}

// The description or a part of the description based on which results should be filtered.
func (r RatePlanAPIGetPackagesRequest) DescriptionWildCard(descriptionWildCard string) RatePlanAPIGetPackagesRequest {
	r.descriptionWildCard = &descriptionWildCard
	return r
}

// Start Date for pricing schedule.
func (r RatePlanAPIGetPackagesRequest) StartDate(startDate string) RatePlanAPIGetPackagesRequest {
	r.startDate = &startDate
	return r
}

// End Date for pricing schedule.
func (r RatePlanAPIGetPackagesRequest) EndDate(endDate string) RatePlanAPIGetPackagesRequest {
	r.endDate = &endDate
	return r
}

// Number of adults for pricing schedule calculation.
func (r RatePlanAPIGetPackagesRequest) Adults(adults int32) RatePlanAPIGetPackagesRequest {
	r.adults = &adults
	return r
}

// Number of children for pricing schedule calculation.
func (r RatePlanAPIGetPackagesRequest) Children(children int32) RatePlanAPIGetPackagesRequest {
	r.children = &children
	return r
}

// Number of children classified under the first Age Qualifying Group(Child Bucket#1).
func (r RatePlanAPIGetPackagesRequest) Bucket1Count(bucket1Count int32) RatePlanAPIGetPackagesRequest {
	r.bucket1Count = &bucket1Count
	return r
}

// Number of children classified under the second Age Qualifying Group(Child Bucket#2).
func (r RatePlanAPIGetPackagesRequest) Bucket2Count(bucket2Count int32) RatePlanAPIGetPackagesRequest {
	r.bucket2Count = &bucket2Count
	return r
}

// Number of children classified under the third Age Qualifying Group(Child Bucket#3).
func (r RatePlanAPIGetPackagesRequest) Bucket3Count(bucket3Count int32) RatePlanAPIGetPackagesRequest {
	r.bucket3Count = &bucket3Count
	return r
}

// Number of children classified under the fourth Age Qualifying Group(Child Bucket#4).
func (r RatePlanAPIGetPackagesRequest) Bucket4Count(bucket4Count int32) RatePlanAPIGetPackagesRequest {
	r.bucket4Count = &bucket4Count
	return r
}

// Number of children classified under the fifth Age Qualifying Group(Child Bucket#5).
func (r RatePlanAPIGetPackagesRequest) Bucket5Count(bucket5Count int32) RatePlanAPIGetPackagesRequest {
	r.bucket5Count = &bucket5Count
	return r
}

// Indicates if Group Packages will be fetched.
func (r RatePlanAPIGetPackagesRequest) IncludeGroup(includeGroup bool) RatePlanAPIGetPackagesRequest {
	r.includeGroup = &includeGroup
	return r
}

// Indicates if Only Sell Separate Packages will be fetched, if not specified, it will ignore the criteria.
func (r RatePlanAPIGetPackagesRequest) SellSeparate(sellSeparate bool) RatePlanAPIGetPackagesRequest {
	r.sellSeparate = &sellSeparate
	return r
}

// Indicates if Only Ticket Posting Rhythm will be fetched, if not specified, it will ignore the criteria.
func (r RatePlanAPIGetPackagesRequest) TicketPostingRhythm(ticketPostingRhythm bool) RatePlanAPIGetPackagesRequest {
	r.ticketPostingRhythm = &ticketPostingRhythm
	return r
}

// Indicates if redemption packages must be excluded from the list.
func (r RatePlanAPIGetPackagesRequest) ExcludeRedemptionPackages(excludeRedemptionPackages bool) RatePlanAPIGetPackagesRequest {
	r.excludeRedemptionPackages = &excludeRedemptionPackages
	return r
}

// Simple type for package instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetPackagesRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetPackagesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetPackagesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPackagesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPackagesRequest) Execute() (*PackagesInfo, *http.Response, error) {
	return r.ApiService.GetPackagesExecute(r)
}

/*
GetPackages Get Packages

Use this API you to get configured packages for a hotel.<p><strong>OperationId:</strong>getPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIGetPackagesRequest
*/
func (a *RatePlanAPIService) GetPackages(ctx context.Context) RatePlanAPIGetPackagesRequest {
	return RatePlanAPIGetPackagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackagesInfo
func (a *RatePlanAPIService) GetPackagesExecute(r RatePlanAPIGetPackagesRequest) (*PackagesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackagesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.packageCode != nil {
		t := *r.packageCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageCode", t, "multi")
		}
  }
	if r.descriptionWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descriptionWildCard", r.descriptionWildCard, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.adults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adults", r.adults, "")
  }
	if r.children != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children", r.children, "")
  }
	if r.bucket1Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket1Count", r.bucket1Count, "")
  }
	if r.bucket2Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket2Count", r.bucket2Count, "")
  }
	if r.bucket3Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket3Count", r.bucket3Count, "")
  }
	if r.bucket4Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket4Count", r.bucket4Count, "")
  }
	if r.bucket5Count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket5Count", r.bucket5Count, "")
  }
	if r.includeGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGroup", r.includeGroup, "")
  }
	if r.sellSeparate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellSeparate", r.sellSeparate, "")
  }
	if r.ticketPostingRhythm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPostingRhythm", r.ticketPostingRhythm, "")
  }
	if r.excludeRedemptionPackages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRedemptionPackages", r.excludeRedemptionPackages, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPromotionCodesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	promotionCode *[]string
	promotionGroup *[]string
	rateCodes *string
	description *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPromotionCodesRequest) Authorization(authorization string) RatePlanAPIGetPromotionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPromotionCodesRequest) XAppKey(xAppKey string) RatePlanAPIGetPromotionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPromotionCodesRequest) XHotelid(xHotelid string) RatePlanAPIGetPromotionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetPromotionCodesRequest) Limit(limit int32) RatePlanAPIGetPromotionCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetPromotionCodesRequest) Offset(offset int32) RatePlanAPIGetPromotionCodesRequest {
	r.offset = &offset
	return r
}

func (r RatePlanAPIGetPromotionCodesRequest) PromotionCode(promotionCode []string) RatePlanAPIGetPromotionCodesRequest {
	r.promotionCode = &promotionCode
	return r
}

func (r RatePlanAPIGetPromotionCodesRequest) PromotionGroup(promotionGroup []string) RatePlanAPIGetPromotionCodesRequest {
	r.promotionGroup = &promotionGroup
	return r
}

// Comma separated list of rates codes. This is used to filter the response and return only those promotion codes that are tied to any of these rate codes.
func (r RatePlanAPIGetPromotionCodesRequest) RateCodes(rateCodes string) RatePlanAPIGetPromotionCodesRequest {
	r.rateCodes = &rateCodes
	return r
}

// Category Description of the promotion.
func (r RatePlanAPIGetPromotionCodesRequest) Description(description string) RatePlanAPIGetPromotionCodesRequest {
	r.description = &description
	return r
}

// Indicates whether to include inactive promotions.
func (r RatePlanAPIGetPromotionCodesRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetPromotionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r RatePlanAPIGetPromotionCodesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPromotionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPromotionCodesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPromotionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPromotionCodesRequest) Execute() (*PropertyPromotionCodes, *http.Response, error) {
	return r.ApiService.GetPromotionCodesExecute(r)
}

/*
GetPromotionCodes Get promotion codes

This API allows you to fetch promotion codes. <p><strong>OperationId:</strong>getPromotionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetPromotionCodesRequest
*/
func (a *RatePlanAPIService) GetPromotionCodes(ctx context.Context, hotelId string) RatePlanAPIGetPromotionCodesRequest {
	return RatePlanAPIGetPromotionCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PropertyPromotionCodes
func (a *RatePlanAPIService) GetPromotionCodesExecute(r RatePlanAPIGetPromotionCodesRequest) (*PropertyPromotionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PropertyPromotionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPromotionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
  }
	if r.promotionGroup != nil {
		t := *r.promotionGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionGroup", t, "multi")
		}
  }
	if r.rateCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCodes", r.rateCodes, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetPromotionGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	code *[]string
	promotionGroupListCode *[]string
	rateCodes *string
	description *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetPromotionGroupsRequest) Authorization(authorization string) RatePlanAPIGetPromotionGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetPromotionGroupsRequest) XAppKey(xAppKey string) RatePlanAPIGetPromotionGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetPromotionGroupsRequest) XHotelid(xHotelid string) RatePlanAPIGetPromotionGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetPromotionGroupsRequest) Limit(limit int32) RatePlanAPIGetPromotionGroupsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetPromotionGroupsRequest) Offset(offset int32) RatePlanAPIGetPromotionGroupsRequest {
	r.offset = &offset
	return r
}

func (r RatePlanAPIGetPromotionGroupsRequest) Code(code []string) RatePlanAPIGetPromotionGroupsRequest {
	r.code = &code
	return r
}

func (r RatePlanAPIGetPromotionGroupsRequest) PromotionGroupListCode(promotionGroupListCode []string) RatePlanAPIGetPromotionGroupsRequest {
	r.promotionGroupListCode = &promotionGroupListCode
	return r
}

// Comma separated list of rates codes. This is used to filter the response and return only those promotion codes that are tied to any of these rate codes.
func (r RatePlanAPIGetPromotionGroupsRequest) RateCodes(rateCodes string) RatePlanAPIGetPromotionGroupsRequest {
	r.rateCodes = &rateCodes
	return r
}

// Category Description of the promotion.
func (r RatePlanAPIGetPromotionGroupsRequest) Description(description string) RatePlanAPIGetPromotionGroupsRequest {
	r.description = &description
	return r
}

// Indicates whether to include inactive promotions.
func (r RatePlanAPIGetPromotionGroupsRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetPromotionGroupsRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r RatePlanAPIGetPromotionGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetPromotionGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetPromotionGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetPromotionGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetPromotionGroupsRequest) Execute() (*PromotionGroups, *http.Response, error) {
	return r.ApiService.GetPromotionGroupsExecute(r)
}

/*
GetPromotionGroups Get promotion groups

This API allows you to fetch promotion codes. <p><strong>OperationId:</strong>getPromotionGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetPromotionGroupsRequest
*/
func (a *RatePlanAPIService) GetPromotionGroups(ctx context.Context, hotelId string) RatePlanAPIGetPromotionGroupsRequest {
	return RatePlanAPIGetPromotionGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return PromotionGroups
func (a *RatePlanAPIService) GetPromotionGroupsExecute(r RatePlanAPIGetPromotionGroupsRequest) (*PromotionGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotionGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetPromotionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.promotionGroupListCode != nil {
		t := *r.promotionGroupListCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionGroupListCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionGroupListCode", t, "multi")
		}
  }
	if r.rateCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCodes", r.rateCodes, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRateActivityLogRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	module *string
	parameterName *[]string
	parameterValue *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	activityGroup *string
	activityType *string
	fromDate *string
	toDate *string
	searchText *string
	userId *[]int32
	userForIdsUserId *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Activity module.
func (r RatePlanAPIGetRateActivityLogRequest) Module(module string) RatePlanAPIGetRateActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r RatePlanAPIGetRateActivityLogRequest) ParameterName(parameterName []string) RatePlanAPIGetRateActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r RatePlanAPIGetRateActivityLogRequest) ParameterValue(parameterValue []string) RatePlanAPIGetRateActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRateActivityLogRequest) Authorization(authorization string) RatePlanAPIGetRateActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRateActivityLogRequest) XAppKey(xAppKey string) RatePlanAPIGetRateActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRateActivityLogRequest) XHotelid(xHotelid string) RatePlanAPIGetRateActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetRateActivityLogRequest) Limit(limit int32) RatePlanAPIGetRateActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetRateActivityLogRequest) Offset(offset int32) RatePlanAPIGetRateActivityLogRequest {
	r.offset = &offset
	return r
}

func (r RatePlanAPIGetRateActivityLogRequest) ActivityGroup(activityGroup string) RatePlanAPIGetRateActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r RatePlanAPIGetRateActivityLogRequest) ActivityType(activityType string) RatePlanAPIGetRateActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r RatePlanAPIGetRateActivityLogRequest) FromDate(fromDate string) RatePlanAPIGetRateActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r RatePlanAPIGetRateActivityLogRequest) ToDate(toDate string) RatePlanAPIGetRateActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Search text for the user activity log.
func (r RatePlanAPIGetRateActivityLogRequest) SearchText(searchText string) RatePlanAPIGetRateActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r RatePlanAPIGetRateActivityLogRequest) UserId(userId []int32) RatePlanAPIGetRateActivityLogRequest {
	r.userId = &userId
	return r
}

func (r RatePlanAPIGetRateActivityLogRequest) UserForIdsUserId(userForIdsUserId []int32) RatePlanAPIGetRateActivityLogRequest {
	r.userForIdsUserId = &userForIdsUserId
	return r
}

// External system code.
func (r RatePlanAPIGetRateActivityLogRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRateActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRateActivityLogRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRateActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRateActivityLogRequest) Execute() (*RateActivityLog, *http.Response, error) {
	return r.ApiService.GetRateActivityLogExecute(r)
}

/*
GetRateActivityLog Get rate activity log

This API allows you to fetch Rate Activity Log. <p><strong>OperationId:</strong>getRateActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRateActivityLogRequest
*/
func (a *RatePlanAPIService) GetRateActivityLog(ctx context.Context, hotelId string) RatePlanAPIGetRateActivityLogRequest {
	return RatePlanAPIGetRateActivityLogRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateActivityLog
func (a *RatePlanAPIService) GetRateActivityLogExecute(r RatePlanAPIGetRateActivityLogRequest) (*RateActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRateActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rates/activityLog"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
	{
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
	}
	{
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
  }
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
  }
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
  }
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
  }
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
  }
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userId", t, "multi")
		}
  }
	if r.userForIdsUserId != nil {
		t := *r.userForIdsUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIdsUserId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIdsUserId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRateGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	code *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRateGroupsRequest) Authorization(authorization string) RatePlanAPIGetRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRateGroupsRequest) XAppKey(xAppKey string) RatePlanAPIGetRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRateGroupsRequest) XHotelid(xHotelid string) RatePlanAPIGetRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetRateGroupsRequest) Limit(limit int32) RatePlanAPIGetRateGroupsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetRateGroupsRequest) Offset(offset int32) RatePlanAPIGetRateGroupsRequest {
	r.offset = &offset
	return r
}

// Codes to be searched.
func (r RatePlanAPIGetRateGroupsRequest) Code(code []string) RatePlanAPIGetRateGroupsRequest {
	r.code = &code
	return r
}

// Wildcard search on the code.
func (r RatePlanAPIGetRateGroupsRequest) WildCard(wildCard string) RatePlanAPIGetRateGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// Rate Group Description.
func (r RatePlanAPIGetRateGroupsRequest) Description(description string) RatePlanAPIGetRateGroupsRequest {
	r.description = &description
	return r
}

// External system code.
func (r RatePlanAPIGetRateGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRateGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRateGroupsRequest) Execute() (*RateGroupsInfo, *http.Response, error) {
	return r.ApiService.GetRateGroupsExecute(r)
}

/*
GetRateGroups Get rate groups

This API allows you to update rate groups. <p><strong>OperationId:</strong>getRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRateGroupsRequest
*/
func (a *RatePlanAPIService) GetRateGroups(ctx context.Context, hotelId string) RatePlanAPIGetRateGroupsRequest {
	return RatePlanAPIGetRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateGroupsInfo
func (a *RatePlanAPIService) GetRateGroupsExecute(r RatePlanAPIGetRateGroupsRequest) (*RateGroupsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateGroupsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.code != nil {
		t := *r.code
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "code", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "code", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRatePlanRequest) Authorization(authorization string) RatePlanAPIGetRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRatePlanRequest) XAppKey(xAppKey string) RatePlanAPIGetRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRatePlanRequest) XHotelid(xHotelid string) RatePlanAPIGetRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for Rate plan codes instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetRatePlanRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetRatePlanRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRatePlanRequest) Execute() (*RatePlanInfo, *http.Response, error) {
	return r.ApiService.GetRatePlanExecute(r)
}

/*
GetRatePlan Get rate plan

This API allows you to fetch Rate Plan for a given hotel id and Rate Plan Code. <p><strong>OperationId:</strong>getRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRatePlanRequest
*/
func (a *RatePlanAPIService) GetRatePlan(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIGetRatePlanRequest {
	return RatePlanAPIGetRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanInfo
func (a *RatePlanAPIService) GetRatePlanExecute(r RatePlanAPIGetRatePlanRequest) (*RatePlanInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	summaryInfo *bool
	id *string
	ratePlanCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) Authorization(authorization string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) XAppKey(xAppKey string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) XHotelid(xHotelid string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) Limit(limit int32) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.limit = &limit
	return r
}

// When true response will return summary information otherwise detailed information.
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) SummaryInfo(summaryInfo bool) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.summaryInfo = &summaryInfo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) Id(id string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.id = &id
	return r
}

// Rate plan code.
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) RatePlanCode(ratePlanCode string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// External system code.
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) Execute() (*RatePlanScheduleYieldAdjustments, *http.Response, error) {
	return r.ApiService.GetRatePlanScheduleYieldAdjustmentsExecute(r)
}

/*
GetRatePlanScheduleYieldAdjustments Get rate plan schedule yield adjustments

This API allows you to fetch Rate Plan  schedules for yield adjustments. <p><strong>OperationId:</strong>getRatePlanScheduleYieldAdjustments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest
*/
func (a *RatePlanAPIService) GetRatePlanScheduleYieldAdjustments(ctx context.Context, hotelId string) RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest {
	return RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanScheduleYieldAdjustments
func (a *RatePlanAPIService) GetRatePlanScheduleYieldAdjustmentsExecute(r RatePlanAPIGetRatePlanScheduleYieldAdjustmentsRequest) (*RatePlanScheduleYieldAdjustments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanScheduleYieldAdjustments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRatePlanScheduleYieldAdjustments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlan/schedule/yieldAdjustment"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeRatePlanPackage *bool
	limit *int32
	tierId *int32
	ratePlanScheduleId *string
	ratePlanScheduleIdType *string
	startDate *string
	endDate *string
	duration *string
	roomType *[]string
	roomClass *[]string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRatePlanSchedulesRequest) Authorization(authorization string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Exclude the List of Pricing Schedule Packages from the response.
func (r RatePlanAPIGetRatePlanSchedulesRequest) ExcludeRatePlanPackage(excludeRatePlanPackage bool) RatePlanAPIGetRatePlanSchedulesRequest {
	r.excludeRatePlanPackage = &excludeRatePlanPackage
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetRatePlanSchedulesRequest) Limit(limit int32) RatePlanAPIGetRatePlanSchedulesRequest {
	r.limit = &limit
	return r
}

func (r RatePlanAPIGetRatePlanSchedulesRequest) TierId(tierId int32) RatePlanAPIGetRatePlanSchedulesRequest {
	r.tierId = &tierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIGetRatePlanSchedulesRequest) RatePlanScheduleId(ratePlanScheduleId string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.ratePlanScheduleId = &ratePlanScheduleId
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanAPIGetRatePlanSchedulesRequest) RatePlanScheduleIdType(ratePlanScheduleIdType string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.ratePlanScheduleIdType = &ratePlanScheduleIdType
	return r
}

func (r RatePlanAPIGetRatePlanSchedulesRequest) StartDate(startDate string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.startDate = &startDate
	return r
}

func (r RatePlanAPIGetRatePlanSchedulesRequest) EndDate(endDate string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.endDate = &endDate
	return r
}

func (r RatePlanAPIGetRatePlanSchedulesRequest) Duration(duration string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.duration = &duration
	return r
}

// Room Type.
func (r RatePlanAPIGetRatePlanSchedulesRequest) RoomType(roomType []string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.roomType = &roomType
	return r
}

// Room Class.
func (r RatePlanAPIGetRatePlanSchedulesRequest) RoomClass(roomClass []string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.roomClass = &roomClass
	return r
}

// Include inactive rate schedules in the fetch result.
func (r RatePlanAPIGetRatePlanSchedulesRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetRatePlanSchedulesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r RatePlanAPIGetRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRatePlanSchedulesRequest) Execute() (*RatePlanSchedulesInfo, *http.Response, error) {
	return r.ApiService.GetRatePlanSchedulesExecute(r)
}

/*
GetRatePlanSchedules Get rate plan schedules

Use this API to get a rate plan&apos;s pricing schedules. The information includes the date range and room types for which the price is valid, rate amounts for multiple persons, and associated packages.<p><strong>OperationId:</strong>getRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRatePlanSchedulesRequest
*/
func (a *RatePlanAPIService) GetRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIGetRatePlanSchedulesRequest {
	return RatePlanAPIGetRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanSchedulesInfo
func (a *RatePlanAPIService) GetRatePlanSchedulesExecute(r RatePlanAPIGetRatePlanSchedulesRequest) (*RatePlanSchedulesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanSchedulesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.excludeRatePlanPackage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRatePlanPackage", r.excludeRatePlanPackage, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.tierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tierId", r.tierId, "")
  }
	if r.ratePlanScheduleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleId", r.ratePlanScheduleId, "")
  }
	if r.ratePlanScheduleIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanScheduleIdType", r.ratePlanScheduleIdType, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
  }
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRatePlansRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeRateInformation *bool
	limit *int32
	offset *int32
	ratePlanCode *[]string
	rateCategory *[]string
	sellDate *string
	displaySet *string
	id *string
	idExtension *int32
	idContext *string
	type_ *string
	attributeName *[]string
	orderType *[]string
	includeInactive *bool
	dayUseOnly *bool
	approvalStatus *string
	xExternalsystem *string
	acceptLanguage *string
}

// Hotel code.
func (r RatePlanAPIGetRatePlansRequest) HotelId(hotelId []string) RatePlanAPIGetRatePlansRequest {
	r.hotelId = &hotelId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRatePlansRequest) Authorization(authorization string) RatePlanAPIGetRatePlansRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRatePlansRequest) XAppKey(xAppKey string) RatePlanAPIGetRatePlansRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRatePlansRequest) XHotelid(xHotelid string) RatePlanAPIGetRatePlansRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether rate plan short and long information should be included in the fetched results.
func (r RatePlanAPIGetRatePlansRequest) IncludeRateInformation(includeRateInformation bool) RatePlanAPIGetRatePlansRequest {
	r.includeRateInformation = &includeRateInformation
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetRatePlansRequest) Limit(limit int32) RatePlanAPIGetRatePlansRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetRatePlansRequest) Offset(offset int32) RatePlanAPIGetRatePlansRequest {
	r.offset = &offset
	return r
}

// Rate Plan code.
func (r RatePlanAPIGetRatePlansRequest) RatePlanCode(ratePlanCode []string) RatePlanAPIGetRatePlansRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Rate category of the rate plan.
func (r RatePlanAPIGetRatePlansRequest) RateCategory(rateCategory []string) RatePlanAPIGetRatePlansRequest {
	r.rateCategory = &rateCategory
	return r
}

// Sell date of the rate plan.
func (r RatePlanAPIGetRatePlansRequest) SellDate(sellDate string) RatePlanAPIGetRatePlansRequest {
	r.sellDate = &sellDate
	return r
}

// Display set for the rate plan.
func (r RatePlanAPIGetRatePlansRequest) DisplaySet(displaySet string) RatePlanAPIGetRatePlansRequest {
	r.displaySet = &displaySet
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIGetRatePlansRequest) Id(id string) RatePlanAPIGetRatePlansRequest {
	r.id = &id
	return r
}

// Additional identifying value assigned by the creating system.
func (r RatePlanAPIGetRatePlansRequest) IdExtension(idExtension int32) RatePlanAPIGetRatePlansRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r RatePlanAPIGetRatePlansRequest) IdContext(idContext string) RatePlanAPIGetRatePlansRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanAPIGetRatePlansRequest) Type_(type_ string) RatePlanAPIGetRatePlansRequest {
	r.type_ = &type_
	return r
}

func (r RatePlanAPIGetRatePlansRequest) AttributeName(attributeName []string) RatePlanAPIGetRatePlansRequest {
	r.attributeName = &attributeName
	return r
}

func (r RatePlanAPIGetRatePlansRequest) OrderType(orderType []string) RatePlanAPIGetRatePlansRequest {
	r.orderType = &orderType
	return r
}

// Include or not include inactive rate codes.
func (r RatePlanAPIGetRatePlansRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetRatePlansRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates to only fetch rate plans flagged as Day Use.
func (r RatePlanAPIGetRatePlansRequest) DayUseOnly(dayUseOnly bool) RatePlanAPIGetRatePlansRequest {
	r.dayUseOnly = &dayUseOnly
	return r
}

// Indicates that the Rate Plan is approved for selling.
func (r RatePlanAPIGetRatePlansRequest) ApprovalStatus(approvalStatus string) RatePlanAPIGetRatePlansRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// External system code.
func (r RatePlanAPIGetRatePlansRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRatePlansRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRatePlansRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRatePlansRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRatePlansRequest) Execute() (*RatePlansSummary, *http.Response, error) {
	return r.ApiService.GetRatePlansExecute(r)
}

/*
GetRatePlans Get rate plans

Use this API to get configured Rate Plans for a property and filter this by search criteria.<p><strong>OperationId:</strong>getRatePlans</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIGetRatePlansRequest
*/
func (a *RatePlanAPIService) GetRatePlans(ctx context.Context) RatePlanAPIGetRatePlansRequest {
	return RatePlanAPIGetRatePlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RatePlansSummary
func (a *RatePlanAPIService) GetRatePlansExecute(r RatePlanAPIGetRatePlansRequest) (*RatePlansSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlansSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRatePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ratePlans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
	}
	if r.includeRateInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRateInformation", r.includeRateInformation, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
  }
	if r.rateCategory != nil {
		t := *r.rateCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rateCategory", t, "multi")
		}
  }
	if r.sellDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellDate", r.sellDate, "")
  }
	if r.displaySet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "displaySet", r.displaySet, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", r.idExtension, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
  }
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.dayUseOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dayUseOnly", r.dayUseOnly, "")
  }
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRatePlansByHotelRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCode *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRatePlansByHotelRequest) Authorization(authorization string) RatePlanAPIGetRatePlansByHotelRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRatePlansByHotelRequest) XAppKey(xAppKey string) RatePlanAPIGetRatePlansByHotelRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRatePlansByHotelRequest) XHotelid(xHotelid string) RatePlanAPIGetRatePlansByHotelRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate plan code.
func (r RatePlanAPIGetRatePlansByHotelRequest) RatePlanCode(ratePlanCode string) RatePlanAPIGetRatePlansByHotelRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Simple type for Rate plan codes instructions that can be used in requests for partial operations.
func (r RatePlanAPIGetRatePlansByHotelRequest) FetchInstructions(fetchInstructions []string) RatePlanAPIGetRatePlansByHotelRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r RatePlanAPIGetRatePlansByHotelRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRatePlansByHotelRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRatePlansByHotelRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRatePlansByHotelRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRatePlansByHotelRequest) Execute() (*RatePlanInfo, *http.Response, error) {
	return r.ApiService.GetRatePlansByHotelExecute(r)
}

/*
GetRatePlansByHotel Get rate plans by Hotel Code

This API allows you to fetch Rate Plans for a given hotel id. <p><strong>OperationId:</strong>getRatePlansByHotel</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRatePlansByHotelRequest
*/
func (a *RatePlanAPIService) GetRatePlansByHotel(ctx context.Context, hotelId string) RatePlanAPIGetRatePlansByHotelRequest {
	return RatePlanAPIGetRatePlansByHotelRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RatePlanInfo
func (a *RatePlanAPIService) GetRatePlansByHotelExecute(r RatePlanAPIGetRatePlansByHotelRequest) (*RatePlanInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatePlanInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRatePlansByHotel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ratePlanCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", r.ratePlanCode, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRatePlansForBlockRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanCode *[]string
	beginDate *string
	endDate *string
	companyId *string
	companyIdType *string
	sourceId *string
	sourceIdType *string
	agentId *string
	agentIdType *string
	negotiatedOnly *bool
	currencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRatePlansForBlockRequest) Authorization(authorization string) RatePlanAPIGetRatePlansForBlockRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRatePlansForBlockRequest) XAppKey(xAppKey string) RatePlanAPIGetRatePlansForBlockRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRatePlansForBlockRequest) XHotelid(xHotelid string) RatePlanAPIGetRatePlansForBlockRequest {
	r.xHotelid = &xHotelid
	return r
}

// Rate Plan code.
func (r RatePlanAPIGetRatePlansForBlockRequest) RatePlanCode(ratePlanCode []string) RatePlanAPIGetRatePlansForBlockRequest {
	r.ratePlanCode = &ratePlanCode
	return r
}

// Start sell date of the rate code.
func (r RatePlanAPIGetRatePlansForBlockRequest) BeginDate(beginDate string) RatePlanAPIGetRatePlansForBlockRequest {
	r.beginDate = &beginDate
	return r
}

// End sell date of the rate code.
func (r RatePlanAPIGetRatePlansForBlockRequest) EndDate(endDate string) RatePlanAPIGetRatePlansForBlockRequest {
	r.endDate = &endDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIGetRatePlansForBlockRequest) CompanyId(companyId string) RatePlanAPIGetRatePlansForBlockRequest {
	r.companyId = &companyId
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanAPIGetRatePlansForBlockRequest) CompanyIdType(companyIdType string) RatePlanAPIGetRatePlansForBlockRequest {
	r.companyIdType = &companyIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIGetRatePlansForBlockRequest) SourceId(sourceId string) RatePlanAPIGetRatePlansForBlockRequest {
	r.sourceId = &sourceId
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanAPIGetRatePlansForBlockRequest) SourceIdType(sourceIdType string) RatePlanAPIGetRatePlansForBlockRequest {
	r.sourceIdType = &sourceIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r RatePlanAPIGetRatePlansForBlockRequest) AgentId(agentId string) RatePlanAPIGetRatePlansForBlockRequest {
	r.agentId = &agentId
	return r
}

// A reference to the type of object defined by the UniqueID element. Refer to OpenTravel Code List Unique ID Type (UIT).
func (r RatePlanAPIGetRatePlansForBlockRequest) AgentIdType(agentIdType string) RatePlanAPIGetRatePlansForBlockRequest {
	r.agentIdType = &agentIdType
	return r
}

// Flag to indicate if negotiated rate codes to be fetched.
func (r RatePlanAPIGetRatePlansForBlockRequest) NegotiatedOnly(negotiatedOnly bool) RatePlanAPIGetRatePlansForBlockRequest {
	r.negotiatedOnly = &negotiatedOnly
	return r
}

// Currency for the rate code to be fetched.
func (r RatePlanAPIGetRatePlansForBlockRequest) CurrencyCode(currencyCode string) RatePlanAPIGetRatePlansForBlockRequest {
	r.currencyCode = &currencyCode
	return r
}

// External system code.
func (r RatePlanAPIGetRatePlansForBlockRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRatePlansForBlockRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRatePlansForBlockRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRatePlansForBlockRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRatePlansForBlockRequest) Execute() (*BlockRatePlans, *http.Response, error) {
	return r.ApiService.GetRatePlansForBlockExecute(r)
}

/*
GetRatePlansForBlock Get rate plans for a given block

This API allows you to fetch Rate Plans on a specific block. <p><strong>OperationId:</strong>getRatePlansForBlock</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRatePlansForBlockRequest
*/
func (a *RatePlanAPIService) GetRatePlansForBlock(ctx context.Context, hotelId string) RatePlanAPIGetRatePlansForBlockRequest {
	return RatePlanAPIGetRatePlansForBlockRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return BlockRatePlans
func (a *RatePlanAPIService) GetRatePlansForBlockExecute(r RatePlanAPIGetRatePlansForBlockRequest) (*BlockRatePlans, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockRatePlans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRatePlansForBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.ratePlanCode != nil {
		t := *r.ratePlanCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratePlanCode", t, "multi")
		}
  }
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
  }
	if r.companyIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyIdType", r.companyIdType, "")
  }
	if r.sourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
  }
	if r.sourceIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIdType", r.sourceIdType, "")
  }
	if r.agentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "agentId", r.agentId, "")
  }
	if r.agentIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "agentIdType", r.agentIdType, "")
  }
	if r.negotiatedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "negotiatedOnly", r.negotiatedOnly, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetRateStrategiesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	restrictionDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetRateStrategiesRequest) Authorization(authorization string) RatePlanAPIGetRateStrategiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetRateStrategiesRequest) XAppKey(xAppKey string) RatePlanAPIGetRateStrategiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetRateStrategiesRequest) XHotelid(xHotelid string) RatePlanAPIGetRateStrategiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetRateStrategiesRequest) Limit(limit int32) RatePlanAPIGetRateStrategiesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetRateStrategiesRequest) Offset(offset int32) RatePlanAPIGetRateStrategiesRequest {
	r.offset = &offset
	return r
}

// search Rate Strategies with this restriction date.
func (r RatePlanAPIGetRateStrategiesRequest) RestrictionDate(restrictionDate string) RatePlanAPIGetRateStrategiesRequest {
	r.restrictionDate = &restrictionDate
	return r
}

// External system code.
func (r RatePlanAPIGetRateStrategiesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetRateStrategiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetRateStrategiesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetRateStrategiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetRateStrategiesRequest) Execute() (*RateStrategies, *http.Response, error) {
	return r.ApiService.GetRateStrategiesExecute(r)
}

/*
GetRateStrategies Get rate strategies

This API allows you to fetch rate strategies. <p><strong>OperationId:</strong>getRateStrategies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetRateStrategiesRequest
*/
func (a *RatePlanAPIService) GetRateStrategies(ctx context.Context, hotelId string) RatePlanAPIGetRateStrategiesRequest {
	return RatePlanAPIGetRateStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RateStrategies
func (a *RatePlanAPIService) GetRateStrategiesExecute(r RatePlanAPIGetRateStrategiesRequest) (*RateStrategies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RateStrategies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetRateStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateStrategies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.restrictionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restrictionDate", r.restrictionDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetTemplatePackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	includeInactive *bool
	authorization *string
	xAppKey *string
	xHotelid *string
	packageForecastGroupCode *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Inactive flag - whether or not to display inactive records
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.includeInactive = &includeInactive
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) PackageForecastGroupCode(packageForecastGroupCode []string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.packageForecastGroupCode = &packageForecastGroupCode
	return r
}

// Wildcard search on the code.
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) WildCard(wildCard string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetTemplatePackageForecastGroupsRequest) Execute() (*TemplatePackageForecastGroups, *http.Response, error) {
	return r.ApiService.GetTemplatePackageForecastGroupsExecute(r)
}

/*
GetTemplatePackageForecastGroups Get Template Package Forecast Groups

This API allows you to fetch Package Forecast groups template. <p><strong>OperationId:</strong>getTemplatePackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIGetTemplatePackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) GetTemplatePackageForecastGroups(ctx context.Context) RatePlanAPIGetTemplatePackageForecastGroupsRequest {
	return RatePlanAPIGetTemplatePackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplatePackageForecastGroups
func (a *RatePlanAPIService) GetTemplatePackageForecastGroupsExecute(r RatePlanAPIGetTemplatePackageForecastGroupsRequest) (*TemplatePackageForecastGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplatePackageForecastGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetTemplatePackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageForecastGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	if r.packageForecastGroupCode != nil {
		t := *r.packageForecastGroupCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "packageForecastGroupCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "packageForecastGroupCode", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetTemplatePromotionCodesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelId *[]string
	promotionCode *[]string
	promotionGroup *[]string
	rateCodes *string
	description *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetTemplatePromotionCodesRequest) Authorization(authorization string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetTemplatePromotionCodesRequest) XAppKey(xAppKey string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetTemplatePromotionCodesRequest) XHotelid(xHotelid string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) Limit(limit int32) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) Offset(offset int32) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.offset = &offset
	return r
}

// Hotel code.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) HotelId(hotelId []string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.hotelId = &hotelId
	return r
}

func (r RatePlanAPIGetTemplatePromotionCodesRequest) PromotionCode(promotionCode []string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.promotionCode = &promotionCode
	return r
}

func (r RatePlanAPIGetTemplatePromotionCodesRequest) PromotionGroup(promotionGroup []string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.promotionGroup = &promotionGroup
	return r
}

// Comma separated list of rates codes. This is used to filter the response and return only those promotion codes that are tied to any of these rate codes.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) RateCodes(rateCodes string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.rateCodes = &rateCodes
	return r
}

// Category Description of the promotion.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) Description(description string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.description = &description
	return r
}

// Indicates whether to include inactive promotions.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) IncludeInactive(includeInactive bool) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r RatePlanAPIGetTemplatePromotionCodesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetTemplatePromotionCodesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetTemplatePromotionCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetTemplatePromotionCodesRequest) Execute() (*TemplatePromotionCodes, *http.Response, error) {
	return r.ApiService.GetTemplatePromotionCodesExecute(r)
}

/*
GetTemplatePromotionCodes Get Template Promotion Codes

This API allows you to fetch Promotion Code template. <p><strong>OperationId:</strong>getTemplatePromotionCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIGetTemplatePromotionCodesRequest
*/
func (a *RatePlanAPIService) GetTemplatePromotionCodes(ctx context.Context) RatePlanAPIGetTemplatePromotionCodesRequest {
	return RatePlanAPIGetTemplatePromotionCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplatePromotionCodes
func (a *RatePlanAPIService) GetTemplatePromotionCodesExecute(r RatePlanAPIGetTemplatePromotionCodesRequest) (*TemplatePromotionCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplatePromotionCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetTemplatePromotionCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/promotionCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.promotionCode != nil {
		t := *r.promotionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionCode", t, "multi")
		}
  }
	if r.promotionGroup != nil {
		t := *r.promotionGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "promotionGroup", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "promotionGroup", t, "multi")
		}
  }
	if r.rateCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateCodes", r.rateCodes, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIGetYieldAdjustmentsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	currencyCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIGetYieldAdjustmentsRequest) Authorization(authorization string) RatePlanAPIGetYieldAdjustmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIGetYieldAdjustmentsRequest) XAppKey(xAppKey string) RatePlanAPIGetYieldAdjustmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIGetYieldAdjustmentsRequest) XHotelid(xHotelid string) RatePlanAPIGetYieldAdjustmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r RatePlanAPIGetYieldAdjustmentsRequest) Limit(limit int32) RatePlanAPIGetYieldAdjustmentsRequest {
	r.limit = &limit
	return r
}

// fetch adjustment codes attached to this Currency code.
func (r RatePlanAPIGetYieldAdjustmentsRequest) CurrencyCode(currencyCode string) RatePlanAPIGetYieldAdjustmentsRequest {
	r.currencyCode = &currencyCode
	return r
}

// External system code.
func (r RatePlanAPIGetYieldAdjustmentsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIGetYieldAdjustmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIGetYieldAdjustmentsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIGetYieldAdjustmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIGetYieldAdjustmentsRequest) Execute() (*YieldAdjustments, *http.Response, error) {
	return r.ApiService.GetYieldAdjustmentsExecute(r)
}

/*
GetYieldAdjustments Get yield adjustments

This API allows you to fetch yield adjustments. <p><strong>OperationId:</strong>getYieldAdjustments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIGetYieldAdjustmentsRequest
*/
func (a *RatePlanAPIService) GetYieldAdjustments(ctx context.Context, hotelId string) RatePlanAPIGetYieldAdjustmentsRequest {
	return RatePlanAPIGetYieldAdjustmentsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return YieldAdjustments
func (a *RatePlanAPIService) GetYieldAdjustmentsExecute(r RatePlanAPIGetYieldAdjustmentsRequest) (*YieldAdjustments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YieldAdjustments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.GetYieldAdjustments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/yieldAdjustments"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIManageRatePlansSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlansSchedulesToManage *RatePlansSchedulesToManage
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIManageRatePlansSchedulesRequest) Authorization(authorization string) RatePlanAPIManageRatePlansSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIManageRatePlansSchedulesRequest) XAppKey(xAppKey string) RatePlanAPIManageRatePlansSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIManageRatePlansSchedulesRequest) XHotelid(xHotelid string) RatePlanAPIManageRatePlansSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create/change/delete rate plans schedules.
func (r RatePlanAPIManageRatePlansSchedulesRequest) RatePlansSchedulesToManage(ratePlansSchedulesToManage RatePlansSchedulesToManage) RatePlanAPIManageRatePlansSchedulesRequest {
	r.ratePlansSchedulesToManage = &ratePlansSchedulesToManage
	return r
}

// External system code.
func (r RatePlanAPIManageRatePlansSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIManageRatePlansSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIManageRatePlansSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIManageRatePlansSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIManageRatePlansSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ManageRatePlansSchedulesExecute(r)
}

/*
ManageRatePlansSchedules Manages rate plan schedules

This API allows you to update Rate Plan schedules. <p><strong>OperationId:</strong>manageRatePlansSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIManageRatePlansSchedulesRequest
*/
func (a *RatePlanAPIService) ManageRatePlansSchedules(ctx context.Context) RatePlanAPIManageRatePlansSchedulesRequest {
	return RatePlanAPIManageRatePlansSchedulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) ManageRatePlansSchedulesExecute(r RatePlanAPIManageRatePlansSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.ManageRatePlansSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ratePlanSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlansSchedulesToManage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPingRatePlanServiceRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPingRatePlanServiceRequest) Authorization(authorization string) RatePlanAPIPingRatePlanServiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPingRatePlanServiceRequest) XAppKey(xAppKey string) RatePlanAPIPingRatePlanServiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPingRatePlanServiceRequest) XHotelid(xHotelid string) RatePlanAPIPingRatePlanServiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r RatePlanAPIPingRatePlanServiceRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPingRatePlanServiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPingRatePlanServiceRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPingRatePlanServiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPingRatePlanServiceRequest) Execute() (*OperaVersion, *http.Response, error) {
	return r.ApiService.PingRatePlanServiceExecute(r)
}

/*
PingRatePlanService Get Rate plan service version

This API allows you to fetch Rate Plan Service version. <p><strong>OperationId:</strong>pingRatePlanService</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIPingRatePlanServiceRequest
*/
func (a *RatePlanAPIService) PingRatePlanService(ctx context.Context) RatePlanAPIPingRatePlanServiceRequest {
	return RatePlanAPIPingRatePlanServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperaVersion
func (a *RatePlanAPIService) PingRatePlanServiceExecute(r RatePlanAPIPingRatePlanServiceRequest) (*OperaVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperaVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PingRatePlanService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/rateplan/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostBestAvailableRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	createBestAvailableRates *CreateBestAvailableRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostBestAvailableRatesRequest) Authorization(authorization string) RatePlanAPIPostBestAvailableRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostBestAvailableRatesRequest) XAppKey(xAppKey string) RatePlanAPIPostBestAvailableRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostBestAvailableRatesRequest) XHotelid(xHotelid string) RatePlanAPIPostBestAvailableRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create best available rates for rate code(s)
func (r RatePlanAPIPostBestAvailableRatesRequest) CreateBestAvailableRates(createBestAvailableRates CreateBestAvailableRates) RatePlanAPIPostBestAvailableRatesRequest {
	r.createBestAvailableRates = &createBestAvailableRates
	return r
}

// External system code.
func (r RatePlanAPIPostBestAvailableRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostBestAvailableRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostBestAvailableRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostBestAvailableRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostBestAvailableRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBestAvailableRatesExecute(r)
}

/*
PostBestAvailableRates Create a Best Available Rates

This API allows to create Best Available rates for rate code(s). <p><strong>OperationId:</strong>postBestAvailableRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostBestAvailableRatesRequest
*/
func (a *RatePlanAPIService) PostBestAvailableRates(ctx context.Context, hotelId string) RatePlanAPIPostBestAvailableRatesRequest {
	return RatePlanAPIPostBestAvailableRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostBestAvailableRatesExecute(r RatePlanAPIPostBestAvailableRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostBestAvailableRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/bestavailablerates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.createBestAvailableRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostHotelPackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelPackageForecastGroupsToCreate *HotelPackageForecastGroupsToCreate
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new package forecast groups for a hotel.
func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) HotelPackageForecastGroupsToCreate(hotelPackageForecastGroupsToCreate HotelPackageForecastGroupsToCreate) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	r.hotelPackageForecastGroupsToCreate = &hotelPackageForecastGroupsToCreate
	return r
}

// External system code.
func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostHotelPackageForecastGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHotelPackageForecastGroupsExecute(r)
}

/*
PostHotelPackageForecastGroups Create Hotel Package Forecast Groups

This API allows you to create package forecast groups. <p><strong>OperationId:</strong>postHotelPackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostHotelPackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) PostHotelPackageForecastGroups(ctx context.Context, hotelId string) RatePlanAPIPostHotelPackageForecastGroupsRequest {
	return RatePlanAPIPostHotelPackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostHotelPackageForecastGroupsExecute(r RatePlanAPIPostHotelPackageForecastGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostHotelPackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageForecastGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelPackageForecastGroupsToCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	negotiatedRates *NegotiatedRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostNegotiatedRatesRequest) Authorization(authorization string) RatePlanAPIPostNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanAPIPostNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanAPIPostNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating negotiated rates. Also this object creates new profile discounts for given negotiated rates.
func (r RatePlanAPIPostNegotiatedRatesRequest) NegotiatedRates(negotiatedRates NegotiatedRates) RatePlanAPIPostNegotiatedRatesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// External system code.
func (r RatePlanAPIPostNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostNegotiatedRatesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostNegotiatedRatesExecute(r)
}

/*
PostNegotiatedRates Create negotiated rates 

This API allows you to create negotiated rate for a given profile. <p><strong>OperationId:</strong>postNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostNegotiatedRatesRequest
*/
func (a *RatePlanAPIService) PostNegotiatedRates(ctx context.Context, hotelId string) RatePlanAPIPostNegotiatedRatesRequest {
	return RatePlanAPIPostNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostNegotiatedRatesExecute(r RatePlanAPIPostNegotiatedRatesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.negotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostPackageRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageInfo *PackageInfo
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostPackageRequest) Authorization(authorization string) RatePlanAPIPostPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostPackageRequest) XAppKey(xAppKey string) RatePlanAPIPostPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostPackageRequest) XHotelid(xHotelid string) RatePlanAPIPostPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create a package.
func (r RatePlanAPIPostPackageRequest) PackageInfo(packageInfo PackageInfo) RatePlanAPIPostPackageRequest {
	r.packageInfo = &packageInfo
	return r
}

// External system code.
func (r RatePlanAPIPostPackageRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostPackageRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostPackageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPackageExecute(r)
}

/*
PostPackage Create package

This API allows you to create a package. <p><strong>OperationId:</strong>postPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostPackageRequest
*/
func (a *RatePlanAPIService) PostPackage(ctx context.Context, packageCode string, hotelId string) RatePlanAPIPostPackageRequest {
	return RatePlanAPIPostPackageRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostPackageExecute(r RatePlanAPIPostPackageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostPackageFormulaRangesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageFormulaRanges *PackageFormulaRanges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostPackageFormulaRangesRequest) Authorization(authorization string) RatePlanAPIPostPackageFormulaRangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostPackageFormulaRangesRequest) XAppKey(xAppKey string) RatePlanAPIPostPackageFormulaRangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostPackageFormulaRangesRequest) XHotelid(xHotelid string) RatePlanAPIPostPackageFormulaRangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new package formula range
func (r RatePlanAPIPostPackageFormulaRangesRequest) PackageFormulaRanges(packageFormulaRanges PackageFormulaRanges) RatePlanAPIPostPackageFormulaRangesRequest {
	r.packageFormulaRanges = &packageFormulaRanges
	return r
}

// External system code.
func (r RatePlanAPIPostPackageFormulaRangesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostPackageFormulaRangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostPackageFormulaRangesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostPackageFormulaRangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostPackageFormulaRangesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPackageFormulaRangesExecute(r)
}

/*
PostPackageFormulaRanges Create package formula ranges

This API allows you to create package formula ranges. <p><strong>OperationId:</strong>postPackageFormulaRanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostPackageFormulaRangesRequest
*/
func (a *RatePlanAPIService) PostPackageFormulaRanges(ctx context.Context, hotelId string) RatePlanAPIPostPackageFormulaRangesRequest {
	return RatePlanAPIPostPackageFormulaRangesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostPackageFormulaRangesExecute(r RatePlanAPIPostPackageFormulaRangesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostPackageFormulaRanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageFormulaRanges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageFormulaRanges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostPackageGroupRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageGroup *PackageGroup
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostPackageGroupRequest) Authorization(authorization string) RatePlanAPIPostPackageGroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostPackageGroupRequest) XAppKey(xAppKey string) RatePlanAPIPostPackageGroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostPackageGroupRequest) XHotelid(xHotelid string) RatePlanAPIPostPackageGroupRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPostPackageGroupRequest) PackageGroup(packageGroup PackageGroup) RatePlanAPIPostPackageGroupRequest {
	r.packageGroup = &packageGroup
	return r
}

// External system code.
func (r RatePlanAPIPostPackageGroupRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostPackageGroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostPackageGroupRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostPackageGroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostPackageGroupRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPackageGroupExecute(r)
}

/*
PostPackageGroup Create package group

This API allows you to create package group. <p><strong>OperationId:</strong>postPackageGroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostPackageGroupRequest
*/
func (a *RatePlanAPIService) PostPackageGroup(ctx context.Context, hotelId string) RatePlanAPIPostPackageGroupRequest {
	return RatePlanAPIPostPackageGroupRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostPackageGroupExecute(r RatePlanAPIPostPackageGroupRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostPackageGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostPromotionCodeRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	promotionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyPromotionCode *PropertyPromotionCode
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostPromotionCodeRequest) Authorization(authorization string) RatePlanAPIPostPromotionCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostPromotionCodeRequest) XAppKey(xAppKey string) RatePlanAPIPostPromotionCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostPromotionCodeRequest) XHotelid(xHotelid string) RatePlanAPIPostPromotionCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPostPromotionCodeRequest) PropertyPromotionCode(propertyPromotionCode PropertyPromotionCode) RatePlanAPIPostPromotionCodeRequest {
	r.propertyPromotionCode = &propertyPromotionCode
	return r
}

// External system code.
func (r RatePlanAPIPostPromotionCodeRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostPromotionCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostPromotionCodeRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostPromotionCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostPromotionCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPromotionCodeExecute(r)
}

/*
PostPromotionCode Create promotion codes

This API allows you to create promotion codes. <p><strong>OperationId:</strong>postPromotionCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promotionCode Promotion Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostPromotionCodeRequest
*/
func (a *RatePlanAPIService) PostPromotionCode(ctx context.Context, promotionCode string, hotelId string) RatePlanAPIPostPromotionCodeRequest {
	return RatePlanAPIPostPromotionCodeRequest{
		ApiService: a,
		ctx: ctx,
		promotionCode: promotionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostPromotionCodeExecute(r RatePlanAPIPostPromotionCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostPromotionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionCodes/{promotionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"promotionCode"+"}", url.PathEscape(parameterValueToString(r.promotionCode, "promotionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.promotionCode) < 1 {
		return localVarReturnValue, nil, reportError("promotionCode must have at least 1 elements")
	}
	if strlen(r.promotionCode) > 2000 {
		return localVarReturnValue, nil, reportError("promotionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.propertyPromotionCode
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostPromotionGroupRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	groupCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	promotionGroup *PromotionGroup
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostPromotionGroupRequest) Authorization(authorization string) RatePlanAPIPostPromotionGroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostPromotionGroupRequest) XAppKey(xAppKey string) RatePlanAPIPostPromotionGroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostPromotionGroupRequest) XHotelid(xHotelid string) RatePlanAPIPostPromotionGroupRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPostPromotionGroupRequest) PromotionGroup(promotionGroup PromotionGroup) RatePlanAPIPostPromotionGroupRequest {
	r.promotionGroup = &promotionGroup
	return r
}

// External system code.
func (r RatePlanAPIPostPromotionGroupRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostPromotionGroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostPromotionGroupRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostPromotionGroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostPromotionGroupRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPromotionGroupExecute(r)
}

/*
PostPromotionGroup Create promotion groups

This API allows you to create promotion groups. <p><strong>OperationId:</strong>postPromotionGroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupCode Promotion Group Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostPromotionGroupRequest
*/
func (a *RatePlanAPIService) PostPromotionGroup(ctx context.Context, groupCode string, hotelId string) RatePlanAPIPostPromotionGroupRequest {
	return RatePlanAPIPostPromotionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupCode: groupCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostPromotionGroupExecute(r RatePlanAPIPostPromotionGroupRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostPromotionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionGroups/{groupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupCode"+"}", url.PathEscape(parameterValueToString(r.groupCode, "groupCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupCode) < 1 {
		return localVarReturnValue, nil, reportError("groupCode must have at least 1 elements")
	}
	if strlen(r.groupCode) > 2000 {
		return localVarReturnValue, nil, reportError("groupCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.promotionGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostRateGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateGroups *RateGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostRateGroupsRequest) Authorization(authorization string) RatePlanAPIPostRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostRateGroupsRequest) XAppKey(xAppKey string) RatePlanAPIPostRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostRateGroupsRequest) XHotelid(xHotelid string) RatePlanAPIPostRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPostRateGroupsRequest) RateGroups(rateGroups RateGroups) RatePlanAPIPostRateGroupsRequest {
	r.rateGroups = &rateGroups
	return r
}

// External system code.
func (r RatePlanAPIPostRateGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostRateGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostRateGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRateGroupsExecute(r)
}

/*
PostRateGroups Create rate groups

This API allows you to create rate groups. <p><strong>OperationId:</strong>postRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostRateGroupsRequest
*/
func (a *RatePlanAPIService) PostRateGroups(ctx context.Context, hotelId string) RatePlanAPIPostRateGroupsRequest {
	return RatePlanAPIPostRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostRateGroupsExecute(r RatePlanAPIPostRateGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlan *RatePlan
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostRatePlanRequest) Authorization(authorization string) RatePlanAPIPostRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostRatePlanRequest) XAppKey(xAppKey string) RatePlanAPIPostRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostRatePlanRequest) XHotelid(xHotelid string) RatePlanAPIPostRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create rate plan.
func (r RatePlanAPIPostRatePlanRequest) RatePlan(ratePlan RatePlan) RatePlanAPIPostRatePlanRequest {
	r.ratePlan = &ratePlan
	return r
}

// External system code.
func (r RatePlanAPIPostRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostRatePlanRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRatePlanExecute(r)
}

/*
PostRatePlan Create rate plans

Use this API you to get Rate Plans for a given hotel.<p><strong>OperationId:</strong>postRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostRatePlanRequest
*/
func (a *RatePlanAPIService) PostRatePlan(ctx context.Context, hotelId string) RatePlanAPIPostRatePlanRequest {
	return RatePlanAPIPostRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostRatePlanExecute(r RatePlanAPIPostRatePlanRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostRatePlanPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanPackages *RatePlanPackages
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostRatePlanPackagesRequest) Authorization(authorization string) RatePlanAPIPostRatePlanPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostRatePlanPackagesRequest) XAppKey(xAppKey string) RatePlanAPIPostRatePlanPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostRatePlanPackagesRequest) XHotelid(xHotelid string) RatePlanAPIPostRatePlanPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to attach package codes and package groups to a rate plan.
func (r RatePlanAPIPostRatePlanPackagesRequest) RatePlanPackages(ratePlanPackages RatePlanPackages) RatePlanAPIPostRatePlanPackagesRequest {
	r.ratePlanPackages = &ratePlanPackages
	return r
}

// External system code.
func (r RatePlanAPIPostRatePlanPackagesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostRatePlanPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostRatePlanPackagesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostRatePlanPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostRatePlanPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRatePlanPackagesExecute(r)
}

/*
PostRatePlanPackages Create rate plan package

This API allows you to create Rate Plan package. <p><strong>OperationId:</strong>postRatePlanPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostRatePlanPackagesRequest
*/
func (a *RatePlanAPIService) PostRatePlanPackages(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPostRatePlanPackagesRequest {
	return RatePlanAPIPostRatePlanPackagesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostRatePlanPackagesExecute(r RatePlanAPIPostRatePlanPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostRatePlanPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanPackages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostRatePlanPostingRhythmsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanPostingRhythms *RatePlanPostingRhythms
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) Authorization(authorization string) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) XAppKey(xAppKey string) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) XHotelid(xHotelid string) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new rate plan advanced posting rhythms.
func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) RatePlanPostingRhythms(ratePlanPostingRhythms RatePlanPostingRhythms) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	r.ratePlanPostingRhythms = &ratePlanPostingRhythms
	return r
}

// External system code.
func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostRatePlanPostingRhythmsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRatePlanPostingRhythmsExecute(r)
}

/*
PostRatePlanPostingRhythms Create rate plan posting rhythms

This API allows you to create Rate Plan posting rhythms. <p><strong>OperationId:</strong>postRatePlanPostingRhythms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostRatePlanPostingRhythmsRequest
*/
func (a *RatePlanAPIService) PostRatePlanPostingRhythms(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPostRatePlanPostingRhythmsRequest {
	return RatePlanAPIPostRatePlanPostingRhythmsRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostRatePlanPostingRhythmsExecute(r RatePlanAPIPostRatePlanPostingRhythmsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostRatePlanPostingRhythms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/postingRhythms"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanPostingRhythms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanSchedulesToCreate *RatePlanSchedulesToCreate
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostRatePlanSchedulesRequest) Authorization(authorization string) RatePlanAPIPostRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanAPIPostRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanAPIPostRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to create rate plan schedules.
func (r RatePlanAPIPostRatePlanSchedulesRequest) RatePlanSchedulesToCreate(ratePlanSchedulesToCreate RatePlanSchedulesToCreate) RatePlanAPIPostRatePlanSchedulesRequest {
	r.ratePlanSchedulesToCreate = &ratePlanSchedulesToCreate
	return r
}

// External system code.
func (r RatePlanAPIPostRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRatePlanSchedulesExecute(r)
}

/*
PostRatePlanSchedules Create rate plan schedules

This API allows you to create Rate Plan pricing schedule. <p><strong>OperationId:</strong>postRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostRatePlanSchedulesRequest
*/
func (a *RatePlanAPIService) PostRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPostRatePlanSchedulesRequest {
	return RatePlanAPIPostRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostRatePlanSchedulesExecute(r RatePlanAPIPostRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanSchedulesToCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostRateStrategyRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateStrategy *RateStrategy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostRateStrategyRequest) Authorization(authorization string) RatePlanAPIPostRateStrategyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostRateStrategyRequest) XAppKey(xAppKey string) RatePlanAPIPostRateStrategyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostRateStrategyRequest) XHotelid(xHotelid string) RatePlanAPIPostRateStrategyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Creating a new Rate Strategy.
func (r RatePlanAPIPostRateStrategyRequest) RateStrategy(rateStrategy RateStrategy) RatePlanAPIPostRateStrategyRequest {
	r.rateStrategy = &rateStrategy
	return r
}

// External system code.
func (r RatePlanAPIPostRateStrategyRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostRateStrategyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostRateStrategyRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostRateStrategyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostRateStrategyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRateStrategyExecute(r)
}

/*
PostRateStrategy Create rate strategies

This API allows you to create rate strategies. <p><strong>OperationId:</strong>postRateStrategy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPostRateStrategyRequest
*/
func (a *RatePlanAPIService) PostRateStrategy(ctx context.Context, hotelId string) RatePlanAPIPostRateStrategyRequest {
	return RatePlanAPIPostRateStrategyRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostRateStrategyExecute(r RatePlanAPIPostRateStrategyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostRateStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateStrategies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostTemplatePackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templatePackageForecastGroups *TemplatePackageForecastGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template package forecast groups.
func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) TemplatePackageForecastGroups(templatePackageForecastGroups TemplatePackageForecastGroups) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	r.templatePackageForecastGroups = &templatePackageForecastGroups
	return r
}

// External system code.
func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostTemplatePackageForecastGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplatePackageForecastGroupsExecute(r)
}

/*
PostTemplatePackageForecastGroups Create Template Package Forecast Groups

This API allows you to create Package Forecast groups template. <p><strong>OperationId:</strong>postTemplatePackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIPostTemplatePackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) PostTemplatePackageForecastGroups(ctx context.Context) RatePlanAPIPostTemplatePackageForecastGroupsRequest {
	return RatePlanAPIPostTemplatePackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostTemplatePackageForecastGroupsExecute(r RatePlanAPIPostTemplatePackageForecastGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostTemplatePackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageForecastGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templatePackageForecastGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPostTemplatePromotionCodeRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	promotionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	templatePromotionCode *TemplatePromotionCode
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPostTemplatePromotionCodeRequest) Authorization(authorization string) RatePlanAPIPostTemplatePromotionCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPostTemplatePromotionCodeRequest) XAppKey(xAppKey string) RatePlanAPIPostTemplatePromotionCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPostTemplatePromotionCodeRequest) XHotelid(xHotelid string) RatePlanAPIPostTemplatePromotionCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPostTemplatePromotionCodeRequest) TemplatePromotionCode(templatePromotionCode TemplatePromotionCode) RatePlanAPIPostTemplatePromotionCodeRequest {
	r.templatePromotionCode = &templatePromotionCode
	return r
}

// External system code.
func (r RatePlanAPIPostTemplatePromotionCodeRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPostTemplatePromotionCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPostTemplatePromotionCodeRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPostTemplatePromotionCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPostTemplatePromotionCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplatePromotionCodeExecute(r)
}

/*
PostTemplatePromotionCode Create Template Promotion Code

This API allows you to create Promotion Code template. <p><strong>OperationId:</strong>postTemplatePromotionCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promotionCode Promotion Code.
 @return RatePlanAPIPostTemplatePromotionCodeRequest
*/
func (a *RatePlanAPIService) PostTemplatePromotionCode(ctx context.Context, promotionCode string) RatePlanAPIPostTemplatePromotionCodeRequest {
	return RatePlanAPIPostTemplatePromotionCodeRequest{
		ApiService: a,
		ctx: ctx,
		promotionCode: promotionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PostTemplatePromotionCodeExecute(r RatePlanAPIPostTemplatePromotionCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PostTemplatePromotionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/promotionCodes/{promotionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"promotionCode"+"}", url.PathEscape(parameterValueToString(r.promotionCode, "promotionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.promotionCode) < 1 {
		return localVarReturnValue, nil, reportError("promotionCode must have at least 1 elements")
	}
	if strlen(r.promotionCode) > 2000 {
		return localVarReturnValue, nil, reportError("promotionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templatePromotionCode
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutHotelPackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelPackageForecastGroupsToChange *HotelPackageForecastGroupsToChange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying package forecast groups for a hotel.
func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) HotelPackageForecastGroupsToChange(hotelPackageForecastGroupsToChange HotelPackageForecastGroupsToChange) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	r.hotelPackageForecastGroupsToChange = &hotelPackageForecastGroupsToChange
	return r
}

// External system code.
func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutHotelPackageForecastGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutHotelPackageForecastGroupsExecute(r)
}

/*
PutHotelPackageForecastGroups Change Hotel Package Forecast Groups

This API allows you to update package forecast groups. <p><strong>OperationId:</strong>putHotelPackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutHotelPackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) PutHotelPackageForecastGroups(ctx context.Context, hotelId string) RatePlanAPIPutHotelPackageForecastGroupsRequest {
	return RatePlanAPIPutHotelPackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutHotelPackageForecastGroupsExecute(r RatePlanAPIPutHotelPackageForecastGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutHotelPackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageForecastGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.hotelPackageForecastGroupsToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutNegotiatedRatesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	rateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	negotiatedRates *NegotiatedRates
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutNegotiatedRatesRequest) Authorization(authorization string) RatePlanAPIPutNegotiatedRatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutNegotiatedRatesRequest) XAppKey(xAppKey string) RatePlanAPIPutNegotiatedRatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutNegotiatedRatesRequest) XHotelid(xHotelid string) RatePlanAPIPutNegotiatedRatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing negotiated rates. This object can be used to manage the negotiated rates and profile discounts. Profile discounts can be created/updated/deleted.
func (r RatePlanAPIPutNegotiatedRatesRequest) NegotiatedRates(negotiatedRates NegotiatedRates) RatePlanAPIPutNegotiatedRatesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// External system code.
func (r RatePlanAPIPutNegotiatedRatesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutNegotiatedRatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutNegotiatedRatesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutNegotiatedRatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutNegotiatedRatesRequest) Execute() (*NegotiatedRatesDetails, *http.Response, error) {
	return r.ApiService.PutNegotiatedRatesExecute(r)
}

/*
PutNegotiatedRates Change negotiated rates 

This API allows you to update negotiated rate for a given profile. <p><strong>OperationId:</strong>putNegotiatedRates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutNegotiatedRatesRequest
*/
func (a *RatePlanAPIService) PutNegotiatedRates(ctx context.Context, rateCode string, hotelId string) RatePlanAPIPutNegotiatedRatesRequest {
	return RatePlanAPIPutNegotiatedRatesRequest{
		ApiService: a,
		ctx: ctx,
		rateCode: rateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return NegotiatedRatesDetails
func (a *RatePlanAPIService) PutNegotiatedRatesExecute(r RatePlanAPIPutNegotiatedRatesRequest) (*NegotiatedRatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiatedRatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutNegotiatedRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/negotiatedRates/{rateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateCode"+"}", url.PathEscape(parameterValueToString(r.rateCode, "rateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateCode) < 1 {
		return localVarReturnValue, nil, reportError("rateCode must have at least 1 elements")
	}
	if strlen(r.rateCode) > 2000 {
		return localVarReturnValue, nil, reportError("rateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.negotiatedRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutPackageRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageInfo *PackageInfo
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutPackageRequest) Authorization(authorization string) RatePlanAPIPutPackageRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutPackageRequest) XAppKey(xAppKey string) RatePlanAPIPutPackageRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutPackageRequest) XHotelid(xHotelid string) RatePlanAPIPutPackageRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change a package details.
func (r RatePlanAPIPutPackageRequest) PackageInfo(packageInfo PackageInfo) RatePlanAPIPutPackageRequest {
	r.packageInfo = &packageInfo
	return r
}

// External system code.
func (r RatePlanAPIPutPackageRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutPackageRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutPackageRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutPackageRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutPackageRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPackageExecute(r)
}

/*
PutPackage Change the package

This API allows you to update a package. <p><strong>OperationId:</strong>putPackage</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageCode Package Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutPackageRequest
*/
func (a *RatePlanAPIService) PutPackage(ctx context.Context, packageCode string, hotelId string) RatePlanAPIPutPackageRequest {
	return RatePlanAPIPutPackageRequest{
		ApiService: a,
		ctx: ctx,
		packageCode: packageCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutPackageExecute(r RatePlanAPIPutPackageRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packages/{packageCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageCode"+"}", url.PathEscape(parameterValueToString(r.packageCode, "packageCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageCode) < 1 {
		return localVarReturnValue, nil, reportError("packageCode must have at least 1 elements")
	}
	if strlen(r.packageCode) > 2000 {
		return localVarReturnValue, nil, reportError("packageCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutPackageFormulaRangesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	packageFormulaRangeId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageFormulaRanges *PackageFormulaRanges
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutPackageFormulaRangesRequest) Authorization(authorization string) RatePlanAPIPutPackageFormulaRangesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutPackageFormulaRangesRequest) XAppKey(xAppKey string) RatePlanAPIPutPackageFormulaRangesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutPackageFormulaRangesRequest) XHotelid(xHotelid string) RatePlanAPIPutPackageFormulaRangesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change and existing package formula ranges. The Property, Amount From, Amount To, Tax Amount, Interval Amount are the details that can be changed on an existing pacakage formula range.
func (r RatePlanAPIPutPackageFormulaRangesRequest) PackageFormulaRanges(packageFormulaRanges PackageFormulaRanges) RatePlanAPIPutPackageFormulaRangesRequest {
	r.packageFormulaRanges = &packageFormulaRanges
	return r
}

// External system code.
func (r RatePlanAPIPutPackageFormulaRangesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutPackageFormulaRangesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutPackageFormulaRangesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutPackageFormulaRangesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutPackageFormulaRangesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPackageFormulaRangesExecute(r)
}

/*
PutPackageFormulaRanges Change package formula ranges

This API allows you to update package formula ranges. <p><strong>OperationId:</strong>putPackageFormulaRanges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageFormulaRangeId Package Formula Range Id.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutPackageFormulaRangesRequest
*/
func (a *RatePlanAPIService) PutPackageFormulaRanges(ctx context.Context, packageFormulaRangeId string, hotelId string) RatePlanAPIPutPackageFormulaRangesRequest {
	return RatePlanAPIPutPackageFormulaRangesRequest{
		ApiService: a,
		ctx: ctx,
		packageFormulaRangeId: packageFormulaRangeId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutPackageFormulaRangesExecute(r RatePlanAPIPutPackageFormulaRangesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutPackageFormulaRanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageFormulaRanges/{packageFormulaRangeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"packageFormulaRangeId"+"}", url.PathEscape(parameterValueToString(r.packageFormulaRangeId, "packageFormulaRangeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.packageFormulaRangeId) < 1 {
		return localVarReturnValue, nil, reportError("packageFormulaRangeId must have at least 1 elements")
	}
	if strlen(r.packageFormulaRangeId) > 2000 {
		return localVarReturnValue, nil, reportError("packageFormulaRangeId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageFormulaRanges
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutPackageGroupRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	packageGroup *PackageGroup
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutPackageGroupRequest) Authorization(authorization string) RatePlanAPIPutPackageGroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutPackageGroupRequest) XAppKey(xAppKey string) RatePlanAPIPutPackageGroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutPackageGroupRequest) XHotelid(xHotelid string) RatePlanAPIPutPackageGroupRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPutPackageGroupRequest) PackageGroup(packageGroup PackageGroup) RatePlanAPIPutPackageGroupRequest {
	r.packageGroup = &packageGroup
	return r
}

// External system code.
func (r RatePlanAPIPutPackageGroupRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutPackageGroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutPackageGroupRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutPackageGroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutPackageGroupRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPackageGroupExecute(r)
}

/*
PutPackageGroup Change package group

This API allows you to change package group. <p><strong>OperationId:</strong>putPackageGroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutPackageGroupRequest
*/
func (a *RatePlanAPIService) PutPackageGroup(ctx context.Context, hotelId string) RatePlanAPIPutPackageGroupRequest {
	return RatePlanAPIPutPackageGroupRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutPackageGroupExecute(r RatePlanAPIPutPackageGroupRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutPackageGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/packageGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.packageGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutPromotionCodeRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	promotionCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	propertyPromotionCode *PropertyPromotionCode
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutPromotionCodeRequest) Authorization(authorization string) RatePlanAPIPutPromotionCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutPromotionCodeRequest) XAppKey(xAppKey string) RatePlanAPIPutPromotionCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutPromotionCodeRequest) XHotelid(xHotelid string) RatePlanAPIPutPromotionCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPutPromotionCodeRequest) PropertyPromotionCode(propertyPromotionCode PropertyPromotionCode) RatePlanAPIPutPromotionCodeRequest {
	r.propertyPromotionCode = &propertyPromotionCode
	return r
}

// External system code.
func (r RatePlanAPIPutPromotionCodeRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutPromotionCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutPromotionCodeRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutPromotionCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutPromotionCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPromotionCodeExecute(r)
}

/*
PutPromotionCode Change promotion codes

This API allows you to update promotion codes. <p><strong>OperationId:</strong>putPromotionCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promotionCode Promotion Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutPromotionCodeRequest
*/
func (a *RatePlanAPIService) PutPromotionCode(ctx context.Context, promotionCode string, hotelId string) RatePlanAPIPutPromotionCodeRequest {
	return RatePlanAPIPutPromotionCodeRequest{
		ApiService: a,
		ctx: ctx,
		promotionCode: promotionCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutPromotionCodeExecute(r RatePlanAPIPutPromotionCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutPromotionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionCodes/{promotionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"promotionCode"+"}", url.PathEscape(parameterValueToString(r.promotionCode, "promotionCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.promotionCode) < 1 {
		return localVarReturnValue, nil, reportError("promotionCode must have at least 1 elements")
	}
	if strlen(r.promotionCode) > 2000 {
		return localVarReturnValue, nil, reportError("promotionCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.propertyPromotionCode
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutPromotionGroupRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	groupCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	promotionGroup *PromotionGroup
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutPromotionGroupRequest) Authorization(authorization string) RatePlanAPIPutPromotionGroupRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutPromotionGroupRequest) XAppKey(xAppKey string) RatePlanAPIPutPromotionGroupRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutPromotionGroupRequest) XHotelid(xHotelid string) RatePlanAPIPutPromotionGroupRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPutPromotionGroupRequest) PromotionGroup(promotionGroup PromotionGroup) RatePlanAPIPutPromotionGroupRequest {
	r.promotionGroup = &promotionGroup
	return r
}

// External system code.
func (r RatePlanAPIPutPromotionGroupRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutPromotionGroupRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutPromotionGroupRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutPromotionGroupRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutPromotionGroupRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutPromotionGroupExecute(r)
}

/*
PutPromotionGroup Change promotion groups

This API allows you to update promotion groups. <p><strong>OperationId:</strong>putPromotionGroup</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupCode Promotion Group Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutPromotionGroupRequest
*/
func (a *RatePlanAPIService) PutPromotionGroup(ctx context.Context, groupCode string, hotelId string) RatePlanAPIPutPromotionGroupRequest {
	return RatePlanAPIPutPromotionGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupCode: groupCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutPromotionGroupExecute(r RatePlanAPIPutPromotionGroupRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutPromotionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/promotionGroups/{groupCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupCode"+"}", url.PathEscape(parameterValueToString(r.groupCode, "groupCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.groupCode) < 1 {
		return localVarReturnValue, nil, reportError("groupCode must have at least 1 elements")
	}
	if strlen(r.groupCode) > 2000 {
		return localVarReturnValue, nil, reportError("groupCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.promotionGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutRateGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateGroups *RateGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutRateGroupsRequest) Authorization(authorization string) RatePlanAPIPutRateGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutRateGroupsRequest) XAppKey(xAppKey string) RatePlanAPIPutRateGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutRateGroupsRequest) XHotelid(xHotelid string) RatePlanAPIPutRateGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPutRateGroupsRequest) RateGroups(rateGroups RateGroups) RatePlanAPIPutRateGroupsRequest {
	r.rateGroups = &rateGroups
	return r
}

// External system code.
func (r RatePlanAPIPutRateGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutRateGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutRateGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutRateGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutRateGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRateGroupsExecute(r)
}

/*
PutRateGroups Change rate groups

This API allows you to update rate groups. <p><strong>OperationId:</strong>putRateGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutRateGroupsRequest
*/
func (a *RatePlanAPIService) PutRateGroups(ctx context.Context, hotelId string) RatePlanAPIPutRateGroupsRequest {
	return RatePlanAPIPutRateGroupsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutRateGroupsExecute(r RatePlanAPIPutRateGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutRateGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutRatePlanRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlan *RatePlan
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutRatePlanRequest) Authorization(authorization string) RatePlanAPIPutRatePlanRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutRatePlanRequest) XAppKey(xAppKey string) RatePlanAPIPutRatePlanRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutRatePlanRequest) XHotelid(xHotelid string) RatePlanAPIPutRatePlanRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change rate plan.
func (r RatePlanAPIPutRatePlanRequest) RatePlan(ratePlan RatePlan) RatePlanAPIPutRatePlanRequest {
	r.ratePlan = &ratePlan
	return r
}

// External system code.
func (r RatePlanAPIPutRatePlanRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutRatePlanRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutRatePlanRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutRatePlanRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutRatePlanRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRatePlanExecute(r)
}

/*
PutRatePlan Change rate plan

Use this API to update Rate Plan information such as date range, linked room types, and rate controls for a given hotel. Use the putRatePlanSchedules operation to add or update the rate plan pricing schedule.<p><strong>OperationId:</strong>putRatePlan</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutRatePlanRequest
*/
func (a *RatePlanAPIService) PutRatePlan(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPutRatePlanRequest {
	return RatePlanAPIPutRatePlanRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutRatePlanExecute(r RatePlanAPIPutRatePlanRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutRatePlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutRatePlanPackagesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanPackages *RatePlanPackages
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutRatePlanPackagesRequest) Authorization(authorization string) RatePlanAPIPutRatePlanPackagesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutRatePlanPackagesRequest) XAppKey(xAppKey string) RatePlanAPIPutRatePlanPackagesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutRatePlanPackagesRequest) XHotelid(xHotelid string) RatePlanAPIPutRatePlanPackagesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change package code and package group details when attached to a rate plan.
func (r RatePlanAPIPutRatePlanPackagesRequest) RatePlanPackages(ratePlanPackages RatePlanPackages) RatePlanAPIPutRatePlanPackagesRequest {
	r.ratePlanPackages = &ratePlanPackages
	return r
}

// External system code.
func (r RatePlanAPIPutRatePlanPackagesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutRatePlanPackagesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutRatePlanPackagesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutRatePlanPackagesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutRatePlanPackagesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRatePlanPackagesExecute(r)
}

/*
PutRatePlanPackages Change rate plan package

This API allows you to update Rate Plan package. <p><strong>OperationId:</strong>putRatePlanPackages</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutRatePlanPackagesRequest
*/
func (a *RatePlanAPIService) PutRatePlanPackages(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPutRatePlanPackagesRequest {
	return RatePlanAPIPutRatePlanPackagesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutRatePlanPackagesExecute(r RatePlanAPIPutRatePlanPackagesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutRatePlanPackages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanPackages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutRatePlanPostingRhythmsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanPostingRhythms *RatePlanPostingRhythms
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) Authorization(authorization string) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) XAppKey(xAppKey string) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) XHotelid(xHotelid string) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing rate plan advanced posting rhythms.
func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) RatePlanPostingRhythms(ratePlanPostingRhythms RatePlanPostingRhythms) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	r.ratePlanPostingRhythms = &ratePlanPostingRhythms
	return r
}

// External system code.
func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutRatePlanPostingRhythmsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRatePlanPostingRhythmsExecute(r)
}

/*
PutRatePlanPostingRhythms Change rate plan posting rhythms

This API allows you to update Rate Plan posting rhythms. <p><strong>OperationId:</strong>putRatePlanPostingRhythms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutRatePlanPostingRhythmsRequest
*/
func (a *RatePlanAPIService) PutRatePlanPostingRhythms(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPutRatePlanPostingRhythmsRequest {
	return RatePlanAPIPutRatePlanPostingRhythmsRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutRatePlanPostingRhythmsExecute(r RatePlanAPIPutRatePlanPostingRhythmsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutRatePlanPostingRhythms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/postingRhythms"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanPostingRhythms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanSchedules *RatePlanSchedules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutRatePlanSchedulesRequest) Authorization(authorization string) RatePlanAPIPutRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanAPIPutRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanAPIPutRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change rate plan schedules.
func (r RatePlanAPIPutRatePlanSchedulesRequest) RatePlanSchedules(ratePlanSchedules RatePlanSchedules) RatePlanAPIPutRatePlanSchedulesRequest {
	r.ratePlanSchedules = &ratePlanSchedules
	return r
}

// External system code.
func (r RatePlanAPIPutRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRatePlanSchedulesExecute(r)
}

/*
PutRatePlanSchedules Change rate plan schedules

Use this API to  update Rate Plan pricing schedules.<p><strong>OperationId:</strong>putRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutRatePlanSchedulesRequest
*/
func (a *RatePlanAPIService) PutRatePlanSchedules(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPIPutRatePlanSchedulesRequest {
	return RatePlanAPIPutRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutRatePlanSchedulesExecute(r RatePlanAPIPutRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanSchedules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutRateStrategyRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	rateStrategyId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateStrategy *RateStrategy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutRateStrategyRequest) Authorization(authorization string) RatePlanAPIPutRateStrategyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutRateStrategyRequest) XAppKey(xAppKey string) RatePlanAPIPutRateStrategyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutRateStrategyRequest) XHotelid(xHotelid string) RatePlanAPIPutRateStrategyRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Modifying Rate Strategy.
func (r RatePlanAPIPutRateStrategyRequest) RateStrategy(rateStrategy RateStrategy) RatePlanAPIPutRateStrategyRequest {
	r.rateStrategy = &rateStrategy
	return r
}

// External system code.
func (r RatePlanAPIPutRateStrategyRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutRateStrategyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutRateStrategyRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutRateStrategyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutRateStrategyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRateStrategyExecute(r)
}

/*
PutRateStrategy Change rate strategies

This API allows you to update rate strategies. <p><strong>OperationId:</strong>putRateStrategy</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rateStrategyId Strategy Id
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPIPutRateStrategyRequest
*/
func (a *RatePlanAPIService) PutRateStrategy(ctx context.Context, rateStrategyId string, hotelId string) RatePlanAPIPutRateStrategyRequest {
	return RatePlanAPIPutRateStrategyRequest{
		ApiService: a,
		ctx: ctx,
		rateStrategyId: rateStrategyId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutRateStrategyExecute(r RatePlanAPIPutRateStrategyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutRateStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateStrategies/{rateStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"rateStrategyId"+"}", url.PathEscape(parameterValueToString(r.rateStrategyId, "rateStrategyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.rateStrategyId) < 1 {
		return localVarReturnValue, nil, reportError("rateStrategyId must have at least 1 elements")
	}
	if strlen(r.rateStrategyId) > 2000 {
		return localVarReturnValue, nil, reportError("rateStrategyId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutTemplatePackageForecastGroupsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templatePackageForecastGroups *TemplatePackageForecastGroups
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) Authorization(authorization string) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) XAppKey(xAppKey string) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) XHotelid(xHotelid string) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying template package forecast groups.
func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) TemplatePackageForecastGroups(templatePackageForecastGroups TemplatePackageForecastGroups) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	r.templatePackageForecastGroups = &templatePackageForecastGroups
	return r
}

// External system code.
func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutTemplatePackageForecastGroupsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplatePackageForecastGroupsExecute(r)
}

/*
PutTemplatePackageForecastGroups Change Template Package Forecast Groups

This API allows you to update Package Forecast groups template. <p><strong>OperationId:</strong>putTemplatePackageForecastGroups</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPIPutTemplatePackageForecastGroupsRequest
*/
func (a *RatePlanAPIService) PutTemplatePackageForecastGroups(ctx context.Context) RatePlanAPIPutTemplatePackageForecastGroupsRequest {
	return RatePlanAPIPutTemplatePackageForecastGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutTemplatePackageForecastGroupsExecute(r RatePlanAPIPutTemplatePackageForecastGroupsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutTemplatePackageForecastGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packageForecastGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templatePackageForecastGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPIPutTemplatePromotionCodeRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	promotionCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	templatePromotionCode *TemplatePromotionCode
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPIPutTemplatePromotionCodeRequest) Authorization(authorization string) RatePlanAPIPutTemplatePromotionCodeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPIPutTemplatePromotionCodeRequest) XAppKey(xAppKey string) RatePlanAPIPutTemplatePromotionCodeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPIPutTemplatePromotionCodeRequest) XHotelid(xHotelid string) RatePlanAPIPutTemplatePromotionCodeRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPIPutTemplatePromotionCodeRequest) TemplatePromotionCode(templatePromotionCode TemplatePromotionCode) RatePlanAPIPutTemplatePromotionCodeRequest {
	r.templatePromotionCode = &templatePromotionCode
	return r
}

// External system code.
func (r RatePlanAPIPutTemplatePromotionCodeRequest) XExternalsystem(xExternalsystem string) RatePlanAPIPutTemplatePromotionCodeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPIPutTemplatePromotionCodeRequest) AcceptLanguage(acceptLanguage string) RatePlanAPIPutTemplatePromotionCodeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPIPutTemplatePromotionCodeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutTemplatePromotionCodeExecute(r)
}

/*
PutTemplatePromotionCode Change Template Promotion Code

This API allows you to update Promotion Code template. <p><strong>OperationId:</strong>putTemplatePromotionCode</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promotionCode Promotion Code.
 @return RatePlanAPIPutTemplatePromotionCodeRequest
*/
func (a *RatePlanAPIService) PutTemplatePromotionCode(ctx context.Context, promotionCode string) RatePlanAPIPutTemplatePromotionCodeRequest {
	return RatePlanAPIPutTemplatePromotionCodeRequest{
		ApiService: a,
		ctx: ctx,
		promotionCode: promotionCode,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) PutTemplatePromotionCodeExecute(r RatePlanAPIPutTemplatePromotionCodeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.PutTemplatePromotionCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/promotionCodes/{promotionCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"promotionCode"+"}", url.PathEscape(parameterValueToString(r.promotionCode, "promotionCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.promotionCode) < 1 {
		return localVarReturnValue, nil, reportError("promotionCode must have at least 1 elements")
	}
	if strlen(r.promotionCode) > 2000 {
		return localVarReturnValue, nil, reportError("promotionCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templatePromotionCode
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPISetDailyRatePlanScheduleRangeRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	ratePlanCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	dailyRatePlanScheduleRange *DailyRatePlanScheduleRange
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) Authorization(authorization string) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) XAppKey(xAppKey string) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) XHotelid(xHotelid string) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	r.xHotelid = &xHotelid
	return r
}

// A Request message that sets the rate plan schedules for daily rates as a range.
func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) DailyRatePlanScheduleRange(dailyRatePlanScheduleRange DailyRatePlanScheduleRange) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	r.dailyRatePlanScheduleRange = &dailyRatePlanScheduleRange
	return r
}

// External system code.
func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) XExternalsystem(xExternalsystem string) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) AcceptLanguage(acceptLanguage string) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPISetDailyRatePlanScheduleRangeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetDailyRatePlanScheduleRangeExecute(r)
}

/*
SetDailyRatePlanScheduleRange Set daily rate plan schedule range

This API allows you to set Rate Plan schedule range. <p><strong>OperationId:</strong>setDailyRatePlanScheduleRange</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ratePlanCode Rate Plan Code.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPISetDailyRatePlanScheduleRangeRequest
*/
func (a *RatePlanAPIService) SetDailyRatePlanScheduleRange(ctx context.Context, ratePlanCode string, hotelId string) RatePlanAPISetDailyRatePlanScheduleRangeRequest {
	return RatePlanAPISetDailyRatePlanScheduleRangeRequest{
		ApiService: a,
		ctx: ctx,
		ratePlanCode: ratePlanCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) SetDailyRatePlanScheduleRangeExecute(r RatePlanAPISetDailyRatePlanScheduleRangeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.SetDailyRatePlanScheduleRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlans/{ratePlanCode}/dailySchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"ratePlanCode"+"}", url.PathEscape(parameterValueToString(r.ratePlanCode, "ratePlanCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.ratePlanCode) < 1 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have at least 1 elements")
	}
	if strlen(r.ratePlanCode) > 2000 {
		return localVarReturnValue, nil, reportError("ratePlanCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.dailyRatePlanScheduleRange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPISetMassRatePlanSchedulesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	massRatePlanSchedules *MassRatePlanSchedules
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPISetMassRatePlanSchedulesRequest) Authorization(authorization string) RatePlanAPISetMassRatePlanSchedulesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPISetMassRatePlanSchedulesRequest) XAppKey(xAppKey string) RatePlanAPISetMassRatePlanSchedulesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPISetMassRatePlanSchedulesRequest) XHotelid(xHotelid string) RatePlanAPISetMassRatePlanSchedulesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A Request message to update the rate codes schedule.
func (r RatePlanAPISetMassRatePlanSchedulesRequest) MassRatePlanSchedules(massRatePlanSchedules MassRatePlanSchedules) RatePlanAPISetMassRatePlanSchedulesRequest {
	r.massRatePlanSchedules = &massRatePlanSchedules
	return r
}

// External system code.
func (r RatePlanAPISetMassRatePlanSchedulesRequest) XExternalsystem(xExternalsystem string) RatePlanAPISetMassRatePlanSchedulesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPISetMassRatePlanSchedulesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPISetMassRatePlanSchedulesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPISetMassRatePlanSchedulesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetMassRatePlanSchedulesExecute(r)
}

/*
SetMassRatePlanSchedules Set mass rate plan schedules

This API allows you to update mass Rate Plan schedules. <p><strong>OperationId:</strong>setMassRatePlanSchedules</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPISetMassRatePlanSchedulesRequest
*/
func (a *RatePlanAPIService) SetMassRatePlanSchedules(ctx context.Context, hotelId string) RatePlanAPISetMassRatePlanSchedulesRequest {
	return RatePlanAPISetMassRatePlanSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) SetMassRatePlanSchedulesExecute(r RatePlanAPISetMassRatePlanSchedulesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.SetMassRatePlanSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/massRatePlanSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.massRatePlanSchedules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPISetRateAccessExclusionsRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	rateAccessExclusions *RateAccessExclusions
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPISetRateAccessExclusionsRequest) Authorization(authorization string) RatePlanAPISetRateAccessExclusionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPISetRateAccessExclusionsRequest) XAppKey(xAppKey string) RatePlanAPISetRateAccessExclusionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPISetRateAccessExclusionsRequest) XHotelid(xHotelid string) RatePlanAPISetRateAccessExclusionsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r RatePlanAPISetRateAccessExclusionsRequest) RateAccessExclusions(rateAccessExclusions RateAccessExclusions) RatePlanAPISetRateAccessExclusionsRequest {
	r.rateAccessExclusions = &rateAccessExclusions
	return r
}

// External system code.
func (r RatePlanAPISetRateAccessExclusionsRequest) XExternalsystem(xExternalsystem string) RatePlanAPISetRateAccessExclusionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPISetRateAccessExclusionsRequest) AcceptLanguage(acceptLanguage string) RatePlanAPISetRateAccessExclusionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPISetRateAccessExclusionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetRateAccessExclusionsExecute(r)
}

/*
SetRateAccessExclusions Set rate access exclusions

This API allows you to set rate access exclusions. <p><strong>OperationId:</strong>setRateAccessExclusions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPISetRateAccessExclusionsRequest
*/
func (a *RatePlanAPIService) SetRateAccessExclusions(ctx context.Context, hotelId string) RatePlanAPISetRateAccessExclusionsRequest {
	return RatePlanAPISetRateAccessExclusionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) SetRateAccessExclusionsExecute(r RatePlanAPISetRateAccessExclusionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.SetRateAccessExclusions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rateAccessExclusions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateAccessExclusions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPISetRateStrategiesRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	rateStrategiesToSet *RateStrategiesToSet
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPISetRateStrategiesRequest) Authorization(authorization string) RatePlanAPISetRateStrategiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPISetRateStrategiesRequest) XAppKey(xAppKey string) RatePlanAPISetRateStrategiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPISetRateStrategiesRequest) XHotelid(xHotelid string) RatePlanAPISetRateStrategiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for setting rate strategies. This operation will change details of rate strategy if rate strategy with the given Hotel Code, Restriction Dates, Rate Code, Rate Category, Room Type, Condition Type and Restriction Type already exists. Otherwise, it will create new rate strategy.
func (r RatePlanAPISetRateStrategiesRequest) RateStrategiesToSet(rateStrategiesToSet RateStrategiesToSet) RatePlanAPISetRateStrategiesRequest {
	r.rateStrategiesToSet = &rateStrategiesToSet
	return r
}

// External system code.
func (r RatePlanAPISetRateStrategiesRequest) XExternalsystem(xExternalsystem string) RatePlanAPISetRateStrategiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPISetRateStrategiesRequest) AcceptLanguage(acceptLanguage string) RatePlanAPISetRateStrategiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPISetRateStrategiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetRateStrategiesExecute(r)
}

/*
SetRateStrategies Set rate strategies

This API allows you to set Rate strategies. <p><strong>OperationId:</strong>setRateStrategies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RatePlanAPISetRateStrategiesRequest
*/
func (a *RatePlanAPIService) SetRateStrategies(ctx context.Context) RatePlanAPISetRateStrategiesRequest {
	return RatePlanAPISetRateStrategiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) SetRateStrategiesExecute(r RatePlanAPISetRateStrategiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.SetRateStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rateStrategies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.rateStrategiesToSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RatePlanAPISplitRatePlanScheduleRequest struct {
	ctx context.Context
	ApiService *RatePlanAPIService
	scheduleId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	ratePlanScheduleToSplit *RatePlanScheduleToSplit
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r RatePlanAPISplitRatePlanScheduleRequest) Authorization(authorization string) RatePlanAPISplitRatePlanScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r RatePlanAPISplitRatePlanScheduleRequest) XAppKey(xAppKey string) RatePlanAPISplitRatePlanScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r RatePlanAPISplitRatePlanScheduleRequest) XHotelid(xHotelid string) RatePlanAPISplitRatePlanScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to split rate plan schedule.
func (r RatePlanAPISplitRatePlanScheduleRequest) RatePlanScheduleToSplit(ratePlanScheduleToSplit RatePlanScheduleToSplit) RatePlanAPISplitRatePlanScheduleRequest {
	r.ratePlanScheduleToSplit = &ratePlanScheduleToSplit
	return r
}

// External system code.
func (r RatePlanAPISplitRatePlanScheduleRequest) XExternalsystem(xExternalsystem string) RatePlanAPISplitRatePlanScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r RatePlanAPISplitRatePlanScheduleRequest) AcceptLanguage(acceptLanguage string) RatePlanAPISplitRatePlanScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r RatePlanAPISplitRatePlanScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SplitRatePlanScheduleExecute(r)
}

/*
SplitRatePlanSchedule Split rate plan schedule

This API allows you to split Rate Plan schedule. <p><strong>OperationId:</strong>splitRatePlanSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param scheduleId Schedule Id.
 @param hotelId Unique ID that identifies a single hotel property.
 @return RatePlanAPISplitRatePlanScheduleRequest
*/
func (a *RatePlanAPIService) SplitRatePlanSchedule(ctx context.Context, scheduleId string, hotelId string) RatePlanAPISplitRatePlanScheduleRequest {
	return RatePlanAPISplitRatePlanScheduleRequest{
		ApiService: a,
		ctx: ctx,
		scheduleId: scheduleId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *RatePlanAPIService) SplitRatePlanScheduleExecute(r RatePlanAPISplitRatePlanScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatePlanAPIService.SplitRatePlanSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/ratePlanSchedules/{scheduleId}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.scheduleId) < 1 {
		return localVarReturnValue, nil, reportError("scheduleId must have at least 1 elements")
	}
	if strlen(r.scheduleId) > 2000 {
		return localVarReturnValue, nil, reportError("scheduleId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.ratePlanScheduleToSplit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
