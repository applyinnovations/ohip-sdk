/*
OPERA Cloud Activity API

APIs to cater for Sales Activity functionality in OPERA Cloud. <br /><br /> Activities provide you with an account management tool for managing daily tasks such as appointments, sales calls, contact follow-up, and so on.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package act

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ActivityApiService ActivityApi service
type ActivityApiService service

type ActivityApiDeleteActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activityIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteActivitiesRequest) Authorization(authorization string) ActivityApiDeleteActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiDeleteActivitiesRequest) XAppKey(xAppKey string) ActivityApiDeleteActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteActivitiesRequest) XHotelid(xHotelid string) ActivityApiDeleteActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiDeleteActivitiesRequest) ActivityIds(activityIds []string) ActivityApiDeleteActivitiesRequest {
	r.activityIds = &activityIds
	return r
}

// External system code.
func (r ActivityApiDeleteActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteActivitiesExecute(r)
}

/*
DeleteActivities Delete activity in a hotel by ID

Use this API to mark an Activity as deleted.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>deleteActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiDeleteActivitiesRequest
*/
func (a *ActivityApiService) DeleteActivities(ctx context.Context, activityId string, hotelId string) ActivityApiDeleteActivitiesRequest {
	return ActivityApiDeleteActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteActivitiesExecute(r ActivityApiDeleteActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.activityIds != nil {
		t := *r.activityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiDeleteMultipleActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	activityIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiDeleteMultipleActivitiesRequest) Authorization(authorization string) ActivityApiDeleteMultipleActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiDeleteMultipleActivitiesRequest) XAppKey(xAppKey string) ActivityApiDeleteMultipleActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiDeleteMultipleActivitiesRequest) XHotelid(xHotelid string) ActivityApiDeleteMultipleActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiDeleteMultipleActivitiesRequest) ActivityIds(activityIds []string) ActivityApiDeleteMultipleActivitiesRequest {
	r.activityIds = &activityIds
	return r
}

// External system code.
func (r ActivityApiDeleteMultipleActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiDeleteMultipleActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiDeleteMultipleActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiDeleteMultipleActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiDeleteMultipleActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMultipleActivitiesExecute(r)
}

/*
DeleteMultipleActivities Delete activities

If you want to delete an activity, use this API.  You must know the activity ID for the request. <p><strong>OperationId:</strong>deleteMultipleActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiDeleteMultipleActivitiesRequest
*/
func (a *ActivityApiService) DeleteMultipleActivities(ctx context.Context) ActivityApiDeleteMultipleActivitiesRequest {
	return ActivityApiDeleteMultipleActivitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) DeleteMultipleActivitiesExecute(r ActivityApiDeleteMultipleActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteMultipleActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activityIds != nil {
		t := *r.activityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completed *bool
	highPriority *bool
	limit *int32
	offset *int32
	text *string
	hotelIds *[]string
	startDate *string
	endDate *string
	ownerCode *[]string
	activityClass *string
	activityType *[]string
	activityPurpose *string
	accountId *string
	contactId *string
	blockId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivitiesRequest) Authorization(authorization string) ActivityApiGetActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiGetActivitiesRequest) XAppKey(xAppKey string) ActivityApiGetActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivitiesRequest) XHotelid(xHotelid string) ActivityApiGetActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether the Activity is completed or not.
func (r ActivityApiGetActivitiesRequest) Completed(completed bool) ActivityApiGetActivitiesRequest {
	r.completed = &completed
	return r
}

// Indicates whether the Activity has high priority.
func (r ActivityApiGetActivitiesRequest) HighPriority(highPriority bool) ActivityApiGetActivitiesRequest {
	r.highPriority = &highPriority
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityApiGetActivitiesRequest) Limit(limit int32) ActivityApiGetActivitiesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityApiGetActivitiesRequest) Offset(offset int32) ActivityApiGetActivitiesRequest {
	r.offset = &offset
	return r
}

// Search string to be used for super search.
func (r ActivityApiGetActivitiesRequest) Text(text string) ActivityApiGetActivitiesRequest {
	r.text = &text
	return r
}

func (r ActivityApiGetActivitiesRequest) HotelIds(hotelIds []string) ActivityApiGetActivitiesRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ActivityApiGetActivitiesRequest) StartDate(startDate string) ActivityApiGetActivitiesRequest {
	r.startDate = &startDate
	return r
}

func (r ActivityApiGetActivitiesRequest) EndDate(endDate string) ActivityApiGetActivitiesRequest {
	r.endDate = &endDate
	return r
}

func (r ActivityApiGetActivitiesRequest) OwnerCode(ownerCode []string) ActivityApiGetActivitiesRequest {
	r.ownerCode = &ownerCode
	return r
}

// A collection of supported list of activity classes.
func (r ActivityApiGetActivitiesRequest) ActivityClass(activityClass string) ActivityApiGetActivitiesRequest {
	r.activityClass = &activityClass
	return r
}

func (r ActivityApiGetActivitiesRequest) ActivityType(activityType []string) ActivityApiGetActivitiesRequest {
	r.activityType = &activityType
	return r
}

// Purpose of the Activity.
func (r ActivityApiGetActivitiesRequest) ActivityPurpose(activityPurpose string) ActivityApiGetActivitiesRequest {
	r.activityPurpose = &activityPurpose
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesRequest) AccountId(accountId string) ActivityApiGetActivitiesRequest {
	r.accountId = &accountId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesRequest) ContactId(contactId string) ActivityApiGetActivitiesRequest {
	r.contactId = &contactId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesRequest) BlockId(blockId string) ActivityApiGetActivitiesRequest {
	r.blockId = &blockId
	return r
}

// External system code.
func (r ActivityApiGetActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivitiesRequest) Execute() (*ActivitiesInfo, *http.Response, error) {
	return r.ApiService.GetActivitiesExecute(r)
}

/*
GetActivities Get activities by hotel

You can use this API to retrieve multiple Activities for a hotel, you can narrow the results using different search criteria  <p><strong>OperationId:</strong>getActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId This is the Hotel Code of the Activity
 @return ActivityApiGetActivitiesRequest
*/
func (a *ActivityApiService) GetActivities(ctx context.Context, hotelId string) ActivityApiGetActivitiesRequest {
	return ActivityApiGetActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ActivitiesInfo
func (a *ActivityApiService) GetActivitiesExecute(r ActivityApiGetActivitiesRequest) (*ActivitiesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivitiesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.completed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed", r.completed, "")
	}
	if r.highPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highPriority", r.highPriority, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ownerCode != nil {
		t := *r.ownerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", t, "multi")
		}
	}
	if r.activityClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityClass", r.activityClass, "")
	}
	if r.activityType != nil {
		t := *r.activityType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", t, "multi")
		}
	}
	if r.activityPurpose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityPurpose", r.activityPurpose, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	if r.contactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivitiesByMultipleHotelIdsRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	completed *bool
	highPriority *bool
	limit *int32
	offset *int32
	text *string
	hotelIds *[]string
	startDate *string
	endDate *string
	ownerCode *[]string
	activityClass *string
	activityType *[]string
	activityPurpose *string
	accountId *string
	contactId *string
	blockId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Authorization(authorization string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) XAppKey(xAppKey string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) XHotelid(xHotelid string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether the Activity is completed or not.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Completed(completed bool) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.completed = &completed
	return r
}

// Indicates whether the Activity has high priority.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) HighPriority(highPriority bool) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.highPriority = &highPriority
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Limit(limit int32) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Offset(offset int32) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.offset = &offset
	return r
}

// Search string to be used for super search.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Text(text string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.text = &text
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) HotelIds(hotelIds []string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.hotelIds = &hotelIds
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) StartDate(startDate string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.startDate = &startDate
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) EndDate(endDate string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.endDate = &endDate
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) OwnerCode(ownerCode []string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.ownerCode = &ownerCode
	return r
}

// A collection of supported list of activity classes.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ActivityClass(activityClass string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.activityClass = &activityClass
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ActivityType(activityType []string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.activityType = &activityType
	return r
}

// Purpose of the Activity.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ActivityPurpose(activityPurpose string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.activityPurpose = &activityPurpose
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) AccountId(accountId string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.accountId = &accountId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) ContactId(contactId string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.contactId = &contactId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) BlockId(blockId string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.blockId = &blockId
	return r
}

// External system code.
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivitiesByMultipleHotelIdsRequest) Execute() (*ActivitiesInfo, *http.Response, error) {
	return r.ApiService.GetActivitiesByMultipleHotelIdsExecute(r)
}

/*
GetActivitiesByMultipleHotelIds Get activities

Use this API to retrieve activities for multiple hotels.  Results can be narrowed down by your search criteria in the request message. <p><strong>OperationId:</strong>getActivitiesByMultipleHotelIds</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiGetActivitiesByMultipleHotelIdsRequest
*/
func (a *ActivityApiService) GetActivitiesByMultipleHotelIds(ctx context.Context) ActivityApiGetActivitiesByMultipleHotelIdsRequest {
	return ActivityApiGetActivitiesByMultipleHotelIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActivitiesInfo
func (a *ActivityApiService) GetActivitiesByMultipleHotelIdsExecute(r ActivityApiGetActivitiesByMultipleHotelIdsRequest) (*ActivitiesInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivitiesInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivitiesByMultipleHotelIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.completed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed", r.completed, "")
	}
	if r.highPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highPriority", r.highPriority, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.ownerCode != nil {
		t := *r.ownerCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", t, "multi")
		}
	}
	if r.activityClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityClass", r.activityClass, "")
	}
	if r.activityType != nil {
		t := *r.activityType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", t, "multi")
		}
	}
	if r.activityPurpose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityPurpose", r.activityPurpose, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	if r.contactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	}
	if r.blockId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockId", r.blockId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiGetActivityRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiGetActivityRequest) Authorization(authorization string) ActivityApiGetActivityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiGetActivityRequest) XAppKey(xAppKey string) ActivityApiGetActivityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiGetActivityRequest) XHotelid(xHotelid string) ActivityApiGetActivityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Instruction to fetch Activity&#39;s information, linked Block and Profile, Attachments and linked Activities.
func (r ActivityApiGetActivityRequest) FetchInstructions(fetchInstructions []string) ActivityApiGetActivityRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ActivityApiGetActivityRequest) XExternalsystem(xExternalsystem string) ActivityApiGetActivityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiGetActivityRequest) AcceptLanguage(acceptLanguage string) ActivityApiGetActivityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiGetActivityRequest) Execute() (*Activity, *http.Response, error) {
	return r.ApiService.GetActivityExecute(r)
}

/*
GetActivity Get activity in a hotel by ID

You can use this API to retrieve an Activity for a hotel, using the OPERA Activity ID in the request. <p><strong>OperationId:</strong>getActivity</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiGetActivityRequest
*/
func (a *ActivityApiService) GetActivity(ctx context.Context, activityId string, hotelId string) ActivityApiGetActivityRequest {
	return ActivityApiGetActivityRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Activity
func (a *ActivityApiService) GetActivityExecute(r ActivityApiGetActivityRequest) (*Activity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Activity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.GetActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesInformation *PostActivitiesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostActivitiesRequest) Authorization(authorization string) ActivityApiPostActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiPostActivitiesRequest) XAppKey(xAppKey string) ActivityApiPostActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostActivitiesRequest) XHotelid(xHotelid string) ActivityApiPostActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating Activities.
func (r ActivityApiPostActivitiesRequest) ActivitiesInformation(activitiesInformation PostActivitiesRequest) ActivityApiPostActivitiesRequest {
	r.activitiesInformation = &activitiesInformation
	return r
}

// External system code.
func (r ActivityApiPostActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiPostActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostActivitiesExecute(r)
}

/*
PostActivities Create activities in a hotel

Use postActivities to create a new activity for a hotel.  You would need to know the types of Activities a hotel accepts, such as Appointments, TODO.  Use ListOfValues API's to find the available types at a hotel. <p><strong>OperationId:</strong>postActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiPostActivitiesRequest
*/
func (a *ActivityApiService) PostActivities(ctx context.Context, hotelId string) ActivityApiPostActivitiesRequest {
	return ActivityApiPostActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostActivitiesExecute(r ActivityApiPostActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostMultipleActivitiesCompletionRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesToChange *PostMultipleActivitiesCompletionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostMultipleActivitiesCompletionRequest) Authorization(authorization string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiPostMultipleActivitiesCompletionRequest) XAppKey(xAppKey string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostMultipleActivitiesCompletionRequest) XHotelid(xHotelid string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activities.
func (r ActivityApiPostMultipleActivitiesCompletionRequest) ActivitiesToChange(activitiesToChange PostMultipleActivitiesCompletionRequest) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.activitiesToChange = &activitiesToChange
	return r
}

// External system code.
func (r ActivityApiPostMultipleActivitiesCompletionRequest) XExternalsystem(xExternalsystem string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostMultipleActivitiesCompletionRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostMultipleActivitiesCompletionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostMultipleActivitiesCompletionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMultipleActivitiesCompletionExecute(r)
}

/*
PostMultipleActivitiesCompletion Complete activities

Use this API to mark multiple Activities as completed in 1 request.  You must know the OPERA Activity ID's for this API. <p><strong>OperationId:</strong>postMultipleActivitiesCompletion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivityApiPostMultipleActivitiesCompletionRequest
*/
func (a *ActivityApiService) PostMultipleActivitiesCompletion(ctx context.Context) ActivityApiPostMultipleActivitiesCompletionRequest {
	return ActivityApiPostMultipleActivitiesCompletionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostMultipleActivitiesCompletionExecute(r ActivityApiPostMultipleActivitiesCompletionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostMultipleActivitiesCompletion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activities/activitiesCompletion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPostSingleActivityCompletionRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesToChange *PostSingleActivityCompletionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPostSingleActivityCompletionRequest) Authorization(authorization string) ActivityApiPostSingleActivityCompletionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiPostSingleActivityCompletionRequest) XAppKey(xAppKey string) ActivityApiPostSingleActivityCompletionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPostSingleActivityCompletionRequest) XHotelid(xHotelid string) ActivityApiPostSingleActivityCompletionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activities.
func (r ActivityApiPostSingleActivityCompletionRequest) ActivitiesToChange(activitiesToChange PostSingleActivityCompletionRequest) ActivityApiPostSingleActivityCompletionRequest {
	r.activitiesToChange = &activitiesToChange
	return r
}

// External system code.
func (r ActivityApiPostSingleActivityCompletionRequest) XExternalsystem(xExternalsystem string) ActivityApiPostSingleActivityCompletionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPostSingleActivityCompletionRequest) AcceptLanguage(acceptLanguage string) ActivityApiPostSingleActivityCompletionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPostSingleActivityCompletionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostSingleActivityCompletionExecute(r)
}

/*
PostSingleActivityCompletion Complete activity in a hotel by ID

Use this API to mark one Activity as completed in 1 request.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>postSingleActivityCompletion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiPostSingleActivityCompletionRequest
*/
func (a *ActivityApiService) PostSingleActivityCompletion(ctx context.Context, activityId string, hotelId string) ActivityApiPostSingleActivityCompletionRequest {
	return ActivityApiPostSingleActivityCompletionRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PostSingleActivityCompletionExecute(r ActivityApiPostSingleActivityCompletionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PostSingleActivityCompletion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}/activityCompletion"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivityApiPutActivitiesRequest struct {
	ctx context.Context
	ApiService *ActivityApiService
	activityId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	activitiesToChange *PutActivitiesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ActivityApiPutActivitiesRequest) Authorization(authorization string) ActivityApiPutActivitiesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r ActivityApiPutActivitiesRequest) XAppKey(xAppKey string) ActivityApiPutActivitiesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ActivityApiPutActivitiesRequest) XHotelid(xHotelid string) ActivityApiPutActivitiesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing Activities.
func (r ActivityApiPutActivitiesRequest) ActivitiesToChange(activitiesToChange PutActivitiesRequest) ActivityApiPutActivitiesRequest {
	r.activitiesToChange = &activitiesToChange
	return r
}

// External system code.
func (r ActivityApiPutActivitiesRequest) XExternalsystem(xExternalsystem string) ActivityApiPutActivitiesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ActivityApiPutActivitiesRequest) AcceptLanguage(acceptLanguage string) ActivityApiPutActivitiesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ActivityApiPutActivitiesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutActivitiesExecute(r)
}

/*
PutActivities Update activity in a hotel by ID

Use this to update an existing Activity for a hotel.  You must know the OPERA Activity ID for this API. <p><strong>OperationId:</strong>putActivities</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param activityId Unique OPERA Activity ID which is used to find an Activity from OPERA. This ID is a primary identification of an Activity in OPERA.
 @param hotelId Unique ID of the hotel where activity is searched based on Activity ID.
 @return ActivityApiPutActivitiesRequest
*/
func (a *ActivityApiService) PutActivities(ctx context.Context, activityId string, hotelId string) ActivityApiPutActivitiesRequest {
	return ActivityApiPutActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ActivityApiService) PutActivitiesExecute(r ActivityApiPutActivitiesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.PutActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", url.PathEscape(parameterValueToString(r.activityId, "activityId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.activityId) < 1 {
		return localVarReturnValue, nil, reportError("activityId must have at least 1 elements")
	}
	if strlen(r.activityId) > 2000 {
		return localVarReturnValue, nil, reportError("activityId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.activitiesToChange
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
