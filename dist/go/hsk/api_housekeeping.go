/*
OPERA Cloud Housekeeping Service API

APIs to cater for Housekeeping functionality in OPERA Cloud. <br /><br />Housekeeping enables you to schedule daily room cleaning, maintenance, and housekeeping staff activities. It provides information on room status, out of order/out of service rooms, and forecasting.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hsk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HousekeepingApiService HousekeepingApi service
type HousekeepingApiService service

type HousekeepingApiCompleteOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completeRoomRepair *CompleteOutOfOrderRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) CompleteRoomRepair(completeRoomRepair CompleteOutOfOrderRoomsRequest) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.completeRoomRepair = &completeRoomRepair
	return r
}

// External system code.
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) Execute() (*CompleteRoomRepairStatus, *http.Response, error) {
	return r.ApiService.CompleteOutOfOrderRoomsExecute(r)
}

/*
CompleteOutOfOrderRooms Complete rooms Out Of Order

Use this API when one or more rooms are no longer Out Of Order, and can now be available for a guest to stay in.  Specify in the request what status the room(s) should be returned to, such as clean, Inspected, dirty or Pickup. <p><strong>OperationId:</strong>completeOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Order rooms needs to be returned to Clean, Inspected, Dirty or Pickup status.
 @return HousekeepingApiCompleteOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) CompleteOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	return HousekeepingApiCompleteOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompleteRoomRepairStatus
func (a *HousekeepingApiService) CompleteOutOfOrderRoomsExecute(r HousekeepingApiCompleteOutOfOrderRoomsRequest) (*CompleteRoomRepairStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteRoomRepairStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.completeRoomRepair
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiCompleteOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completeRoomRepair *CompleteOutOfServiceRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) CompleteRoomRepair(completeRoomRepair CompleteOutOfServiceRoomsRequest) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.completeRoomRepair = &completeRoomRepair
	return r
}

// External system code.
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) Execute() (*CompleteRoomRepairStatus, *http.Response, error) {
	return r.ApiService.CompleteOutOfServiceRoomsExecute(r)
}

/*
CompleteOutOfServiceRooms Complete Rooms Out of Service

Use this API when one or more rooms are no longer Out Of Service, and can now be available for a guest to stay in.  Specify in the request what status the room(s) should be returned to, such as clean, Inspected, dirty or Pickup. <p><strong>OperationId:</strong>completeOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Service rooms needs to be returned to Clean, Inspected, Dirty or Pickup status.
 @return HousekeepingApiCompleteOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) CompleteOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	return HousekeepingApiCompleteOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompleteRoomRepairStatus
func (a *HousekeepingApiService) CompleteOutOfServiceRoomsExecute(r HousekeepingApiCompleteOutOfServiceRoomsRequest) (*CompleteRoomRepairStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteRoomRepairStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.completeRoomRepair
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHouseKeepingTasksRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	taskDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	attendantInRoomOnly *bool
	generateCleaningSequence *bool
	includeReservationInfo *bool
	includeTaskSheetDetails *bool
	includeTaskSheetsSummary *bool
	sortByCleaningSequence *bool
	taskCodes *[]string
	taskHotelCodes *[]string
	taskSequences *[]int32
	taskDescriptions *[]string
	taskInstructions *[]string
	facilityDepartureTask *[]bool
	linenChange *[]bool
	taskCodesBreakOutId *string
	taskCodesBreakOutIdContext *string
	taskCodesBreakOutIdType *string
	attendantId *string
	taskSheetNumber *[]int32
	housekeepingRoomStatus *[]string
	guestService *[]string
	roomStatusToChange *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Date for which the Task Assignment information is required.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskDate(taskDate string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskDate = &taskDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHouseKeepingTasksRequest) Authorization(authorization string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetHouseKeepingTasksRequest) XAppKey(xAppKey string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHouseKeepingTasksRequest) XHotelid(xHotelid string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Query only rooms with attendant working in them.
func (r HousekeepingApiGetHouseKeepingTasksRequest) AttendantInRoomOnly(attendantInRoomOnly bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.attendantInRoomOnly = &attendantInRoomOnly
	return r
}

// Setting this to true will generate a sequence based on the current condition of the room for cleaning. This sequence would be the same sequence with which the Task Companion works.
func (r HousekeepingApiGetHouseKeepingTasksRequest) GenerateCleaningSequence(generateCleaningSequence bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.generateCleaningSequence = &generateCleaningSequence
	return r
}

// Setting this to true will include reservation information associated to the room.
func (r HousekeepingApiGetHouseKeepingTasksRequest) IncludeReservationInfo(includeReservationInfo bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.includeReservationInfo = &includeReservationInfo
	return r
}

// This will include room details for the Task Sheets. If summary information is only required, then this could be set to false. If a Task Sheet Number is included in the Search and this flag is set to true, then the details for that particular Task Sheet will be returned. For all other task sheets, the IncludeTaskSheetsSummary will determine if Summary details are required or not.
func (r HousekeepingApiGetHouseKeepingTasksRequest) IncludeTaskSheetDetails(includeTaskSheetDetails bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.includeTaskSheetDetails = &includeTaskSheetDetails
	return r
}

// Setting this to true, will return Summary information for the task sheets required. If a Task Sheet Number is included in the Search and IncludeTaskSheetDetails is set to false and IncludeTaskSheetsSummary is false, then only the Summary information for that particular task sheet will be returned. IncludeTaskSheetDetails &#x3D; True, IncludeTaskSheetsSummary &#x3D; True : includes all task sheets details and summary IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; True : includes only summary IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; false, Task Sheet No &#x3D;null : no task sheet detail or summary for any of the tasksheets. Returns the Task Assignnment header. IncludeTaskSheetDetails &#x3D; True, IncludeTaskSheetsSummary &#x3D; True, Task Sheet No &#x3D; XX : includes task sheets detail for XX and summary for others. IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; True, Task Sheet No &#x3D; XX : includes summary for all including XX. IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; false, Task Sheet No &#x3D; XX : includes summary for XX. No information for others.
func (r HousekeepingApiGetHouseKeepingTasksRequest) IncludeTaskSheetsSummary(includeTaskSheetsSummary bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.includeTaskSheetsSummary = &includeTaskSheetsSummary
	return r
}

// The rooms in the task sheet would be sorted with the cleaning sequence. The normal sort would be done based on the Default Sequence.
func (r HousekeepingApiGetHouseKeepingTasksRequest) SortByCleaningSequence(sortByCleaningSequence bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.sortByCleaningSequence = &sortByCleaningSequence
	return r
}

// The Code for the task.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodes(taskCodes []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodes = &taskCodes
	return r
}

// Property for which the Task Assignment information is required.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskHotelCodes(taskHotelCodes []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskHotelCodes = &taskHotelCodes
	return r
}

// Ordering sequence for display.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskSequences(taskSequences []int32) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskSequences = &taskSequences
	return r
}

// Description of the Task Code.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskDescriptions(taskDescriptions []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskDescriptions = &taskDescriptions
	return r
}

// Instructions for this Task Code.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskInstructions(taskInstructions []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskInstructions = &taskInstructions
	return r
}

// Indicates if this task code is the default departure task for Facility Tasks. This requires
func (r HousekeepingApiGetHouseKeepingTasksRequest) FacilityDepartureTask(facilityDepartureTask []bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.facilityDepartureTask = &facilityDepartureTask
	return r
}

// Indicates if a linen change is necessary.
func (r HousekeepingApiGetHouseKeepingTasksRequest) LinenChange(linenChange []bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.linenChange = &linenChange
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodesBreakOutId(taskCodesBreakOutId string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodesBreakOutId = &taskCodesBreakOutId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodesBreakOutIdContext(taskCodesBreakOutIdContext string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodesBreakOutIdContext = &taskCodesBreakOutIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodesBreakOutIdType(taskCodesBreakOutIdType string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodesBreakOutIdType = &taskCodesBreakOutIdType
	return r
}

// Attendant ID for which the Task Sheets are assigned.
func (r HousekeepingApiGetHouseKeepingTasksRequest) AttendantId(attendantId string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.attendantId = &attendantId
	return r
}

// Specific Task Sheet number for which the information is required.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskSheetNumber(taskSheetNumber []int32) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskSheetNumber = &taskSheetNumber
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHouseKeepingTasksRequest) HousekeepingRoomStatus(housekeepingRoomStatus []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.housekeepingRoomStatus = &housekeepingRoomStatus
	return r
}

// Possible values for the Guest Service Status.
func (r HousekeepingApiGetHouseKeepingTasksRequest) GuestService(guestService []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.guestService = &guestService
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHouseKeepingTasksRequest) RoomStatusToChange(roomStatusToChange []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.roomStatusToChange = &roomStatusToChange
	return r
}

// External system code.
func (r HousekeepingApiGetHouseKeepingTasksRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHouseKeepingTasksRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHouseKeepingTasksRequest) Execute() (*TaskAssignment, *http.Response, error) {
	return r.ApiService.GetHouseKeepingTasksExecute(r)
}

/*
GetHouseKeepingTasks Get the existing task sheets

This API will allow you to get the existing task sheets. <p><strong>OperationId:</strong>getHouseKeepingTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetHouseKeepingTasksRequest
*/
func (a *HousekeepingApiService) GetHouseKeepingTasks(ctx context.Context, hotelId string) HousekeepingApiGetHouseKeepingTasksRequest {
	return HousekeepingApiGetHouseKeepingTasksRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TaskAssignment
func (a *HousekeepingApiService) GetHouseKeepingTasksExecute(r HousekeepingApiGetHouseKeepingTasksRequest) (*TaskAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHouseKeepingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/houseKeepingtasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "taskDate", r.taskDate, "")
	if r.attendantInRoomOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attendantInRoomOnly", r.attendantInRoomOnly, "")
	}
	if r.generateCleaningSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateCleaningSequence", r.generateCleaningSequence, "")
	}
	if r.includeReservationInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReservationInfo", r.includeReservationInfo, "")
	}
	if r.includeTaskSheetDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTaskSheetDetails", r.includeTaskSheetDetails, "")
	}
	if r.includeTaskSheetsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTaskSheetsSummary", r.includeTaskSheetsSummary, "")
	}
	if r.sortByCleaningSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortByCleaningSequence", r.sortByCleaningSequence, "")
	}
	if r.taskCodes != nil {
		t := *r.taskCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", t, "multi")
		}
	}
	if r.taskHotelCodes != nil {
		t := *r.taskHotelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskHotelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskHotelCodes", t, "multi")
		}
	}
	if r.taskSequences != nil {
		t := *r.taskSequences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskSequences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskSequences", t, "multi")
		}
	}
	if r.taskDescriptions != nil {
		t := *r.taskDescriptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskDescriptions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskDescriptions", t, "multi")
		}
	}
	if r.taskInstructions != nil {
		t := *r.taskInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskInstructions", t, "multi")
		}
	}
	if r.facilityDepartureTask != nil {
		t := *r.facilityDepartureTask
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facilityDepartureTask", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facilityDepartureTask", t, "multi")
		}
	}
	if r.linenChange != nil {
		t := *r.linenChange
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "linenChange", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "linenChange", t, "multi")
		}
	}
	if r.taskCodesBreakOutId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodesBreakOutId", r.taskCodesBreakOutId, "")
	}
	if r.taskCodesBreakOutIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodesBreakOutIdContext", r.taskCodesBreakOutIdContext, "")
	}
	if r.taskCodesBreakOutIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodesBreakOutIdType", r.taskCodesBreakOutIdType, "")
	}
	if r.attendantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attendantId", r.attendantId, "")
	}
	if r.taskSheetNumber != nil {
		t := *r.taskSheetNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskSheetNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskSheetNumber", t, "multi")
		}
	}
	if r.housekeepingRoomStatus != nil {
		t := *r.housekeepingRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", t, "multi")
		}
	}
	if r.guestService != nil {
		t := *r.guestService
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestService", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestService", t, "multi")
		}
	}
	if r.roomStatusToChange != nil {
		t := *r.roomStatusToChange
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatusToChange", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatusToChange", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingDiscrepanciesRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomDiscrepancyStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	roomClass *[]string
	housekeepingEndDate *string
	housekeepingStartDate *string
	floor *[]string
	dueOut *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for discrepant room status instructions to be used in requests for fetching housekeeping and front office room discrepancy. Valid values are Sleep, Skip, Person Discrepancy, Due Out Only.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) RoomDiscrepancyStatus(roomDiscrepancyStatus []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.roomDiscrepancyStatus = &roomDiscrepancyStatus
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

// Room Class of the Room.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) RoomClass(roomClass []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.roomClass = &roomClass
	return r
}

// The ending value of the date range.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) HousekeepingEndDate(housekeepingEndDate string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.housekeepingEndDate = &housekeepingEndDate
	return r
}

// The starting value of the date range.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) HousekeepingStartDate(housekeepingStartDate string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.housekeepingStartDate = &housekeepingStartDate
	return r
}

// The floor of room to be fetched.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Floor(floor []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.floor = &floor
	return r
}

// List the rooms based on the flag DUE OUT for departure only.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) DueOut(dueOut bool) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.dueOut = &dueOut
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetHousekeepingDiscrepanciesExecute(r)
}

/*
GetHousekeepingDiscrepancies Get hotel housekeeping discrepant rooms

Use this API to return the current housekeeping discrepant rooms for a specific property based on search parameters such as roomDiscrepancyStatus, roomClass, floor, dueOut, etc. These are rooms where the housekeeping status does not match the front office status.<p><strong>OperationId:</strong>getHousekeepingDiscrepancies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetHousekeepingDiscrepanciesRequest
*/
func (a *HousekeepingApiService) GetHousekeepingDiscrepancies(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	return HousekeepingApiGetHousekeepingDiscrepanciesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetHousekeepingDiscrepanciesExecute(r HousekeepingApiGetHousekeepingDiscrepanciesRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingDiscrepancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingDiscrepancies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomDiscrepancyStatus != nil {
		t := *r.roomDiscrepancyStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomDiscrepancyStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomDiscrepancyStatus", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.housekeepingEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingEndDate", r.housekeepingEndDate, "")
	}
	if r.housekeepingStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingStartDate", r.housekeepingStartDate, "")
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.dueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueOut", r.dueOut, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingOverviewRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	housekeepingRoomStatus *[]string
	frontOfficeRoomStatus *[]string
	turndownStatus *[]string
	roomParityStatus *[]string
	serviceRequestStatus *[]string
	roomAssignmentStatus *[]string
	fetchInstructions *[]string
	fromRoomNumber *string
	toRoomNumber *string
	floor *[]string
	roomType *[]string
	roomClass *[]string
	building *[]string
	roomFeatures *[]string
	daySection *[]string
	eveningSection *[]string
	reservationStatus *[]string
	guestServiceRequest *string
	roomIdText *string
	excludeCombo *bool
	cleaningPriorityOnly *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingOverviewRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetHousekeepingOverviewRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingOverviewRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Limit(limit int32) HousekeepingApiGetHousekeepingOverviewRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Offset(offset int32) HousekeepingApiGetHousekeepingOverviewRequest {
	r.offset = &offset
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHousekeepingOverviewRequest) HousekeepingRoomStatus(housekeepingRoomStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.housekeepingRoomStatus = &housekeepingRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r HousekeepingApiGetHousekeepingOverviewRequest) FrontOfficeRoomStatus(frontOfficeRoomStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.frontOfficeRoomStatus = &frontOfficeRoomStatus
	return r
}

// Simple type for turndown status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Required, Not Required and Completed.
func (r HousekeepingApiGetHousekeepingOverviewRequest) TurndownStatus(turndownStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.turndownStatus = &turndownStatus
	return r
}

// Simple type for room parity instructions to be used in requests for fetching housekeeping rooms. Valid status values are Odd and Even.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomParityStatus(roomParityStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomParityStatus = &roomParityStatus
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) ServiceRequestStatus(serviceRequestStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.serviceRequestStatus = &serviceRequestStatus
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomAssignmentStatus(roomAssignmentStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomAssignmentStatus = &roomAssignmentStatus
	return r
}

// Simple type for housekeeping instructions that can be used in requests for partial operations.
func (r HousekeepingApiGetHousekeepingOverviewRequest) FetchInstructions(fetchInstructions []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

// The floor of room to be fetched.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Floor(floor []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.floor = &floor
	return r
}

// Room Type of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomType(roomType []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomType = &roomType
	return r
}

// Room Class of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomClass(roomClass []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomClass = &roomClass
	return r
}

// Building of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Building(building []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.building = &building
	return r
}

// Features of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomFeatures(roomFeatures []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// AM Sections of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) DaySection(daySection []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.daySection = &daySection
	return r
}

// PM Sections of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) EveningSection(eveningSection []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.eveningSection = &eveningSection
	return r
}

// The status of the reservation to which this Room is assigned.
func (r HousekeepingApiGetHousekeepingOverviewRequest) ReservationStatus(reservationStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// Possible values for the Guest Service Status.
func (r HousekeepingApiGetHousekeepingOverviewRequest) GuestServiceRequest(guestServiceRequest string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.guestServiceRequest = &guestServiceRequest
	return r
}

// Wild Card entry for Room numbers to be Fetched.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomIdText(roomIdText string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomIdText = &roomIdText
	return r
}

// Indicates we need to exclude the combo rooms while fetching the housekeeping details.
func (r HousekeepingApiGetHousekeepingOverviewRequest) ExcludeCombo(excludeCombo bool) HousekeepingApiGetHousekeepingOverviewRequest {
	r.excludeCombo = &excludeCombo
	return r
}

// Determines whether fetching cleaning priority rooms only.
func (r HousekeepingApiGetHousekeepingOverviewRequest) CleaningPriorityOnly(cleaningPriorityOnly bool) HousekeepingApiGetHousekeepingOverviewRequest {
	r.cleaningPriorityOnly = &cleaningPriorityOnly
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingOverviewRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingOverviewRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) Execute() (*HousekeepingBoard, *http.Response, error) {
	return r.ApiService.GetHousekeepingOverviewExecute(r)
}

/*
GetHousekeepingOverview Get housekeeping rooms overview

Use this API to return the status of rooms for a specific property based on search criteria such as hotelId, limit, housekeepingRoomStatus, frontOfficeRoomStatus, roomAssignmentStatus, roomType, roomFeatures. The results will give you a list of rooms, and their current housekeeping details.  You could then go ahead and update any of these rooms by using postOutOfOrderRoom for example. <p><strong>OperationId:</strong>getHousekeepingOverview</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Housekeeping overview needs to be fetched
 @return HousekeepingApiGetHousekeepingOverviewRequest
*/
func (a *HousekeepingApiService) GetHousekeepingOverview(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingOverviewRequest {
	return HousekeepingApiGetHousekeepingOverviewRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingBoard
func (a *HousekeepingApiService) GetHousekeepingOverviewExecute(r HousekeepingApiGetHousekeepingOverviewRequest) (*HousekeepingBoard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingBoard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingOverview"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.housekeepingRoomStatus != nil {
		t := *r.housekeepingRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", t, "multi")
		}
	}
	if r.frontOfficeRoomStatus != nil {
		t := *r.frontOfficeRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", t, "multi")
		}
	}
	if r.turndownStatus != nil {
		t := *r.turndownStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "turndownStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "turndownStatus", t, "multi")
		}
	}
	if r.roomParityStatus != nil {
		t := *r.roomParityStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", t, "multi")
		}
	}
	if r.serviceRequestStatus != nil {
		t := *r.serviceRequestStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRequestStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRequestStatus", t, "multi")
		}
	}
	if r.roomAssignmentStatus != nil {
		t := *r.roomAssignmentStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.building != nil {
		t := *r.building
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "building", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "building", t, "multi")
		}
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.daySection != nil {
		t := *r.daySection
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daySection", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daySection", t, "multi")
		}
	}
	if r.eveningSection != nil {
		t := *r.eveningSection
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eveningSection", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eveningSection", t, "multi")
		}
	}
	if r.reservationStatus != nil {
		t := *r.reservationStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", t, "multi")
		}
	}
	if r.guestServiceRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestServiceRequest", r.guestServiceRequest, "")
	}
	if r.roomIdText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomIdText", r.roomIdText, "")
	}
	if r.excludeCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCombo", r.excludeCombo, "")
	}
	if r.cleaningPriorityOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cleaningPriorityOnly", r.cleaningPriorityOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomId *string
	endDate *string
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The start date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) StartDate(startDate string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room number to be Fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomId(roomId string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomId = &roomId
	return r
}

// The end date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) EndDate(endDate string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.endDate = &endDate
	return r
}

// The room type of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomTypes = &roomTypes
	return r
}

// The room class of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetOutOfOrderRoomsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetOutOfOrderRoomsExecute(r)
}

/*
GetOutOfOrderRooms Get Out of Order Rooms

Use this API to get a list of rooms for a hotel that are Out of Order.  You can narrow down your results with search criteria such as Room class, Room Type, date range. <p><strong>OperationId:</strong>getOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Order rooms needs to be fetched.
 @return HousekeepingApiGetOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) GetOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiGetOutOfOrderRoomsRequest {
	return HousekeepingApiGetOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetOutOfOrderRoomsExecute(r HousekeepingApiGetOutOfOrderRoomsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomId *string
	endDate *string
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The start date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) StartDate(startDate string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room number to be Fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomId(roomId string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomId = &roomId
	return r
}

// The end date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) EndDate(endDate string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.endDate = &endDate
	return r
}

// The room type of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomTypes = &roomTypes
	return r
}

// The room class of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetOutOfServiceRoomsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetOutOfServiceRoomsExecute(r)
}

/*
GetOutOfServiceRooms Get Out of Service Rooms

Use this API to get a list of rooms for a hotel that are Out of Service.  You can narrow down your results with search criteria such as Room class, Room Type, date range. <p><strong>OperationId:</strong>getOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Service rooms needs to be fetched.
 @return HousekeepingApiGetOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) GetOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiGetOutOfServiceRoomsRequest {
	return HousekeepingApiGetOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetOutOfServiceRoomsExecute(r HousekeepingApiGetOutOfServiceRoomsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRepairOutOfOrder *PostOutOfOrderRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPostOutOfOrderRoomsRequest) RoomRepairOutOfOrder(roomRepairOutOfOrder PostOutOfOrderRoomsRequest) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.roomRepairOutOfOrder = &roomRepairOutOfOrder
	return r
}

// External system code.
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostOutOfOrderRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOutOfOrderRoomsExecute(r)
}

/*
PostOutOfOrderRooms Set multiple rooms to Out Of Order

This API allows you to initially set rooms to 'Out Of Order' housekeeping status and update existing outOfOrderRooms. <p><strong>OperationId:</strong>postOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code of Room(s) which is to be set as Out Of Order.
 @return HousekeepingApiPostOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) PostOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiPostOutOfOrderRoomsRequest {
	return HousekeepingApiPostOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostOutOfOrderRoomsExecute(r HousekeepingApiPostOutOfOrderRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRepairOutOfOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRepairOutOfService *PostOutOfServiceRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPostOutOfServiceRoomsRequest) RoomRepairOutOfService(roomRepairOutOfService PostOutOfServiceRoomsRequest) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.roomRepairOutOfService = &roomRepairOutOfService
	return r
}

// External system code.
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostOutOfServiceRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOutOfServiceRoomsExecute(r)
}

/*
PostOutOfServiceRooms Set multiple rooms to Out Of Service

This API allows you to initially set rooms to 'Out Of Service' housekeeping status and update existing outOfServiceRooms. <p><strong>OperationId:</strong>postOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code of Room(s) which is to be set as Out Of Service.
 @return HousekeepingApiPostOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) PostOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiPostOutOfServiceRoomsRequest {
	return HousekeepingApiPostOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostOutOfServiceRoomsExecute(r HousekeepingApiPostOutOfServiceRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRepairOutOfService
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutRoomRelatedStatusRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingRoomStatusCriteria *PutRoomRelatedStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutRoomRelatedStatusRequest) Authorization(authorization string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HousekeepingApiPutRoomRelatedStatusRequest) XAppKey(xAppKey string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutRoomRelatedStatusRequest) XHotelid(xHotelid string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPutRoomRelatedStatusRequest) HousekeepingRoomStatusCriteria(housekeepingRoomStatusCriteria PutRoomRelatedStatusRequest) HousekeepingApiPutRoomRelatedStatusRequest {
	r.housekeepingRoomStatusCriteria = &housekeepingRoomStatusCriteria
	return r
}

// External system code.
func (r HousekeepingApiPutRoomRelatedStatusRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutRoomRelatedStatusRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutRoomRelatedStatusRequest) Execute() (*HousekeepingRoomStatus, *http.Response, error) {
	return r.ApiService.PutRoomRelatedStatusExecute(r)
}

/*
PutRoomRelatedStatus Update Housekeeping Room Status

Use this API to update the housekeeping room status for multiple rooms.  Statuses typically include Inspected, Clean, Pickup or Dirty. <p><strong>OperationId:</strong>putRoomRelatedStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which housekeeping room status, housekeeping status or turndown status have to be modified
 @return HousekeepingApiPutRoomRelatedStatusRequest
*/
func (a *HousekeepingApiService) PutRoomRelatedStatus(ctx context.Context, hotelId string) HousekeepingApiPutRoomRelatedStatusRequest {
	return HousekeepingApiPutRoomRelatedStatusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingRoomStatus
func (a *HousekeepingApiService) PutRoomRelatedStatusExecute(r HousekeepingApiPutRoomRelatedStatusRequest) (*HousekeepingRoomStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingRoomStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutRoomRelatedStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/status"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingRoomStatusCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
