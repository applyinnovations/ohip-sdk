/*
OPERA Cloud Housekeeping Service API

APIs to cater for Housekeeping functionality in OPERA Cloud. <br /><br />Housekeeping enables you to schedule daily room cleaning, maintenance, and housekeeping staff activities. It provides information on room status, out of order/out of service rooms, and forecasting.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hsk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HousekeepingApiService HousekeepingApi service
type HousekeepingApiService service

type HousekeepingApiAutoGenerateTaskSheetsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheets *AutoGenerateTaskSheetsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiAutoGenerateTaskSheetsRequest) Authorization(authorization string) HousekeepingApiAutoGenerateTaskSheetsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiAutoGenerateTaskSheetsRequest) XAppKey(xAppKey string) HousekeepingApiAutoGenerateTaskSheetsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiAutoGenerateTaskSheetsRequest) XHotelid(xHotelid string) HousekeepingApiAutoGenerateTaskSheetsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for generating housekeeping Task Sheets automatically. To generate task sheets automatically the minimum required criteria is the Task Date, Task Code, Number of Attendants/Tasksheets required and the Room Statuses. Based on the criteria defined, task sheets will be created and the rooms will be assigned to the Tasksheets. Example: if the criteria defines that Dirty room status to be used to generate 5 sheets, then only those rooms which have the status &#x3D; Dirty will be used and will be assigned to the 5 sheets.
func (r HousekeepingApiAutoGenerateTaskSheetsRequest) TaskSheets(taskSheets AutoGenerateTaskSheetsRequest) HousekeepingApiAutoGenerateTaskSheetsRequest {
	r.taskSheets = &taskSheets
	return r
}

// External system code.
func (r HousekeepingApiAutoGenerateTaskSheetsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiAutoGenerateTaskSheetsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiAutoGenerateTaskSheetsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiAutoGenerateTaskSheetsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiAutoGenerateTaskSheetsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.AutoGenerateTaskSheetsExecute(r)
}

/*
AutoGenerateTaskSheets Auto generate the task sheets

This API will allow you to Auto generate the task sheets. <p><strong>OperationId:</strong>autoGenerateTaskSheets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiAutoGenerateTaskSheetsRequest
*/
func (a *HousekeepingApiService) AutoGenerateTaskSheets(ctx context.Context, hotelId string) HousekeepingApiAutoGenerateTaskSheetsRequest {
	return HousekeepingApiAutoGenerateTaskSheetsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) AutoGenerateTaskSheetsExecute(r HousekeepingApiAutoGenerateTaskSheetsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.AutoGenerateTaskSheets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/autoTaskSheets"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheets
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiCancelServicingTaskRoomRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskRoom *CancelServicingTaskRoomRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCancelServicingTaskRoomRequest) Authorization(authorization string) HousekeepingApiCancelServicingTaskRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiCancelServicingTaskRoomRequest) XAppKey(xAppKey string) HousekeepingApiCancelServicingTaskRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCancelServicingTaskRoomRequest) XHotelid(xHotelid string) HousekeepingApiCancelServicingTaskRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to cancel the servicing of a task room.
func (r HousekeepingApiCancelServicingTaskRoomRequest) TaskRoom(taskRoom CancelServicingTaskRoomRequest) HousekeepingApiCancelServicingTaskRoomRequest {
	r.taskRoom = &taskRoom
	return r
}

// External system code.
func (r HousekeepingApiCancelServicingTaskRoomRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCancelServicingTaskRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCancelServicingTaskRoomRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCancelServicingTaskRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCancelServicingTaskRoomRequest) Execute() (*CanceledServicingTaskRoom, *http.Response, error) {
	return r.ApiService.CancelServicingTaskRoomExecute(r)
}

/*
CancelServicingTaskRoom Cancel servicing task room

This API will allow you to cancel servicing task room. <p><strong>OperationId:</strong>cancelServicingTaskRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param roomId
 @param hotelId
 @return HousekeepingApiCancelServicingTaskRoomRequest
*/
func (a *HousekeepingApiService) CancelServicingTaskRoom(ctx context.Context, sheetNumber string, roomId string, hotelId string) HousekeepingApiCancelServicingTaskRoomRequest {
	return HousekeepingApiCancelServicingTaskRoomRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CanceledServicingTaskRoom
func (a *HousekeepingApiService) CancelServicingTaskRoomExecute(r HousekeepingApiCancelServicingTaskRoomRequest) (*CanceledServicingTaskRoom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CanceledServicingTaskRoom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CancelServicingTaskRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/sheets/{sheetNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiCompleteOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completeRoomRepair *CompleteOutOfOrderRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) CompleteRoomRepair(completeRoomRepair CompleteOutOfOrderRoomsRequest) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.completeRoomRepair = &completeRoomRepair
	return r
}

// External system code.
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteOutOfOrderRoomsRequest) Execute() (*CompleteRoomRepairStatus, *http.Response, error) {
	return r.ApiService.CompleteOutOfOrderRoomsExecute(r)
}

/*
CompleteOutOfOrderRooms Complete rooms Out Of Order

Use this API when one or more rooms are no longer Out Of Order, and can now be available for a guest to stay in.  Specify in the request what status the room(s) should be returned to, such as clean, Inspected, dirty or Pickup. <p><strong>OperationId:</strong>completeOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Order rooms needs to be returned to Clean, Inspected, Dirty or Pickup status.
 @return HousekeepingApiCompleteOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) CompleteOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiCompleteOutOfOrderRoomsRequest {
	return HousekeepingApiCompleteOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompleteRoomRepairStatus
func (a *HousekeepingApiService) CompleteOutOfOrderRoomsExecute(r HousekeepingApiCompleteOutOfOrderRoomsRequest) (*CompleteRoomRepairStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteRoomRepairStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.completeRoomRepair
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiCompleteOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	completeRoomRepair *CompleteOutOfServiceRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) CompleteRoomRepair(completeRoomRepair CompleteOutOfServiceRoomsRequest) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.completeRoomRepair = &completeRoomRepair
	return r
}

// External system code.
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteOutOfServiceRoomsRequest) Execute() (*CompleteRoomRepairStatus, *http.Response, error) {
	return r.ApiService.CompleteOutOfServiceRoomsExecute(r)
}

/*
CompleteOutOfServiceRooms Complete Rooms Out of Service

Use this API when one or more rooms are no longer Out Of Service, and can now be available for a guest to stay in.  Specify in the request what status the room(s) should be returned to, such as clean, Inspected, dirty or Pickup. <p><strong>OperationId:</strong>completeOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Service rooms needs to be returned to Clean, Inspected, Dirty or Pickup status.
 @return HousekeepingApiCompleteOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) CompleteOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiCompleteOutOfServiceRoomsRequest {
	return HousekeepingApiCompleteOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompleteRoomRepairStatus
func (a *HousekeepingApiService) CompleteOutOfServiceRoomsExecute(r HousekeepingApiCompleteOutOfServiceRoomsRequest) (*CompleteRoomRepairStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompleteRoomRepairStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.completeRoomRepair
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiCompleteServicingTaskRoomRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskRoom *CancelServicingTaskRoomRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiCompleteServicingTaskRoomRequest) Authorization(authorization string) HousekeepingApiCompleteServicingTaskRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiCompleteServicingTaskRoomRequest) XAppKey(xAppKey string) HousekeepingApiCompleteServicingTaskRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiCompleteServicingTaskRoomRequest) XHotelid(xHotelid string) HousekeepingApiCompleteServicingTaskRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to complete servicing of a task room. This will complete the servicing and set the end time and status to COMPLETED.
func (r HousekeepingApiCompleteServicingTaskRoomRequest) TaskRoom(taskRoom CancelServicingTaskRoomRequest) HousekeepingApiCompleteServicingTaskRoomRequest {
	r.taskRoom = &taskRoom
	return r
}

// External system code.
func (r HousekeepingApiCompleteServicingTaskRoomRequest) XExternalsystem(xExternalsystem string) HousekeepingApiCompleteServicingTaskRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiCompleteServicingTaskRoomRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiCompleteServicingTaskRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiCompleteServicingTaskRoomRequest) Execute() (*CompletedServicingTaskRoom, *http.Response, error) {
	return r.ApiService.CompleteServicingTaskRoomExecute(r)
}

/*
CompleteServicingTaskRoom Complete servicing task room

This API will allow you to complete servicing task room. <p><strong>OperationId:</strong>completeServicingTaskRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param roomId
 @param hotelId
 @return HousekeepingApiCompleteServicingTaskRoomRequest
*/
func (a *HousekeepingApiService) CompleteServicingTaskRoom(ctx context.Context, sheetNumber string, roomId string, hotelId string) HousekeepingApiCompleteServicingTaskRoomRequest {
	return HousekeepingApiCompleteServicingTaskRoomRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompletedServicingTaskRoom
func (a *HousekeepingApiService) CompleteServicingTaskRoomExecute(r HousekeepingApiCompleteServicingTaskRoomRequest) (*CompletedServicingTaskRoom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompletedServicingTaskRoom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.CompleteServicingTaskRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/sheets/{sheetNumber}/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteHouseKeepingTaskSheetsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	taskCodesBreakOutId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) Authorization(authorization string) HousekeepingApiDeleteHouseKeepingTaskSheetsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) XAppKey(xAppKey string) HousekeepingApiDeleteHouseKeepingTaskSheetsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) XHotelid(xHotelid string) HousekeepingApiDeleteHouseKeepingTaskSheetsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteHouseKeepingTaskSheetsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteHouseKeepingTaskSheetsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHouseKeepingTaskSheetsExecute(r)
}

/*
DeleteHouseKeepingTaskSheets Delete all the hotel task sheets for an existing Task Sheet Set.

Use this API to delete all task sheets for an existing task sheet set for a specific property. Task Sheet Sets can be used to break out the rooms to be cleaned by the housekeeping attendants.<p><strong>OperationId:</strong>deleteHouseKeepingTaskSheets</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Indicates Unique Hotel Code for which the task sheets will be deleted.
 @param taskCodesBreakOutId Indicates Unique breakout ID for which the task sheets will be deleted.
 @return HousekeepingApiDeleteHouseKeepingTaskSheetsRequest
*/
func (a *HousekeepingApiService) DeleteHouseKeepingTaskSheets(ctx context.Context, hotelId string, taskCodesBreakOutId string) HousekeepingApiDeleteHouseKeepingTaskSheetsRequest {
	return HousekeepingApiDeleteHouseKeepingTaskSheetsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		taskCodesBreakOutId: taskCodesBreakOutId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteHouseKeepingTaskSheetsExecute(r HousekeepingApiDeleteHouseKeepingTaskSheetsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteHouseKeepingTaskSheets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/houseKeepingTasks/{taskCodesBreakOutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskCodesBreakOutId"+"}", url.PathEscape(parameterValueToString(r.taskCodesBreakOutId, "taskCodesBreakOutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.taskCodesBreakOutId) < 1 {
		return localVarReturnValue, nil, reportError("taskCodesBreakOutId must have at least 1 elements")
	}
	if strlen(r.taskCodesBreakOutId) > 2000 {
		return localVarReturnValue, nil, reportError("taskCodesBreakOutId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteHousekeepingAttendantScheduleRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	scheduleDate *string
	attendantId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Schedule date of attendants&#39; assignment. Used when attendants to scheduled are of the same date.
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) ScheduleDate(scheduleDate string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.scheduleDate = &scheduleDate
	return r
}

// ID of the attendant.
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) AttendantId(attendantId []string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.attendantId = &attendantId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) Authorization(authorization string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) XAppKey(xAppKey string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) XHotelid(xHotelid string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteHousekeepingAttendantScheduleExecute(r)
}

/*
DeleteHousekeepingAttendantSchedule Delete housekeeping attendant schedule

This API will allow you to delete housekeeping attendant schedule. <p><strong>OperationId:</strong>deleteHousekeepingAttendantSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiDeleteHousekeepingAttendantScheduleRequest
*/
func (a *HousekeepingApiService) DeleteHousekeepingAttendantSchedule(ctx context.Context, hotelId string) HousekeepingApiDeleteHousekeepingAttendantScheduleRequest {
	return HousekeepingApiDeleteHousekeepingAttendantScheduleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteHousekeepingAttendantScheduleExecute(r HousekeepingApiDeleteHousekeepingAttendantScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteHousekeepingAttendantSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/attendants/houseKeepingTasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleDate", r.scheduleDate, "")
	{
		t := *r.attendantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attendantId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attendantId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteReservationHousekeepingTasksRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	customized *bool
	cycleStartDay *int32
	endDate *string
	startDate *string
	facilityTaskCode *string
	facilityTaskDescription *string
	facilityTaskPriority *int32
	taskDate *[]string
	taskStartDate *[]string
	taskEndDate *[]string
	stayPeriod *[]string
	frequency *[]int32
	taskCycleStartDay *[]int32
	roomType *[]string
	roomId *[]string
	facilityCodes *[]string
	facilityCodesDescription *[]string
	facilityCodesQuantity *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) Authorization(authorization string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) XAppKey(xAppKey string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) XHotelid(xHotelid string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Signifies whether task has been customized or not.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) Customized(customized bool) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.customized = &customized
	return r
}

// Signifies the shift of the housekeeping schedule.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) CycleStartDay(cycleStartDay int32) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.cycleStartDay = &cycleStartDay
	return r
}

// Date at which facility tasks stopped being retrieved.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) EndDate(endDate string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.endDate = &endDate
	return r
}

// Date at which facility tasks started being retrieved.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) StartDate(startDate string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.startDate = &startDate
	return r
}

// Code of the housekeeping task.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) FacilityTaskCode(facilityTaskCode string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.facilityTaskCode = &facilityTaskCode
	return r
}

// Facility task description.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) FacilityTaskDescription(facilityTaskDescription string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.facilityTaskDescription = &facilityTaskDescription
	return r
}

// Signifies the priority of the task.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) FacilityTaskPriority(facilityTaskPriority int32) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.facilityTaskPriority = &facilityTaskPriority
	return r
}

// A reservation date on which task must occur.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) TaskDate(taskDate []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.taskDate = &taskDate
	return r
}

// Date on which the task needs to start being performed.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) TaskStartDate(taskStartDate []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.taskStartDate = &taskStartDate
	return r
}

// Date on which task will stop being performed.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) TaskEndDate(taskEndDate []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.taskEndDate = &taskEndDate
	return r
}

// Simple type for controlling the fetch operations of the housekeeping schedule request.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) StayPeriod(stayPeriod []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.stayPeriod = &stayPeriod
	return r
}

// Signifies frequency(i.e. every 2 days) with which task is to be performed.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) Frequency(frequency []int32) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.frequency = &frequency
	return r
}

// Signifies offset(in days) i.e. start on 3rd day from arrival.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) TaskCycleStartDay(taskCycleStartDay []int32) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.taskCycleStartDay = &taskCycleStartDay
	return r
}

// Signifies the room type for which task is being performed .
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) RoomType(roomType []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.roomType = &roomType
	return r
}

// Room number at which task is to be performed.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) RoomId(roomId []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.roomId = &roomId
	return r
}

// Facility code value.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) FacilityCodes(facilityCodes []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.facilityCodes = &facilityCodes
	return r
}

// Facility Code.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) FacilityCodesDescription(facilityCodesDescription []string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.facilityCodesDescription = &facilityCodesDescription
	return r
}

// Signifies the quantity.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) FacilityCodesQuantity(facilityCodesQuantity []int32) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.facilityCodesQuantity = &facilityCodesQuantity
	return r
}

// External system code.
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteReservationHousekeepingTasksRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteReservationHousekeepingTasksExecute(r)
}

/*
DeleteReservationHousekeepingTasks Delete reservation housekeeping task

This API will allow you to delete reservation housekeeping task. <p><strong>OperationId:</strong>deleteReservationHousekeepingTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiDeleteReservationHousekeepingTasksRequest
*/
func (a *HousekeepingApiService) DeleteReservationHousekeepingTasks(ctx context.Context, reservationId string, hotelId string) HousekeepingApiDeleteReservationHousekeepingTasksRequest {
	return HousekeepingApiDeleteReservationHousekeepingTasksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteReservationHousekeepingTasksExecute(r HousekeepingApiDeleteReservationHousekeepingTasksRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteReservationHousekeepingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingTaskSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.customized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customized", r.customized, "")
	}
	if r.cycleStartDay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cycleStartDay", r.cycleStartDay, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.facilityTaskCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facilityTaskCode", r.facilityTaskCode, "")
	}
	if r.facilityTaskDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facilityTaskDescription", r.facilityTaskDescription, "")
	}
	if r.facilityTaskPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facilityTaskPriority", r.facilityTaskPriority, "")
	}
	if r.taskDate != nil {
		t := *r.taskDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskDate", t, "multi")
		}
	}
	if r.taskStartDate != nil {
		t := *r.taskStartDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskStartDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskStartDate", t, "multi")
		}
	}
	if r.taskEndDate != nil {
		t := *r.taskEndDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskEndDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskEndDate", t, "multi")
		}
	}
	if r.stayPeriod != nil {
		t := *r.stayPeriod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "stayPeriod", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "stayPeriod", t, "multi")
		}
	}
	if r.frequency != nil {
		t := *r.frequency
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", t, "multi")
		}
	}
	if r.taskCycleStartDay != nil {
		t := *r.taskCycleStartDay
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskCycleStartDay", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskCycleStartDay", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomId != nil {
		t := *r.roomId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", t, "multi")
		}
	}
	if r.facilityCodes != nil {
		t := *r.facilityCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facilityCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facilityCodes", t, "multi")
		}
	}
	if r.facilityCodesDescription != nil {
		t := *r.facilityCodesDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facilityCodesDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facilityCodesDescription", t, "multi")
		}
	}
	if r.facilityCodesQuantity != nil {
		t := *r.facilityCodesQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facilityCodesQuantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facilityCodesQuantity", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteRoomMaintenanceRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	mainteananceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteRoomMaintenanceRequest) Authorization(authorization string) HousekeepingApiDeleteRoomMaintenanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteRoomMaintenanceRequest) XAppKey(xAppKey string) HousekeepingApiDeleteRoomMaintenanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteRoomMaintenanceRequest) XHotelid(xHotelid string) HousekeepingApiDeleteRoomMaintenanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HousekeepingApiDeleteRoomMaintenanceRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteRoomMaintenanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteRoomMaintenanceRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteRoomMaintenanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteRoomMaintenanceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteRoomMaintenanceExecute(r)
}

/*
DeleteRoomMaintenance Delete the maintenances for rooms

Use this API to delete maintenances from rooms. <p><strong>OperationId:</strong>deleteRoomMaintenance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mainteananceId
 @param hotelId
 @return HousekeepingApiDeleteRoomMaintenanceRequest
*/
func (a *HousekeepingApiService) DeleteRoomMaintenance(ctx context.Context, mainteananceId string, hotelId string) HousekeepingApiDeleteRoomMaintenanceRequest {
	return HousekeepingApiDeleteRoomMaintenanceRequest{
		ApiService: a,
		ctx: ctx,
		mainteananceId: mainteananceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteRoomMaintenanceExecute(r HousekeepingApiDeleteRoomMaintenanceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteRoomMaintenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/maintenances/{mainteananceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mainteananceId"+"}", url.PathEscape(parameterValueToString(r.mainteananceId, "mainteananceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.mainteananceId) < 1 {
		return localVarReturnValue, nil, reportError("mainteananceId must have at least 1 elements")
	}
	if strlen(r.mainteananceId) > 2000 {
		return localVarReturnValue, nil, reportError("mainteananceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteTaskSheetRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	sheetNumber *int32
	taskCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	date *string
	xExternalsystem *string
	acceptLanguage *string
}

// The Task Sheet number. This will be a sequential number for the task sheets generated for a particular Task Code.
func (r HousekeepingApiDeleteTaskSheetRequest) SheetNumber(sheetNumber int32) HousekeepingApiDeleteTaskSheetRequest {
	r.sheetNumber = &sheetNumber
	return r
}

// The Code for the task.
func (r HousekeepingApiDeleteTaskSheetRequest) TaskCodes(taskCodes []string) HousekeepingApiDeleteTaskSheetRequest {
	r.taskCodes = &taskCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteTaskSheetRequest) Authorization(authorization string) HousekeepingApiDeleteTaskSheetRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteTaskSheetRequest) XAppKey(xAppKey string) HousekeepingApiDeleteTaskSheetRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteTaskSheetRequest) XHotelid(xHotelid string) HousekeepingApiDeleteTaskSheetRequest {
	r.xHotelid = &xHotelid
	return r
}

// The date for which the task sheet applies.
func (r HousekeepingApiDeleteTaskSheetRequest) Date(date string) HousekeepingApiDeleteTaskSheetRequest {
	r.date = &date
	return r
}

// External system code.
func (r HousekeepingApiDeleteTaskSheetRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteTaskSheetRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteTaskSheetRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteTaskSheetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteTaskSheetRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTaskSheetExecute(r)
}

/*
DeleteTaskSheet Delete the task sheet

This API allows you to delete the task sheet. <p><strong>OperationId:</strong>deleteTaskSheet</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiDeleteTaskSheetRequest
*/
func (a *HousekeepingApiService) DeleteTaskSheet(ctx context.Context, hotelId string) HousekeepingApiDeleteTaskSheetRequest {
	return HousekeepingApiDeleteTaskSheetRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteTaskSheetExecute(r HousekeepingApiDeleteTaskSheetRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteTaskSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sheetNumber", r.sheetNumber, "")
	{
		t := *r.taskCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", t, "multi")
		}
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteTaskSheetRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	sheetNumber *int32
	taskCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	date *string
	roomId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The Task Sheet number. This will be a sequential number for the task sheets generated for a particular Task Code.
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) SheetNumber(sheetNumber int32) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.sheetNumber = &sheetNumber
	return r
}

// The Code for the task.
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) TaskCodes(taskCodes []string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.taskCodes = &taskCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) Authorization(authorization string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) XAppKey(xAppKey string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) XHotelid(xHotelid string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The date for which the task sheet applies.
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) Date(date string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.date = &date
	return r
}

// Code of the room.
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) RoomId(roomId []string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.roomId = &roomId
	return r
}

// External system code.
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteTaskSheetRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteTaskSheetRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTaskSheetRoomsExecute(r)
}

/*
DeleteTaskSheetRooms Delete task sheet rooms

This API allows you to delete task sheet rooms. <p><strong>OperationId:</strong>deleteTaskSheetRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiDeleteTaskSheetRoomsRequest
*/
func (a *HousekeepingApiService) DeleteTaskSheetRooms(ctx context.Context, hotelId string) HousekeepingApiDeleteTaskSheetRoomsRequest {
	return HousekeepingApiDeleteTaskSheetRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteTaskSheetRoomsExecute(r HousekeepingApiDeleteTaskSheetRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteTaskSheetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sheetNumber", r.sheetNumber, "")
	{
		t := *r.taskCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", t, "multi")
		}
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.roomId != nil {
		t := *r.roomId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiDeleteTaskSheetTemplateRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	taskSheetTemplateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiDeleteTaskSheetTemplateRequest) Authorization(authorization string) HousekeepingApiDeleteTaskSheetTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiDeleteTaskSheetTemplateRequest) XAppKey(xAppKey string) HousekeepingApiDeleteTaskSheetTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiDeleteTaskSheetTemplateRequest) XHotelid(xHotelid string) HousekeepingApiDeleteTaskSheetTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HousekeepingApiDeleteTaskSheetTemplateRequest) XExternalsystem(xExternalsystem string) HousekeepingApiDeleteTaskSheetTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiDeleteTaskSheetTemplateRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiDeleteTaskSheetTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiDeleteTaskSheetTemplateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteTaskSheetTemplateExecute(r)
}

/*
DeleteTaskSheetTemplate Delete task sheet templates

This API allows you to delete task sheet templates. <p><strong>OperationId:</strong>deleteTaskSheetTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskSheetTemplateCode
 @param hotelId
 @return HousekeepingApiDeleteTaskSheetTemplateRequest
*/
func (a *HousekeepingApiService) DeleteTaskSheetTemplate(ctx context.Context, taskSheetTemplateCode string, hotelId string) HousekeepingApiDeleteTaskSheetTemplateRequest {
	return HousekeepingApiDeleteTaskSheetTemplateRequest{
		ApiService: a,
		ctx: ctx,
		taskSheetTemplateCode: taskSheetTemplateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) DeleteTaskSheetTemplateExecute(r HousekeepingApiDeleteTaskSheetTemplateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.DeleteTaskSheetTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheetTemplates/{taskSheetTemplateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskSheetTemplateCode"+"}", url.PathEscape(parameterValueToString(r.taskSheetTemplateCode, "taskSheetTemplateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskSheetTemplateCode) < 1 {
		return localVarReturnValue, nil, reportError("taskSheetTemplateCode must have at least 1 elements")
	}
	if strlen(r.taskSheetTemplateCode) > 2000 {
		return localVarReturnValue, nil, reportError("taskSheetTemplateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiEditReservationHousekeepingTasksRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	schedule *EditReservationHousekeepingTasksRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiEditReservationHousekeepingTasksRequest) Authorization(authorization string) HousekeepingApiEditReservationHousekeepingTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiEditReservationHousekeepingTasksRequest) XAppKey(xAppKey string) HousekeepingApiEditReservationHousekeepingTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiEditReservationHousekeepingTasksRequest) XHotelid(xHotelid string) HousekeepingApiEditReservationHousekeepingTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// A schedule with task(s) to be edited for the given reservation.
func (r HousekeepingApiEditReservationHousekeepingTasksRequest) Schedule(schedule EditReservationHousekeepingTasksRequest) HousekeepingApiEditReservationHousekeepingTasksRequest {
	r.schedule = &schedule
	return r
}

// External system code.
func (r HousekeepingApiEditReservationHousekeepingTasksRequest) XExternalsystem(xExternalsystem string) HousekeepingApiEditReservationHousekeepingTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiEditReservationHousekeepingTasksRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiEditReservationHousekeepingTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiEditReservationHousekeepingTasksRequest) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.EditReservationHousekeepingTasksExecute(r)
}

/*
EditReservationHousekeepingTasks Update reservation housekeeping tasks

This API will allow you to update reservation housekeeping tasks. <p><strong>OperationId:</strong>editReservationHousekeepingTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiEditReservationHousekeepingTasksRequest
*/
func (a *HousekeepingApiService) EditReservationHousekeepingTasks(ctx context.Context, reservationId string, hotelId string) HousekeepingApiEditReservationHousekeepingTasksRequest {
	return HousekeepingApiEditReservationHousekeepingTasksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Schedule
func (a *HousekeepingApiService) EditReservationHousekeepingTasksExecute(r HousekeepingApiEditReservationHousekeepingTasksRequest) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.EditReservationHousekeepingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingTaskSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.schedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiEndServiceBreakRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	taskSheetNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskRoom *CancelServicingTaskRoomRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiEndServiceBreakRequest) Authorization(authorization string) HousekeepingApiEndServiceBreakRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiEndServiceBreakRequest) XAppKey(xAppKey string) HousekeepingApiEndServiceBreakRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiEndServiceBreakRequest) XHotelid(xHotelid string) HousekeepingApiEndServiceBreakRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to end service break.
func (r HousekeepingApiEndServiceBreakRequest) TaskRoom(taskRoom CancelServicingTaskRoomRequest) HousekeepingApiEndServiceBreakRequest {
	r.taskRoom = &taskRoom
	return r
}

// External system code.
func (r HousekeepingApiEndServiceBreakRequest) XExternalsystem(xExternalsystem string) HousekeepingApiEndServiceBreakRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiEndServiceBreakRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiEndServiceBreakRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiEndServiceBreakRequest) Execute() (*EndedServiceBreak, *http.Response, error) {
	return r.ApiService.EndServiceBreakExecute(r)
}

/*
EndServiceBreak End the service break

This API allows you to end the Attendant's service break. <p><strong>OperationId:</strong>endServiceBreak</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskSheetNumber
 @param hotelId
 @return HousekeepingApiEndServiceBreakRequest
*/
func (a *HousekeepingApiService) EndServiceBreak(ctx context.Context, taskSheetNumber string, hotelId string) HousekeepingApiEndServiceBreakRequest {
	return HousekeepingApiEndServiceBreakRequest{
		ApiService: a,
		ctx: ctx,
		taskSheetNumber: taskSheetNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EndedServiceBreak
func (a *HousekeepingApiService) EndServiceBreakExecute(r HousekeepingApiEndServiceBreakRequest) (*EndedServiceBreak, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndedServiceBreak
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.EndServiceBreak")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/{taskSheetNumber}/end"
	localVarPath = strings.Replace(localVarPath, "{"+"taskSheetNumber"+"}", url.PathEscape(parameterValueToString(r.taskSheetNumber, "taskSheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskSheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("taskSheetNumber must have at least 1 elements")
	}
	if strlen(r.taskSheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("taskSheetNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetFacilityForecastRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	startDate *string
	endDate *string
	duration *string
	codes *[]string
	usePriority *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetFacilityForecastRequest) Authorization(authorization string) HousekeepingApiGetFacilityForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetFacilityForecastRequest) XAppKey(xAppKey string) HousekeepingApiGetFacilityForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetFacilityForecastRequest) XHotelid(xHotelid string) HousekeepingApiGetFacilityForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiGetFacilityForecastRequest) StartDate(startDate string) HousekeepingApiGetFacilityForecastRequest {
	r.startDate = &startDate
	return r
}

func (r HousekeepingApiGetFacilityForecastRequest) EndDate(endDate string) HousekeepingApiGetFacilityForecastRequest {
	r.endDate = &endDate
	return r
}

func (r HousekeepingApiGetFacilityForecastRequest) Duration(duration string) HousekeepingApiGetFacilityForecastRequest {
	r.duration = &duration
	return r
}

func (r HousekeepingApiGetFacilityForecastRequest) Codes(codes []string) HousekeepingApiGetFacilityForecastRequest {
	r.codes = &codes
	return r
}

// .
func (r HousekeepingApiGetFacilityForecastRequest) UsePriority(usePriority bool) HousekeepingApiGetFacilityForecastRequest {
	r.usePriority = &usePriority
	return r
}

// External system code.
func (r HousekeepingApiGetFacilityForecastRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetFacilityForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetFacilityForecastRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetFacilityForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetFacilityForecastRequest) Execute() (*FacilityForecast, *http.Response, error) {
	return r.ApiService.GetFacilityForecastExecute(r)
}

/*
GetFacilityForecast Get facility forecast

This API will allow you to get facility forecast for Housekeeping attendants and tasks for a current or future start date . <p><strong>OperationId:</strong>getFacilityForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetFacilityForecastRequest
*/
func (a *HousekeepingApiService) GetFacilityForecast(ctx context.Context, hotelId string) HousekeepingApiGetFacilityForecastRequest {
	return HousekeepingApiGetFacilityForecastRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FacilityForecast
func (a *HousekeepingApiService) GetFacilityForecastExecute(r HousekeepingApiGetFacilityForecastRequest) (*FacilityForecast, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FacilityForecast
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetFacilityForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/forecastTaskSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	}
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "Codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "Codes", t, "multi")
		}
	}
	if r.usePriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usePriority", r.usePriority, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetGuestHousekeepingNotesRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	room *string
	housekeepingInstruction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) Authorization(authorization string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) XAppKey(xAppKey string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) XHotelid(xHotelid string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) ReservationIdContext(reservationIdContext string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) ReservationIdType(reservationIdType string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Room to which housekeeping record belongs.
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) Room(room string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.room = &room
	return r
}

// Simple type for housekeeping instructions that can be used in requests for partial operations.
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) HousekeepingInstruction(housekeepingInstruction []string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.housekeepingInstruction = &housekeepingInstruction
	return r
}

// External system code.
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetGuestHousekeepingNotesRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetGuestHousekeepingNotesRequest) Execute() (*GuestHousekeepingInstructions, *http.Response, error) {
	return r.ApiService.GetGuestHousekeepingNotesExecute(r)
}

/*
GetGuestHousekeepingNotes Get the guest housekeeping instructions

This API will allow you to get the guest housekeeping instructions. <p><strong>OperationId:</strong>getGuestHousekeepingNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiGetGuestHousekeepingNotesRequest
*/
func (a *HousekeepingApiService) GetGuestHousekeepingNotes(ctx context.Context, reservationId string, hotelId string) HousekeepingApiGetGuestHousekeepingNotesRequest {
	return HousekeepingApiGetGuestHousekeepingNotesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestHousekeepingInstructions
func (a *HousekeepingApiService) GetGuestHousekeepingNotesExecute(r HousekeepingApiGetGuestHousekeepingNotesRequest) (*GuestHousekeepingInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestHousekeepingInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetGuestHousekeepingNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingNotes"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	if r.housekeepingInstruction != nil {
		t := *r.housekeepingInstruction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingInstruction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingInstruction", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHouseKeepingTasksRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	taskDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	attendantInRoomOnly *bool
	generateCleaningSequence *bool
	includeReservationInfo *bool
	includeTaskSheetDetails *bool
	includeTaskSheetsSummary *bool
	sortByCleaningSequence *bool
	taskCodes *[]string
	taskHotelCodes *[]string
	taskSequences *[]int32
	taskDescriptions *[]string
	taskInstructions *[]string
	facilityDepartureTask *[]bool
	linenChange *[]bool
	taskCodesBreakOutId *string
	taskCodesBreakOutIdContext *string
	taskCodesBreakOutIdType *string
	attendantId *string
	taskSheetNumber *[]int32
	housekeepingRoomStatus *[]string
	guestService *[]string
	roomStatusToChange *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Date for which the Task Assignment information is required.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskDate(taskDate string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskDate = &taskDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHouseKeepingTasksRequest) Authorization(authorization string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetHouseKeepingTasksRequest) XAppKey(xAppKey string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHouseKeepingTasksRequest) XHotelid(xHotelid string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// Query only rooms with attendant working in them.
func (r HousekeepingApiGetHouseKeepingTasksRequest) AttendantInRoomOnly(attendantInRoomOnly bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.attendantInRoomOnly = &attendantInRoomOnly
	return r
}

// Setting this to true will generate a sequence based on the current condition of the room for cleaning. This sequence would be the same sequence with which the Task Companion works.
func (r HousekeepingApiGetHouseKeepingTasksRequest) GenerateCleaningSequence(generateCleaningSequence bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.generateCleaningSequence = &generateCleaningSequence
	return r
}

// Setting this to true will include reservation information associated to the room.
func (r HousekeepingApiGetHouseKeepingTasksRequest) IncludeReservationInfo(includeReservationInfo bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.includeReservationInfo = &includeReservationInfo
	return r
}

// This will include room details for the Task Sheets. If summary information is only required, then this could be set to false. If a Task Sheet Number is included in the Search and this flag is set to true, then the details for that particular Task Sheet will be returned. For all other task sheets, the IncludeTaskSheetsSummary will determine if Summary details are required or not.
func (r HousekeepingApiGetHouseKeepingTasksRequest) IncludeTaskSheetDetails(includeTaskSheetDetails bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.includeTaskSheetDetails = &includeTaskSheetDetails
	return r
}

// Setting this to true, will return Summary information for the task sheets required. If a Task Sheet Number is included in the Search and IncludeTaskSheetDetails is set to false and IncludeTaskSheetsSummary is false, then only the Summary information for that particular task sheet will be returned. IncludeTaskSheetDetails &#x3D; True, IncludeTaskSheetsSummary &#x3D; True : includes all task sheets details and summary IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; True : includes only summary IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; false, Task Sheet No &#x3D;null : no task sheet detail or summary for any of the tasksheets. Returns the Task Assignnment header. IncludeTaskSheetDetails &#x3D; True, IncludeTaskSheetsSummary &#x3D; True, Task Sheet No &#x3D; XX : includes task sheets detail for XX and summary for others. IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; True, Task Sheet No &#x3D; XX : includes summary for all including XX. IncludeTaskSheetDetails &#x3D; false, IncludeTaskSheetsSummary &#x3D; false, Task Sheet No &#x3D; XX : includes summary for XX. No information for others.
func (r HousekeepingApiGetHouseKeepingTasksRequest) IncludeTaskSheetsSummary(includeTaskSheetsSummary bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.includeTaskSheetsSummary = &includeTaskSheetsSummary
	return r
}

// The rooms in the task sheet would be sorted with the cleaning sequence. The normal sort would be done based on the Default Sequence.
func (r HousekeepingApiGetHouseKeepingTasksRequest) SortByCleaningSequence(sortByCleaningSequence bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.sortByCleaningSequence = &sortByCleaningSequence
	return r
}

// The Code for the task.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodes(taskCodes []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodes = &taskCodes
	return r
}

// Property for which the Task Assignment information is required.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskHotelCodes(taskHotelCodes []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskHotelCodes = &taskHotelCodes
	return r
}

// Ordering sequence for display.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskSequences(taskSequences []int32) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskSequences = &taskSequences
	return r
}

// Description of the Task Code.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskDescriptions(taskDescriptions []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskDescriptions = &taskDescriptions
	return r
}

// Instructions for this Task Code.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskInstructions(taskInstructions []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskInstructions = &taskInstructions
	return r
}

// Indicates if this task code is the default departure task for Facility Tasks. This requires
func (r HousekeepingApiGetHouseKeepingTasksRequest) FacilityDepartureTask(facilityDepartureTask []bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.facilityDepartureTask = &facilityDepartureTask
	return r
}

// Indicates if a linen change is necessary.
func (r HousekeepingApiGetHouseKeepingTasksRequest) LinenChange(linenChange []bool) HousekeepingApiGetHouseKeepingTasksRequest {
	r.linenChange = &linenChange
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodesBreakOutId(taskCodesBreakOutId string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodesBreakOutId = &taskCodesBreakOutId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodesBreakOutIdContext(taskCodesBreakOutIdContext string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodesBreakOutIdContext = &taskCodesBreakOutIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskCodesBreakOutIdType(taskCodesBreakOutIdType string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskCodesBreakOutIdType = &taskCodesBreakOutIdType
	return r
}

// Attendant ID for which the Task Sheets are assigned.
func (r HousekeepingApiGetHouseKeepingTasksRequest) AttendantId(attendantId string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.attendantId = &attendantId
	return r
}

// Specific Task Sheet number for which the information is required.
func (r HousekeepingApiGetHouseKeepingTasksRequest) TaskSheetNumber(taskSheetNumber []int32) HousekeepingApiGetHouseKeepingTasksRequest {
	r.taskSheetNumber = &taskSheetNumber
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHouseKeepingTasksRequest) HousekeepingRoomStatus(housekeepingRoomStatus []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.housekeepingRoomStatus = &housekeepingRoomStatus
	return r
}

// Possible values for the Guest Service Status.
func (r HousekeepingApiGetHouseKeepingTasksRequest) GuestService(guestService []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.guestService = &guestService
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHouseKeepingTasksRequest) RoomStatusToChange(roomStatusToChange []string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.roomStatusToChange = &roomStatusToChange
	return r
}

// External system code.
func (r HousekeepingApiGetHouseKeepingTasksRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHouseKeepingTasksRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHouseKeepingTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHouseKeepingTasksRequest) Execute() (*TaskAssignment, *http.Response, error) {
	return r.ApiService.GetHouseKeepingTasksExecute(r)
}

/*
GetHouseKeepingTasks Get the existing task sheets

This API will allow you to get the existing task sheets. <p><strong>OperationId:</strong>getHouseKeepingTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetHouseKeepingTasksRequest
*/
func (a *HousekeepingApiService) GetHouseKeepingTasks(ctx context.Context, hotelId string) HousekeepingApiGetHouseKeepingTasksRequest {
	return HousekeepingApiGetHouseKeepingTasksRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TaskAssignment
func (a *HousekeepingApiService) GetHouseKeepingTasksExecute(r HousekeepingApiGetHouseKeepingTasksRequest) (*TaskAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHouseKeepingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/houseKeepingtasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "taskDate", r.taskDate, "")
	if r.attendantInRoomOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attendantInRoomOnly", r.attendantInRoomOnly, "")
	}
	if r.generateCleaningSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateCleaningSequence", r.generateCleaningSequence, "")
	}
	if r.includeReservationInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReservationInfo", r.includeReservationInfo, "")
	}
	if r.includeTaskSheetDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTaskSheetDetails", r.includeTaskSheetDetails, "")
	}
	if r.includeTaskSheetsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTaskSheetsSummary", r.includeTaskSheetsSummary, "")
	}
	if r.sortByCleaningSequence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortByCleaningSequence", r.sortByCleaningSequence, "")
	}
	if r.taskCodes != nil {
		t := *r.taskCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", t, "multi")
		}
	}
	if r.taskHotelCodes != nil {
		t := *r.taskHotelCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskHotelCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskHotelCodes", t, "multi")
		}
	}
	if r.taskSequences != nil {
		t := *r.taskSequences
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskSequences", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskSequences", t, "multi")
		}
	}
	if r.taskDescriptions != nil {
		t := *r.taskDescriptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskDescriptions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskDescriptions", t, "multi")
		}
	}
	if r.taskInstructions != nil {
		t := *r.taskInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskInstructions", t, "multi")
		}
	}
	if r.facilityDepartureTask != nil {
		t := *r.facilityDepartureTask
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "facilityDepartureTask", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "facilityDepartureTask", t, "multi")
		}
	}
	if r.linenChange != nil {
		t := *r.linenChange
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "linenChange", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "linenChange", t, "multi")
		}
	}
	if r.taskCodesBreakOutId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodesBreakOutId", r.taskCodesBreakOutId, "")
	}
	if r.taskCodesBreakOutIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodesBreakOutIdContext", r.taskCodesBreakOutIdContext, "")
	}
	if r.taskCodesBreakOutIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodesBreakOutIdType", r.taskCodesBreakOutIdType, "")
	}
	if r.attendantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attendantId", r.attendantId, "")
	}
	if r.taskSheetNumber != nil {
		t := *r.taskSheetNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskSheetNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskSheetNumber", t, "multi")
		}
	}
	if r.housekeepingRoomStatus != nil {
		t := *r.housekeepingRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", t, "multi")
		}
	}
	if r.guestService != nil {
		t := *r.guestService
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestService", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestService", t, "multi")
		}
	}
	if r.roomStatusToChange != nil {
		t := *r.roomStatusToChange
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatusToChange", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatusToChange", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingAttendantsScheduleRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	scheduleStartDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	scheduleEndDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// The starting value of the date range.
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) ScheduleStartDate(scheduleStartDate string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.scheduleStartDate = &scheduleStartDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) ScheduleEndDate(scheduleEndDate string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.scheduleEndDate = &scheduleEndDate
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) Execute() (*AttendantSchedule, *http.Response, error) {
	return r.ApiService.GetHousekeepingAttendantsScheduleExecute(r)
}

/*
GetHousekeepingAttendantsSchedule Get the housekeeping attendants schedule

This API will allow you to get the housekeeping attendants schedule. <p><strong>OperationId:</strong>getHousekeepingAttendantsSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetHousekeepingAttendantsScheduleRequest
*/
func (a *HousekeepingApiService) GetHousekeepingAttendantsSchedule(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingAttendantsScheduleRequest {
	return HousekeepingApiGetHousekeepingAttendantsScheduleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return AttendantSchedule
func (a *HousekeepingApiService) GetHousekeepingAttendantsScheduleExecute(r HousekeepingApiGetHousekeepingAttendantsScheduleRequest) (*AttendantSchedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttendantSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingAttendantsSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/attendants/houseKeepingTasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleStartDate", r.scheduleStartDate, "")
	if r.scheduleEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleEndDate", r.scheduleEndDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingDiscrepanciesRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomDiscrepancyStatus *[]string
	fromRoomNumber *string
	toRoomNumber *string
	roomClass *[]string
	housekeepingEndDate *string
	housekeepingStartDate *string
	floor *[]string
	dueOut *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Simple type for discrepant room status instructions to be used in requests for fetching housekeeping and front office room discrepancy. Valid values are Sleep, Skip, Person Discrepancy, Due Out Only.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) RoomDiscrepancyStatus(roomDiscrepancyStatus []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.roomDiscrepancyStatus = &roomDiscrepancyStatus
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

// Room Class of the Room.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) RoomClass(roomClass []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.roomClass = &roomClass
	return r
}

// The ending value of the date range.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) HousekeepingEndDate(housekeepingEndDate string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.housekeepingEndDate = &housekeepingEndDate
	return r
}

// The starting value of the date range.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) HousekeepingStartDate(housekeepingStartDate string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.housekeepingStartDate = &housekeepingStartDate
	return r
}

// The floor of room to be fetched.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Floor(floor []string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.floor = &floor
	return r
}

// List the rooms based on the flag DUE OUT for departure only.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) DueOut(dueOut bool) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.dueOut = &dueOut
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingDiscrepanciesRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetHousekeepingDiscrepanciesExecute(r)
}

/*
GetHousekeepingDiscrepancies Get hotel housekeeping discrepant rooms

Use this API to return the current housekeeping discrepant rooms for a specific property based on search parameters such as roomDiscrepancyStatus, roomClass, floor, dueOut, etc. These are rooms where the housekeeping status does not match the front office status.<p><strong>OperationId:</strong>getHousekeepingDiscrepancies</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetHousekeepingDiscrepanciesRequest
*/
func (a *HousekeepingApiService) GetHousekeepingDiscrepancies(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingDiscrepanciesRequest {
	return HousekeepingApiGetHousekeepingDiscrepanciesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetHousekeepingDiscrepanciesExecute(r HousekeepingApiGetHousekeepingDiscrepanciesRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingDiscrepancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingDiscrepancies"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomDiscrepancyStatus != nil {
		t := *r.roomDiscrepancyStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomDiscrepancyStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomDiscrepancyStatus", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.housekeepingEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingEndDate", r.housekeepingEndDate, "")
	}
	if r.housekeepingStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingStartDate", r.housekeepingStartDate, "")
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.dueOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dueOut", r.dueOut, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetHousekeepingOverviewRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	housekeepingRoomStatus *[]string
	frontOfficeRoomStatus *[]string
	turndownStatus *[]string
	roomParityStatus *[]string
	serviceRequestStatus *[]string
	roomAssignmentStatus *[]string
	fetchInstructions *[]string
	fromRoomNumber *string
	toRoomNumber *string
	floor *[]string
	roomType *[]string
	roomClass *[]string
	building *[]string
	roomFeatures *[]string
	daySection *[]string
	eveningSection *[]string
	reservationStatus *[]string
	guestServiceRequest *string
	roomIdText *string
	excludeCombo *bool
	cleaningPriorityOnly *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetHousekeepingOverviewRequest) Authorization(authorization string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetHousekeepingOverviewRequest) XAppKey(xAppKey string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetHousekeepingOverviewRequest) XHotelid(xHotelid string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Limit(limit int32) HousekeepingApiGetHousekeepingOverviewRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Offset(offset int32) HousekeepingApiGetHousekeepingOverviewRequest {
	r.offset = &offset
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetHousekeepingOverviewRequest) HousekeepingRoomStatus(housekeepingRoomStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.housekeepingRoomStatus = &housekeepingRoomStatus
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r HousekeepingApiGetHousekeepingOverviewRequest) FrontOfficeRoomStatus(frontOfficeRoomStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.frontOfficeRoomStatus = &frontOfficeRoomStatus
	return r
}

// Simple type for turndown status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Required, Not Required and Completed.
func (r HousekeepingApiGetHousekeepingOverviewRequest) TurndownStatus(turndownStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.turndownStatus = &turndownStatus
	return r
}

// Simple type for room parity instructions to be used in requests for fetching housekeeping rooms. Valid status values are Odd and Even.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomParityStatus(roomParityStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomParityStatus = &roomParityStatus
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) ServiceRequestStatus(serviceRequestStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.serviceRequestStatus = &serviceRequestStatus
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomAssignmentStatus(roomAssignmentStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomAssignmentStatus = &roomAssignmentStatus
	return r
}

// Simple type for housekeeping instructions that can be used in requests for partial operations.
func (r HousekeepingApiGetHousekeepingOverviewRequest) FetchInstructions(fetchInstructions []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

// The floor of room to be fetched.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Floor(floor []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.floor = &floor
	return r
}

// Room Type of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomType(roomType []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomType = &roomType
	return r
}

// Room Class of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomClass(roomClass []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomClass = &roomClass
	return r
}

// Building of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) Building(building []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.building = &building
	return r
}

// Features of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomFeatures(roomFeatures []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomFeatures = &roomFeatures
	return r
}

// AM Sections of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) DaySection(daySection []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.daySection = &daySection
	return r
}

// PM Sections of the Room.
func (r HousekeepingApiGetHousekeepingOverviewRequest) EveningSection(eveningSection []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.eveningSection = &eveningSection
	return r
}

// The status of the reservation to which this Room is assigned.
func (r HousekeepingApiGetHousekeepingOverviewRequest) ReservationStatus(reservationStatus []string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.reservationStatus = &reservationStatus
	return r
}

// Possible values for the Guest Service Status.
func (r HousekeepingApiGetHousekeepingOverviewRequest) GuestServiceRequest(guestServiceRequest string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.guestServiceRequest = &guestServiceRequest
	return r
}

// Wild Card entry for Room numbers to be Fetched.
func (r HousekeepingApiGetHousekeepingOverviewRequest) RoomIdText(roomIdText string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.roomIdText = &roomIdText
	return r
}

// Indicates we need to exclude the combo rooms while fetching the housekeeping details.
func (r HousekeepingApiGetHousekeepingOverviewRequest) ExcludeCombo(excludeCombo bool) HousekeepingApiGetHousekeepingOverviewRequest {
	r.excludeCombo = &excludeCombo
	return r
}

// Determines whether fetching cleaning priority rooms only.
func (r HousekeepingApiGetHousekeepingOverviewRequest) CleaningPriorityOnly(cleaningPriorityOnly bool) HousekeepingApiGetHousekeepingOverviewRequest {
	r.cleaningPriorityOnly = &cleaningPriorityOnly
	return r
}

// External system code.
func (r HousekeepingApiGetHousekeepingOverviewRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetHousekeepingOverviewRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetHousekeepingOverviewRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetHousekeepingOverviewRequest) Execute() (*HousekeepingBoard, *http.Response, error) {
	return r.ApiService.GetHousekeepingOverviewExecute(r)
}

/*
GetHousekeepingOverview Get housekeeping rooms overview

Use this API to return the status of rooms for a specific property based on search criteria such as hotelId, limit, housekeepingRoomStatus, frontOfficeRoomStatus, roomAssignmentStatus, roomType, roomFeatures. The results will give you a list of rooms, and their current housekeeping details.  You could then go ahead and update any of these rooms by using postOutOfOrderRoom for example. <p><strong>OperationId:</strong>getHousekeepingOverview</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Housekeeping overview needs to be fetched
 @return HousekeepingApiGetHousekeepingOverviewRequest
*/
func (a *HousekeepingApiService) GetHousekeepingOverview(ctx context.Context, hotelId string) HousekeepingApiGetHousekeepingOverviewRequest {
	return HousekeepingApiGetHousekeepingOverviewRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingBoard
func (a *HousekeepingApiService) GetHousekeepingOverviewExecute(r HousekeepingApiGetHousekeepingOverviewRequest) (*HousekeepingBoard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingBoard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetHousekeepingOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingOverview"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.housekeepingRoomStatus != nil {
		t := *r.housekeepingRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", t, "multi")
		}
	}
	if r.frontOfficeRoomStatus != nil {
		t := *r.frontOfficeRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", t, "multi")
		}
	}
	if r.turndownStatus != nil {
		t := *r.turndownStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "turndownStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "turndownStatus", t, "multi")
		}
	}
	if r.roomParityStatus != nil {
		t := *r.roomParityStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", t, "multi")
		}
	}
	if r.serviceRequestStatus != nil {
		t := *r.serviceRequestStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRequestStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serviceRequestStatus", t, "multi")
		}
	}
	if r.roomAssignmentStatus != nil {
		t := *r.roomAssignmentStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", t, "multi")
		}
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.floor != nil {
		t := *r.floor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floor", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floor", t, "multi")
		}
	}
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
	}
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
	}
	if r.building != nil {
		t := *r.building
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "building", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "building", t, "multi")
		}
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.daySection != nil {
		t := *r.daySection
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daySection", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daySection", t, "multi")
		}
	}
	if r.eveningSection != nil {
		t := *r.eveningSection
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eveningSection", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eveningSection", t, "multi")
		}
	}
	if r.reservationStatus != nil {
		t := *r.reservationStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatus", t, "multi")
		}
	}
	if r.guestServiceRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestServiceRequest", r.guestServiceRequest, "")
	}
	if r.roomIdText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomIdText", r.roomIdText, "")
	}
	if r.excludeCombo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCombo", r.excludeCombo, "")
	}
	if r.cleaningPriorityOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cleaningPriorityOnly", r.cleaningPriorityOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomId *string
	endDate *string
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The start date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) StartDate(startDate string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// From this Room number onwards to be Fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomId(roomId string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomId = &roomId
	return r
}

// The end date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) EndDate(endDate string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.endDate = &endDate
	return r
}

// The room type of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomTypes = &roomTypes
	return r
}

// The room class of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r HousekeepingApiGetOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetOutOfOrderRoomsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetOutOfOrderRoomsExecute(r)
}

/*
GetOutOfOrderRooms Get Out of Order Rooms

Use this API to get a list of rooms for a hotel that are Out of Order.  You can narrow down your results with search criteria such as Room class, Room Type, date range. <p><strong>OperationId:</strong>getOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Order rooms needs to be fetched.
 @return HousekeepingApiGetOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) GetOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiGetOutOfOrderRoomsRequest {
	return HousekeepingApiGetOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetOutOfOrderRoomsExecute(r HousekeepingApiGetOutOfOrderRoomsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	startDate *string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomId *string
	endDate *string
	roomTypes *[]string
	roomClasses *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// The start date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) StartDate(startDate string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.startDate = &startDate
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// From this Room number onwards to be Fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomId(roomId string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomId = &roomId
	return r
}

// The end date for which the out of order / out of service rooms are to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) EndDate(endDate string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.endDate = &endDate
	return r
}

// The room type of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomTypes = &roomTypes
	return r
}

// The room class of out of order / out of service rooms to be fetched.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.roomClasses = &roomClasses
	return r
}

// External system code.
func (r HousekeepingApiGetOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetOutOfServiceRoomsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetOutOfServiceRoomsExecute(r)
}

/*
GetOutOfServiceRooms Get Out of Service Rooms

Use this API to get a list of rooms for a hotel that are Out of Service.  You can narrow down your results with search criteria such as Room class, Room Type, date range. <p><strong>OperationId:</strong>getOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which Out Of Service rooms needs to be fetched.
 @return HousekeepingApiGetOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) GetOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiGetOutOfServiceRoomsRequest {
	return HousekeepingApiGetOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetOutOfServiceRoomsExecute(r HousekeepingApiGetOutOfServiceRoomsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetReservationHousekeepingScheduleRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reservationIdContext *string
	reservationIdType *string
	beginDate *string
	endDate *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) Authorization(authorization string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) XAppKey(xAppKey string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) XHotelid(xHotelid string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) ReservationIdContext(reservationIdContext string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) ReservationIdType(reservationIdType string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.reservationIdType = &reservationIdType
	return r
}

// Begin date from which to start fetching facility tasks.
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) BeginDate(beginDate string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.beginDate = &beginDate
	return r
}

// End date for facility task schedule request.
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) EndDate(endDate string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.endDate = &endDate
	return r
}

// Simple type for controlling the fetch operations of the housekeeping schedule request.
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) FetchInstructions(fetchInstructions []string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetReservationHousekeepingScheduleRequest) Execute() (*Schedule, *http.Response, error) {
	return r.ApiService.GetReservationHousekeepingScheduleExecute(r)
}

/*
GetReservationHousekeepingSchedule Get reservation housekeeping schedule

This API will allow you to get reservation housekeeping schedule. <p><strong>OperationId:</strong>getReservationHousekeepingSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiGetReservationHousekeepingScheduleRequest
*/
func (a *HousekeepingApiService) GetReservationHousekeepingSchedule(ctx context.Context, reservationId string, hotelId string) HousekeepingApiGetReservationHousekeepingScheduleRequest {
	return HousekeepingApiGetReservationHousekeepingScheduleRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Schedule
func (a *HousekeepingApiService) GetReservationHousekeepingScheduleExecute(r HousekeepingApiGetReservationHousekeepingScheduleRequest) (*Schedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Schedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetReservationHousekeepingSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingTaskSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdType", r.reservationIdType, "")
	}
	if r.beginDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beginDate", r.beginDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetRoomConditionsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomConditionsOnly *bool
	roomWithoutConditionsOnly *bool
	room *string
	fromRoomNumber *string
	toRoomNumber *string
	roomConditions *[]string
	roomTypes *[]string
	roomClasses *[]string
	frontOfficeRoomStatus *[]string
	reservationStatuses *[]string
	roomAssignmentStatus *[]string
	floors *[]string
	roomFeatures *[]string
	amSections *[]string
	pmSections *[]string
	buildings *[]string
	housekeepingRoomStatus *[]string
	roomParityStatus *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetRoomConditionsRequest) Authorization(authorization string) HousekeepingApiGetRoomConditionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetRoomConditionsRequest) XAppKey(xAppKey string) HousekeepingApiGetRoomConditionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetRoomConditionsRequest) XHotelid(xHotelid string) HousekeepingApiGetRoomConditionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Include rooms with conditions only.
func (r HousekeepingApiGetRoomConditionsRequest) RoomConditionsOnly(roomConditionsOnly bool) HousekeepingApiGetRoomConditionsRequest {
	r.roomConditionsOnly = &roomConditionsOnly
	return r
}

// Include rooms without conditions only.
func (r HousekeepingApiGetRoomConditionsRequest) RoomWithoutConditionsOnly(roomWithoutConditionsOnly bool) HousekeepingApiGetRoomConditionsRequest {
	r.roomWithoutConditionsOnly = &roomWithoutConditionsOnly
	return r
}

// Identifier of the room.
func (r HousekeepingApiGetRoomConditionsRequest) Room(room string) HousekeepingApiGetRoomConditionsRequest {
	r.room = &room
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) FromRoomNumber(fromRoomNumber string) HousekeepingApiGetRoomConditionsRequest {
	r.fromRoomNumber = &fromRoomNumber
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) ToRoomNumber(toRoomNumber string) HousekeepingApiGetRoomConditionsRequest {
	r.toRoomNumber = &toRoomNumber
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) RoomConditions(roomConditions []string) HousekeepingApiGetRoomConditionsRequest {
	r.roomConditions = &roomConditions
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) RoomTypes(roomTypes []string) HousekeepingApiGetRoomConditionsRequest {
	r.roomTypes = &roomTypes
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) RoomClasses(roomClasses []string) HousekeepingApiGetRoomConditionsRequest {
	r.roomClasses = &roomClasses
	return r
}

// Simple type for front office room status instructions to be used in requests for fetching housekeeping rooms. Valid values are Vacant and Occupied.
func (r HousekeepingApiGetRoomConditionsRequest) FrontOfficeRoomStatus(frontOfficeRoomStatus []string) HousekeepingApiGetRoomConditionsRequest {
	r.frontOfficeRoomStatus = &frontOfficeRoomStatus
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) ReservationStatuses(reservationStatuses []string) HousekeepingApiGetRoomConditionsRequest {
	r.reservationStatuses = &reservationStatuses
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) RoomAssignmentStatus(roomAssignmentStatus []string) HousekeepingApiGetRoomConditionsRequest {
	r.roomAssignmentStatus = &roomAssignmentStatus
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) Floors(floors []string) HousekeepingApiGetRoomConditionsRequest {
	r.floors = &floors
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) RoomFeatures(roomFeatures []string) HousekeepingApiGetRoomConditionsRequest {
	r.roomFeatures = &roomFeatures
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) AmSections(amSections []string) HousekeepingApiGetRoomConditionsRequest {
	r.amSections = &amSections
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) PmSections(pmSections []string) HousekeepingApiGetRoomConditionsRequest {
	r.pmSections = &pmSections
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) Buildings(buildings []string) HousekeepingApiGetRoomConditionsRequest {
	r.buildings = &buildings
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetRoomConditionsRequest) HousekeepingRoomStatus(housekeepingRoomStatus []string) HousekeepingApiGetRoomConditionsRequest {
	r.housekeepingRoomStatus = &housekeepingRoomStatus
	return r
}

// Simple type for room parity instructions to be used in requests for fetching housekeeping rooms. Valid status values are Odd and Even.
func (r HousekeepingApiGetRoomConditionsRequest) RoomParityStatus(roomParityStatus []string) HousekeepingApiGetRoomConditionsRequest {
	r.roomParityStatus = &roomParityStatus
	return r
}

// External system code.
func (r HousekeepingApiGetRoomConditionsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetRoomConditionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetRoomConditionsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetRoomConditionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetRoomConditionsRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetRoomConditionsExecute(r)
}

/*
GetRoomConditions Get rooms condition

This API will allow you to get a list of rooms that have a condition set. <p><strong>OperationId:</strong>getRoomConditions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetRoomConditionsRequest
*/
func (a *HousekeepingApiService) GetRoomConditions(ctx context.Context, hotelId string) HousekeepingApiGetRoomConditionsRequest {
	return HousekeepingApiGetRoomConditionsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Rooms
func (a *HousekeepingApiService) GetRoomConditionsExecute(r HousekeepingApiGetRoomConditionsRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetRoomConditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/conditions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomConditionsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomConditionsOnly", r.roomConditionsOnly, "")
	}
	if r.roomWithoutConditionsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomWithoutConditionsOnly", r.roomWithoutConditionsOnly, "")
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	if r.fromRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromRoomNumber", r.fromRoomNumber, "")
	}
	if r.toRoomNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toRoomNumber", r.toRoomNumber, "")
	}
	if r.roomConditions != nil {
		t := *r.roomConditions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomConditions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomConditions", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.frontOfficeRoomStatus != nil {
		t := *r.frontOfficeRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "frontOfficeRoomStatus", t, "multi")
		}
	}
	if r.reservationStatuses != nil {
		t := *r.reservationStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reservationStatuses", t, "multi")
		}
	}
	if r.roomAssignmentStatus != nil {
		t := *r.roomAssignmentStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomAssignmentStatus", t, "multi")
		}
	}
	if r.floors != nil {
		t := *r.floors
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floors", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floors", t, "multi")
		}
	}
	if r.roomFeatures != nil {
		t := *r.roomFeatures
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomFeatures", t, "multi")
		}
	}
	if r.amSections != nil {
		t := *r.amSections
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "amSections", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "amSections", t, "multi")
		}
	}
	if r.pmSections != nil {
		t := *r.pmSections
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pmSections", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pmSections", t, "multi")
		}
	}
	if r.buildings != nil {
		t := *r.buildings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "buildings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "buildings", t, "multi")
		}
	}
	if r.housekeepingRoomStatus != nil {
		t := *r.housekeepingRoomStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "housekeepingRoomStatus", t, "multi")
		}
	}
	if r.roomParityStatus != nil {
		t := *r.roomParityStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomParityStatus", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetRoomMaintenanceRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomIdText *string
	roomId *string
	roomClasses *[]string
	roomTypes *[]string
	maintenanceCodes *[]string
	roomMaintenanceStatus *string
	assignedUserId *[]string
	assignedUserIdContext *[]string
	assignedUserIdType *[]string
	maintenanceId *string
	maintenanceIdContext *string
	maintenanceIdType *string
	resolvedEndDate *string
	resolvedStartDate *string
	includeImages *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetRoomMaintenanceRequest) Authorization(authorization string) HousekeepingApiGetRoomMaintenanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetRoomMaintenanceRequest) XAppKey(xAppKey string) HousekeepingApiGetRoomMaintenanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetRoomMaintenanceRequest) XHotelid(xHotelid string) HousekeepingApiGetRoomMaintenanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Wildcard Room filter.
func (r HousekeepingApiGetRoomMaintenanceRequest) RoomIdText(roomIdText string) HousekeepingApiGetRoomMaintenanceRequest {
	r.roomIdText = &roomIdText
	return r
}

// Room Number filter.
func (r HousekeepingApiGetRoomMaintenanceRequest) RoomId(roomId string) HousekeepingApiGetRoomMaintenanceRequest {
	r.roomId = &roomId
	return r
}

func (r HousekeepingApiGetRoomMaintenanceRequest) RoomClasses(roomClasses []string) HousekeepingApiGetRoomMaintenanceRequest {
	r.roomClasses = &roomClasses
	return r
}

func (r HousekeepingApiGetRoomMaintenanceRequest) RoomTypes(roomTypes []string) HousekeepingApiGetRoomMaintenanceRequest {
	r.roomTypes = &roomTypes
	return r
}

func (r HousekeepingApiGetRoomMaintenanceRequest) MaintenanceCodes(maintenanceCodes []string) HousekeepingApiGetRoomMaintenanceRequest {
	r.maintenanceCodes = &maintenanceCodes
	return r
}

// Room Maintenance Status.
func (r HousekeepingApiGetRoomMaintenanceRequest) RoomMaintenanceStatus(roomMaintenanceStatus string) HousekeepingApiGetRoomMaintenanceRequest {
	r.roomMaintenanceStatus = &roomMaintenanceStatus
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r HousekeepingApiGetRoomMaintenanceRequest) AssignedUserId(assignedUserId []string) HousekeepingApiGetRoomMaintenanceRequest {
	r.assignedUserId = &assignedUserId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r HousekeepingApiGetRoomMaintenanceRequest) AssignedUserIdContext(assignedUserIdContext []string) HousekeepingApiGetRoomMaintenanceRequest {
	r.assignedUserIdContext = &assignedUserIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r HousekeepingApiGetRoomMaintenanceRequest) AssignedUserIdType(assignedUserIdType []string) HousekeepingApiGetRoomMaintenanceRequest {
	r.assignedUserIdType = &assignedUserIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r HousekeepingApiGetRoomMaintenanceRequest) MaintenanceId(maintenanceId string) HousekeepingApiGetRoomMaintenanceRequest {
	r.maintenanceId = &maintenanceId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r HousekeepingApiGetRoomMaintenanceRequest) MaintenanceIdContext(maintenanceIdContext string) HousekeepingApiGetRoomMaintenanceRequest {
	r.maintenanceIdContext = &maintenanceIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r HousekeepingApiGetRoomMaintenanceRequest) MaintenanceIdType(maintenanceIdType string) HousekeepingApiGetRoomMaintenanceRequest {
	r.maintenanceIdType = &maintenanceIdType
	return r
}

// The ending value of the date range.
func (r HousekeepingApiGetRoomMaintenanceRequest) ResolvedEndDate(resolvedEndDate string) HousekeepingApiGetRoomMaintenanceRequest {
	r.resolvedEndDate = &resolvedEndDate
	return r
}

// The starting value of the date range.
func (r HousekeepingApiGetRoomMaintenanceRequest) ResolvedStartDate(resolvedStartDate string) HousekeepingApiGetRoomMaintenanceRequest {
	r.resolvedStartDate = &resolvedStartDate
	return r
}

// Indicator that tells whether to include Images in search results.
func (r HousekeepingApiGetRoomMaintenanceRequest) IncludeImages(includeImages bool) HousekeepingApiGetRoomMaintenanceRequest {
	r.includeImages = &includeImages
	return r
}

// External system code.
func (r HousekeepingApiGetRoomMaintenanceRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetRoomMaintenanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetRoomMaintenanceRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetRoomMaintenanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetRoomMaintenanceRequest) Execute() (*RoomMaintenanceDetails, *http.Response, error) {
	return r.ApiService.GetRoomMaintenanceExecute(r)
}

/*
GetRoomMaintenance Get the maintenance rooms

Use this API to get a list of rooms with maintenances. <p><strong>OperationId:</strong>getRoomMaintenance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiGetRoomMaintenanceRequest
*/
func (a *HousekeepingApiService) GetRoomMaintenance(ctx context.Context, hotelId string) HousekeepingApiGetRoomMaintenanceRequest {
	return HousekeepingApiGetRoomMaintenanceRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomMaintenanceDetails
func (a *HousekeepingApiService) GetRoomMaintenanceExecute(r HousekeepingApiGetRoomMaintenanceRequest) (*RoomMaintenanceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomMaintenanceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetRoomMaintenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/maintenances"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.roomIdText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomIdText", r.roomIdText, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.roomClasses != nil {
		t := *r.roomClasses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClasses", t, "multi")
		}
	}
	if r.roomTypes != nil {
		t := *r.roomTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypes", t, "multi")
		}
	}
	if r.maintenanceCodes != nil {
		t := *r.maintenanceCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "maintenanceCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "maintenanceCodes", t, "multi")
		}
	}
	if r.roomMaintenanceStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomMaintenanceStatus", r.roomMaintenanceStatus, "")
	}
	if r.assignedUserId != nil {
		t := *r.assignedUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assignedUserId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assignedUserId", t, "multi")
		}
	}
	if r.assignedUserIdContext != nil {
		t := *r.assignedUserIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assignedUserIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assignedUserIdContext", t, "multi")
		}
	}
	if r.assignedUserIdType != nil {
		t := *r.assignedUserIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assignedUserIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assignedUserIdType", t, "multi")
		}
	}
	if r.maintenanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maintenanceId", r.maintenanceId, "")
	}
	if r.maintenanceIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maintenanceIdContext", r.maintenanceIdContext, "")
	}
	if r.maintenanceIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maintenanceIdType", r.maintenanceIdType, "")
	}
	if r.resolvedEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolvedEndDate", r.resolvedEndDate, "")
	}
	if r.resolvedStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolvedStartDate", r.resolvedStartDate, "")
	}
	if r.includeImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeImages", r.includeImages, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetTaskCompanionRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	hotelId string
	taskCodes *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskDate *string
	roomId *string
	skipRoomNumbers *[]string
	roomStatusToChange *[]string
	xExternalsystem *string
	acceptLanguage *string
}

func (r HousekeepingApiGetTaskCompanionRequest) TaskCodes(taskCodes []string) HousekeepingApiGetTaskCompanionRequest {
	r.taskCodes = &taskCodes
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetTaskCompanionRequest) Authorization(authorization string) HousekeepingApiGetTaskCompanionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetTaskCompanionRequest) XAppKey(xAppKey string) HousekeepingApiGetTaskCompanionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetTaskCompanionRequest) XHotelid(xHotelid string) HousekeepingApiGetTaskCompanionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Date for which the task sheet was created. By default this would be the current business date.
func (r HousekeepingApiGetTaskCompanionRequest) TaskDate(taskDate string) HousekeepingApiGetTaskCompanionRequest {
	r.taskDate = &taskDate
	return r
}

// Choice to search by a room number if a particular room is required.
func (r HousekeepingApiGetTaskCompanionRequest) RoomId(roomId string) HousekeepingApiGetTaskCompanionRequest {
	r.roomId = &roomId
	return r
}

// Room number that should be skipped.
func (r HousekeepingApiGetTaskCompanionRequest) SkipRoomNumbers(skipRoomNumbers []string) HousekeepingApiGetTaskCompanionRequest {
	r.skipRoomNumbers = &skipRoomNumbers
	return r
}

// Simple type for room status instructions to be used in requests for fetching housekeeping rooms. Valid status values are Clean, Dirty, Pickup, Inspected, OutOfOrder, OutOfService.
func (r HousekeepingApiGetTaskCompanionRequest) RoomStatusToChange(roomStatusToChange []string) HousekeepingApiGetTaskCompanionRequest {
	r.roomStatusToChange = &roomStatusToChange
	return r
}

// External system code.
func (r HousekeepingApiGetTaskCompanionRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetTaskCompanionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetTaskCompanionRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetTaskCompanionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetTaskCompanionRequest) Execute() (*TaskCompanion, *http.Response, error) {
	return r.ApiService.GetTaskCompanionExecute(r)
}

/*
GetTaskCompanion Get task companion

This API allows you to get task companion. <p><strong>OperationId:</strong>getTaskCompanion</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param hotelId
 @return HousekeepingApiGetTaskCompanionRequest
*/
func (a *HousekeepingApiService) GetTaskCompanion(ctx context.Context, sheetNumber string, hotelId string) HousekeepingApiGetTaskCompanionRequest {
	return HousekeepingApiGetTaskCompanionRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TaskCompanion
func (a *HousekeepingApiService) GetTaskCompanionExecute(r HousekeepingApiGetTaskCompanionRequest) (*TaskCompanion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskCompanion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetTaskCompanion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/sheets/{sheetNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.taskCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "taskCodes", t, "multi")
		}
	}
	if r.taskDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskDate", r.taskDate, "")
	}
	if r.roomId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", r.roomId, "")
	}
	if r.skipRoomNumbers != nil {
		t := *r.skipRoomNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "skipRoomNumbers", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "skipRoomNumbers", t, "multi")
		}
	}
	if r.roomStatusToChange != nil {
		t := *r.roomStatusToChange
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatusToChange", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomStatusToChange", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiGetTaskSheetTemplateRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	templateCode *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiGetTaskSheetTemplateRequest) Authorization(authorization string) HousekeepingApiGetTaskSheetTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiGetTaskSheetTemplateRequest) XAppKey(xAppKey string) HousekeepingApiGetTaskSheetTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiGetTaskSheetTemplateRequest) XHotelid(xHotelid string) HousekeepingApiGetTaskSheetTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Template name for the task sheet.
func (r HousekeepingApiGetTaskSheetTemplateRequest) TemplateCode(templateCode string) HousekeepingApiGetTaskSheetTemplateRequest {
	r.templateCode = &templateCode
	return r
}

// External system code.
func (r HousekeepingApiGetTaskSheetTemplateRequest) XExternalsystem(xExternalsystem string) HousekeepingApiGetTaskSheetTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiGetTaskSheetTemplateRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiGetTaskSheetTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiGetTaskSheetTemplateRequest) Execute() (*TaskSheetTemplate, *http.Response, error) {
	return r.ApiService.GetTaskSheetTemplateExecute(r)
}

/*
GetTaskSheetTemplate Get the task sheet templates

This API allows you to get the task sheet templates. <p><strong>OperationId:</strong>getTaskSheetTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which task sheet templates needs to be fetched
 @return HousekeepingApiGetTaskSheetTemplateRequest
*/
func (a *HousekeepingApiService) GetTaskSheetTemplate(ctx context.Context, hotelId string) HousekeepingApiGetTaskSheetTemplateRequest {
	return HousekeepingApiGetTaskSheetTemplateRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return TaskSheetTemplate
func (a *HousekeepingApiService) GetTaskSheetTemplateExecute(r HousekeepingApiGetTaskSheetTemplateRequest) (*TaskSheetTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskSheetTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.GetTaskSheetTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheetTemplates"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.templateCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateCode", r.templateCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiLockTaskSheetRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheetToLock *LockTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiLockTaskSheetRequest) Authorization(authorization string) HousekeepingApiLockTaskSheetRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiLockTaskSheetRequest) XAppKey(xAppKey string) HousekeepingApiLockTaskSheetRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiLockTaskSheetRequest) XHotelid(xHotelid string) HousekeepingApiLockTaskSheetRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for locking a task sheet.
func (r HousekeepingApiLockTaskSheetRequest) TaskSheetToLock(taskSheetToLock LockTaskSheetRequest) HousekeepingApiLockTaskSheetRequest {
	r.taskSheetToLock = &taskSheetToLock
	return r
}

// External system code.
func (r HousekeepingApiLockTaskSheetRequest) XExternalsystem(xExternalsystem string) HousekeepingApiLockTaskSheetRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiLockTaskSheetRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiLockTaskSheetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiLockTaskSheetRequest) Execute() (*LockedTaskSheet, *http.Response, error) {
	return r.ApiService.LockTaskSheetExecute(r)
}

/*
LockTaskSheet Lock the task sheet

This API allows you to Lock the task sheet. <p><strong>OperationId:</strong>lockTaskSheet</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param hotelId
 @return HousekeepingApiLockTaskSheetRequest
*/
func (a *HousekeepingApiService) LockTaskSheet(ctx context.Context, sheetNumber string, hotelId string) HousekeepingApiLockTaskSheetRequest {
	return HousekeepingApiLockTaskSheetRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return LockedTaskSheet
func (a *HousekeepingApiService) LockTaskSheetExecute(r HousekeepingApiLockTaskSheetRequest) (*LockedTaskSheet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LockedTaskSheet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.LockTaskSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/{sheetNumber}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheetToLock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiMergeTaskSheetRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	toTaskSequenceNo string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheetToMerge *MergeTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiMergeTaskSheetRequest) Authorization(authorization string) HousekeepingApiMergeTaskSheetRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiMergeTaskSheetRequest) XAppKey(xAppKey string) HousekeepingApiMergeTaskSheetRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiMergeTaskSheetRequest) XHotelid(xHotelid string) HousekeepingApiMergeTaskSheetRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for merging task sheets.
func (r HousekeepingApiMergeTaskSheetRequest) TaskSheetToMerge(taskSheetToMerge MergeTaskSheetRequest) HousekeepingApiMergeTaskSheetRequest {
	r.taskSheetToMerge = &taskSheetToMerge
	return r
}

// External system code.
func (r HousekeepingApiMergeTaskSheetRequest) XExternalsystem(xExternalsystem string) HousekeepingApiMergeTaskSheetRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiMergeTaskSheetRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiMergeTaskSheetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiMergeTaskSheetRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.MergeTaskSheetExecute(r)
}

/*
MergeTaskSheet Merge task sheet

This API allows you to merge task sheet. <p><strong>OperationId:</strong>mergeTaskSheet</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param toTaskSequenceNo
 @param hotelId
 @return HousekeepingApiMergeTaskSheetRequest
*/
func (a *HousekeepingApiService) MergeTaskSheet(ctx context.Context, toTaskSequenceNo string, hotelId string) HousekeepingApiMergeTaskSheetRequest {
	return HousekeepingApiMergeTaskSheetRequest{
		ApiService: a,
		ctx: ctx,
		toTaskSequenceNo: toTaskSequenceNo,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) MergeTaskSheetExecute(r HousekeepingApiMergeTaskSheetRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.MergeTaskSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/{toTaskSequenceNo}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"toTaskSequenceNo"+"}", url.PathEscape(parameterValueToString(r.toTaskSequenceNo, "toTaskSequenceNo")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.toTaskSequenceNo) < 1 {
		return localVarReturnValue, nil, reportError("toTaskSequenceNo must have at least 1 elements")
	}
	if strlen(r.toTaskSequenceNo) > 2000 {
		return localVarReturnValue, nil, reportError("toTaskSequenceNo must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheetToMerge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiMoveTaskRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	moveTaskRooms *MoveTaskRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiMoveTaskRoomsRequest) Authorization(authorization string) HousekeepingApiMoveTaskRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiMoveTaskRoomsRequest) XAppKey(xAppKey string) HousekeepingApiMoveTaskRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiMoveTaskRoomsRequest) XHotelid(xHotelid string) HousekeepingApiMoveTaskRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for moving rooms between task sheets.
func (r HousekeepingApiMoveTaskRoomsRequest) MoveTaskRooms(moveTaskRooms MoveTaskRoomsRequest) HousekeepingApiMoveTaskRoomsRequest {
	r.moveTaskRooms = &moveTaskRooms
	return r
}

// External system code.
func (r HousekeepingApiMoveTaskRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiMoveTaskRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiMoveTaskRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiMoveTaskRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiMoveTaskRoomsRequest) Execute() (*MovedTaskRoomsRS, *http.Response, error) {
	return r.ApiService.MoveTaskRoomsExecute(r)
}

/*
MoveTaskRooms Move the task rooms

This API will allow you to Move the tasksheet rooms. <p><strong>OperationId:</strong>moveTaskRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiMoveTaskRoomsRequest
*/
func (a *HousekeepingApiService) MoveTaskRooms(ctx context.Context, hotelId string) HousekeepingApiMoveTaskRoomsRequest {
	return HousekeepingApiMoveTaskRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MovedTaskRoomsRS
func (a *HousekeepingApiService) MoveTaskRoomsExecute(r HousekeepingApiMoveTaskRoomsRequest) (*MovedTaskRoomsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MovedTaskRoomsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.MoveTaskRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/moveTaskRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.moveTaskRooms
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostHousekeepingAttendantScheduleRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	attendantSchedule *PostHousekeepingAttendantScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) Authorization(authorization string) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) XAppKey(xAppKey string) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) XHotelid(xHotelid string) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for creating the attendant schedule.
func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) AttendantSchedule(attendantSchedule PostHousekeepingAttendantScheduleRequest) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	r.attendantSchedule = &attendantSchedule
	return r
}

// External system code.
func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostHousekeepingAttendantScheduleRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostHousekeepingAttendantScheduleExecute(r)
}

/*
PostHousekeepingAttendantSchedule Create housekeeping attendant schedule

This API will allow you to create housekeeping attendant schedule. <p><strong>OperationId:</strong>postHousekeepingAttendantSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiPostHousekeepingAttendantScheduleRequest
*/
func (a *HousekeepingApiService) PostHousekeepingAttendantSchedule(ctx context.Context, hotelId string) HousekeepingApiPostHousekeepingAttendantScheduleRequest {
	return HousekeepingApiPostHousekeepingAttendantScheduleRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostHousekeepingAttendantScheduleExecute(r HousekeepingApiPostHousekeepingAttendantScheduleRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostHousekeepingAttendantSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/schedules/houseKeepingTasks"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.attendantSchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostOutOfOrderRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRepairOutOfOrder *PostOutOfOrderRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostOutOfOrderRoomsRequest) Authorization(authorization string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPostOutOfOrderRoomsRequest) RoomRepairOutOfOrder(roomRepairOutOfOrder PostOutOfOrderRoomsRequest) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.roomRepairOutOfOrder = &roomRepairOutOfOrder
	return r
}

// External system code.
func (r HousekeepingApiPostOutOfOrderRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostOutOfOrderRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostOutOfOrderRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostOutOfOrderRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOutOfOrderRoomsExecute(r)
}

/*
PostOutOfOrderRooms Set multiple rooms to Out Of Order

This API allows you to initially set rooms to 'Out Of Order' housekeeping status and update existing outOfOrderRooms. <p><strong>OperationId:</strong>postOutOfOrderRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code of Room(s) which is to be set as Out Of Order.
 @return HousekeepingApiPostOutOfOrderRoomsRequest
*/
func (a *HousekeepingApiService) PostOutOfOrderRooms(ctx context.Context, hotelId string) HousekeepingApiPostOutOfOrderRoomsRequest {
	return HousekeepingApiPostOutOfOrderRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostOutOfOrderRoomsExecute(r HousekeepingApiPostOutOfOrderRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostOutOfOrderRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfOrderRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRepairOutOfOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostOutOfServiceRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomRepairOutOfService *PostOutOfServiceRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostOutOfServiceRoomsRequest) Authorization(authorization string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPostOutOfServiceRoomsRequest) RoomRepairOutOfService(roomRepairOutOfService PostOutOfServiceRoomsRequest) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.roomRepairOutOfService = &roomRepairOutOfService
	return r
}

// External system code.
func (r HousekeepingApiPostOutOfServiceRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostOutOfServiceRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostOutOfServiceRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostOutOfServiceRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostOutOfServiceRoomsExecute(r)
}

/*
PostOutOfServiceRooms Set multiple rooms to Out Of Service

This API allows you to initially set rooms to 'Out Of Service' housekeeping status and update existing outOfServiceRooms. <p><strong>OperationId:</strong>postOutOfServiceRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code of Room(s) which is to be set as Out Of Service.
 @return HousekeepingApiPostOutOfServiceRoomsRequest
*/
func (a *HousekeepingApiService) PostOutOfServiceRooms(ctx context.Context, hotelId string) HousekeepingApiPostOutOfServiceRoomsRequest {
	return HousekeepingApiPostOutOfServiceRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostOutOfServiceRoomsExecute(r HousekeepingApiPostOutOfServiceRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostOutOfServiceRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/outOfServiceRooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomRepairOutOfService
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostReservationHousekeepingTasksRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	schedule *EditReservationHousekeepingTasksRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostReservationHousekeepingTasksRequest) Authorization(authorization string) HousekeepingApiPostReservationHousekeepingTasksRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostReservationHousekeepingTasksRequest) XAppKey(xAppKey string) HousekeepingApiPostReservationHousekeepingTasksRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostReservationHousekeepingTasksRequest) XHotelid(xHotelid string) HousekeepingApiPostReservationHousekeepingTasksRequest {
	r.xHotelid = &xHotelid
	return r
}

// A schedule with task(s) to be created for the given reservation.
func (r HousekeepingApiPostReservationHousekeepingTasksRequest) Schedule(schedule EditReservationHousekeepingTasksRequest) HousekeepingApiPostReservationHousekeepingTasksRequest {
	r.schedule = &schedule
	return r
}

// External system code.
func (r HousekeepingApiPostReservationHousekeepingTasksRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostReservationHousekeepingTasksRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostReservationHousekeepingTasksRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostReservationHousekeepingTasksRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostReservationHousekeepingTasksRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReservationHousekeepingTasksExecute(r)
}

/*
PostReservationHousekeepingTasks Create reservation housekeeping tasks

This API will allow you to create reservation housekeeping tasks. <p><strong>OperationId:</strong>postReservationHousekeepingTasks</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiPostReservationHousekeepingTasksRequest
*/
func (a *HousekeepingApiService) PostReservationHousekeepingTasks(ctx context.Context, reservationId string, hotelId string) HousekeepingApiPostReservationHousekeepingTasksRequest {
	return HousekeepingApiPostReservationHousekeepingTasksRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostReservationHousekeepingTasksExecute(r HousekeepingApiPostReservationHousekeepingTasksRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostReservationHousekeepingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingTaskSchedules"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.schedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostRoomMaintenanceRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	maintenanceCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomMaintenanceRequest *PostRoomMaintenanceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostRoomMaintenanceRequest) Authorization(authorization string) HousekeepingApiPostRoomMaintenanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostRoomMaintenanceRequest) XAppKey(xAppKey string) HousekeepingApiPostRoomMaintenanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostRoomMaintenanceRequest) XHotelid(xHotelid string) HousekeepingApiPostRoomMaintenanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a room maintenance record.
func (r HousekeepingApiPostRoomMaintenanceRequest) RoomMaintenanceRequest(roomMaintenanceRequest PostRoomMaintenanceRequest) HousekeepingApiPostRoomMaintenanceRequest {
	r.roomMaintenanceRequest = &roomMaintenanceRequest
	return r
}

// External system code.
func (r HousekeepingApiPostRoomMaintenanceRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostRoomMaintenanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostRoomMaintenanceRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostRoomMaintenanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostRoomMaintenanceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomMaintenanceExecute(r)
}

/*
PostRoomMaintenance Create maintenances for rooms

Use this API to create maintenances for rooms. <p><strong>OperationId:</strong>postRoomMaintenance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintenanceCode
 @param hotelId
 @return HousekeepingApiPostRoomMaintenanceRequest
*/
func (a *HousekeepingApiService) PostRoomMaintenance(ctx context.Context, maintenanceCode string, hotelId string) HousekeepingApiPostRoomMaintenanceRequest {
	return HousekeepingApiPostRoomMaintenanceRequest{
		ApiService: a,
		ctx: ctx,
		maintenanceCode: maintenanceCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostRoomMaintenanceExecute(r HousekeepingApiPostRoomMaintenanceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostRoomMaintenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/maintenanceCodes/{maintenanceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintenanceCode"+"}", url.PathEscape(parameterValueToString(r.maintenanceCode, "maintenanceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.maintenanceCode) < 1 {
		return localVarReturnValue, nil, reportError("maintenanceCode must have at least 1 elements")
	}
	if strlen(r.maintenanceCode) > 2000 {
		return localVarReturnValue, nil, reportError("maintenanceCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomMaintenanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostTaskSheetRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheet *PutTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostTaskSheetRequest) Authorization(authorization string) HousekeepingApiPostTaskSheetRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostTaskSheetRequest) XAppKey(xAppKey string) HousekeepingApiPostTaskSheetRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostTaskSheetRequest) XHotelid(xHotelid string) HousekeepingApiPostTaskSheetRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new task sheet. Details for the task sheet required are the Task Code, Task Date and Resort. Task Instructions and total credits if not provided will be retrieved from the task code setup. If room and attendant information is sent, this will be added to the task sheet created.
func (r HousekeepingApiPostTaskSheetRequest) TaskSheet(taskSheet PutTaskSheetRequest) HousekeepingApiPostTaskSheetRequest {
	r.taskSheet = &taskSheet
	return r
}

// External system code.
func (r HousekeepingApiPostTaskSheetRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostTaskSheetRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostTaskSheetRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostTaskSheetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostTaskSheetRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTaskSheetExecute(r)
}

/*
PostTaskSheet Create the task sheet

This API allows you to create the task sheet. <p><strong>OperationId:</strong>postTaskSheet</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiPostTaskSheetRequest
*/
func (a *HousekeepingApiService) PostTaskSheet(ctx context.Context, hotelId string) HousekeepingApiPostTaskSheetRequest {
	return HousekeepingApiPostTaskSheetRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostTaskSheetExecute(r HousekeepingApiPostTaskSheetRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostTaskSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPostTaskSheetRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheet *PutTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPostTaskSheetRoomsRequest) Authorization(authorization string) HousekeepingApiPostTaskSheetRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPostTaskSheetRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPostTaskSheetRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPostTaskSheetRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPostTaskSheetRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create(add) a room in a task sheet. Details for the task sheet required are the Task Code, Task Date and Resort. The room element will contain the list of rooms that are to be added to the task sheet. These rooms will be added to the existing rooms on the task sheet. Room instructions and credits will be updated for each room.
func (r HousekeepingApiPostTaskSheetRoomsRequest) TaskSheet(taskSheet PutTaskSheetRequest) HousekeepingApiPostTaskSheetRoomsRequest {
	r.taskSheet = &taskSheet
	return r
}

// External system code.
func (r HousekeepingApiPostTaskSheetRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPostTaskSheetRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPostTaskSheetRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPostTaskSheetRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPostTaskSheetRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTaskSheetRoomsExecute(r)
}

/*
PostTaskSheetRooms Create the task sheet rooms

This API allows you to create the task sheet rooms. <p><strong>OperationId:</strong>postTaskSheetRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiPostTaskSheetRoomsRequest
*/
func (a *HousekeepingApiService) PostTaskSheetRooms(ctx context.Context, hotelId string) HousekeepingApiPostTaskSheetRoomsRequest {
	return HousekeepingApiPostTaskSheetRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PostTaskSheetRoomsExecute(r HousekeepingApiPostTaskSheetRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PostTaskSheetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutRoomCleaningPriorityRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	roomId *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Collection of room numbers.
func (r HousekeepingApiPutRoomCleaningPriorityRequest) RoomId(roomId []string) HousekeepingApiPutRoomCleaningPriorityRequest {
	r.roomId = &roomId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutRoomCleaningPriorityRequest) Authorization(authorization string) HousekeepingApiPutRoomCleaningPriorityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPutRoomCleaningPriorityRequest) XAppKey(xAppKey string) HousekeepingApiPutRoomCleaningPriorityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutRoomCleaningPriorityRequest) XHotelid(xHotelid string) HousekeepingApiPutRoomCleaningPriorityRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HousekeepingApiPutRoomCleaningPriorityRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutRoomCleaningPriorityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutRoomCleaningPriorityRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutRoomCleaningPriorityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutRoomCleaningPriorityRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutRoomCleaningPriorityExecute(r)
}

/*
PutRoomCleaningPriority Delete room cleaning priority

This API will allow you to delete room cleaning priority. <p><strong>OperationId:</strong>putRoomCleaningPriority</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiPutRoomCleaningPriorityRequest
*/
func (a *HousekeepingApiService) PutRoomCleaningPriority(ctx context.Context, hotelId string) HousekeepingApiPutRoomCleaningPriorityRequest {
	return HousekeepingApiPutRoomCleaningPriorityRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HousekeepingApiService) PutRoomCleaningPriorityExecute(r HousekeepingApiPutRoomCleaningPriorityRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutRoomCleaningPriority")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/cleaningPriority"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.roomId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomId", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutRoomMaintenanceRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	maintenanceId string
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomMaintenance *ResolveRoomMaintenanceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutRoomMaintenanceRequest) Authorization(authorization string) HousekeepingApiPutRoomMaintenanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPutRoomMaintenanceRequest) XAppKey(xAppKey string) HousekeepingApiPutRoomMaintenanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutRoomMaintenanceRequest) XHotelid(xHotelid string) HousekeepingApiPutRoomMaintenanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change room maintenance details.
func (r HousekeepingApiPutRoomMaintenanceRequest) RoomMaintenance(roomMaintenance ResolveRoomMaintenanceRequest) HousekeepingApiPutRoomMaintenanceRequest {
	r.roomMaintenance = &roomMaintenance
	return r
}

// External system code.
func (r HousekeepingApiPutRoomMaintenanceRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutRoomMaintenanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutRoomMaintenanceRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutRoomMaintenanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutRoomMaintenanceRequest) Execute() (*ChangedRoomMaintenance, *http.Response, error) {
	return r.ApiService.PutRoomMaintenanceExecute(r)
}

/*
PutRoomMaintenance Change maintenances for rooms

Use this API to change the maintenances for rooms. <p><strong>OperationId:</strong>putRoomMaintenance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param maintenanceId
 @param roomId
 @param hotelId
 @return HousekeepingApiPutRoomMaintenanceRequest
*/
func (a *HousekeepingApiService) PutRoomMaintenance(ctx context.Context, maintenanceId string, roomId string, hotelId string) HousekeepingApiPutRoomMaintenanceRequest {
	return HousekeepingApiPutRoomMaintenanceRequest{
		ApiService: a,
		ctx: ctx,
		maintenanceId: maintenanceId,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedRoomMaintenance
func (a *HousekeepingApiService) PutRoomMaintenanceExecute(r HousekeepingApiPutRoomMaintenanceRequest) (*ChangedRoomMaintenance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedRoomMaintenance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutRoomMaintenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/maintenances/{maintenanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"maintenanceId"+"}", url.PathEscape(parameterValueToString(r.maintenanceId, "maintenanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.maintenanceId) < 1 {
		return localVarReturnValue, nil, reportError("maintenanceId must have at least 1 elements")
	}
	if strlen(r.maintenanceId) > 2000 {
		return localVarReturnValue, nil, reportError("maintenanceId must have less than 2000 elements")
	}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomMaintenance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutRoomRelatedStatusRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	housekeepingRoomStatusCriteria *PutRoomRelatedStatusRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutRoomRelatedStatusRequest) Authorization(authorization string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPutRoomRelatedStatusRequest) XAppKey(xAppKey string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutRoomRelatedStatusRequest) XHotelid(xHotelid string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HousekeepingApiPutRoomRelatedStatusRequest) HousekeepingRoomStatusCriteria(housekeepingRoomStatusCriteria PutRoomRelatedStatusRequest) HousekeepingApiPutRoomRelatedStatusRequest {
	r.housekeepingRoomStatusCriteria = &housekeepingRoomStatusCriteria
	return r
}

// External system code.
func (r HousekeepingApiPutRoomRelatedStatusRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutRoomRelatedStatusRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutRoomRelatedStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutRoomRelatedStatusRequest) Execute() (*HousekeepingRoomStatus, *http.Response, error) {
	return r.ApiService.PutRoomRelatedStatusExecute(r)
}

/*
PutRoomRelatedStatus Update Housekeeping Room Status

Use this API to update the housekeeping room status for multiple rooms.  Statuses typically include Inspected, Clean, Pickup or Dirty. <p><strong>OperationId:</strong>putRoomRelatedStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code for which housekeeping room status, housekeeping status or turndown status have to be modified
 @return HousekeepingApiPutRoomRelatedStatusRequest
*/
func (a *HousekeepingApiService) PutRoomRelatedStatus(ctx context.Context, hotelId string) HousekeepingApiPutRoomRelatedStatusRequest {
	return HousekeepingApiPutRoomRelatedStatusRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return HousekeepingRoomStatus
func (a *HousekeepingApiService) PutRoomRelatedStatusExecute(r HousekeepingApiPutRoomRelatedStatusRequest) (*HousekeepingRoomStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HousekeepingRoomStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutRoomRelatedStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/status"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.housekeepingRoomStatusCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutTaskSheetRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheet *PutTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutTaskSheetRequest) Authorization(authorization string) HousekeepingApiPutTaskSheetRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPutTaskSheetRequest) XAppKey(xAppKey string) HousekeepingApiPutTaskSheetRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutTaskSheetRequest) XHotelid(xHotelid string) HousekeepingApiPutTaskSheetRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request of Changing a Task Sheet. The task instructions, total credits, attendant information and room information can be changed on a task sheet. Task Instructions , Total Credits and Attendants will be replaced with what is sent in this request. Example: If the task instructions is null in the request, the task instructions on the task sheet will be updated to null. If rooms are sent as part of this request, this will replace the existing rooms on the task sheet. If rooms are not sent, then the original rooms will remain. The task date, hotel code, task sheet number and task code is required to search for the task sheet which has to be changed
func (r HousekeepingApiPutTaskSheetRequest) TaskSheet(taskSheet PutTaskSheetRequest) HousekeepingApiPutTaskSheetRequest {
	r.taskSheet = &taskSheet
	return r
}

// External system code.
func (r HousekeepingApiPutTaskSheetRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutTaskSheetRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutTaskSheetRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutTaskSheetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutTaskSheetRequest) Execute() (*ChangedTaskSheet, *http.Response, error) {
	return r.ApiService.PutTaskSheetExecute(r)
}

/*
PutTaskSheet Change the task sheet

This API allows you to change the task sheet. <p><strong>OperationId:</strong>putTaskSheet</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiPutTaskSheetRequest
*/
func (a *HousekeepingApiService) PutTaskSheet(ctx context.Context, hotelId string) HousekeepingApiPutTaskSheetRequest {
	return HousekeepingApiPutTaskSheetRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedTaskSheet
func (a *HousekeepingApiService) PutTaskSheetExecute(r HousekeepingApiPutTaskSheetRequest) (*ChangedTaskSheet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedTaskSheet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutTaskSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutTaskSheetRoomsRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheet *PutTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutTaskSheetRoomsRequest) Authorization(authorization string) HousekeepingApiPutTaskSheetRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPutTaskSheetRoomsRequest) XAppKey(xAppKey string) HousekeepingApiPutTaskSheetRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutTaskSheetRoomsRequest) XHotelid(xHotelid string) HousekeepingApiPutTaskSheetRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change a room on a task sheet. The information that can be changed are the room instructions and credits. The instructions and credits for a room will be updated based on the information sent in this request. The criteria required to search for the particular task sheet to update requires the HotelCode, Task Sheet Number, Task Code and Task Date.
func (r HousekeepingApiPutTaskSheetRoomsRequest) TaskSheet(taskSheet PutTaskSheetRequest) HousekeepingApiPutTaskSheetRoomsRequest {
	r.taskSheet = &taskSheet
	return r
}

// External system code.
func (r HousekeepingApiPutTaskSheetRoomsRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutTaskSheetRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutTaskSheetRoomsRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutTaskSheetRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutTaskSheetRoomsRequest) Execute() (*ChangedTaskSheetRooms, *http.Response, error) {
	return r.ApiService.PutTaskSheetRoomsExecute(r)
}

/*
PutTaskSheetRooms Change the task sheet rooms

This API allows you to change the task sheet rooms. <p><strong>OperationId:</strong>putTaskSheetRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiPutTaskSheetRoomsRequest
*/
func (a *HousekeepingApiService) PutTaskSheetRooms(ctx context.Context, hotelId string) HousekeepingApiPutTaskSheetRoomsRequest {
	return HousekeepingApiPutTaskSheetRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedTaskSheetRooms
func (a *HousekeepingApiService) PutTaskSheetRoomsExecute(r HousekeepingApiPutTaskSheetRoomsRequest) (*ChangedTaskSheetRooms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedTaskSheetRooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutTaskSheetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiPutTaskSheetTemplateRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	taskSheetTemplateCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheetTemplate *PutTaskSheetTemplateRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiPutTaskSheetTemplateRequest) Authorization(authorization string) HousekeepingApiPutTaskSheetTemplateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiPutTaskSheetTemplateRequest) XAppKey(xAppKey string) HousekeepingApiPutTaskSheetTemplateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiPutTaskSheetTemplateRequest) XHotelid(xHotelid string) HousekeepingApiPutTaskSheetTemplateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for changing task sheet template.
func (r HousekeepingApiPutTaskSheetTemplateRequest) TaskSheetTemplate(taskSheetTemplate PutTaskSheetTemplateRequest) HousekeepingApiPutTaskSheetTemplateRequest {
	r.taskSheetTemplate = &taskSheetTemplate
	return r
}

// External system code.
func (r HousekeepingApiPutTaskSheetTemplateRequest) XExternalsystem(xExternalsystem string) HousekeepingApiPutTaskSheetTemplateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiPutTaskSheetTemplateRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiPutTaskSheetTemplateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiPutTaskSheetTemplateRequest) Execute() (*ChangedTaskSheetTemplate, *http.Response, error) {
	return r.ApiService.PutTaskSheetTemplateExecute(r)
}

/*
PutTaskSheetTemplate Change the task sheet templates

This API allows you to change the task sheet templates. <p><strong>OperationId:</strong>putTaskSheetTemplate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskSheetTemplateCode
 @param hotelId
 @return HousekeepingApiPutTaskSheetTemplateRequest
*/
func (a *HousekeepingApiService) PutTaskSheetTemplate(ctx context.Context, taskSheetTemplateCode string, hotelId string) HousekeepingApiPutTaskSheetTemplateRequest {
	return HousekeepingApiPutTaskSheetTemplateRequest{
		ApiService: a,
		ctx: ctx,
		taskSheetTemplateCode: taskSheetTemplateCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ChangedTaskSheetTemplate
func (a *HousekeepingApiService) PutTaskSheetTemplateExecute(r HousekeepingApiPutTaskSheetTemplateRequest) (*ChangedTaskSheetTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedTaskSheetTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.PutTaskSheetTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheetTemplates/{taskSheetTemplateCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskSheetTemplateCode"+"}", url.PathEscape(parameterValueToString(r.taskSheetTemplateCode, "taskSheetTemplateCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskSheetTemplateCode) < 1 {
		return localVarReturnValue, nil, reportError("taskSheetTemplateCode must have at least 1 elements")
	}
	if strlen(r.taskSheetTemplateCode) > 2000 {
		return localVarReturnValue, nil, reportError("taskSheetTemplateCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheetTemplate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiResetReservationHousekeepingScheduleRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	scheduleSearch *ResetReservationHousekeepingScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) Authorization(authorization string) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) XAppKey(xAppKey string) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) XHotelid(xHotelid string) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request with basic information reservation needed for the reset of the schedule.
func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) ScheduleSearch(scheduleSearch ResetReservationHousekeepingScheduleRequest) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	r.scheduleSearch = &scheduleSearch
	return r
}

// External system code.
func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) XExternalsystem(xExternalsystem string) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiResetReservationHousekeepingScheduleRequest) Execute() (*ScheduledSearch, *http.Response, error) {
	return r.ApiService.ResetReservationHousekeepingScheduleExecute(r)
}

/*
ResetReservationHousekeepingSchedule Reset reservation housekeeping schedule

This API will allow you to reset reservation housekeeping schedule. <p><strong>OperationId:</strong>resetReservationHousekeepingSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiResetReservationHousekeepingScheduleRequest
*/
func (a *HousekeepingApiService) ResetReservationHousekeepingSchedule(ctx context.Context, reservationId string, hotelId string) HousekeepingApiResetReservationHousekeepingScheduleRequest {
	return HousekeepingApiResetReservationHousekeepingScheduleRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ScheduledSearch
func (a *HousekeepingApiService) ResetReservationHousekeepingScheduleExecute(r HousekeepingApiResetReservationHousekeepingScheduleRequest) (*ScheduledSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.ResetReservationHousekeepingSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingTaskSchedules/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.scheduleSearch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiResolveRoomMaintenanceRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	mainteananceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomMaintenance *ResolveRoomMaintenanceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiResolveRoomMaintenanceRequest) Authorization(authorization string) HousekeepingApiResolveRoomMaintenanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiResolveRoomMaintenanceRequest) XAppKey(xAppKey string) HousekeepingApiResolveRoomMaintenanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiResolveRoomMaintenanceRequest) XHotelid(xHotelid string) HousekeepingApiResolveRoomMaintenanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to resolve a room maintenance request.
func (r HousekeepingApiResolveRoomMaintenanceRequest) RoomMaintenance(roomMaintenance ResolveRoomMaintenanceRequest) HousekeepingApiResolveRoomMaintenanceRequest {
	r.roomMaintenance = &roomMaintenance
	return r
}

// External system code.
func (r HousekeepingApiResolveRoomMaintenanceRequest) XExternalsystem(xExternalsystem string) HousekeepingApiResolveRoomMaintenanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiResolveRoomMaintenanceRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiResolveRoomMaintenanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiResolveRoomMaintenanceRequest) Execute() (*ResolvedRoomMaintenance, *http.Response, error) {
	return r.ApiService.ResolveRoomMaintenanceExecute(r)
}

/*
ResolveRoomMaintenance Resolve maintenances for rooms

Use this API to Resolve maintenances for rooms. <p><strong>OperationId:</strong>resolveRoomMaintenance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mainteananceId
 @param hotelId
 @return HousekeepingApiResolveRoomMaintenanceRequest
*/
func (a *HousekeepingApiService) ResolveRoomMaintenance(ctx context.Context, mainteananceId string, hotelId string) HousekeepingApiResolveRoomMaintenanceRequest {
	return HousekeepingApiResolveRoomMaintenanceRequest{
		ApiService: a,
		ctx: ctx,
		mainteananceId: mainteananceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ResolvedRoomMaintenance
func (a *HousekeepingApiService) ResolveRoomMaintenanceExecute(r HousekeepingApiResolveRoomMaintenanceRequest) (*ResolvedRoomMaintenance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResolvedRoomMaintenance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.ResolveRoomMaintenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/maintenances/{mainteananceId}/resolve"
	localVarPath = strings.Replace(localVarPath, "{"+"mainteananceId"+"}", url.PathEscape(parameterValueToString(r.mainteananceId, "mainteananceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.mainteananceId) < 1 {
		return localVarReturnValue, nil, reportError("mainteananceId must have at least 1 elements")
	}
	if strlen(r.mainteananceId) > 2000 {
		return localVarReturnValue, nil, reportError("mainteananceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomMaintenance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiSetGuestHousekeepingNotesRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestHousekeepingServiceRequest *SetGuestHousekeepingNotesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiSetGuestHousekeepingNotesRequest) Authorization(authorization string) HousekeepingApiSetGuestHousekeepingNotesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiSetGuestHousekeepingNotesRequest) XAppKey(xAppKey string) HousekeepingApiSetGuestHousekeepingNotesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiSetGuestHousekeepingNotesRequest) XHotelid(xHotelid string) HousekeepingApiSetGuestHousekeepingNotesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to get set guest housekeeping instructions for the room.
func (r HousekeepingApiSetGuestHousekeepingNotesRequest) GuestHousekeepingServiceRequest(guestHousekeepingServiceRequest SetGuestHousekeepingNotesRequest) HousekeepingApiSetGuestHousekeepingNotesRequest {
	r.guestHousekeepingServiceRequest = &guestHousekeepingServiceRequest
	return r
}

// External system code.
func (r HousekeepingApiSetGuestHousekeepingNotesRequest) XExternalsystem(xExternalsystem string) HousekeepingApiSetGuestHousekeepingNotesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiSetGuestHousekeepingNotesRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiSetGuestHousekeepingNotesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiSetGuestHousekeepingNotesRequest) Execute() (*GuestHousekeepingService, *http.Response, error) {
	return r.ApiService.SetGuestHousekeepingNotesExecute(r)
}

/*
SetGuestHousekeepingNotes Set guest housekeeping instructions

This API will allow you to Set guest housekeeping instructions. <p><strong>OperationId:</strong>setGuestHousekeepingNotes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiSetGuestHousekeepingNotesRequest
*/
func (a *HousekeepingApiService) SetGuestHousekeepingNotes(ctx context.Context, reservationId string, hotelId string) HousekeepingApiSetGuestHousekeepingNotesRequest {
	return HousekeepingApiSetGuestHousekeepingNotesRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestHousekeepingService
func (a *HousekeepingApiService) SetGuestHousekeepingNotesExecute(r HousekeepingApiSetGuestHousekeepingNotesRequest) (*GuestHousekeepingService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestHousekeepingService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.SetGuestHousekeepingNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingNotes"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestHousekeepingServiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiSetGuestHousekeepingServiceRequestRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	guestHousekeepingServiceRequestCriteria *SetGuestHousekeepingServiceRequestRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) Authorization(authorization string) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) XAppKey(xAppKey string) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) XHotelid(xHotelid string) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to set the Guest Service status of an occupied room. The service status can be Do Not Disturb or Make Up Room.
func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) GuestHousekeepingServiceRequestCriteria(guestHousekeepingServiceRequestCriteria SetGuestHousekeepingServiceRequestRequest) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	r.guestHousekeepingServiceRequestCriteria = &guestHousekeepingServiceRequestCriteria
	return r
}

// External system code.
func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) XExternalsystem(xExternalsystem string) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) Execute() (*GuestHousekeepingServiceRequestStatus, *http.Response, error) {
	return r.ApiService.SetGuestHousekeepingServiceRequestExecute(r)
}

/*
SetGuestHousekeepingServiceRequest Set the Guest housekeeping service requests

This API allows you to Set the guest housekeeping service requests <p><strong>OperationId:</strong>setGuestHousekeepingServiceRequest</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiSetGuestHousekeepingServiceRequestRequest
*/
func (a *HousekeepingApiService) SetGuestHousekeepingServiceRequest(ctx context.Context, hotelId string) HousekeepingApiSetGuestHousekeepingServiceRequestRequest {
	return HousekeepingApiSetGuestHousekeepingServiceRequestRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return GuestHousekeepingServiceRequestStatus
func (a *HousekeepingApiService) SetGuestHousekeepingServiceRequestExecute(r HousekeepingApiSetGuestHousekeepingServiceRequestRequest) (*GuestHousekeepingServiceRequestStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuestHousekeepingServiceRequestStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.SetGuestHousekeepingServiceRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/serviceRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guestHousekeepingServiceRequestCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiSetRoomCleaningPriorityRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomCleaningPriority *SetRoomCleaningPriorityRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiSetRoomCleaningPriorityRequest) Authorization(authorization string) HousekeepingApiSetRoomCleaningPriorityRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiSetRoomCleaningPriorityRequest) XAppKey(xAppKey string) HousekeepingApiSetRoomCleaningPriorityRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiSetRoomCleaningPriorityRequest) XHotelid(xHotelid string) HousekeepingApiSetRoomCleaningPriorityRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to set a list of rooms as priority for cleaning. This will set a flag as priority and a priority number at the bottom of the current priority line.
func (r HousekeepingApiSetRoomCleaningPriorityRequest) RoomCleaningPriority(roomCleaningPriority SetRoomCleaningPriorityRequest) HousekeepingApiSetRoomCleaningPriorityRequest {
	r.roomCleaningPriority = &roomCleaningPriority
	return r
}

// External system code.
func (r HousekeepingApiSetRoomCleaningPriorityRequest) XExternalsystem(xExternalsystem string) HousekeepingApiSetRoomCleaningPriorityRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiSetRoomCleaningPriorityRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiSetRoomCleaningPriorityRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiSetRoomCleaningPriorityRequest) Execute() (*RoomCleaningPriorityRequestStatus, *http.Response, error) {
	return r.ApiService.SetRoomCleaningPriorityExecute(r)
}

/*
SetRoomCleaningPriority Set the room cleaning priority

This API will allow you to set the room cleaning priority. <p><strong>OperationId:</strong>setRoomCleaningPriority</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomId
 @param hotelId
 @return HousekeepingApiSetRoomCleaningPriorityRequest
*/
func (a *HousekeepingApiService) SetRoomCleaningPriority(ctx context.Context, roomId string, hotelId string) HousekeepingApiSetRoomCleaningPriorityRequest {
	return HousekeepingApiSetRoomCleaningPriorityRequest{
		ApiService: a,
		ctx: ctx,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomCleaningPriorityRequestStatus
func (a *HousekeepingApiService) SetRoomCleaningPriorityExecute(r HousekeepingApiSetRoomCleaningPriorityRequest) (*RoomCleaningPriorityRequestStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomCleaningPriorityRequestStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.SetRoomCleaningPriority")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/cleaningPriority"
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomCleaningPriority
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiSetRoomConditionRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomCondition *SetRoomConditionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiSetRoomConditionRequest) Authorization(authorization string) HousekeepingApiSetRoomConditionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiSetRoomConditionRequest) XAppKey(xAppKey string) HousekeepingApiSetRoomConditionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiSetRoomConditionRequest) XHotelid(xHotelid string) HousekeepingApiSetRoomConditionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request element for setting room condition.
func (r HousekeepingApiSetRoomConditionRequest) RoomCondition(roomCondition SetRoomConditionRequest) HousekeepingApiSetRoomConditionRequest {
	r.roomCondition = &roomCondition
	return r
}

// External system code.
func (r HousekeepingApiSetRoomConditionRequest) XExternalsystem(xExternalsystem string) HousekeepingApiSetRoomConditionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiSetRoomConditionRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiSetRoomConditionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiSetRoomConditionRequest) Execute() (*RoomConditionRequestStatus, *http.Response, error) {
	return r.ApiService.SetRoomConditionExecute(r)
}

/*
SetRoomCondition Set rooms condition

This API will allow you to set, change, or delete a condition on rooms. A condition is used to designate rooms that are available for show, set aside for special housekeeping attention, or are to be treated differently for any other reason. <p><strong>OperationId:</strong>setRoomCondition</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @return HousekeepingApiSetRoomConditionRequest
*/
func (a *HousekeepingApiService) SetRoomCondition(ctx context.Context, hotelId string) HousekeepingApiSetRoomConditionRequest {
	return HousekeepingApiSetRoomConditionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomConditionRequestStatus
func (a *HousekeepingApiService) SetRoomConditionExecute(r HousekeepingApiSetRoomConditionRequest) (*RoomConditionRequestStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomConditionRequestStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.SetRoomCondition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/conditions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomCondition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiShiftReservationHousekeepingScheduleRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	reservationId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	scheduleShiftRequest *ShiftReservationHousekeepingScheduleRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) Authorization(authorization string) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) XAppKey(xAppKey string) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) XHotelid(xHotelid string) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request with the information needed for the shift of the schedule.
func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) ScheduleShiftRequest(scheduleShiftRequest ShiftReservationHousekeepingScheduleRequest) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	r.scheduleShiftRequest = &scheduleShiftRequest
	return r
}

// External system code.
func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) XExternalsystem(xExternalsystem string) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiShiftReservationHousekeepingScheduleRequest) Execute() (*ScheduledShiftRequest, *http.Response, error) {
	return r.ApiService.ShiftReservationHousekeepingScheduleExecute(r)
}

/*
ShiftReservationHousekeepingSchedule Shift reservation housekeeping schedule

This API will allow you to shift reservation housekeeping schedule. <p><strong>OperationId:</strong>shiftReservationHousekeepingSchedule</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reservationId
 @param hotelId
 @return HousekeepingApiShiftReservationHousekeepingScheduleRequest
*/
func (a *HousekeepingApiService) ShiftReservationHousekeepingSchedule(ctx context.Context, reservationId string, hotelId string) HousekeepingApiShiftReservationHousekeepingScheduleRequest {
	return HousekeepingApiShiftReservationHousekeepingScheduleRequest{
		ApiService: a,
		ctx: ctx,
		reservationId: reservationId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ScheduledShiftRequest
func (a *HousekeepingApiService) ShiftReservationHousekeepingScheduleExecute(r HousekeepingApiShiftReservationHousekeepingScheduleRequest) (*ScheduledShiftRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledShiftRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.ShiftReservationHousekeepingSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservations/{reservationId}/houseKeepingTaskSchedules/shift"
	localVarPath = strings.Replace(localVarPath, "{"+"reservationId"+"}", url.PathEscape(parameterValueToString(r.reservationId, "reservationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.reservationId) < 1 {
		return localVarReturnValue, nil, reportError("reservationId must have at least 1 elements")
	}
	if strlen(r.reservationId) > 2000 {
		return localVarReturnValue, nil, reportError("reservationId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.scheduleShiftRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiSkipServicingTaskRoomRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskRoom *CancelServicingTaskRoomRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiSkipServicingTaskRoomRequest) Authorization(authorization string) HousekeepingApiSkipServicingTaskRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiSkipServicingTaskRoomRequest) XAppKey(xAppKey string) HousekeepingApiSkipServicingTaskRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiSkipServicingTaskRoomRequest) XHotelid(xHotelid string) HousekeepingApiSkipServicingTaskRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to start servicing a task room. When the attendant starts working on a room this request can be called to set the times and the status to WORKING for the room.
func (r HousekeepingApiSkipServicingTaskRoomRequest) TaskRoom(taskRoom CancelServicingTaskRoomRequest) HousekeepingApiSkipServicingTaskRoomRequest {
	r.taskRoom = &taskRoom
	return r
}

// External system code.
func (r HousekeepingApiSkipServicingTaskRoomRequest) XExternalsystem(xExternalsystem string) HousekeepingApiSkipServicingTaskRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiSkipServicingTaskRoomRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiSkipServicingTaskRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiSkipServicingTaskRoomRequest) Execute() (*SkipedServicingTaskRoom, *http.Response, error) {
	return r.ApiService.SkipServicingTaskRoomExecute(r)
}

/*
SkipServicingTaskRoom Skip servicing task room

This API will allow you to Skip servicing task room. <p><strong>OperationId:</strong>skipServicingTaskRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param roomId
 @param hotelId
 @return HousekeepingApiSkipServicingTaskRoomRequest
*/
func (a *HousekeepingApiService) SkipServicingTaskRoom(ctx context.Context, sheetNumber string, roomId string, hotelId string) HousekeepingApiSkipServicingTaskRoomRequest {
	return HousekeepingApiSkipServicingTaskRoomRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return SkipedServicingTaskRoom
func (a *HousekeepingApiService) SkipServicingTaskRoomExecute(r HousekeepingApiSkipServicingTaskRoomRequest) (*SkipedServicingTaskRoom, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SkipedServicingTaskRoom
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.SkipServicingTaskRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/sheets/{sheetNumber}/skip"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiStartServiceBreakRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	taskSheetNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskRoom *CancelServicingTaskRoomRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiStartServiceBreakRequest) Authorization(authorization string) HousekeepingApiStartServiceBreakRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiStartServiceBreakRequest) XAppKey(xAppKey string) HousekeepingApiStartServiceBreakRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiStartServiceBreakRequest) XHotelid(xHotelid string) HousekeepingApiStartServiceBreakRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to start service break.
func (r HousekeepingApiStartServiceBreakRequest) TaskRoom(taskRoom CancelServicingTaskRoomRequest) HousekeepingApiStartServiceBreakRequest {
	r.taskRoom = &taskRoom
	return r
}

// External system code.
func (r HousekeepingApiStartServiceBreakRequest) XExternalsystem(xExternalsystem string) HousekeepingApiStartServiceBreakRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiStartServiceBreakRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiStartServiceBreakRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiStartServiceBreakRequest) Execute() (*StartedServiceBreak, *http.Response, error) {
	return r.ApiService.StartServiceBreakExecute(r)
}

/*
StartServiceBreak Start the service break

This API allows you to Start the Attendant's service break. <p><strong>OperationId:</strong>startServiceBreak</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskSheetNumber
 @param hotelId
 @return HousekeepingApiStartServiceBreakRequest
*/
func (a *HousekeepingApiService) StartServiceBreak(ctx context.Context, taskSheetNumber string, hotelId string) HousekeepingApiStartServiceBreakRequest {
	return HousekeepingApiStartServiceBreakRequest{
		ApiService: a,
		ctx: ctx,
		taskSheetNumber: taskSheetNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StartedServiceBreak
func (a *HousekeepingApiService) StartServiceBreakExecute(r HousekeepingApiStartServiceBreakRequest) (*StartedServiceBreak, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StartedServiceBreak
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.StartServiceBreak")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/{taskSheetNumber}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"taskSheetNumber"+"}", url.PathEscape(parameterValueToString(r.taskSheetNumber, "taskSheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.taskSheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("taskSheetNumber must have at least 1 elements")
	}
	if strlen(r.taskSheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("taskSheetNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiStartServicingTaskRoomRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	roomId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskRoom *CancelServicingTaskRoomRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiStartServicingTaskRoomRequest) Authorization(authorization string) HousekeepingApiStartServicingTaskRoomRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiStartServicingTaskRoomRequest) XAppKey(xAppKey string) HousekeepingApiStartServicingTaskRoomRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiStartServicingTaskRoomRequest) XHotelid(xHotelid string) HousekeepingApiStartServicingTaskRoomRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to start servicing a task room. When the attendant starts working on a room this request can be called to set the times and the status to WORKING for the room.
func (r HousekeepingApiStartServicingTaskRoomRequest) TaskRoom(taskRoom CancelServicingTaskRoomRequest) HousekeepingApiStartServicingTaskRoomRequest {
	r.taskRoom = &taskRoom
	return r
}

// External system code.
func (r HousekeepingApiStartServicingTaskRoomRequest) XExternalsystem(xExternalsystem string) HousekeepingApiStartServicingTaskRoomRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiStartServicingTaskRoomRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiStartServicingTaskRoomRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiStartServicingTaskRoomRequest) Execute() (*ServiceTime, *http.Response, error) {
	return r.ApiService.StartServicingTaskRoomExecute(r)
}

/*
StartServicingTaskRoom Start servicing task room

This API will allow you to start servicing task room. <p><strong>OperationId:</strong>startServicingTaskRoom</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param roomId
 @param hotelId
 @return HousekeepingApiStartServicingTaskRoomRequest
*/
func (a *HousekeepingApiService) StartServicingTaskRoom(ctx context.Context, sheetNumber string, roomId string, hotelId string) HousekeepingApiStartServicingTaskRoomRequest {
	return HousekeepingApiStartServicingTaskRoomRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		roomId: roomId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ServiceTime
func (a *HousekeepingApiService) StartServicingTaskRoomExecute(r HousekeepingApiStartServicingTaskRoomRequest) (*ServiceTime, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceTime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.StartServicingTaskRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms/{roomId}/sheets/{sheetNumber}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", url.PathEscape(parameterValueToString(r.roomId, "roomId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.roomId) < 1 {
		return localVarReturnValue, nil, reportError("roomId must have at least 1 elements")
	}
	if strlen(r.roomId) > 2000 {
		return localVarReturnValue, nil, reportError("roomId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskRoom
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiUnResolveRoomMaintenanceRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	mainteananceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomMaintenance *ResolveRoomMaintenanceRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiUnResolveRoomMaintenanceRequest) Authorization(authorization string) HousekeepingApiUnResolveRoomMaintenanceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiUnResolveRoomMaintenanceRequest) XAppKey(xAppKey string) HousekeepingApiUnResolveRoomMaintenanceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiUnResolveRoomMaintenanceRequest) XHotelid(xHotelid string) HousekeepingApiUnResolveRoomMaintenanceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to set unresolved status for room maintenance request.
func (r HousekeepingApiUnResolveRoomMaintenanceRequest) RoomMaintenance(roomMaintenance ResolveRoomMaintenanceRequest) HousekeepingApiUnResolveRoomMaintenanceRequest {
	r.roomMaintenance = &roomMaintenance
	return r
}

// External system code.
func (r HousekeepingApiUnResolveRoomMaintenanceRequest) XExternalsystem(xExternalsystem string) HousekeepingApiUnResolveRoomMaintenanceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiUnResolveRoomMaintenanceRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiUnResolveRoomMaintenanceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiUnResolveRoomMaintenanceRequest) Execute() (*UnresolvedRoomMaintenance, *http.Response, error) {
	return r.ApiService.UnResolveRoomMaintenanceExecute(r)
}

/*
UnResolveRoomMaintenance unResolve the maintenances for rooms

Use this API to unResolve maintenances for rooms. <p><strong>OperationId:</strong>unResolveRoomMaintenance</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mainteananceId
 @param hotelId
 @return HousekeepingApiUnResolveRoomMaintenanceRequest
*/
func (a *HousekeepingApiService) UnResolveRoomMaintenance(ctx context.Context, mainteananceId string, hotelId string) HousekeepingApiUnResolveRoomMaintenanceRequest {
	return HousekeepingApiUnResolveRoomMaintenanceRequest{
		ApiService: a,
		ctx: ctx,
		mainteananceId: mainteananceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UnresolvedRoomMaintenance
func (a *HousekeepingApiService) UnResolveRoomMaintenanceExecute(r HousekeepingApiUnResolveRoomMaintenanceRequest) (*UnresolvedRoomMaintenance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnresolvedRoomMaintenance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.UnResolveRoomMaintenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/maintenances/{mainteananceId}/unResolve"
	localVarPath = strings.Replace(localVarPath, "{"+"mainteananceId"+"}", url.PathEscape(parameterValueToString(r.mainteananceId, "mainteananceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.mainteananceId) < 1 {
		return localVarReturnValue, nil, reportError("mainteananceId must have at least 1 elements")
	}
	if strlen(r.mainteananceId) > 2000 {
		return localVarReturnValue, nil, reportError("mainteananceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomMaintenance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HousekeepingApiUnlockTaskSheetRequest struct {
	ctx context.Context
	ApiService *HousekeepingApiService
	sheetNumber string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	taskSheetToUnlock *UnlockTaskSheetRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HousekeepingApiUnlockTaskSheetRequest) Authorization(authorization string) HousekeepingApiUnlockTaskSheetRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HousekeepingApiUnlockTaskSheetRequest) XAppKey(xAppKey string) HousekeepingApiUnlockTaskSheetRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HousekeepingApiUnlockTaskSheetRequest) XHotelid(xHotelid string) HousekeepingApiUnlockTaskSheetRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for unlocking a task sheet.
func (r HousekeepingApiUnlockTaskSheetRequest) TaskSheetToUnlock(taskSheetToUnlock UnlockTaskSheetRequest) HousekeepingApiUnlockTaskSheetRequest {
	r.taskSheetToUnlock = &taskSheetToUnlock
	return r
}

// External system code.
func (r HousekeepingApiUnlockTaskSheetRequest) XExternalsystem(xExternalsystem string) HousekeepingApiUnlockTaskSheetRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HousekeepingApiUnlockTaskSheetRequest) AcceptLanguage(acceptLanguage string) HousekeepingApiUnlockTaskSheetRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HousekeepingApiUnlockTaskSheetRequest) Execute() (*UnlockedTaskSheet, *http.Response, error) {
	return r.ApiService.UnlockTaskSheetExecute(r)
}

/*
UnlockTaskSheet Unlock the task sheet

This API allows you to Unlock the task sheet. <p><strong>OperationId:</strong>unlockTaskSheet</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sheetNumber
 @param hotelId
 @return HousekeepingApiUnlockTaskSheetRequest
*/
func (a *HousekeepingApiService) UnlockTaskSheet(ctx context.Context, sheetNumber string, hotelId string) HousekeepingApiUnlockTaskSheetRequest {
	return HousekeepingApiUnlockTaskSheetRequest{
		ApiService: a,
		ctx: ctx,
		sheetNumber: sheetNumber,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return UnlockedTaskSheet
func (a *HousekeepingApiService) UnlockTaskSheetExecute(r HousekeepingApiUnlockTaskSheetRequest) (*UnlockedTaskSheet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnlockedTaskSheet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HousekeepingApiService.UnlockTaskSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/taskSheets/{sheetNumber}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"sheetNumber"+"}", url.PathEscape(parameterValueToString(r.sheetNumber, "sheetNumber")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sheetNumber) < 1 {
		return localVarReturnValue, nil, reportError("sheetNumber must have at least 1 elements")
	}
	if strlen(r.sheetNumber) > 2000 {
		return localVarReturnValue, nil, reportError("sheetNumber must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.taskSheetToUnlock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
