/*
OPERA Cloud Customer Relationship Management API

APIs to cater for Customer Relationship Management (profile) functionality in OPERA Cloud.  There are different types of profiles in OPERA Cloud, including Guest, Company, Travel Agent, Source, Group, and Contact profile types.  A profile can store and display a wide range of information about the guest, company, travel agent etc., depending upon the type of profile.  For example, a guest profile can store the guest name, address, contact information, details on billing, membership benefits, preferences and much more.  All profiles in OPERA when created are assigned a ProfileID.  This ID will be used throughout the CRM APIs.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crm

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProfileAPIService ProfileAPI service
type ProfileAPIService service

type ProfileAPIChangeMembershipRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	membershipId string
	membershipType string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membership *Membership
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIChangeMembershipRequest) Authorization(authorization string) ProfileAPIChangeMembershipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIChangeMembershipRequest) XAppKey(xAppKey string) ProfileAPIChangeMembershipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIChangeMembershipRequest) XHotelid(xHotelid string) ProfileAPIChangeMembershipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change/update membership. This object contains unique identifiers for each profile and list of membership details to be updated/changed. The standard optional Opera Context element is also included.
func (r ProfileAPIChangeMembershipRequest) Membership(membership Membership) ProfileAPIChangeMembershipRequest {
	r.membership = &membership
	return r
}

// External system code.
func (r ProfileAPIChangeMembershipRequest) XExternalsystem(xExternalsystem string) ProfileAPIChangeMembershipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIChangeMembershipRequest) AcceptLanguage(acceptLanguage string) ProfileAPIChangeMembershipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIChangeMembershipRequest) Execute() (*ChangedMembership, *http.Response, error) {
	return r.ApiService.ChangeMembershipExecute(r)
}

/*
ChangeMembership Change membership information on a profile

Use this API to update membership details on a profile. <p><strong>OperationId:</strong>changeMembership</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId
 @param membershipType
 @param profileId
 @return ProfileAPIChangeMembershipRequest
*/
func (a *ProfileAPIService) ChangeMembership(ctx context.Context, membershipId string, membershipType string, profileId string) ProfileAPIChangeMembershipRequest {
	return ProfileAPIChangeMembershipRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		membershipType: membershipType,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ChangedMembership
func (a *ProfileAPIService) ChangeMembershipExecute(r ProfileAPIChangeMembershipRequest) (*ChangedMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangedMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ChangeMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/membershipType/{membershipType}/membershipId/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membership
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIChangeProfileCashieringDetailsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileCashieringDetails *ProfileCashieringDetails
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIChangeProfileCashieringDetailsRequest) Authorization(authorization string) ProfileAPIChangeProfileCashieringDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIChangeProfileCashieringDetailsRequest) XAppKey(xAppKey string) ProfileAPIChangeProfileCashieringDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIChangeProfileCashieringDetailsRequest) XHotelid(xHotelid string) ProfileAPIChangeProfileCashieringDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the profile cashiering details.
func (r ProfileAPIChangeProfileCashieringDetailsRequest) ProfileCashieringDetails(profileCashieringDetails ProfileCashieringDetails) ProfileAPIChangeProfileCashieringDetailsRequest {
	r.profileCashieringDetails = &profileCashieringDetails
	return r
}

// External system code.
func (r ProfileAPIChangeProfileCashieringDetailsRequest) XExternalsystem(xExternalsystem string) ProfileAPIChangeProfileCashieringDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIChangeProfileCashieringDetailsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIChangeProfileCashieringDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIChangeProfileCashieringDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeProfileCashieringDetailsExecute(r)
}

/*
ChangeProfileCashieringDetails Change cashiering details for a profile

Update a profiles Financial details, such as billing, routing instructions. <p><strong>OperationId:</strong>changeProfileCashieringDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIChangeProfileCashieringDetailsRequest
*/
func (a *ProfileAPIService) ChangeProfileCashieringDetails(ctx context.Context, profileId string) ProfileAPIChangeProfileCashieringDetailsRequest {
	return ProfileAPIChangeProfileCashieringDetailsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) ChangeProfileCashieringDetailsExecute(r ProfileAPIChangeProfileCashieringDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ChangeProfileCashieringDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/cashieringDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileCashieringDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIChangeProfileOwnersRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileOwners *ChangeProfileOwnersRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIChangeProfileOwnersRequest) Authorization(authorization string) ProfileAPIChangeProfileOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIChangeProfileOwnersRequest) XAppKey(xAppKey string) ProfileAPIChangeProfileOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIChangeProfileOwnersRequest) XHotelid(xHotelid string) ProfileAPIChangeProfileOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to change profile owners.
func (r ProfileAPIChangeProfileOwnersRequest) ProfileOwners(profileOwners ChangeProfileOwnersRequest) ProfileAPIChangeProfileOwnersRequest {
	r.profileOwners = &profileOwners
	return r
}

// External system code.
func (r ProfileAPIChangeProfileOwnersRequest) XExternalsystem(xExternalsystem string) ProfileAPIChangeProfileOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIChangeProfileOwnersRequest) AcceptLanguage(acceptLanguage string) ProfileAPIChangeProfileOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIChangeProfileOwnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeProfileOwnersExecute(r)
}

/*
ChangeProfileOwners Change profile owners

Update an Owner on a profile  <p><strong>OperationId:</strong>changeProfileOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIChangeProfileOwnersRequest
*/
func (a *ProfileAPIService) ChangeProfileOwners(ctx context.Context, profileId string) ProfileAPIChangeProfileOwnersRequest {
	return ProfileAPIChangeProfileOwnersRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) ChangeProfileOwnersExecute(r ProfileAPIChangeProfileOwnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ChangeProfileOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileOwners
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIChangeStagedProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	id string
	authorization *string
	xAppKey *string
	xHotelid *string
	stagedProfile *StagedProfile
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIChangeStagedProfileRequest) Authorization(authorization string) ProfileAPIChangeStagedProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIChangeStagedProfileRequest) XAppKey(xAppKey string) ProfileAPIChangeStagedProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIChangeStagedProfileRequest) XHotelid(xHotelid string) ProfileAPIChangeStagedProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing the staged profile.
func (r ProfileAPIChangeStagedProfileRequest) StagedProfile(stagedProfile StagedProfile) ProfileAPIChangeStagedProfileRequest {
	r.stagedProfile = &stagedProfile
	return r
}

// External system code.
func (r ProfileAPIChangeStagedProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIChangeStagedProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIChangeStagedProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIChangeStagedProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIChangeStagedProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeStagedProfileExecute(r)
}

/*
ChangeStagedProfile Change a staged profile

This API can be used to update the staged Profile. <p><strong>OperationId:</strong>changeStagedProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProfileAPIChangeStagedProfileRequest
*/
func (a *ProfileAPIService) ChangeStagedProfile(ctx context.Context, id string) ProfileAPIChangeStagedProfileRequest {
	return ProfileAPIChangeStagedProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) ChangeStagedProfileExecute(r ProfileAPIChangeStagedProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ChangeStagedProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stagedProfile/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.id) < 1 {
		return localVarReturnValue, nil, reportError("id must have at least 1 elements")
	}
	if strlen(r.id) > 2000 {
		return localVarReturnValue, nil, reportError("id must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.stagedProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPICheckProfileTypeRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idContext *string
	idType *string
	checkProfileInstruction *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPICheckProfileTypeRequest) Authorization(authorization string) ProfileAPICheckProfileTypeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPICheckProfileTypeRequest) XAppKey(xAppKey string) ProfileAPICheckProfileTypeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPICheckProfileTypeRequest) XHotelid(xHotelid string) ProfileAPICheckProfileTypeRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPICheckProfileTypeRequest) Id(id string) ProfileAPICheckProfileTypeRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPICheckProfileTypeRequest) IdContext(idContext string) ProfileAPICheckProfileTypeRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPICheckProfileTypeRequest) IdType(idType string) ProfileAPICheckProfileTypeRequest {
	r.idType = &idType
	return r
}

// Simple type that corresponds to check profile instructions.
func (r ProfileAPICheckProfileTypeRequest) CheckProfileInstruction(checkProfileInstruction string) ProfileAPICheckProfileTypeRequest {
	r.checkProfileInstruction = &checkProfileInstruction
	return r
}

// External system code.
func (r ProfileAPICheckProfileTypeRequest) XExternalsystem(xExternalsystem string) ProfileAPICheckProfileTypeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPICheckProfileTypeRequest) AcceptLanguage(acceptLanguage string) ProfileAPICheckProfileTypeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPICheckProfileTypeRequest) Execute() (*CheckedProfiles, *http.Response, error) {
	return r.ApiService.CheckProfileTypeExecute(r)
}

/*
CheckProfileType Validate and check profiles

This API validates/checks allowed actions, the existence of attached records and/or indicators of a profile. <p><strong>OperationId:</strong>checkProfileType</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPICheckProfileTypeRequest
*/
func (a *ProfileAPIService) CheckProfileType(ctx context.Context) ProfileAPICheckProfileTypeRequest {
	return ProfileAPICheckProfileTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckedProfiles
func (a *ProfileAPIService) CheckProfileTypeExecute(r ProfileAPICheckProfileTypeRequest) (*CheckedProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckedProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.CheckProfileType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/action/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	if r.checkProfileInstruction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkProfileInstruction", r.checkProfileInstruction, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIConsumeECertificateRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	certificateId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCertificateToConsume *ECertificateToConsume
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIConsumeECertificateRequest) Authorization(authorization string) ProfileAPIConsumeECertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIConsumeECertificateRequest) XAppKey(xAppKey string) ProfileAPIConsumeECertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIConsumeECertificateRequest) XHotelid(xHotelid string) ProfileAPIConsumeECertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Consume an E-Certificate.
func (r ProfileAPIConsumeECertificateRequest) ECertificateToConsume(eCertificateToConsume ECertificateToConsume) ProfileAPIConsumeECertificateRequest {
	r.eCertificateToConsume = &eCertificateToConsume
	return r
}

// External system code.
func (r ProfileAPIConsumeECertificateRequest) XExternalsystem(xExternalsystem string) ProfileAPIConsumeECertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIConsumeECertificateRequest) AcceptLanguage(acceptLanguage string) ProfileAPIConsumeECertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIConsumeECertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ConsumeECertificateExecute(r)
}

/*
ConsumeECertificate Consume an E-Certificate

Use this API to consume (use) an E-Certificate.  <p><strong>OperationId:</strong>consumeECertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificateId
 @return ProfileAPIConsumeECertificateRequest
*/
func (a *ProfileAPIService) ConsumeECertificate(ctx context.Context, certificateId string) ProfileAPIConsumeECertificateRequest {
	return ProfileAPIConsumeECertificateRequest{
		ApiService: a,
		ctx: ctx,
		certificateId: certificateId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) ConsumeECertificateExecute(r ProfileAPIConsumeECertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ConsumeECertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecertificates/{certificateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"certificateId"+"}", url.PathEscape(parameterValueToString(r.certificateId, "certificateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.certificateId) < 1 {
		return localVarReturnValue, nil, reportError("certificateId must have at least 1 elements")
	}
	if strlen(r.certificateId) > 2000 {
		return localVarReturnValue, nil, reportError("certificateId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCertificateToConsume
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPICopyProfileCommissionAccountRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileCommissionAccountCopy *ProfileCommissionAccountCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPICopyProfileCommissionAccountRequest) Authorization(authorization string) ProfileAPICopyProfileCommissionAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPICopyProfileCommissionAccountRequest) XAppKey(xAppKey string) ProfileAPICopyProfileCommissionAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPICopyProfileCommissionAccountRequest) XHotelid(xHotelid string) ProfileAPICopyProfileCommissionAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for copying transaction groups configuration.
func (r ProfileAPICopyProfileCommissionAccountRequest) ProfileCommissionAccountCopy(profileCommissionAccountCopy ProfileCommissionAccountCopy) ProfileAPICopyProfileCommissionAccountRequest {
	r.profileCommissionAccountCopy = &profileCommissionAccountCopy
	return r
}

// External system code.
func (r ProfileAPICopyProfileCommissionAccountRequest) XExternalsystem(xExternalsystem string) ProfileAPICopyProfileCommissionAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPICopyProfileCommissionAccountRequest) AcceptLanguage(acceptLanguage string) ProfileAPICopyProfileCommissionAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPICopyProfileCommissionAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyProfileCommissionAccountExecute(r)
}

/*
CopyProfileCommissionAccount Copy profile commission account

You can use this API to copy the commission account on a profile <p><strong>OperationId:</strong>copyProfileCommissionAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @param hotelId
 @return ProfileAPICopyProfileCommissionAccountRequest
*/
func (a *ProfileAPIService) CopyProfileCommissionAccount(ctx context.Context, profileId string, hotelId string) ProfileAPICopyProfileCommissionAccountRequest {
	return ProfileAPICopyProfileCommissionAccountRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) CopyProfileCommissionAccountExecute(r ProfileAPICopyProfileCommissionAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.CopyProfileCommissionAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/commissionAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileCommissionAccountCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteAccountForecastRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	periodCode string
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	periodCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteAccountForecastRequest) Authorization(authorization string) ProfileAPIDeleteAccountForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteAccountForecastRequest) XAppKey(xAppKey string) ProfileAPIDeleteAccountForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteAccountForecastRequest) XHotelid(xHotelid string) ProfileAPIDeleteAccountForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ProfileAPIDeleteAccountForecastRequest) PeriodCodes(periodCodes []string) ProfileAPIDeleteAccountForecastRequest {
	r.periodCodes = &periodCodes
	return r
}

// External system code.
func (r ProfileAPIDeleteAccountForecastRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteAccountForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteAccountForecastRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteAccountForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteAccountForecastRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountForecastExecute(r)
}

/*
DeleteAccountForecast Delete account forecast in a hotel by period code

Use this to delete an existing account Forecast for a hotel.  You must know the period code for this API. <p><strong>OperationId:</strong>deleteAccountForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param periodCode Period Code.
 @param hotelId Unique ID of the hotel.
 @param profileId Unique Account Profile ID.
 @return ProfileAPIDeleteAccountForecastRequest
*/
func (a *ProfileAPIService) DeleteAccountForecast(ctx context.Context, periodCode string, hotelId string, profileId string) ProfileAPIDeleteAccountForecastRequest {
	return ProfileAPIDeleteAccountForecastRequest{
		ApiService: a,
		ctx: ctx,
		periodCode: periodCode,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteAccountForecastExecute(r ProfileAPIDeleteAccountForecastRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteAccountForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/hotels/{hotelId}/forecasts/periodCodes/{periodCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"periodCode"+"}", url.PathEscape(parameterValueToString(r.periodCode, "periodCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.periodCode) < 1 {
		return localVarReturnValue, nil, reportError("periodCode must have at least 1 elements")
	}
	if strlen(r.periodCode) > 2000 {
		return localVarReturnValue, nil, reportError("periodCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.periodCodes != nil {
		t := *r.periodCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "periodCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "periodCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteCertificateRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteCertificateRequest) Authorization(authorization string) ProfileAPIDeleteCertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteCertificateRequest) XAppKey(xAppKey string) ProfileAPIDeleteCertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteCertificateRequest) XHotelid(xHotelid string) ProfileAPIDeleteCertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileAPIDeleteCertificateRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteCertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteCertificateRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteCertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteCertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteCertificateExecute(r)
}

/*
DeleteCertificate Delete certificate

This API will allow you to delete a certificate. <p><strong>OperationId:</strong>deleteCertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIDeleteCertificateRequest
*/
func (a *ProfileAPIService) DeleteCertificate(ctx context.Context) ProfileAPIDeleteCertificateRequest {
	return ProfileAPIDeleteCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteCertificateExecute(r ProfileAPIDeleteCertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteECertificateRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	certificateId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteECertificateRequest) Authorization(authorization string) ProfileAPIDeleteECertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteECertificateRequest) XAppKey(xAppKey string) ProfileAPIDeleteECertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteECertificateRequest) XHotelid(xHotelid string) ProfileAPIDeleteECertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileAPIDeleteECertificateRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteECertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteECertificateRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteECertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteECertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteECertificateExecute(r)
}

/*
DeleteECertificate Delete e-certificate

This API allows you to delete an eCertificates which exist on a profile in OPERA Cloud. <p><strong>OperationId:</strong>deleteECertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificateId
 @return ProfileAPIDeleteECertificateRequest
*/
func (a *ProfileAPIService) DeleteECertificate(ctx context.Context, certificateId string) ProfileAPIDeleteECertificateRequest {
	return ProfileAPIDeleteECertificateRequest{
		ApiService: a,
		ctx: ctx,
		certificateId: certificateId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteECertificateExecute(r ProfileAPIDeleteECertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteECertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecertificates/{certificateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"certificateId"+"}", url.PathEscape(parameterValueToString(r.certificateId, "certificateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.certificateId) < 1 {
		return localVarReturnValue, nil, reportError("certificateId must have at least 1 elements")
	}
	if strlen(r.certificateId) > 2000 {
		return localVarReturnValue, nil, reportError("certificateId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteGlobalPreferenceRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	preferenceCode string
	preferenceType string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	registeredProperty *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteGlobalPreferenceRequest) Authorization(authorization string) ProfileAPIDeleteGlobalPreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteGlobalPreferenceRequest) XAppKey(xAppKey string) ProfileAPIDeleteGlobalPreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteGlobalPreferenceRequest) XHotelid(xHotelid string) ProfileAPIDeleteGlobalPreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Profiles Registered Property
func (r ProfileAPIDeleteGlobalPreferenceRequest) RegisteredProperty(registeredProperty string) ProfileAPIDeleteGlobalPreferenceRequest {
	r.registeredProperty = &registeredProperty
	return r
}

// External system code.
func (r ProfileAPIDeleteGlobalPreferenceRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteGlobalPreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteGlobalPreferenceRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteGlobalPreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteGlobalPreferenceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteGlobalPreferenceExecute(r)
}

/*
DeleteGlobalPreference Delete a global preference from a profile

This will allow you to delete a global preference code from a profile.  For example the guest no longer has a preference for High Floor Room, so you would go ahead and delete this preference from their profile. <p><strong>OperationId:</strong>deleteGlobalPreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceCode
 @param preferenceType
 @param profileId
 @return ProfileAPIDeleteGlobalPreferenceRequest
*/
func (a *ProfileAPIService) DeleteGlobalPreference(ctx context.Context, preferenceCode string, preferenceType string, profileId string) ProfileAPIDeleteGlobalPreferenceRequest {
	return ProfileAPIDeleteGlobalPreferenceRequest{
		ApiService: a,
		ctx: ctx,
		preferenceCode: preferenceCode,
		preferenceType: preferenceType,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteGlobalPreferenceExecute(r ProfileAPIDeleteGlobalPreferenceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteGlobalPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/preferenceType/{preferenceType}/preferences/{preferenceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceCode"+"}", url.PathEscape(parameterValueToString(r.preferenceCode, "preferenceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceType"+"}", url.PathEscape(parameterValueToString(r.preferenceType, "preferenceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceCode) < 1 {
		return localVarReturnValue, nil, reportError("preferenceCode must have at least 1 elements")
	}
	if strlen(r.preferenceCode) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceCode must have less than 2000 elements")
	}
	if strlen(r.preferenceType) < 1 {
		return localVarReturnValue, nil, reportError("preferenceType must have at least 1 elements")
	}
	if strlen(r.preferenceType) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceType must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.registeredProperty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "registeredProperty", r.registeredProperty, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteMembershipRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	membershipId string
	membershipType string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteMembershipRequest) Authorization(authorization string) ProfileAPIDeleteMembershipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteMembershipRequest) XAppKey(xAppKey string) ProfileAPIDeleteMembershipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteMembershipRequest) XHotelid(xHotelid string) ProfileAPIDeleteMembershipRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileAPIDeleteMembershipRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteMembershipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteMembershipRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteMembershipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteMembershipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMembershipExecute(r)
}

/*
DeleteMembership Delete membership information from a profile

Use this API to delete membership details on a profile. <p><strong>OperationId:</strong>deleteMembership</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId
 @param membershipType
 @param profileId
 @return ProfileAPIDeleteMembershipRequest
*/
func (a *ProfileAPIService) DeleteMembership(ctx context.Context, membershipId string, membershipType string, profileId string) ProfileAPIDeleteMembershipRequest {
	return ProfileAPIDeleteMembershipRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
		membershipType: membershipType,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteMembershipExecute(r ProfileAPIDeleteMembershipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/membershipType/{membershipType}/membershipId/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteMultipleAccountForecastsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	periodCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteMultipleAccountForecastsRequest) Authorization(authorization string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteMultipleAccountForecastsRequest) XAppKey(xAppKey string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteMultipleAccountForecastsRequest) XHotelid(xHotelid string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ProfileAPIDeleteMultipleAccountForecastsRequest) PeriodCodes(periodCodes []string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	r.periodCodes = &periodCodes
	return r
}

// External system code.
func (r ProfileAPIDeleteMultipleAccountForecastsRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteMultipleAccountForecastsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteMultipleAccountForecastsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteMultipleAccountForecastsExecute(r)
}

/*
DeleteMultipleAccountForecasts Delete multiple account forecasts

Use this API to delete multiple account forecasts. <p><strong>OperationId:</strong>deleteMultipleAccountForecasts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId
 @param profileId Unique OPERA internal account profile ID
 @return ProfileAPIDeleteMultipleAccountForecastsRequest
*/
func (a *ProfileAPIService) DeleteMultipleAccountForecasts(ctx context.Context, hotelId string, profileId string) ProfileAPIDeleteMultipleAccountForecastsRequest {
	return ProfileAPIDeleteMultipleAccountForecastsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteMultipleAccountForecastsExecute(r ProfileAPIDeleteMultipleAccountForecastsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteMultipleAccountForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/hotels/{hotelId}/forecasts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.periodCodes != nil {
		t := *r.periodCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "periodCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "periodCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeletePreferenceRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	preferenceCode string
	preferenceType string
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	registeredProperty *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeletePreferenceRequest) Authorization(authorization string) ProfileAPIDeletePreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeletePreferenceRequest) XAppKey(xAppKey string) ProfileAPIDeletePreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeletePreferenceRequest) XHotelid(xHotelid string) ProfileAPIDeletePreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Profiles Registered Property
func (r ProfileAPIDeletePreferenceRequest) RegisteredProperty(registeredProperty string) ProfileAPIDeletePreferenceRequest {
	r.registeredProperty = &registeredProperty
	return r
}

// External system code.
func (r ProfileAPIDeletePreferenceRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeletePreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeletePreferenceRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeletePreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeletePreferenceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePreferenceExecute(r)
}

/*
DeletePreference Delete a preference from a profile

This will allow you to delete a preference code from a profile.  For example the guest no longer has a preference for High Floor Room, so you would go ahead and delete this preference from their profile. <p><strong>OperationId:</strong>deletePreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param preferenceCode
 @param preferenceType
 @param hotelId
 @param profileId
 @return ProfileAPIDeletePreferenceRequest
*/
func (a *ProfileAPIService) DeletePreference(ctx context.Context, preferenceCode string, preferenceType string, hotelId string, profileId string) ProfileAPIDeletePreferenceRequest {
	return ProfileAPIDeletePreferenceRequest{
		ApiService: a,
		ctx: ctx,
		preferenceCode: preferenceCode,
		preferenceType: preferenceType,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeletePreferenceExecute(r ProfileAPIDeletePreferenceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeletePreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/hotels/{hotelId}/preferenceType/{preferenceType}/preferences/{preferenceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceCode"+"}", url.PathEscape(parameterValueToString(r.preferenceCode, "preferenceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"preferenceType"+"}", url.PathEscape(parameterValueToString(r.preferenceType, "preferenceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.preferenceCode) < 1 {
		return localVarReturnValue, nil, reportError("preferenceCode must have at least 1 elements")
	}
	if strlen(r.preferenceCode) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceCode must have less than 2000 elements")
	}
	if strlen(r.preferenceType) < 1 {
		return localVarReturnValue, nil, reportError("preferenceType must have at least 1 elements")
	}
	if strlen(r.preferenceType) > 2000 {
		return localVarReturnValue, nil, reportError("preferenceType must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.registeredProperty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "registeredProperty", r.registeredProperty, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteProfileRequest) Authorization(authorization string) ProfileAPIDeleteProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteProfileRequest) XAppKey(xAppKey string) ProfileAPIDeleteProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteProfileRequest) XHotelid(xHotelid string) ProfileAPIDeleteProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileAPIDeleteProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileExecute(r)
}

/*
DeleteProfile Forget or delete a profile by ID

Use deleteProfile to inactivate and remove a profile from OPERA. The profile will stay in the Database, until a nightly purge process is run to remove profile details from the OPERA database. <p><strong>OperationId:</strong>deleteProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId OPERA internal profile ID which is used to uniquely identify the profile in OPERA. This ID is a primary identification of a profile in OPERA.
 @return ProfileAPIDeleteProfileRequest
*/
func (a *ProfileAPIService) DeleteProfile(ctx context.Context, profileId string) ProfileAPIDeleteProfileRequest {
	return ProfileAPIDeleteProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteProfileExecute(r ProfileAPIDeleteProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteProfileAttachmentRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	attachmentId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idExtension *[]int32
	idContext *[]string
	type_ *[]string
	uniqueIdIdExtension *[]int32
	uniqueIdIdContext *[]string
	uniqueIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteProfileAttachmentRequest) Authorization(authorization string) ProfileAPIDeleteProfileAttachmentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteProfileAttachmentRequest) XAppKey(xAppKey string) ProfileAPIDeleteProfileAttachmentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteProfileAttachmentRequest) XHotelid(xHotelid string) ProfileAPIDeleteProfileAttachmentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Additional identifying value assigned by the creating system.
func (r ProfileAPIDeleteProfileAttachmentRequest) IdExtension(idExtension []int32) ProfileAPIDeleteProfileAttachmentRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIDeleteProfileAttachmentRequest) IdContext(idContext []string) ProfileAPIDeleteProfileAttachmentRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIDeleteProfileAttachmentRequest) Type_(type_ []string) ProfileAPIDeleteProfileAttachmentRequest {
	r.type_ = &type_
	return r
}

// Additional identifying value assigned by the creating system.
func (r ProfileAPIDeleteProfileAttachmentRequest) UniqueIdIdExtension(uniqueIdIdExtension []int32) ProfileAPIDeleteProfileAttachmentRequest {
	r.uniqueIdIdExtension = &uniqueIdIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIDeleteProfileAttachmentRequest) UniqueIdIdContext(uniqueIdIdContext []string) ProfileAPIDeleteProfileAttachmentRequest {
	r.uniqueIdIdContext = &uniqueIdIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIDeleteProfileAttachmentRequest) UniqueIdType(uniqueIdType []string) ProfileAPIDeleteProfileAttachmentRequest {
	r.uniqueIdType = &uniqueIdType
	return r
}

// External system code.
func (r ProfileAPIDeleteProfileAttachmentRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteProfileAttachmentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteProfileAttachmentRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteProfileAttachmentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteProfileAttachmentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileAttachmentExecute(r)
}

/*
DeleteProfileAttachment Delete profile attachment

This API will delete an attachment on a profile in OPERA Cloud. <p><strong>OperationId:</strong>deleteProfileAttachment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attachmentId
 @param profileId
 @return ProfileAPIDeleteProfileAttachmentRequest
*/
func (a *ProfileAPIService) DeleteProfileAttachment(ctx context.Context, attachmentId string, profileId string) ProfileAPIDeleteProfileAttachmentRequest {
	return ProfileAPIDeleteProfileAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		attachmentId: attachmentId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteProfileAttachmentExecute(r ProfileAPIDeleteProfileAttachmentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteProfileAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/attachments/{attachmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attachmentId"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.attachmentId) < 1 {
		return localVarReturnValue, nil, reportError("attachmentId must have at least 1 elements")
	}
	if strlen(r.attachmentId) > 2000 {
		return localVarReturnValue, nil, reportError("attachmentId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.idExtension != nil {
		t := *r.idExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.uniqueIdIdExtension != nil {
		t := *r.uniqueIdIdExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdExtension", t, "multi")
		}
  }
	if r.uniqueIdIdContext != nil {
		t := *r.uniqueIdIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdIdContext", t, "multi")
		}
  }
	if r.uniqueIdType != nil {
		t := *r.uniqueIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteProfileCommissionAccountRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	validatePending *bool
	hotelId *string
	profileIdExtension *int32
	profileContext *string
	profileType *string
	bankAccountId *string
	bankAccountIdExtension *int32
	bankAccountIdContext *string
	bankAccountIdType *string
	commissionCode *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteProfileCommissionAccountRequest) Authorization(authorization string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteProfileCommissionAccountRequest) XAppKey(xAppKey string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteProfileCommissionAccountRequest) XHotelid(xHotelid string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used in CRUD operations. When set to true, proceed validating pending commissions
func (r ProfileAPIDeleteProfileCommissionAccountRequest) ValidatePending(validatePending bool) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.validatePending = &validatePending
	return r
}

// Hotel code from which the profile bank account and code belongs to
func (r ProfileAPIDeleteProfileCommissionAccountRequest) HotelId(hotelId string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.hotelId = &hotelId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) ProfileIdExtension(profileIdExtension int32) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.profileIdExtension = &profileIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIDeleteProfileCommissionAccountRequest) ProfileContext(profileContext string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.profileContext = &profileContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) ProfileType(profileType string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) BankAccountId(bankAccountId string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.bankAccountId = &bankAccountId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) BankAccountIdExtension(bankAccountIdExtension int32) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.bankAccountIdExtension = &bankAccountIdExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIDeleteProfileCommissionAccountRequest) BankAccountIdContext(bankAccountIdContext string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.bankAccountIdContext = &bankAccountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) BankAccountIdType(bankAccountIdType string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.bankAccountIdType = &bankAccountIdType
	return r
}

// Code.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) CommissionCode(commissionCode string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.commissionCode = &commissionCode
	return r
}

// description.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) Description(description string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.description = &description
	return r
}

// External system code.
func (r ProfileAPIDeleteProfileCommissionAccountRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteProfileCommissionAccountRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteProfileCommissionAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteProfileCommissionAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfileCommissionAccountExecute(r)
}

/*
DeleteProfileCommissionAccount Delete a commission account from a profile

Delete a Commission Account from a specified profile. <p><strong>OperationId:</strong>deleteProfileCommissionAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIDeleteProfileCommissionAccountRequest
*/
func (a *ProfileAPIService) DeleteProfileCommissionAccount(ctx context.Context, profileId string) ProfileAPIDeleteProfileCommissionAccountRequest {
	return ProfileAPIDeleteProfileCommissionAccountRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteProfileCommissionAccountExecute(r ProfileAPIDeleteProfileCommissionAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteProfileCommissionAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/commissionAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.validatePending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validatePending", r.validatePending, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.profileIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdExtension", r.profileIdExtension, "")
  }
	if r.profileContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileContext", r.profileContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.bankAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bankAccountId", r.bankAccountId, "")
  }
	if r.bankAccountIdExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bankAccountIdExtension", r.bankAccountIdExtension, "")
  }
	if r.bankAccountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bankAccountIdContext", r.bankAccountIdContext, "")
  }
	if r.bankAccountIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bankAccountIdType", r.bankAccountIdType, "")
  }
	if r.commissionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "commissionCode", r.commissionCode, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDeleteProfilePermanentlyRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDeleteProfilePermanentlyRequest) Authorization(authorization string) ProfileAPIDeleteProfilePermanentlyRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDeleteProfilePermanentlyRequest) XAppKey(xAppKey string) ProfileAPIDeleteProfilePermanentlyRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDeleteProfilePermanentlyRequest) XHotelid(xHotelid string) ProfileAPIDeleteProfilePermanentlyRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileAPIDeleteProfilePermanentlyRequest) XExternalsystem(xExternalsystem string) ProfileAPIDeleteProfilePermanentlyRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDeleteProfilePermanentlyRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDeleteProfilePermanentlyRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDeleteProfilePermanentlyRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteProfilePermanentlyExecute(r)
}

/*
DeleteProfilePermanently Delete the profile permanently.

 <p><strong>OperationId:</strong>deleteProfilePermanently</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIDeleteProfilePermanentlyRequest
*/
func (a *ProfileAPIService) DeleteProfilePermanently(ctx context.Context, profileId string) ProfileAPIDeleteProfilePermanentlyRequest {
	return ProfileAPIDeleteProfilePermanentlyRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DeleteProfilePermanentlyExecute(r ProfileAPIDeleteProfilePermanentlyRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteProfilePermanently")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/action/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIDistributePreferenceRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preference *Preference
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIDistributePreferenceRequest) Authorization(authorization string) ProfileAPIDistributePreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIDistributePreferenceRequest) XAppKey(xAppKey string) ProfileAPIDistributePreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIDistributePreferenceRequest) XHotelid(xHotelid string) ProfileAPIDistributePreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for distribute Preference. This object contains unique identifiers for each profile and list of preferences to be associated with the profile. The standard optional Opera Context element is also included.
func (r ProfileAPIDistributePreferenceRequest) Preference(preference Preference) ProfileAPIDistributePreferenceRequest {
	r.preference = &preference
	return r
}

// External system code.
func (r ProfileAPIDistributePreferenceRequest) XExternalsystem(xExternalsystem string) ProfileAPIDistributePreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIDistributePreferenceRequest) AcceptLanguage(acceptLanguage string) ProfileAPIDistributePreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIDistributePreferenceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DistributePreferenceExecute(r)
}

/*
DistributePreference Distribute preferences on a profile

With this API you can distribute preferences on a profile. <p><strong>OperationId:</strong>distributePreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIDistributePreferenceRequest
*/
func (a *ProfileAPIService) DistributePreference(ctx context.Context, profileId string) ProfileAPIDistributePreferenceRequest {
	return ProfileAPIDistributePreferenceRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) DistributePreferenceExecute(r ProfileAPIDistributePreferenceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DistributePreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIExtendECertificateRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	certificateId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCertificateToExtend *ECertificateToExtend
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIExtendECertificateRequest) Authorization(authorization string) ProfileAPIExtendECertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIExtendECertificateRequest) XAppKey(xAppKey string) ProfileAPIExtendECertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIExtendECertificateRequest) XHotelid(xHotelid string) ProfileAPIExtendECertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Consume an E-Certificate.
func (r ProfileAPIExtendECertificateRequest) ECertificateToExtend(eCertificateToExtend ECertificateToExtend) ProfileAPIExtendECertificateRequest {
	r.eCertificateToExtend = &eCertificateToExtend
	return r
}

// External system code.
func (r ProfileAPIExtendECertificateRequest) XExternalsystem(xExternalsystem string) ProfileAPIExtendECertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIExtendECertificateRequest) AcceptLanguage(acceptLanguage string) ProfileAPIExtendECertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIExtendECertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ExtendECertificateExecute(r)
}

/*
ExtendECertificate Extend E-Certificate Expiry date

Use this API to extend the date of an existing E-Certificate. <p><strong>OperationId:</strong>extendECertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificateId
 @return ProfileAPIExtendECertificateRequest
*/
func (a *ProfileAPIService) ExtendECertificate(ctx context.Context, certificateId string) ProfileAPIExtendECertificateRequest {
	return ProfileAPIExtendECertificateRequest{
		ApiService: a,
		ctx: ctx,
		certificateId: certificateId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) ExtendECertificateExecute(r ProfileAPIExtendECertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ExtendECertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecertificates/{certificateId}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"certificateId"+"}", url.PathEscape(parameterValueToString(r.certificateId, "certificateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.certificateId) < 1 {
		return localVarReturnValue, nil, reportError("certificateId must have at least 1 elements")
	}
	if strlen(r.certificateId) > 2000 {
		return localVarReturnValue, nil, reportError("certificateId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCertificateToExtend
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetAccountForecastsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fromPeriodCode *string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetAccountForecastsRequest) Authorization(authorization string) ProfileAPIGetAccountForecastsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetAccountForecastsRequest) XAppKey(xAppKey string) ProfileAPIGetAccountForecastsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetAccountForecastsRequest) XHotelid(xHotelid string) ProfileAPIGetAccountForecastsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Specifies the From Fiscal or Calendar Period Code
func (r ProfileAPIGetAccountForecastsRequest) FromPeriodCode(fromPeriodCode string) ProfileAPIGetAccountForecastsRequest {
	r.fromPeriodCode = &fromPeriodCode
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetAccountForecastsRequest) Limit(limit int32) ProfileAPIGetAccountForecastsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ProfileAPIGetAccountForecastsRequest) Offset(offset int32) ProfileAPIGetAccountForecastsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r ProfileAPIGetAccountForecastsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetAccountForecastsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetAccountForecastsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetAccountForecastsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetAccountForecastsRequest) Execute() (*AccountForecasts, *http.Response, error) {
	return r.ApiService.GetAccountForecastsExecute(r)
}

/*
GetAccountForecasts Fetch Account Forecasts by hotel

You can use this API to retrieve account forecasts for a hotel <p><strong>OperationId:</strong>getAccountForecasts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Hotel Code
 @param profileId Unique OPERA internal account profile ID
 @return ProfileAPIGetAccountForecastsRequest
*/
func (a *ProfileAPIService) GetAccountForecasts(ctx context.Context, hotelId string, profileId string) ProfileAPIGetAccountForecastsRequest {
	return ProfileAPIGetAccountForecastsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return AccountForecasts
func (a *ProfileAPIService) GetAccountForecastsExecute(r ProfileAPIGetAccountForecastsRequest) (*AccountForecasts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountForecasts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetAccountForecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/hotels/{hotelId}/forecasts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.fromPeriodCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromPeriodCode", r.fromPeriodCode, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetAddressRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeNoCity *bool
	cityName *string
	postalCode *string
	state *string
	code *string
	streetAddress *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetAddressRequest) Authorization(authorization string) ProfileAPIGetAddressRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetAddressRequest) XAppKey(xAppKey string) ProfileAPIGetAddressRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetAddressRequest) XHotelid(xHotelid string) ProfileAPIGetAddressRequest {
	r.xHotelid = &xHotelid
	return r
}

// When true indicates that only profiles with city will be fetched.
func (r ProfileAPIGetAddressRequest) ExcludeNoCity(excludeNoCity bool) ProfileAPIGetAddressRequest {
	r.excludeNoCity = &excludeNoCity
	return r
}

// City (e.g., Dublin), town, or postal station (i.e., a postal service territory, often used in a military address).
func (r ProfileAPIGetAddressRequest) CityName(cityName string) ProfileAPIGetAddressRequest {
	r.cityName = &cityName
	return r
}

// Post Office Code number.
func (r ProfileAPIGetAddressRequest) PostalCode(postalCode string) ProfileAPIGetAddressRequest {
	r.postalCode = &postalCode
	return r
}

// State or Province name (e.g., Texas).
func (r ProfileAPIGetAddressRequest) State(state string) ProfileAPIGetAddressRequest {
	r.state = &state
	return r
}

// Code for a country or a nationality.
func (r ProfileAPIGetAddressRequest) Code(code string) ProfileAPIGetAddressRequest {
	r.code = &code
	return r
}

// First Line of Street Address. For profile search it matches the first Address line.
func (r ProfileAPIGetAddressRequest) StreetAddress(streetAddress string) ProfileAPIGetAddressRequest {
	r.streetAddress = &streetAddress
	return r
}

// External system code.
func (r ProfileAPIGetAddressRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetAddressRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetAddressRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetAddressRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetAddressRequest) Execute() (*CityState, *http.Response, error) {
	return r.ApiService.GetAddressExecute(r)
}

/*
GetAddress Get city states

This API will get city and states. <p><strong>OperationId:</strong>getAddress</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetAddressRequest
*/
func (a *ProfileAPIService) GetAddress(ctx context.Context) ProfileAPIGetAddressRequest {
	return ProfileAPIGetAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CityState
func (a *ProfileAPIService) GetAddressExecute(r ProfileAPIGetAddressRequest) (*CityState, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CityState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeNoCity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNoCity", r.excludeNoCity, "")
  }
	if r.cityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cityName", r.cityName, "")
  }
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
  }
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetAwardsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileContext *string
	profileType *string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetAwardsRequest) Authorization(authorization string) ProfileAPIGetAwardsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetAwardsRequest) XAppKey(xAppKey string) ProfileAPIGetAwardsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetAwardsRequest) XHotelid(xHotelid string) ProfileAPIGetAwardsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetAwardsRequest) ProfileContext(profileContext string) ProfileAPIGetAwardsRequest {
	r.profileContext = &profileContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetAwardsRequest) ProfileType(profileType string) ProfileAPIGetAwardsRequest {
	r.profileType = &profileType
	return r
}

// Hotel Code for which the routing instructions are provided for a profile.
func (r ProfileAPIGetAwardsRequest) HotelId(hotelId string) ProfileAPIGetAwardsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ProfileAPIGetAwardsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetAwardsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetAwardsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetAwardsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetAwardsRequest) Execute() (*AwardDetails, *http.Response, error) {
	return r.ApiService.GetAwardsExecute(r)
}

/*
GetAwards Get Profile awards and certificates

Get Profile awards and certificates that exist on a profile. <p><strong>OperationId:</strong>getAwards</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetAwardsRequest
*/
func (a *ProfileAPIService) GetAwards(ctx context.Context, profileId string) ProfileAPIGetAwardsRequest {
	return ProfileAPIGetAwardsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return AwardDetails
func (a *ProfileAPIService) GetAwardsExecute(r ProfileAPIGetAwardsRequest) (*AwardDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AwardDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetAwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/awardsAndCertificates"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.profileContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileContext", r.profileContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetCashieringDetailsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchPaymentMethod *bool
	fetchRoutingInstruction *bool
	idContext *string
	idType *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetCashieringDetailsRequest) Authorization(authorization string) ProfileAPIGetCashieringDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetCashieringDetailsRequest) XAppKey(xAppKey string) ProfileAPIGetCashieringDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetCashieringDetailsRequest) XHotelid(xHotelid string) ProfileAPIGetCashieringDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Boolean flag that indicates whether the payment method has to be fetched or not.
func (r ProfileAPIGetCashieringDetailsRequest) FetchPaymentMethod(fetchPaymentMethod bool) ProfileAPIGetCashieringDetailsRequest {
	r.fetchPaymentMethod = &fetchPaymentMethod
	return r
}

// Boolean flag that indicates whether the routing instruction has to be fetched or not.
func (r ProfileAPIGetCashieringDetailsRequest) FetchRoutingInstruction(fetchRoutingInstruction bool) ProfileAPIGetCashieringDetailsRequest {
	r.fetchRoutingInstruction = &fetchRoutingInstruction
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetCashieringDetailsRequest) IdContext(idContext string) ProfileAPIGetCashieringDetailsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetCashieringDetailsRequest) IdType(idType string) ProfileAPIGetCashieringDetailsRequest {
	r.idType = &idType
	return r
}

// List of Hotel Codes.
func (r ProfileAPIGetCashieringDetailsRequest) HotelIds(hotelIds []string) ProfileAPIGetCashieringDetailsRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ProfileAPIGetCashieringDetailsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetCashieringDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetCashieringDetailsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetCashieringDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetCashieringDetailsRequest) Execute() (*ProfileCashieringDetailsInfo, *http.Response, error) {
	return r.ApiService.GetCashieringDetailsExecute(r)
}

/*
GetCashieringDetails Get cashiering details for a profile

Retrieve any profile Financial details that exists on a profile (typically Company or Travel Agent profiles).  This includes Routing Instructions on the profile. <p><strong>OperationId:</strong>getCashieringDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetCashieringDetailsRequest
*/
func (a *ProfileAPIService) GetCashieringDetails(ctx context.Context, profileId string) ProfileAPIGetCashieringDetailsRequest {
	return ProfileAPIGetCashieringDetailsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileCashieringDetailsInfo
func (a *ProfileAPIService) GetCashieringDetailsExecute(r ProfileAPIGetCashieringDetailsRequest) (*ProfileCashieringDetailsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileCashieringDetailsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetCashieringDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/cashieringDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.fetchPaymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchPaymentMethod", r.fetchPaymentMethod, "")
  }
	if r.fetchRoutingInstruction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchRoutingInstruction", r.fetchRoutingInstruction, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetCompanyProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	corporateID string
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetCompanyProfileRequest) Authorization(authorization string) ProfileAPIGetCompanyProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetCompanyProfileRequest) XAppKey(xAppKey string) ProfileAPIGetCompanyProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetCompanyProfileRequest) XHotelid(xHotelid string) ProfileAPIGetCompanyProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Room Ownership information associated with the profile.
func (r ProfileAPIGetCompanyProfileRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetCompanyProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ProfileAPIGetCompanyProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetCompanyProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetCompanyProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetCompanyProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetCompanyProfileRequest) Execute() (*Company, *http.Response, error) {
	return r.ApiService.GetCompanyProfileExecute(r)
}

/*
GetCompanyProfile Get company profile by corporate ID

Use this to retrieve a specific Company, Travel Agent, Group or Source profile. You must know the corporate ID of the profile for the request API. <p><strong>OperationId:</strong>getCompanyProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param corporateID Unique OPERA Corporate ID used to find company/agent/group/source profile in OPERA.
 @return ProfileAPIGetCompanyProfileRequest
*/
func (a *ProfileAPIService) GetCompanyProfile(ctx context.Context, corporateID string) ProfileAPIGetCompanyProfileRequest {
	return ProfileAPIGetCompanyProfileRequest{
		ApiService: a,
		ctx: ctx,
		corporateID: corporateID,
	}
}

// Execute executes the request
//  @return Company
func (a *ProfileAPIService) GetCompanyProfileExecute(r ProfileAPIGetCompanyProfileRequest) (*Company, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Company
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetCompanyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{corporateID}"
	localVarPath = strings.Replace(localVarPath, "{"+"corporateID"+"}", url.PathEscape(parameterValueToString(r.corporateID, "corporateID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.corporateID) < 1 {
		return localVarReturnValue, nil, reportError("corporateID must have at least 1 elements")
	}
	if strlen(r.corporateID) > 2000 {
		return localVarReturnValue, nil, reportError("corporateID must have less than 2000 elements")
	}

	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetDuplicateExternalSubscriptionsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	databaseId *string
	profileId *string
	profileContext *string
	profileType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) Authorization(authorization string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) XAppKey(xAppKey string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) XHotelid(xHotelid string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) Limit(limit int32) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) Offset(offset int32) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.offset = &offset
	return r
}

// Code identifying the external database record which is linked to external systems.
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) DatabaseId(databaseId string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.databaseId = &databaseId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) ProfileId(profileId string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) ProfileContext(profileContext string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.profileContext = &profileContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) ProfileType(profileType string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.profileType = &profileType
	return r
}

// External system code.
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetDuplicateExternalSubscriptionsRequest) Execute() (*DuplicateExternalSubscriptions, *http.Response, error) {
	return r.ApiService.GetDuplicateExternalSubscriptionsExecute(r)
}

/*
GetDuplicateExternalSubscriptions Get profiles with duplicate external subscriptions 

Fetch profile subscriptions where the same OPERA Cloud profile is linked to multiple external profiles, within the same external system. <p><strong>OperationId:</strong>getDuplicateExternalSubscriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetDuplicateExternalSubscriptionsRequest
*/
func (a *ProfileAPIService) GetDuplicateExternalSubscriptions(ctx context.Context) ProfileAPIGetDuplicateExternalSubscriptionsRequest {
	return ProfileAPIGetDuplicateExternalSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DuplicateExternalSubscriptions
func (a *ProfileAPIService) GetDuplicateExternalSubscriptionsExecute(r ProfileAPIGetDuplicateExternalSubscriptionsRequest) (*DuplicateExternalSubscriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DuplicateExternalSubscriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetDuplicateExternalSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/duplicateExternalSubscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.databaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "databaseId", r.databaseId, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileContext", r.profileContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetDuplicateOPERASubscriptionsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	databaseId *string
	profileId *string
	profileContext *string
	profileType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) Authorization(authorization string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) XAppKey(xAppKey string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) XHotelid(xHotelid string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) Limit(limit int32) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) Offset(offset int32) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.offset = &offset
	return r
}

// Code identifying the external database record which is linked to external systems.
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) DatabaseId(databaseId string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.databaseId = &databaseId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) ProfileId(profileId string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) ProfileContext(profileContext string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.profileContext = &profileContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) ProfileType(profileType string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.profileType = &profileType
	return r
}

// External system code.
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetDuplicateOPERASubscriptionsRequest) Execute() (*DuplicateOPERASubscriptions, *http.Response, error) {
	return r.ApiService.GetDuplicateOPERASubscriptionsExecute(r)
}

/*
GetDuplicateOPERASubscriptions Get profiles with duplicate OPERA Cloud subscriptions

Fetch subscriptions where an external profile within a particular external system is linked to multiple OPERA Cloud profiles. <p><strong>OperationId:</strong>getDuplicateOPERASubscriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetDuplicateOPERASubscriptionsRequest
*/
func (a *ProfileAPIService) GetDuplicateOPERASubscriptions(ctx context.Context) ProfileAPIGetDuplicateOPERASubscriptionsRequest {
	return ProfileAPIGetDuplicateOPERASubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DuplicateOPERASubscriptions
func (a *ProfileAPIService) GetDuplicateOPERASubscriptionsExecute(r ProfileAPIGetDuplicateOPERASubscriptionsRequest) (*DuplicateOPERASubscriptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DuplicateOPERASubscriptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetDuplicateOPERASubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/duplicateOPERASubscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.databaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "databaseId", r.databaseId, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileContext", r.profileContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetECertificatesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileId *string
	profileContext *string
	profileType *string
	hotelId *string
	code *string
	groupCode *string
	status *[]string
	includeInactive *bool
	voucherNo *string
	excludeVoucherNumbers *[]string
	availableECertificates *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetECertificatesRequest) Authorization(authorization string) ProfileAPIGetECertificatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetECertificatesRequest) XAppKey(xAppKey string) ProfileAPIGetECertificatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetECertificatesRequest) XHotelid(xHotelid string) ProfileAPIGetECertificatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetECertificatesRequest) ProfileId(profileId string) ProfileAPIGetECertificatesRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetECertificatesRequest) ProfileContext(profileContext string) ProfileAPIGetECertificatesRequest {
	r.profileContext = &profileContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetECertificatesRequest) ProfileType(profileType string) ProfileAPIGetECertificatesRequest {
	r.profileType = &profileType
	return r
}

// Property for which preferences are to be fetched.
func (r ProfileAPIGetECertificatesRequest) HotelId(hotelId string) ProfileAPIGetECertificatesRequest {
	r.hotelId = &hotelId
	return r
}

// Ecertificates search criteria
func (r ProfileAPIGetECertificatesRequest) Code(code string) ProfileAPIGetECertificatesRequest {
	r.code = &code
	return r
}

// Ecertificates search criteria
func (r ProfileAPIGetECertificatesRequest) GroupCode(groupCode string) ProfileAPIGetECertificatesRequest {
	r.groupCode = &groupCode
	return r
}

// Indicates that OPERA E-Certificate is reserved.
func (r ProfileAPIGetECertificatesRequest) Status(status []string) ProfileAPIGetECertificatesRequest {
	r.status = &status
	return r
}

// Include or not include inactive E-certificate.
func (r ProfileAPIGetECertificatesRequest) IncludeInactive(includeInactive bool) ProfileAPIGetECertificatesRequest {
	r.includeInactive = &includeInactive
	return r
}

// System generated unique voucher number.
func (r ProfileAPIGetECertificatesRequest) VoucherNo(voucherNo string) ProfileAPIGetECertificatesRequest {
	r.voucherNo = &voucherNo
	return r
}

// List of System generated unique voucher numbers to be excluded.
func (r ProfileAPIGetECertificatesRequest) ExcludeVoucherNumbers(excludeVoucherNumbers []string) ProfileAPIGetECertificatesRequest {
	r.excludeVoucherNumbers = &excludeVoucherNumbers
	return r
}

// Search criteria to limit Ecertificates that are available for reservation consumption.
func (r ProfileAPIGetECertificatesRequest) AvailableECertificates(availableECertificates bool) ProfileAPIGetECertificatesRequest {
	r.availableECertificates = &availableECertificates
	return r
}

// External system code.
func (r ProfileAPIGetECertificatesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetECertificatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetECertificatesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetECertificatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetECertificatesRequest) Execute() (*ECertificates, *http.Response, error) {
	return r.ApiService.GetECertificatesExecute(r)
}

/*
GetECertificates Get e-certificate

This API allows you to retrieve eCertificates which exist on a profile in OPERA Cloud. <p><strong>OperationId:</strong>getECertificates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetECertificatesRequest
*/
func (a *ProfileAPIService) GetECertificates(ctx context.Context) ProfileAPIGetECertificatesRequest {
	return ProfileAPIGetECertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ECertificates
func (a *ProfileAPIService) GetECertificatesExecute(r ProfileAPIGetECertificatesRequest) (*ECertificates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECertificates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetECertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecertificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileContext", r.profileContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
  }
	if r.groupCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupCode", r.groupCode, "")
  }
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.voucherNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voucherNo", r.voucherNo, "")
  }
	if r.excludeVoucherNumbers != nil {
		t := *r.excludeVoucherNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVoucherNumbers", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeVoucherNumbers", t, "multi")
		}
  }
	if r.availableECertificates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableECertificates", r.availableECertificates, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetFulfillmentExportLogsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	membershipId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	idContext *string
	idType *string
	membershipType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetFulfillmentExportLogsRequest) Authorization(authorization string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetFulfillmentExportLogsRequest) XAppKey(xAppKey string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetFulfillmentExportLogsRequest) XHotelid(xHotelid string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetFulfillmentExportLogsRequest) Id(id string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetFulfillmentExportLogsRequest) IdContext(idContext string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetFulfillmentExportLogsRequest) IdType(idType string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.idType = &idType
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ProfileAPIGetFulfillmentExportLogsRequest) MembershipType(membershipType string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.membershipType = &membershipType
	return r
}

// External system code.
func (r ProfileAPIGetFulfillmentExportLogsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetFulfillmentExportLogsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetFulfillmentExportLogsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetFulfillmentExportLogsRequest) Execute() (*FulfillmentExportedLogs, *http.Response, error) {
	return r.ApiService.GetFulfillmentExportLogsExecute(r)
}

/*
GetFulfillmentExportLogs Get Fulfillment Export Logs

Use this API to Get Fulfillment Export Logs. <p><strong>OperationId:</strong>getFulfillmentExportLogs</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId
 @return ProfileAPIGetFulfillmentExportLogsRequest
*/
func (a *ProfileAPIService) GetFulfillmentExportLogs(ctx context.Context, membershipId string) ProfileAPIGetFulfillmentExportLogsRequest {
	return ProfileAPIGetFulfillmentExportLogsRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return FulfillmentExportedLogs
func (a *ProfileAPIService) GetFulfillmentExportLogsExecute(r ProfileAPIGetFulfillmentExportLogsRequest) (*FulfillmentExportedLogs, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FulfillmentExportedLogs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetFulfillmentExportLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/memberships/{membershipId}/fullfillmentExportLogs"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipId) < 1 {
		return localVarReturnValue, nil, reportError("membershipId must have at least 1 elements")
	}
	if strlen(r.membershipId) > 2000 {
		return localVarReturnValue, nil, reportError("membershipId must have less than 2000 elements")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetGuestProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	guestId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetGuestProfileRequest) Authorization(authorization string) ProfileAPIGetGuestProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetGuestProfileRequest) XAppKey(xAppKey string) ProfileAPIGetGuestProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetGuestProfileRequest) XHotelid(xHotelid string) ProfileAPIGetGuestProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ProfileAPIGetGuestProfileRequest) HotelId(hotelId string) ProfileAPIGetGuestProfileRequest {
	r.hotelId = &hotelId
	return r
}

// Room Ownership information associated with the profile.
func (r ProfileAPIGetGuestProfileRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetGuestProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ProfileAPIGetGuestProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetGuestProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetGuestProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetGuestProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetGuestProfileRequest) Execute() (*Guest, *http.Response, error) {
	return r.ApiService.GetGuestProfileExecute(r)
}

/*
GetGuestProfile Get guest profile by guest ID

Use this API to retrieve all data stored for a guest Profile, such as their address, phone number, preferences. You must already know the guests Profile ID. If you don't know the profile ID, first use the API getGuests to find the profile ID. <p><strong>OperationId:</strong>getGuestProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guestId Unique OPERA internal ID used to find guest/contact/employee profile in OPERA.
 @return ProfileAPIGetGuestProfileRequest
*/
func (a *ProfileAPIService) GetGuestProfile(ctx context.Context, guestId string) ProfileAPIGetGuestProfileRequest {
	return ProfileAPIGetGuestProfileRequest{
		ApiService: a,
		ctx: ctx,
		guestId: guestId,
	}
}

// Execute executes the request
//  @return Guest
func (a *ProfileAPIService) GetGuestProfileExecute(r ProfileAPIGetGuestProfileRequest) (*Guest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Guest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetGuestProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guests/{guestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"guestId"+"}", url.PathEscape(parameterValueToString(r.guestId, "guestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.guestId) < 1 {
		return localVarReturnValue, nil, reportError("guestId must have at least 1 elements")
	}
	if strlen(r.guestId) > 2000 {
		return localVarReturnValue, nil, reportError("guestId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetLinkedProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	idType *string
	profileTypes *[]string
	accountsReceivables *bool
	corporateProfiles *bool
	excludeInactive *bool
	excludeIncompleteProfiles *bool
	includeHasHierarchyOnly *bool
	negotiatedRates *bool
	linkedProfileAdditionalCriteriaProfileType *string
	linkedProfileid *string
	linkedProfileIdContext *string
	linkedProfileIdType *string
	name *string
	givenName *string
	excludeNoCity *bool
	cityName *string
	postalCode *string
	state *string
	countryCode *string
	streetAddress *string
	ownerCode *[]string
	aRNumber *string
	prioritiesCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetLinkedProfilesRequest) Authorization(authorization string) ProfileAPIGetLinkedProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetLinkedProfilesRequest) XAppKey(xAppKey string) ProfileAPIGetLinkedProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetLinkedProfilesRequest) XHotelid(xHotelid string) ProfileAPIGetLinkedProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetLinkedProfilesRequest) IdContext(idContext string) ProfileAPIGetLinkedProfilesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetLinkedProfilesRequest) IdType(idType string) ProfileAPIGetLinkedProfilesRequest {
	r.idType = &idType
	return r
}

// The types of Profile handled by the web service.
func (r ProfileAPIGetLinkedProfilesRequest) ProfileTypes(profileTypes []string) ProfileAPIGetLinkedProfilesRequest {
	r.profileTypes = &profileTypes
	return r
}

// When true indicates that only profiles with AR account fetched.
func (r ProfileAPIGetLinkedProfilesRequest) AccountsReceivables(accountsReceivables bool) ProfileAPIGetLinkedProfilesRequest {
	r.accountsReceivables = &accountsReceivables
	return r
}

// When true indicates that only profiles with client id are searched for.
func (r ProfileAPIGetLinkedProfilesRequest) CorporateProfiles(corporateProfiles bool) ProfileAPIGetLinkedProfilesRequest {
	r.corporateProfiles = &corporateProfiles
	return r
}

// Indicates whether to exclude Inactive Profiles, when true indicates that only profiles with active status will be displayed.
func (r ProfileAPIGetLinkedProfilesRequest) ExcludeInactive(excludeInactive bool) ProfileAPIGetLinkedProfilesRequest {
	r.excludeInactive = &excludeInactive
	return r
}

// When true indicates that only profiles with an Address Line 1 and Country or at least one Communications Type will be displayed.
func (r ProfileAPIGetLinkedProfilesRequest) ExcludeIncompleteProfiles(excludeIncompleteProfiles bool) ProfileAPIGetLinkedProfilesRequest {
	r.excludeIncompleteProfiles = &excludeIncompleteProfiles
	return r
}

// Include profiles that have one or more relationships in the search.
func (r ProfileAPIGetLinkedProfilesRequest) IncludeHasHierarchyOnly(includeHasHierarchyOnly bool) ProfileAPIGetLinkedProfilesRequest {
	r.includeHasHierarchyOnly = &includeHasHierarchyOnly
	return r
}

// When true indicates that this option has to be included in advanced search.
func (r ProfileAPIGetLinkedProfilesRequest) NegotiatedRates(negotiatedRates bool) ProfileAPIGetLinkedProfilesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// The types of Profile handled by the web service.
func (r ProfileAPIGetLinkedProfilesRequest) LinkedProfileAdditionalCriteriaProfileType(linkedProfileAdditionalCriteriaProfileType string) ProfileAPIGetLinkedProfilesRequest {
	r.linkedProfileAdditionalCriteriaProfileType = &linkedProfileAdditionalCriteriaProfileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetLinkedProfilesRequest) LinkedProfileid(linkedProfileid string) ProfileAPIGetLinkedProfilesRequest {
	r.linkedProfileid = &linkedProfileid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetLinkedProfilesRequest) LinkedProfileIdContext(linkedProfileIdContext string) ProfileAPIGetLinkedProfilesRequest {
	r.linkedProfileIdContext = &linkedProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetLinkedProfilesRequest) LinkedProfileIdType(linkedProfileIdType string) ProfileAPIGetLinkedProfilesRequest {
	r.linkedProfileIdType = &linkedProfileIdType
	return r
}

// Family name, last name or Company Name.
func (r ProfileAPIGetLinkedProfilesRequest) Name(name string) ProfileAPIGetLinkedProfilesRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r ProfileAPIGetLinkedProfilesRequest) GivenName(givenName string) ProfileAPIGetLinkedProfilesRequest {
	r.givenName = &givenName
	return r
}

// When true indicates that only profiles with city will be fetched.
func (r ProfileAPIGetLinkedProfilesRequest) ExcludeNoCity(excludeNoCity bool) ProfileAPIGetLinkedProfilesRequest {
	r.excludeNoCity = &excludeNoCity
	return r
}

// City (e.g., Dublin), town, or postal station (i.e., a postal service territory, often used in a military address).
func (r ProfileAPIGetLinkedProfilesRequest) CityName(cityName string) ProfileAPIGetLinkedProfilesRequest {
	r.cityName = &cityName
	return r
}

// Post Office Code number.
func (r ProfileAPIGetLinkedProfilesRequest) PostalCode(postalCode string) ProfileAPIGetLinkedProfilesRequest {
	r.postalCode = &postalCode
	return r
}

// State or Province name (e.g., Texas).
func (r ProfileAPIGetLinkedProfilesRequest) State(state string) ProfileAPIGetLinkedProfilesRequest {
	r.state = &state
	return r
}

// Code for a country or a nationality.
func (r ProfileAPIGetLinkedProfilesRequest) CountryCode(countryCode string) ProfileAPIGetLinkedProfilesRequest {
	r.countryCode = &countryCode
	return r
}

// First Line of Street Address. For profile search it matches the first Address line.
func (r ProfileAPIGetLinkedProfilesRequest) StreetAddress(streetAddress string) ProfileAPIGetLinkedProfilesRequest {
	r.streetAddress = &streetAddress
	return r
}

func (r ProfileAPIGetLinkedProfilesRequest) OwnerCode(ownerCode []string) ProfileAPIGetLinkedProfilesRequest {
	r.ownerCode = &ownerCode
	return r
}

// Account Receivable associated to the profile.
func (r ProfileAPIGetLinkedProfilesRequest) ARNumber(aRNumber string) ProfileAPIGetLinkedProfilesRequest {
	r.aRNumber = &aRNumber
	return r
}

func (r ProfileAPIGetLinkedProfilesRequest) PrioritiesCode(prioritiesCode []string) ProfileAPIGetLinkedProfilesRequest {
	r.prioritiesCode = &prioritiesCode
	return r
}

// External system code.
func (r ProfileAPIGetLinkedProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetLinkedProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetLinkedProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetLinkedProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetLinkedProfilesRequest) Execute() (*LinkedProfiles, *http.Response, error) {
	return r.ApiService.GetLinkedProfilesExecute(r)
}

/*
GetLinkedProfiles Get linked profiles

Retrieve profiles that are linked to an existing profile in OPERA Cloud. <p><strong>OperationId:</strong>getLinkedProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetLinkedProfilesRequest
*/
func (a *ProfileAPIService) GetLinkedProfiles(ctx context.Context, profileId string) ProfileAPIGetLinkedProfilesRequest {
	return ProfileAPIGetLinkedProfilesRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return LinkedProfiles
func (a *ProfileAPIService) GetLinkedProfilesExecute(r ProfileAPIGetLinkedProfilesRequest) (*LinkedProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetLinkedProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	if r.profileTypes != nil {
		t := *r.profileTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileTypes", t, "multi")
		}
  }
	if r.accountsReceivables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountsReceivables", r.accountsReceivables, "")
  }
	if r.corporateProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateProfiles", r.corporateProfiles, "")
  }
	if r.excludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInactive", r.excludeInactive, "")
  }
	if r.excludeIncompleteProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeIncompleteProfiles", r.excludeIncompleteProfiles, "")
  }
	if r.includeHasHierarchyOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHasHierarchyOnly", r.includeHasHierarchyOnly, "")
  }
	if r.negotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "negotiatedRates", r.negotiatedRates, "")
  }
	if r.linkedProfileAdditionalCriteriaProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedProfileAdditionalCriteriaProfileType", r.linkedProfileAdditionalCriteriaProfileType, "")
  }
	if r.linkedProfileid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedProfileid", r.linkedProfileid, "")
  }
	if r.linkedProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedProfileIdContext", r.linkedProfileIdContext, "")
  }
	if r.linkedProfileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedProfileIdType", r.linkedProfileIdType, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
  }
	if r.excludeNoCity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNoCity", r.excludeNoCity, "")
  }
	if r.cityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cityName", r.cityName, "")
  }
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
  }
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
  }
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
  }
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "")
  }
	if r.ownerCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCode", r.ownerCode, "csv")
  }
	if r.aRNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aRNumber", r.aRNumber, "")
  }
	if r.prioritiesCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prioritiesCode", r.prioritiesCode, "csv")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetMatchProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	idContext *string
	idType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetMatchProfilesRequest) Authorization(authorization string) ProfileAPIGetMatchProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetMatchProfilesRequest) XAppKey(xAppKey string) ProfileAPIGetMatchProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetMatchProfilesRequest) XHotelid(xHotelid string) ProfileAPIGetMatchProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code for the profile.
func (r ProfileAPIGetMatchProfilesRequest) HotelId(hotelId string) ProfileAPIGetMatchProfilesRequest {
	r.hotelId = &hotelId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetMatchProfilesRequest) IdContext(idContext string) ProfileAPIGetMatchProfilesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetMatchProfilesRequest) IdType(idType string) ProfileAPIGetMatchProfilesRequest {
	r.idType = &idType
	return r
}

// External system code.
func (r ProfileAPIGetMatchProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetMatchProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetMatchProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetMatchProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetMatchProfilesRequest) Execute() (*MatchedProfiles, *http.Response, error) {
	return r.ApiService.GetMatchProfilesExecute(r)
}

/*
GetMatchProfiles Get profile matches

Retrieve profiles that match another profile. <p><strong>OperationId:</strong>getMatchProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetMatchProfilesRequest
*/
func (a *ProfileAPIService) GetMatchProfiles(ctx context.Context, profileId string) ProfileAPIGetMatchProfilesRequest {
	return ProfileAPIGetMatchProfilesRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return MatchedProfiles
func (a *ProfileAPIService) GetMatchProfilesExecute(r ProfileAPIGetMatchProfilesRequest) (*MatchedProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchedProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetMatchProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/matches"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.idType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idType", r.idType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetMembershipTierProjectionsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipId *string
	membershipType *string
	id *string
	idContext *string
	type_ *string
	projectionDate *string
	projectionType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetMembershipTierProjectionsRequest) Authorization(authorization string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetMembershipTierProjectionsRequest) XAppKey(xAppKey string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetMembershipTierProjectionsRequest) XHotelid(xHotelid string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Membership Card Number.
func (r ProfileAPIGetMembershipTierProjectionsRequest) MembershipId(membershipId string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.membershipId = &membershipId
	return r
}

// Type of the Membership.
func (r ProfileAPIGetMembershipTierProjectionsRequest) MembershipType(membershipType string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.membershipType = &membershipType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetMembershipTierProjectionsRequest) Id(id string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetMembershipTierProjectionsRequest) IdContext(idContext string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetMembershipTierProjectionsRequest) Type_(type_ string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.type_ = &type_
	return r
}

// Date for which Tier projections is fetched.
func (r ProfileAPIGetMembershipTierProjectionsRequest) ProjectionDate(projectionDate string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.projectionDate = &projectionDate
	return r
}

// Upgrade And Downgrade
func (r ProfileAPIGetMembershipTierProjectionsRequest) ProjectionType(projectionType string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.projectionType = &projectionType
	return r
}

// External system code.
func (r ProfileAPIGetMembershipTierProjectionsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetMembershipTierProjectionsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetMembershipTierProjectionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetMembershipTierProjectionsRequest) Execute() (*MembershipTierProjections, *http.Response, error) {
	return r.ApiService.GetMembershipTierProjectionsExecute(r)
}

/*
GetMembershipTierProjections Get Membership Tier Projection

Retrieve a list of membership Tier Projection such as upgrades and downgrades. <p><strong>OperationId:</strong>getMembershipTierProjections</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetMembershipTierProjectionsRequest
*/
func (a *ProfileAPIService) GetMembershipTierProjections(ctx context.Context) ProfileAPIGetMembershipTierProjectionsRequest {
	return ProfileAPIGetMembershipTierProjectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MembershipTierProjections
func (a *ProfileAPIService) GetMembershipTierProjectionsExecute(r ProfileAPIGetMembershipTierProjectionsRequest) (*MembershipTierProjections, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MembershipTierProjections
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetMembershipTierProjections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/membershipTierProjections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.membershipId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipId", r.membershipId, "")
  }
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.projectionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectionDate", r.projectionDate, "")
  }
	if r.projectionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectionType", r.projectionType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetMergeProfilesSnapshotRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	survivorProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	originalId *string
	originalIdContext *string
	originalIdType *string
	toBeMergedId *[]string
	toBeMergedIdContext *[]string
	toBeMergedIdType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetMergeProfilesSnapshotRequest) Authorization(authorization string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetMergeProfilesSnapshotRequest) XAppKey(xAppKey string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetMergeProfilesSnapshotRequest) XHotelid(xHotelid string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetMergeProfilesSnapshotRequest) OriginalId(originalId string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.originalId = &originalId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetMergeProfilesSnapshotRequest) OriginalIdContext(originalIdContext string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.originalIdContext = &originalIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetMergeProfilesSnapshotRequest) OriginalIdType(originalIdType string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.originalIdType = &originalIdType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetMergeProfilesSnapshotRequest) ToBeMergedId(toBeMergedId []string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.toBeMergedId = &toBeMergedId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetMergeProfilesSnapshotRequest) ToBeMergedIdContext(toBeMergedIdContext []string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.toBeMergedIdContext = &toBeMergedIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetMergeProfilesSnapshotRequest) ToBeMergedIdType(toBeMergedIdType []string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.toBeMergedIdType = &toBeMergedIdType
	return r
}

// External system code.
func (r ProfileAPIGetMergeProfilesSnapshotRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetMergeProfilesSnapshotRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetMergeProfilesSnapshotRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetMergeProfilesSnapshotRequest) Execute() (*MergedProfilesSnapshotDetails, *http.Response, error) {
	return r.ApiService.GetMergeProfilesSnapshotExecute(r)
}

/*
GetMergeProfilesSnapshot Get merge profiles snapshot

This API will provide you with a snapshot of the to be merged profile. In the request you will pass the survivor profile, along with the profile ID of the profile which it to be merged into the survivor profile.  The response will provide you with the combined profile data of both profiles which are being merged. <p><strong>OperationId:</strong>getMergeProfilesSnapshot</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param survivorProfileId
 @return ProfileAPIGetMergeProfilesSnapshotRequest
*/
func (a *ProfileAPIService) GetMergeProfilesSnapshot(ctx context.Context, survivorProfileId string) ProfileAPIGetMergeProfilesSnapshotRequest {
	return ProfileAPIGetMergeProfilesSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		survivorProfileId: survivorProfileId,
	}
}

// Execute executes the request
//  @return MergedProfilesSnapshotDetails
func (a *ProfileAPIService) GetMergeProfilesSnapshotExecute(r ProfileAPIGetMergeProfilesSnapshotRequest) (*MergedProfilesSnapshotDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergedProfilesSnapshotDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetMergeProfilesSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{survivorProfileId}/merges/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"survivorProfileId"+"}", url.PathEscape(parameterValueToString(r.survivorProfileId, "survivorProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.survivorProfileId) < 1 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have at least 1 elements")
	}
	if strlen(r.survivorProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have less than 2000 elements")
	}

	if r.originalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalId", r.originalId, "")
  }
	if r.originalIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalIdContext", r.originalIdContext, "")
  }
	if r.originalIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalIdType", r.originalIdType, "")
  }
	if r.toBeMergedId != nil {
		t := *r.toBeMergedId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "toBeMergedId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "toBeMergedId", t, "multi")
		}
  }
	if r.toBeMergedIdContext != nil {
		t := *r.toBeMergedIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "toBeMergedIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "toBeMergedIdContext", t, "multi")
		}
  }
	if r.toBeMergedIdType != nil {
		t := *r.toBeMergedIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "toBeMergedIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "toBeMergedIdType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetMergeStageProfileSnapshotRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	survivorProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	resortProfileId *string
	resortProfileIdContext *string
	resortProfileIdType *string
	profileIdContext *string
	profileIdType *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) Authorization(authorization string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) XAppKey(xAppKey string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) XHotelid(xHotelid string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code for the profile.
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) HotelId(hotelId string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) ResortProfileId(resortProfileId string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.resortProfileId = &resortProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) ResortProfileIdContext(resortProfileIdContext string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.resortProfileIdContext = &resortProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) ResortProfileIdType(resortProfileIdType string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.resortProfileIdType = &resortProfileIdType
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) ProfileIdContext(profileIdContext string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) ProfileIdType(profileIdType string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.profileIdType = &profileIdType
	return r
}

// External system code.
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetMergeStageProfileSnapshotRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetMergeStageProfileSnapshotRequest) Execute() (*MergedStageProfileSnapshot, *http.Response, error) {
	return r.ApiService.GetMergeStageProfileSnapshotExecute(r)
}

/*
GetMergeStageProfileSnapshot Get merge stage profile snapshot

This API will provide you with a snapshot of the to be merged profile in staging. <p><strong>OperationId:</strong>getMergeStageProfileSnapshot</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param survivorProfileId
 @return ProfileAPIGetMergeStageProfileSnapshotRequest
*/
func (a *ProfileAPIService) GetMergeStageProfileSnapshot(ctx context.Context, survivorProfileId string) ProfileAPIGetMergeStageProfileSnapshotRequest {
	return ProfileAPIGetMergeStageProfileSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		survivorProfileId: survivorProfileId,
	}
}

// Execute executes the request
//  @return MergedStageProfileSnapshot
func (a *ProfileAPIService) GetMergeStageProfileSnapshotExecute(r ProfileAPIGetMergeStageProfileSnapshotRequest) (*MergedStageProfileSnapshot, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergedStageProfileSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetMergeStageProfileSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{survivorProfileId}/stageProfiles/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"survivorProfileId"+"}", url.PathEscape(parameterValueToString(r.survivorProfileId, "survivorProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.survivorProfileId) < 1 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have at least 1 elements")
	}
	if strlen(r.survivorProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.resortProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resortProfileId", r.resortProfileId, "")
  }
	if r.resortProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resortProfileIdContext", r.resortProfileIdContext, "")
  }
	if r.resortProfileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resortProfileIdType", r.resortProfileIdType, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetPreferenceForProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idContext *[]string
	type_ *[]string
	hotelId *string
	codes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetPreferenceForProfileRequest) Authorization(authorization string) ProfileAPIGetPreferenceForProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetPreferenceForProfileRequest) XAppKey(xAppKey string) ProfileAPIGetPreferenceForProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetPreferenceForProfileRequest) XHotelid(xHotelid string) ProfileAPIGetPreferenceForProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetPreferenceForProfileRequest) Id(id []string) ProfileAPIGetPreferenceForProfileRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetPreferenceForProfileRequest) IdContext(idContext []string) ProfileAPIGetPreferenceForProfileRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetPreferenceForProfileRequest) Type_(type_ []string) ProfileAPIGetPreferenceForProfileRequest {
	r.type_ = &type_
	return r
}

// Used for codes in the OPERA Code tables. Possible values of this pattern are 1, 101, 101.EQP, or 101.EQP.X.
func (r ProfileAPIGetPreferenceForProfileRequest) HotelId(hotelId string) ProfileAPIGetPreferenceForProfileRequest {
	r.hotelId = &hotelId
	return r
}

func (r ProfileAPIGetPreferenceForProfileRequest) Codes(codes []string) ProfileAPIGetPreferenceForProfileRequest {
	r.codes = &codes
	return r
}

// External system code.
func (r ProfileAPIGetPreferenceForProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetPreferenceForProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetPreferenceForProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetPreferenceForProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetPreferenceForProfileRequest) Execute() (*Preference, *http.Response, error) {
	return r.ApiService.GetPreferenceForProfileExecute(r)
}

/*
GetPreferenceForProfile Get preferences on a profile

Use this API to retrieve all preferences that a profile has stored on it.  Preferences are configured codes by a property, examples are usually High Floor, Non smoking room, Room with a View, soft pillow etc.  <p><strong>OperationId:</strong>getPreferenceForProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetPreferenceForProfileRequest
*/
func (a *ProfileAPIService) GetPreferenceForProfile(ctx context.Context, profileId string) ProfileAPIGetPreferenceForProfileRequest {
	return ProfileAPIGetPreferenceForProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Preference
func (a *ProfileAPIService) GetPreferenceForProfileExecute(r ProfileAPIGetPreferenceForProfileRequest) (*Preference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Preference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetPreferenceForProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	logViewProfile *bool
	showInactiveRoomOwners *bool
	markAsRecentlyAccessed *bool
	fetchInstructions *[]string
	instructionParameterType *[]string
	value *[]string
	allowedAction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileRequest) Authorization(authorization string) ProfileAPIGetProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileRequest) XAppKey(xAppKey string) ProfileAPIGetProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileRequest) XHotelid(xHotelid string) ProfileAPIGetProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ProfileAPIGetProfileRequest) HotelId(hotelId string) ProfileAPIGetProfileRequest {
	r.hotelId = &hotelId
	return r
}

// This element tells when the view profile should be logged.
func (r ProfileAPIGetProfileRequest) LogViewProfile(logViewProfile bool) ProfileAPIGetProfileRequest {
	r.logViewProfile = &logViewProfile
	return r
}

// Flag to show inactive Room Owners.
func (r ProfileAPIGetProfileRequest) ShowInactiveRoomOwners(showInactiveRoomOwners bool) ProfileAPIGetProfileRequest {
	r.showInactiveRoomOwners = &showInactiveRoomOwners
	return r
}

// Providing this flag marks the profile as recently accessed.
func (r ProfileAPIGetProfileRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ProfileAPIGetProfileRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Room Ownership information associated with the profile.
func (r ProfileAPIGetProfileRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Simple type enumerating the different parameters accepted by a profile Instructions. Parameter names have the name of the instruction expecting it, and the parameter name itself.
func (r ProfileAPIGetProfileRequest) InstructionParameterType(instructionParameterType []string) ProfileAPIGetProfileRequest {
	r.instructionParameterType = &instructionParameterType
	return r
}

// Value of Profile Instruction Parameter
func (r ProfileAPIGetProfileRequest) Value(value []string) ProfileAPIGetProfileRequest {
	r.value = &value
	return r
}

// Flag indicating whether Profile is Enrolled to Primary Membership Program.
func (r ProfileAPIGetProfileRequest) AllowedAction(allowedAction []string) ProfileAPIGetProfileRequest {
	r.allowedAction = &allowedAction
	return r
}

// External system code.
func (r ProfileAPIGetProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.GetProfileExecute(r)
}

/*
GetProfile Get profile by ID

Use this API to retrieve a specific profile&apos;s detail information using OPERA&apos;s profileId. You can retrieve any type of profile including guest, travel agent, company, source, group, or contact. If you do not know OPERA profileID, use getProfiles or getProfileByExtId API first to get OPERA profileId.<p><strong>OperationId:</strong>getProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique OPERA internal profile ID which is used to find any type of profile from OPERA. This ID is a primary identification of a profile in OPERA.
 @return ProfileAPIGetProfileRequest
*/
func (a *ProfileAPIService) GetProfile(ctx context.Context, profileId string) ProfileAPIGetProfileRequest {
	return ProfileAPIGetProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileAPIService) GetProfileExecute(r ProfileAPIGetProfileRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.logViewProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logViewProfile", r.logViewProfile, "")
  }
	if r.showInactiveRoomOwners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactiveRoomOwners", r.showInactiveRoomOwners, "")
  }
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.instructionParameterType != nil {
		t := *r.instructionParameterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", t, "multi")
		}
  }
	if r.value != nil {
		t := *r.value
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "value", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "value", t, "multi")
		}
  }
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileAccountsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *[]string
	type_ *[]string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileAccountsRequest) Authorization(authorization string) ProfileAPIGetProfileAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileAccountsRequest) XAppKey(xAppKey string) ProfileAPIGetProfileAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileAccountsRequest) XHotelid(xHotelid string) ProfileAPIGetProfileAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetProfileAccountsRequest) IdContext(idContext []string) ProfileAPIGetProfileAccountsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetProfileAccountsRequest) Type_(type_ []string) ProfileAPIGetProfileAccountsRequest {
	r.type_ = &type_
	return r
}

func (r ProfileAPIGetProfileAccountsRequest) HotelIds(hotelIds []string) ProfileAPIGetProfileAccountsRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ProfileAPIGetProfileAccountsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileAccountsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileAccountsRequest) Execute() (*ProfileAccounts, *http.Response, error) {
	return r.ApiService.GetProfileAccountsExecute(r)
}

/*
GetProfileAccounts Get profile accounts

You can find the accounts that are listed on a profile with this API. <p><strong>OperationId:</strong>getProfileAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetProfileAccountsRequest
*/
func (a *ProfileAPIService) GetProfileAccounts(ctx context.Context, profileId string) ProfileAPIGetProfileAccountsRequest {
	return ProfileAPIGetProfileAccountsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileAccounts
func (a *ProfileAPIService) GetProfileAccountsExecute(r ProfileAPIGetProfileAccountsRequest) (*ProfileAccounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileAccounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileActivityLogRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	activityParamsHotelId *string
	module *string
	parameterName *[]string
	parameterValue *[]string
	activityGroup *string
	activityType *string
	fromDate *string
	toDate *string
	searchText *string
	userByIDs *[]int32
	userForIDs *[]int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileActivityLogRequest) Authorization(authorization string) ProfileAPIGetProfileActivityLogRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileActivityLogRequest) XAppKey(xAppKey string) ProfileAPIGetProfileActivityLogRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileActivityLogRequest) XHotelid(xHotelid string) ProfileAPIGetProfileActivityLogRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetProfileActivityLogRequest) Limit(limit int32) ProfileAPIGetProfileActivityLogRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ProfileAPIGetProfileActivityLogRequest) Offset(offset int32) ProfileAPIGetProfileActivityLogRequest {
	r.offset = &offset
	return r
}

// Hotel code.
func (r ProfileAPIGetProfileActivityLogRequest) ActivityParamsHotelId(activityParamsHotelId string) ProfileAPIGetProfileActivityLogRequest {
	r.activityParamsHotelId = &activityParamsHotelId
	return r
}

// Activity module.
func (r ProfileAPIGetProfileActivityLogRequest) Module(module string) ProfileAPIGetProfileActivityLogRequest {
	r.module = &module
	return r
}

// Name of the parameter.
func (r ProfileAPIGetProfileActivityLogRequest) ParameterName(parameterName []string) ProfileAPIGetProfileActivityLogRequest {
	r.parameterName = &parameterName
	return r
}

// Value of the parameter.
func (r ProfileAPIGetProfileActivityLogRequest) ParameterValue(parameterValue []string) ProfileAPIGetProfileActivityLogRequest {
	r.parameterValue = &parameterValue
	return r
}

func (r ProfileAPIGetProfileActivityLogRequest) ActivityGroup(activityGroup string) ProfileAPIGetProfileActivityLogRequest {
	r.activityGroup = &activityGroup
	return r
}

func (r ProfileAPIGetProfileActivityLogRequest) ActivityType(activityType string) ProfileAPIGetProfileActivityLogRequest {
	r.activityType = &activityType
	return r
}

// Search from date for the user activity log.
func (r ProfileAPIGetProfileActivityLogRequest) FromDate(fromDate string) ProfileAPIGetProfileActivityLogRequest {
	r.fromDate = &fromDate
	return r
}

// Search to date for the user activity log.
func (r ProfileAPIGetProfileActivityLogRequest) ToDate(toDate string) ProfileAPIGetProfileActivityLogRequest {
	r.toDate = &toDate
	return r
}

// Search text for the user activity log.
func (r ProfileAPIGetProfileActivityLogRequest) SearchText(searchText string) ProfileAPIGetProfileActivityLogRequest {
	r.searchText = &searchText
	return r
}

func (r ProfileAPIGetProfileActivityLogRequest) UserByIDs(userByIDs []int32) ProfileAPIGetProfileActivityLogRequest {
	r.userByIDs = &userByIDs
	return r
}

func (r ProfileAPIGetProfileActivityLogRequest) UserForIDs(userForIDs []int32) ProfileAPIGetProfileActivityLogRequest {
	r.userForIDs = &userForIDs
	return r
}

// External system code.
func (r ProfileAPIGetProfileActivityLogRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileActivityLogRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileActivityLogRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileActivityLogRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileActivityLogRequest) Execute() (*ProfileActivityLog, *http.Response, error) {
	return r.ApiService.GetProfileActivityLogExecute(r)
}

/*
GetProfileActivityLog Fetch profile activity log

Use this API to fetch the activity log for a specific profile.  This will allow you to see the changes that have occurred on this profile. <p><strong>OperationId:</strong>getProfileActivityLog</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetProfileActivityLogRequest
*/
func (a *ProfileAPIService) GetProfileActivityLog(ctx context.Context) ProfileAPIGetProfileActivityLogRequest {
	return ProfileAPIGetProfileActivityLogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileActivityLog
func (a *ProfileAPIService) GetProfileActivityLogExecute(r ProfileAPIGetProfileActivityLogRequest) (*ProfileActivityLog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileActivityLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileActivityLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/activityLog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.activityParamsHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityParamsHotelId", r.activityParamsHotelId, "")
  }
	if r.module != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "module", r.module, "")
  }
	if r.parameterName != nil {
		t := *r.parameterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterName", t, "multi")
		}
  }
	if r.parameterValue != nil {
		t := *r.parameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parameterValue", t, "multi")
		}
  }
	if r.activityGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityGroup", r.activityGroup, "")
  }
	if r.activityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityType", r.activityType, "")
  }
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
  }
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
  }
	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
  }
	if r.userByIDs != nil {
		t := *r.userByIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userByIDs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userByIDs", t, "multi")
		}
  }
	if r.userForIDs != nil {
		t := *r.userForIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userForIDs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userForIDs", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileAttachmentsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	idContext *string
	type_ *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileAttachmentsRequest) Authorization(authorization string) ProfileAPIGetProfileAttachmentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileAttachmentsRequest) XAppKey(xAppKey string) ProfileAPIGetProfileAttachmentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileAttachmentsRequest) XHotelid(xHotelid string) ProfileAPIGetProfileAttachmentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetProfileAttachmentsRequest) IdContext(idContext string) ProfileAPIGetProfileAttachmentsRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetProfileAttachmentsRequest) Type_(type_ string) ProfileAPIGetProfileAttachmentsRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ProfileAPIGetProfileAttachmentsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileAttachmentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileAttachmentsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileAttachmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileAttachmentsRequest) Execute() (*ProfileAttachments, *http.Response, error) {
	return r.ApiService.GetProfileAttachmentsExecute(r)
}

/*
GetProfileAttachments Get profile attachments

This API will provide the attachments on a profile in OPERA Cloud. <p><strong>OperationId:</strong>getProfileAttachments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetProfileAttachmentsRequest
*/
func (a *ProfileAPIService) GetProfileAttachments(ctx context.Context, profileId string) ProfileAPIGetProfileAttachmentsRequest {
	return ProfileAPIGetProfileAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileAttachments
func (a *ProfileAPIService) GetProfileAttachmentsExecute(r ProfileAPIGetProfileAttachmentsRequest) (*ProfileAttachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.idContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", r.idContext, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileByExtIdRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileExternalId string
	extSystemCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	logViewProfile *bool
	showInactiveRoomOwners *bool
	fetchInstructions *[]string
	instructionParameterType *[]string
	value *[]string
	allowedAction *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileByExtIdRequest) Authorization(authorization string) ProfileAPIGetProfileByExtIdRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileByExtIdRequest) XAppKey(xAppKey string) ProfileAPIGetProfileByExtIdRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileByExtIdRequest) XHotelid(xHotelid string) ProfileAPIGetProfileByExtIdRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ProfileAPIGetProfileByExtIdRequest) HotelId(hotelId string) ProfileAPIGetProfileByExtIdRequest {
	r.hotelId = &hotelId
	return r
}

// This element tells when the view profile should be logged.
func (r ProfileAPIGetProfileByExtIdRequest) LogViewProfile(logViewProfile bool) ProfileAPIGetProfileByExtIdRequest {
	r.logViewProfile = &logViewProfile
	return r
}

// Flag to show inactive Room Owners.
func (r ProfileAPIGetProfileByExtIdRequest) ShowInactiveRoomOwners(showInactiveRoomOwners bool) ProfileAPIGetProfileByExtIdRequest {
	r.showInactiveRoomOwners = &showInactiveRoomOwners
	return r
}

// Room Ownership information associated with the profile.
func (r ProfileAPIGetProfileByExtIdRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetProfileByExtIdRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Simple type enumerating the different parameters accepted by a profile Instructions. Parameter names have the name of the instruction expecting it, and the parameter name itself.
func (r ProfileAPIGetProfileByExtIdRequest) InstructionParameterType(instructionParameterType []string) ProfileAPIGetProfileByExtIdRequest {
	r.instructionParameterType = &instructionParameterType
	return r
}

// Value of Profile Instruction Parameter
func (r ProfileAPIGetProfileByExtIdRequest) Value(value []string) ProfileAPIGetProfileByExtIdRequest {
	r.value = &value
	return r
}

// Flag indicating whether Profile is Enrolled to Primary Membership Program.
func (r ProfileAPIGetProfileByExtIdRequest) AllowedAction(allowedAction []string) ProfileAPIGetProfileByExtIdRequest {
	r.allowedAction = &allowedAction
	return r
}

// External system code.
func (r ProfileAPIGetProfileByExtIdRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileByExtIdRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileByExtIdRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileByExtIdRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileByExtIdRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.GetProfileByExtIdExecute(r)
}

/*
GetProfileByExtId Get profile by external ID

When a reservation is booked via an external system, you would use this API to retrieve a reservation using the external ID in the request <p><strong>OperationId:</strong>getProfileByExtId</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileExternalId External System's ID used to get the profile.
 @param extSystemCode Code to identify the external system from which the request is coming. This is the ExternalSystem ID used to exchange information between OPERA and the external system.
 @return ProfileAPIGetProfileByExtIdRequest
*/
func (a *ProfileAPIService) GetProfileByExtId(ctx context.Context, profileExternalId string, extSystemCode string) ProfileAPIGetProfileByExtIdRequest {
	return ProfileAPIGetProfileByExtIdRequest{
		ApiService: a,
		ctx: ctx,
		profileExternalId: profileExternalId,
		extSystemCode: extSystemCode,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileAPIService) GetProfileByExtIdExecute(r ProfileAPIGetProfileByExtIdRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileByExtId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/profiles/{profileExternalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileExternalId"+"}", url.PathEscape(parameterValueToString(r.profileExternalId, "profileExternalId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileExternalId) < 1 {
		return localVarReturnValue, nil, reportError("profileExternalId must have at least 1 elements")
	}
	if strlen(r.profileExternalId) > 2000 {
		return localVarReturnValue, nil, reportError("profileExternalId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.logViewProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logViewProfile", r.logViewProfile, "")
  }
	if r.showInactiveRoomOwners != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInactiveRoomOwners", r.showInactiveRoomOwners, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.instructionParameterType != nil {
		t := *r.instructionParameterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", t, "multi")
		}
  }
	if r.value != nil {
		t := *r.value
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "value", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "value", t, "multi")
		}
  }
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileCommissionAccountRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileCommissionAccountRequest) Authorization(authorization string) ProfileAPIGetProfileCommissionAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileCommissionAccountRequest) XAppKey(xAppKey string) ProfileAPIGetProfileCommissionAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileCommissionAccountRequest) XHotelid(xHotelid string) ProfileAPIGetProfileCommissionAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileAPIGetProfileCommissionAccountRequest) HotelIds(hotelIds []string) ProfileAPIGetProfileCommissionAccountRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ProfileAPIGetProfileCommissionAccountRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileCommissionAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileCommissionAccountRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileCommissionAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileCommissionAccountRequest) Execute() (*ProfileCommissionAccountInfo, *http.Response, error) {
	return r.ApiService.GetProfileCommissionAccountExecute(r)
}

/*
GetProfileCommissionAccount Get commission account on a profile

Retrieve Commission Account details from a specified profile. <p><strong>OperationId:</strong>getProfileCommissionAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetProfileCommissionAccountRequest
*/
func (a *ProfileAPIService) GetProfileCommissionAccount(ctx context.Context, profileId string) ProfileAPIGetProfileCommissionAccountRequest {
	return ProfileAPIGetProfileCommissionAccountRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileCommissionAccountInfo
func (a *ProfileAPIService) GetProfileCommissionAccountExecute(r ProfileAPIGetProfileCommissionAccountRequest) (*ProfileCommissionAccountInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileCommissionAccountInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileCommissionAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/commissionAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileOwnersRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *[]string
	idContext *[]string
	type_ *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileOwnersRequest) Authorization(authorization string) ProfileAPIGetProfileOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileOwnersRequest) XAppKey(xAppKey string) ProfileAPIGetProfileOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileOwnersRequest) XHotelid(xHotelid string) ProfileAPIGetProfileOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfileOwnersRequest) Id(id []string) ProfileAPIGetProfileOwnersRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetProfileOwnersRequest) IdContext(idContext []string) ProfileAPIGetProfileOwnersRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetProfileOwnersRequest) Type_(type_ []string) ProfileAPIGetProfileOwnersRequest {
	r.type_ = &type_
	return r
}

// External system code.
func (r ProfileAPIGetProfileOwnersRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileOwnersRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileOwnersRequest) Execute() (*ProfileOwnersDetail, *http.Response, error) {
	return r.ApiService.GetProfileOwnersExecute(r)
}

/*
GetProfileOwners Get profile owners

Retrieve the Owners listed on a profile. <p><strong>OperationId:</strong>getProfileOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetProfileOwnersRequest
*/
func (a *ProfileAPIService) GetProfileOwners(ctx context.Context, profileId string) ProfileAPIGetProfileOwnersRequest {
	return ProfileAPIGetProfileOwnersRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileOwnersDetail
func (a *ProfileAPIService) GetProfileOwnersExecute(r ProfileAPIGetProfileOwnersRequest) (*ProfileOwnersDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileOwnersDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfileRelationshipsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	relationshipPrimaryProfile *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfileRelationshipsRequest) Authorization(authorization string) ProfileAPIGetProfileRelationshipsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfileRelationshipsRequest) XAppKey(xAppKey string) ProfileAPIGetProfileRelationshipsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfileRelationshipsRequest) XHotelid(xHotelid string) ProfileAPIGetProfileRelationshipsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Type of Profile to be fetched from OPERA.
func (r ProfileAPIGetProfileRelationshipsRequest) RelationshipPrimaryProfile(relationshipPrimaryProfile bool) ProfileAPIGetProfileRelationshipsRequest {
	r.relationshipPrimaryProfile = &relationshipPrimaryProfile
	return r
}

// External system code.
func (r ProfileAPIGetProfileRelationshipsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfileRelationshipsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfileRelationshipsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfileRelationshipsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfileRelationshipsRequest) Execute() (*ProfileRelationships, *http.Response, error) {
	return r.ApiService.GetProfileRelationshipsExecute(r)
}

/*
GetProfileRelationships FetchProfileRelationships method provides the ability to retrieve a profile relationships for a profile based on the unique internal profile ID specified.

 <p><strong>OperationId:</strong>getProfileRelationships</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetProfileRelationshipsRequest
*/
func (a *ProfileAPIService) GetProfileRelationships(ctx context.Context, profileId string) ProfileAPIGetProfileRelationshipsRequest {
	return ProfileAPIGetProfileRelationshipsRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileRelationships
func (a *ProfileAPIService) GetProfileRelationshipsExecute(r ProfileAPIGetProfileRelationshipsRequest) (*ProfileRelationships, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileRelationships
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileRelationships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.relationshipPrimaryProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relationshipPrimaryProfile", r.relationshipPrimaryProfile, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	excludeInactive *bool
	hotelId *string
	includeHasHierarchyOnly *bool
	includePrimaryOwnersOnly *bool
	includePurgeProfiles *bool
	limit *int32
	offset *int32
	searchType *string
	summaryInfo *bool
	searchString *string
	includeAnonymized *bool
	profileType *[]string
	profileIds *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	corporateIds *[]string
	profileName *string
	givenName *string
	incognitoName *string
	incognitoGivenName *string
	city *string
	postalCode *string
	state *string
	countryCode *string
	streetAddress *string
	keyword *string
	communication *string
	membership *string
	membershipType *string
	ownerCodes *[]string
	membershipLevel *string
	aRNumber *string
	taxID *string
	businessSegment *[]string
	accountsReceivables *bool
	corporateProfiles *bool
	excludeIncompleteProfiles *bool
	negotiatedRates *bool
	relatedProfileExcludeInactive *bool
	realtedProfileIncludeHasHierarchyOnly *bool
	relatedProfileNegotiatedRates *bool
	relatedProfileType *string
	relatedProfileName *string
	protectedProfiles *bool
	excludedProfilesId *[]string
	idExtension *[]int32
	excludedProfilesIdContext *[]string
	excludedProfilesIdType *[]string
	identificationNo *string
	fetchInstructions *[]string
	allowedAction *[]string
	vipCodes *[]string
	predefinedFilterId *float32
	predefinedFilterCode *string
	prioritieCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfilesRequest) Authorization(authorization string) ProfileAPIGetProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfilesRequest) XAppKey(xAppKey string) ProfileAPIGetProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfilesRequest) XHotelid(xHotelid string) ProfileAPIGetProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates whether to exclude Inactive Profiles, when true indicates that only profiles with active status will be displayed.
func (r ProfileAPIGetProfilesRequest) ExcludeInactive(excludeInactive bool) ProfileAPIGetProfilesRequest {
	r.excludeInactive = &excludeInactive
	return r
}

// Hotel Code, It is used to filter hotel specific children to this specific hotel code.
func (r ProfileAPIGetProfilesRequest) HotelId(hotelId string) ProfileAPIGetProfilesRequest {
	r.hotelId = &hotelId
	return r
}

// Include profiles that have one or more relationships in the search.
func (r ProfileAPIGetProfilesRequest) IncludeHasHierarchyOnly(includeHasHierarchyOnly bool) ProfileAPIGetProfilesRequest {
	r.includeHasHierarchyOnly = &includeHasHierarchyOnly
	return r
}

// Include primary owners in the search.
func (r ProfileAPIGetProfilesRequest) IncludePrimaryOwnersOnly(includePrimaryOwnersOnly bool) ProfileAPIGetProfilesRequest {
	r.includePrimaryOwnersOnly = &includePrimaryOwnersOnly
	return r
}

// Include purged profiles in the search.
func (r ProfileAPIGetProfilesRequest) IncludePurgeProfiles(includePurgeProfiles bool) ProfileAPIGetProfilesRequest {
	r.includePurgeProfiles = &includePurgeProfiles
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetProfilesRequest) Limit(limit int32) ProfileAPIGetProfilesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ProfileAPIGetProfilesRequest) Offset(offset int32) ProfileAPIGetProfilesRequest {
	r.offset = &offset
	return r
}

// When search type is PatronTrackingSystemMemberProfiles, the FetchProfiles will return the Membership Number of the searched Membership Type regardless of primary flag or sequence of the profile memberships.
func (r ProfileAPIGetProfilesRequest) SearchType(searchType string) ProfileAPIGetProfilesRequest {
	r.searchType = &searchType
	return r
}

// When true response will return summary information otherwise detailed information.
func (r ProfileAPIGetProfilesRequest) SummaryInfo(summaryInfo bool) ProfileAPIGetProfilesRequest {
	r.summaryInfo = &summaryInfo
	return r
}

// Search string to be used for super search.
func (r ProfileAPIGetProfilesRequest) SearchString(searchString string) ProfileAPIGetProfilesRequest {
	r.searchString = &searchString
	return r
}

// Indicates whether to include Anonymized Profiles.
func (r ProfileAPIGetProfilesRequest) IncludeAnonymized(includeAnonymized bool) ProfileAPIGetProfilesRequest {
	r.includeAnonymized = &includeAnonymized
	return r
}

// The types of Profile handled by the web service.
func (r ProfileAPIGetProfilesRequest) ProfileType(profileType []string) ProfileAPIGetProfilesRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesRequest) ProfileIds(profileIds []string) ProfileAPIGetProfilesRequest {
	r.profileIds = &profileIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesRequest) ExternalReferenceIds(externalReferenceIds []string) ProfileAPIGetProfilesRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetProfilesRequest) ExternalSystemCodes(externalSystemCodes []string) ProfileAPIGetProfilesRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesRequest) CorporateIds(corporateIds []string) ProfileAPIGetProfilesRequest {
	r.corporateIds = &corporateIds
	return r
}

// Family name, last name or Company Name.
func (r ProfileAPIGetProfilesRequest) ProfileName(profileName string) ProfileAPIGetProfilesRequest {
	r.profileName = &profileName
	return r
}

// Given name, first name or names.
func (r ProfileAPIGetProfilesRequest) GivenName(givenName string) ProfileAPIGetProfilesRequest {
	r.givenName = &givenName
	return r
}

// Family name, last name or Company Name.
func (r ProfileAPIGetProfilesRequest) IncognitoName(incognitoName string) ProfileAPIGetProfilesRequest {
	r.incognitoName = &incognitoName
	return r
}

// Given name, first name or names.
func (r ProfileAPIGetProfilesRequest) IncognitoGivenName(incognitoGivenName string) ProfileAPIGetProfilesRequest {
	r.incognitoGivenName = &incognitoGivenName
	return r
}

// City (e.g., Dublin), town, or postal station (i.e., a postal service territory, often used in a military address).
func (r ProfileAPIGetProfilesRequest) City(city string) ProfileAPIGetProfilesRequest {
	r.city = &city
	return r
}

// Post Office Code number.
func (r ProfileAPIGetProfilesRequest) PostalCode(postalCode string) ProfileAPIGetProfilesRequest {
	r.postalCode = &postalCode
	return r
}

// State or Province name (e.g., Texas).
func (r ProfileAPIGetProfilesRequest) State(state string) ProfileAPIGetProfilesRequest {
	r.state = &state
	return r
}

// Code for a country or a nationality.
func (r ProfileAPIGetProfilesRequest) CountryCode(countryCode string) ProfileAPIGetProfilesRequest {
	r.countryCode = &countryCode
	return r
}

// First Line of Street Address. For profile search it matches the first Address line.
func (r ProfileAPIGetProfilesRequest) StreetAddress(streetAddress string) ProfileAPIGetProfilesRequest {
	r.streetAddress = &streetAddress
	return r
}

// Keyword associated to the profile.
func (r ProfileAPIGetProfilesRequest) Keyword(keyword string) ProfileAPIGetProfilesRequest {
	r.keyword = &keyword
	return r
}

// Any communication method associated to the profile such as phone, fax, eMail id.
func (r ProfileAPIGetProfilesRequest) Communication(communication string) ProfileAPIGetProfilesRequest {
	r.communication = &communication
	return r
}

// Membership number associated to the profile.
func (r ProfileAPIGetProfilesRequest) Membership(membership string) ProfileAPIGetProfilesRequest {
	r.membership = &membership
	return r
}

// Member Type of searching profile.
func (r ProfileAPIGetProfilesRequest) MembershipType(membershipType string) ProfileAPIGetProfilesRequest {
	r.membershipType = &membershipType
	return r
}

func (r ProfileAPIGetProfilesRequest) OwnerCodes(ownerCodes []string) ProfileAPIGetProfilesRequest {
	r.ownerCodes = &ownerCodes
	return r
}

// Membership level associated to the profile.
func (r ProfileAPIGetProfilesRequest) MembershipLevel(membershipLevel string) ProfileAPIGetProfilesRequest {
	r.membershipLevel = &membershipLevel
	return r
}

// Account Receivable associated to the profile.
func (r ProfileAPIGetProfilesRequest) ARNumber(aRNumber string) ProfileAPIGetProfilesRequest {
	r.aRNumber = &aRNumber
	return r
}

// Tax ID associated to the profile
func (r ProfileAPIGetProfilesRequest) TaxID(taxID string) ProfileAPIGetProfilesRequest {
	r.taxID = &taxID
	return r
}

// Business/Market Segment associated to the profile.
func (r ProfileAPIGetProfilesRequest) BusinessSegment(businessSegment []string) ProfileAPIGetProfilesRequest {
	r.businessSegment = &businessSegment
	return r
}

// When true indicates that only profiles with AR account fetched.
func (r ProfileAPIGetProfilesRequest) AccountsReceivables(accountsReceivables bool) ProfileAPIGetProfilesRequest {
	r.accountsReceivables = &accountsReceivables
	return r
}

// When true indicates that only profiles with client id are searched for.
func (r ProfileAPIGetProfilesRequest) CorporateProfiles(corporateProfiles bool) ProfileAPIGetProfilesRequest {
	r.corporateProfiles = &corporateProfiles
	return r
}

// When true indicates that only profiles with an Address Line 1 and Country or at least one Communications Type will be displayed.
func (r ProfileAPIGetProfilesRequest) ExcludeIncompleteProfiles(excludeIncompleteProfiles bool) ProfileAPIGetProfilesRequest {
	r.excludeIncompleteProfiles = &excludeIncompleteProfiles
	return r
}

// When true indicates that this option has to be included in advanced search.
func (r ProfileAPIGetProfilesRequest) NegotiatedRates(negotiatedRates bool) ProfileAPIGetProfilesRequest {
	r.negotiatedRates = &negotiatedRates
	return r
}

// Indicates whether to exclude Inactive Profiles, when true indicates that only profiles with active status will be displayed.
func (r ProfileAPIGetProfilesRequest) RelatedProfileExcludeInactive(relatedProfileExcludeInactive bool) ProfileAPIGetProfilesRequest {
	r.relatedProfileExcludeInactive = &relatedProfileExcludeInactive
	return r
}

// Include profiles that have one or more relationships in the search.
func (r ProfileAPIGetProfilesRequest) RealtedProfileIncludeHasHierarchyOnly(realtedProfileIncludeHasHierarchyOnly bool) ProfileAPIGetProfilesRequest {
	r.realtedProfileIncludeHasHierarchyOnly = &realtedProfileIncludeHasHierarchyOnly
	return r
}

// When true indicates that this option has to be included in advanced search.
func (r ProfileAPIGetProfilesRequest) RelatedProfileNegotiatedRates(relatedProfileNegotiatedRates bool) ProfileAPIGetProfilesRequest {
	r.relatedProfileNegotiatedRates = &relatedProfileNegotiatedRates
	return r
}

// The types of Profile handled by the web service.
func (r ProfileAPIGetProfilesRequest) RelatedProfileType(relatedProfileType string) ProfileAPIGetProfilesRequest {
	r.relatedProfileType = &relatedProfileType
	return r
}

// Family name, last name or Company Name.
func (r ProfileAPIGetProfilesRequest) RelatedProfileName(relatedProfileName string) ProfileAPIGetProfilesRequest {
	r.relatedProfileName = &relatedProfileName
	return r
}

// Indicates whether to exclude Protected Profiles.
func (r ProfileAPIGetProfilesRequest) ProtectedProfiles(protectedProfiles bool) ProfileAPIGetProfilesRequest {
	r.protectedProfiles = &protectedProfiles
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesRequest) ExcludedProfilesId(excludedProfilesId []string) ProfileAPIGetProfilesRequest {
	r.excludedProfilesId = &excludedProfilesId
	return r
}

// Additional identifying value assigned by the creating system.
func (r ProfileAPIGetProfilesRequest) IdExtension(idExtension []int32) ProfileAPIGetProfilesRequest {
	r.idExtension = &idExtension
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetProfilesRequest) ExcludedProfilesIdContext(excludedProfilesIdContext []string) ProfileAPIGetProfilesRequest {
	r.excludedProfilesIdContext = &excludedProfilesIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetProfilesRequest) ExcludedProfilesIdType(excludedProfilesIdType []string) ProfileAPIGetProfilesRequest {
	r.excludedProfilesIdType = &excludedProfilesIdType
	return r
}

// Any identification number associated with the profile such as Passport Number, StateID.
func (r ProfileAPIGetProfilesRequest) IdentificationNo(identificationNo string) ProfileAPIGetProfilesRequest {
	r.identificationNo = &identificationNo
	return r
}

// Room Ownership information associated with the profile.
func (r ProfileAPIGetProfilesRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetProfilesRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Flag indicating whether Profile is Enrolled to Primary Membership Program.
func (r ProfileAPIGetProfilesRequest) AllowedAction(allowedAction []string) ProfileAPIGetProfilesRequest {
	r.allowedAction = &allowedAction
	return r
}

func (r ProfileAPIGetProfilesRequest) VipCodes(vipCodes []string) ProfileAPIGetProfilesRequest {
	r.vipCodes = &vipCodes
	return r
}

// Unique ID of the Filter used to filter profiles.
func (r ProfileAPIGetProfilesRequest) PredefinedFilterId(predefinedFilterId float32) ProfileAPIGetProfilesRequest {
	r.predefinedFilterId = &predefinedFilterId
	return r
}

// Filter code.
func (r ProfileAPIGetProfilesRequest) PredefinedFilterCode(predefinedFilterCode string) ProfileAPIGetProfilesRequest {
	r.predefinedFilterCode = &predefinedFilterCode
	return r
}

func (r ProfileAPIGetProfilesRequest) PrioritieCodes(prioritieCodes []string) ProfileAPIGetProfilesRequest {
	r.prioritieCodes = &prioritieCodes
	return r
}

// External system code.
func (r ProfileAPIGetProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfilesRequest) Execute() (*ProfileSummaries, *http.Response, error) {
	return r.ApiService.GetProfilesExecute(r)
}

/*
GetProfiles Search for profile(s)

Use this API when you want to search for a profile as part of a booking process or to manage a profile data. The response will include a list of profiles that exist in OPERA, based on your search criteria.  For example, you want to see if a profile for Mr David Smith exists - you can search by various criteria, such as first name, last name, email.  The response will include a list of any profiles that exist for Mr David Smith.  If a profile matches the criteria, and you want to get more details of that profile, proceed to use getProfile with the profileId in the request. Maximum response data limit is 1000 records, so use more query parameters to narrow your results. This API is not designed to support sync between two systems or initial upload of data.<p><strong>OperationId:</strong>getProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetProfilesRequest
*/
func (a *ProfileAPIService) GetProfiles(ctx context.Context) ProfileAPIGetProfilesRequest {
	return ProfileAPIGetProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileSummaries
func (a *ProfileAPIService) GetProfilesExecute(r ProfileAPIGetProfilesRequest) (*ProfileSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInactive", r.excludeInactive, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.includeHasHierarchyOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHasHierarchyOnly", r.includeHasHierarchyOnly, "")
  }
	if r.includePrimaryOwnersOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePrimaryOwnersOnly", r.includePrimaryOwnersOnly, "")
  }
	if r.includePurgeProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePurgeProfiles", r.includePurgeProfiles, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchType", r.searchType, "")
  }
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
  }
	if r.searchString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchString", r.searchString, "")
  }
	if r.includeAnonymized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAnonymized", r.includeAnonymized, "")
  }
	if r.profileType != nil {
		t := *r.profileType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", t, "multi")
		}
  }
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
  }
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
  }
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
  }
	if r.corporateIds != nil {
		t := *r.corporateIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIds", t, "multi")
		}
  }
	if r.profileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileName", r.profileName, "")
  }
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
  }
	if r.incognitoName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incognitoName", r.incognitoName, "")
  }
	if r.incognitoGivenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incognitoGivenName", r.incognitoGivenName, "")
  }
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
  }
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
  }
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
  }
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
  }
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "")
  }
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "")
  }
	if r.communication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "communication", r.communication, "")
  }
	if r.membership != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membership", r.membership, "")
  }
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "")
  }
	if r.ownerCodes != nil {
		t := *r.ownerCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ownerCodes", t, "multi")
		}
  }
	if r.membershipLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipLevel", r.membershipLevel, "")
  }
	if r.aRNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aRNumber", r.aRNumber, "")
  }
	if r.taxID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxID", r.taxID, "")
  }
	if r.businessSegment != nil {
		t := *r.businessSegment
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "businessSegment", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "businessSegment", t, "multi")
		}
  }
	if r.accountsReceivables != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountsReceivables", r.accountsReceivables, "")
  }
	if r.corporateProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "corporateProfiles", r.corporateProfiles, "")
  }
	if r.excludeIncompleteProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeIncompleteProfiles", r.excludeIncompleteProfiles, "")
  }
	if r.negotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "negotiatedRates", r.negotiatedRates, "")
  }
	if r.relatedProfileExcludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileExcludeInactive", r.relatedProfileExcludeInactive, "")
  }
	if r.realtedProfileIncludeHasHierarchyOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "realtedProfileIncludeHasHierarchyOnly", r.realtedProfileIncludeHasHierarchyOnly, "")
  }
	if r.relatedProfileNegotiatedRates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileNegotiatedRates", r.relatedProfileNegotiatedRates, "")
  }
	if r.relatedProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileType", r.relatedProfileType, "")
  }
	if r.relatedProfileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relatedProfileName", r.relatedProfileName, "")
  }
	if r.protectedProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectedProfiles", r.protectedProfiles, "")
  }
	if r.excludedProfilesId != nil {
		t := *r.excludedProfilesId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludedProfilesId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludedProfilesId", t, "multi")
		}
  }
	if r.idExtension != nil {
		t := *r.idExtension
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idExtension", t, "multi")
		}
  }
	if r.excludedProfilesIdContext != nil {
		t := *r.excludedProfilesIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludedProfilesIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludedProfilesIdContext", t, "multi")
		}
  }
	if r.excludedProfilesIdType != nil {
		t := *r.excludedProfilesIdType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludedProfilesIdType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludedProfilesIdType", t, "multi")
		}
  }
	if r.identificationNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identificationNo", r.identificationNo, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.allowedAction != nil {
		t := *r.allowedAction
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowedAction", t, "multi")
		}
  }
	if r.vipCodes != nil {
		t := *r.vipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vipCodes", t, "multi")
		}
  }
	if r.predefinedFilterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "predefinedFilterId", r.predefinedFilterId, "")
  }
	if r.predefinedFilterCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "predefinedFilterCode", r.predefinedFilterCode, "")
  }
	if r.prioritieCodes != nil {
		t := *r.prioritieCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prioritieCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prioritieCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetProfilesByIdsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileIds *[]string
	corporateIds *[]string
	externalReferenceIds *[]string
	externalSystemCodes *[]string
	limit *[]int32
	fetchInstructions *[]string
	instructionParameterType *[]string
	instructionParameterValue *[]string
	hotelId *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetProfilesByIdsRequest) Authorization(authorization string) ProfileAPIGetProfilesByIdsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetProfilesByIdsRequest) XAppKey(xAppKey string) ProfileAPIGetProfilesByIdsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetProfilesByIdsRequest) XHotelid(xHotelid string) ProfileAPIGetProfilesByIdsRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesByIdsRequest) ProfileIds(profileIds []string) ProfileAPIGetProfilesByIdsRequest {
	r.profileIds = &profileIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesByIdsRequest) CorporateIds(corporateIds []string) ProfileAPIGetProfilesByIdsRequest {
	r.corporateIds = &corporateIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetProfilesByIdsRequest) ExternalReferenceIds(externalReferenceIds []string) ProfileAPIGetProfilesByIdsRequest {
	r.externalReferenceIds = &externalReferenceIds
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetProfilesByIdsRequest) ExternalSystemCodes(externalSystemCodes []string) ProfileAPIGetProfilesByIdsRequest {
	r.externalSystemCodes = &externalSystemCodes
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetProfilesByIdsRequest) Limit(limit []int32) ProfileAPIGetProfilesByIdsRequest {
	r.limit = &limit
	return r
}

// Room Ownership information associated with the profile.
func (r ProfileAPIGetProfilesByIdsRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetProfilesByIdsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// Simple type enumerating the different parameters accepted by a profile Instructions. Parameter names have the name of the instruction expecting it, and the parameter name itself.
func (r ProfileAPIGetProfilesByIdsRequest) InstructionParameterType(instructionParameterType []string) ProfileAPIGetProfilesByIdsRequest {
	r.instructionParameterType = &instructionParameterType
	return r
}

// Value of Profile Instruction Parameter
func (r ProfileAPIGetProfilesByIdsRequest) InstructionParameterValue(instructionParameterValue []string) ProfileAPIGetProfilesByIdsRequest {
	r.instructionParameterValue = &instructionParameterValue
	return r
}

// Hotel Code, It is used to filter hotel specific.
func (r ProfileAPIGetProfilesByIdsRequest) HotelId(hotelId string) ProfileAPIGetProfilesByIdsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r ProfileAPIGetProfilesByIdsRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetProfilesByIdsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetProfilesByIdsRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetProfilesByIdsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetProfilesByIdsRequest) Execute() (*ProfileDetails, *http.Response, error) {
	return r.ApiService.GetProfilesByIdsExecute(r)
}

/*
GetProfilesByIds Search for profile(s)

Use this API when you want to search for a profile. The response will include a list of profiles that exist in OPERA, based on your search criteria.  For example, you want to see if  a profile for Mr David Smith exists - you can search by various criteria, such as first, last name, email.  The response will include a list of any profiles that exist for Mr Davis Smith.  If a profile matches the criteria, and you want to get more details of that profile, proceed to use getProfile with the profileID in the request. <p><strong>OperationId:</strong>getProfilesByIds</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetProfilesByIdsRequest
*/
func (a *ProfileAPIService) GetProfilesByIds(ctx context.Context) ProfileAPIGetProfilesByIdsRequest {
	return ProfileAPIGetProfilesByIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfileDetails
func (a *ProfileAPIService) GetProfilesByIdsExecute(r ProfileAPIGetProfilesByIdsRequest) (*ProfileDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfilesByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profilesByIds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileIds", t, "multi")
		}
  }
	if r.corporateIds != nil {
		t := *r.corporateIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "corporateIds", t, "multi")
		}
  }
	if r.externalReferenceIds != nil {
		t := *r.externalReferenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalReferenceIds", t, "multi")
		}
  }
	if r.externalSystemCodes != nil {
		t := *r.externalSystemCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalSystemCodes", t, "multi")
		}
  }
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	if r.instructionParameterType != nil {
		t := *r.instructionParameterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterType", t, "multi")
		}
  }
	if r.instructionParameterValue != nil {
		t := *r.instructionParameterValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterValue", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "instructionParameterValue", t, "multi")
		}
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetRecentlyAccessedProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetRecentlyAccessedProfilesRequest) Authorization(authorization string) ProfileAPIGetRecentlyAccessedProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetRecentlyAccessedProfilesRequest) XAppKey(xAppKey string) ProfileAPIGetRecentlyAccessedProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetRecentlyAccessedProfilesRequest) XHotelid(xHotelid string) ProfileAPIGetRecentlyAccessedProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ProfileAPIGetRecentlyAccessedProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetRecentlyAccessedProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetRecentlyAccessedProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetRecentlyAccessedProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetRecentlyAccessedProfilesRequest) Execute() (*RecentlyAccessedProfiles, *http.Response, error) {
	return r.ApiService.GetRecentlyAccessedProfilesExecute(r)
}

/*
GetRecentlyAccessedProfiles Fetch recently accessed profiles

Use this API to fetch the profiles that have recently been accessed by an application user. <p><strong>OperationId:</strong>getRecentlyAccessedProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetRecentlyAccessedProfilesRequest
*/
func (a *ProfileAPIService) GetRecentlyAccessedProfiles(ctx context.Context) ProfileAPIGetRecentlyAccessedProfilesRequest {
	return ProfileAPIGetRecentlyAccessedProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecentlyAccessedProfiles
func (a *ProfileAPIService) GetRecentlyAccessedProfilesExecute(r ProfileAPIGetRecentlyAccessedProfilesRequest) (*RecentlyAccessedProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecentlyAccessedProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetRecentlyAccessedProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recentlyAccessedProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetStagedProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	id string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	idContext *[]string
	type_ *[]string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetStagedProfileRequest) Authorization(authorization string) ProfileAPIGetStagedProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetStagedProfileRequest) XAppKey(xAppKey string) ProfileAPIGetStagedProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetStagedProfileRequest) XHotelid(xHotelid string) ProfileAPIGetStagedProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// The hotel code that the stage profile belongs to.
func (r ProfileAPIGetStagedProfileRequest) HotelId(hotelId string) ProfileAPIGetStagedProfileRequest {
	r.hotelId = &hotelId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetStagedProfileRequest) IdContext(idContext []string) ProfileAPIGetStagedProfileRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetStagedProfileRequest) Type_(type_ []string) ProfileAPIGetStagedProfileRequest {
	r.type_ = &type_
	return r
}

// If selected, only invalid details of the staged profile will be retrieved.
func (r ProfileAPIGetStagedProfileRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetStagedProfileRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ProfileAPIGetStagedProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetStagedProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetStagedProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetStagedProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetStagedProfileRequest) Execute() (*StagedProfileDetails, *http.Response, error) {
	return r.ApiService.GetStagedProfileExecute(r)
}

/*
GetStagedProfile Get a staged profile

The system suspends / stages a profile with a point value between the upper and lower thresholds. When a profile is staged, you must review the suspended profile and determine if it should be merged with an internal profile or added as a new profile.  This API will get a specific profile that has been staged. <p><strong>OperationId:</strong>getStagedProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProfileAPIGetStagedProfileRequest
*/
func (a *ProfileAPIService) GetStagedProfile(ctx context.Context, id string) ProfileAPIGetStagedProfileRequest {
	return ProfileAPIGetStagedProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StagedProfileDetails
func (a *ProfileAPIService) GetStagedProfileExecute(r ProfileAPIGetStagedProfileRequest) (*StagedProfileDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StagedProfileDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetStagedProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stagedProfile/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.id) < 1 {
		return localVarReturnValue, nil, reportError("id must have at least 1 elements")
	}
	if strlen(r.id) > 2000 {
		return localVarReturnValue, nil, reportError("id must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetStagedProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	hotelIds *[]string
	id *[]string
	idContext *[]string
	type_ *[]string
	name *string
	givenName *string
	region *string
	countryCode *string
	profileType *string
	importDate *string
	stageStatus *string
	applyTo *string
	membershipCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetStagedProfilesRequest) Authorization(authorization string) ProfileAPIGetStagedProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetStagedProfilesRequest) XAppKey(xAppKey string) ProfileAPIGetStagedProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetStagedProfilesRequest) XHotelid(xHotelid string) ProfileAPIGetStagedProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetStagedProfilesRequest) Limit(limit int32) ProfileAPIGetStagedProfilesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r ProfileAPIGetStagedProfilesRequest) Offset(offset int32) ProfileAPIGetStagedProfilesRequest {
	r.offset = &offset
	return r
}

func (r ProfileAPIGetStagedProfilesRequest) HotelIds(hotelIds []string) ProfileAPIGetStagedProfilesRequest {
	r.hotelIds = &hotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r ProfileAPIGetStagedProfilesRequest) Id(id []string) ProfileAPIGetStagedProfilesRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r ProfileAPIGetStagedProfilesRequest) IdContext(idContext []string) ProfileAPIGetStagedProfilesRequest {
	r.idContext = &idContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r ProfileAPIGetStagedProfilesRequest) Type_(type_ []string) ProfileAPIGetStagedProfilesRequest {
	r.type_ = &type_
	return r
}

// Family name, last name or Company Name.
func (r ProfileAPIGetStagedProfilesRequest) Name(name string) ProfileAPIGetStagedProfilesRequest {
	r.name = &name
	return r
}

// Given name, first name or names.
func (r ProfileAPIGetStagedProfilesRequest) GivenName(givenName string) ProfileAPIGetStagedProfilesRequest {
	r.givenName = &givenName
	return r
}

// The profile region for which the staged profiles shall be fetched.
func (r ProfileAPIGetStagedProfilesRequest) Region(region string) ProfileAPIGetStagedProfilesRequest {
	r.region = &region
	return r
}

// Code for a country or a nationality.
func (r ProfileAPIGetStagedProfilesRequest) CountryCode(countryCode string) ProfileAPIGetStagedProfilesRequest {
	r.countryCode = &countryCode
	return r
}

// Profile type to be included in the search.
func (r ProfileAPIGetStagedProfilesRequest) ProfileType(profileType string) ProfileAPIGetStagedProfilesRequest {
	r.profileType = &profileType
	return r
}

// The date on which the staged profiles have been received.
func (r ProfileAPIGetStagedProfilesRequest) ImportDate(importDate string) ProfileAPIGetStagedProfilesRequest {
	r.importDate = &importDate
	return r
}

// The status of the staged profiles.
func (r ProfileAPIGetStagedProfilesRequest) StageStatus(stageStatus string) ProfileAPIGetStagedProfilesRequest {
	r.stageStatus = &stageStatus
	return r
}

// Membership filter of staged profiles.
func (r ProfileAPIGetStagedProfilesRequest) ApplyTo(applyTo string) ProfileAPIGetStagedProfilesRequest {
	r.applyTo = &applyTo
	return r
}

func (r ProfileAPIGetStagedProfilesRequest) MembershipCodes(membershipCodes []string) ProfileAPIGetStagedProfilesRequest {
	r.membershipCodes = &membershipCodes
	return r
}

// External system code.
func (r ProfileAPIGetStagedProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetStagedProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetStagedProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetStagedProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetStagedProfilesRequest) Execute() (*StagedProfiles, *http.Response, error) {
	return r.ApiService.GetStagedProfilesExecute(r)
}

/*
GetStagedProfiles Get staged profiles

The system suspends / stages a profile with a point value between the upper and lower thresholds. When a profile is staged, you must review the suspended profile and determine if it should be merged with an internal profile or added as a new profile. <p><strong>OperationId:</strong>getStagedProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetStagedProfilesRequest
*/
func (a *ProfileAPIService) GetStagedProfiles(ctx context.Context) ProfileAPIGetStagedProfilesRequest {
	return ProfileAPIGetStagedProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StagedProfiles
func (a *ProfileAPIService) GetStagedProfilesExecute(r ProfileAPIGetStagedProfilesRequest) (*StagedProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StagedProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetStagedProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stagedProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
  }
	if r.idContext != nil {
		t := *r.idContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idContext", t, "multi")
		}
  }
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.givenName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "givenName", r.givenName, "")
  }
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
  }
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.importDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importDate", r.importDate, "")
  }
	if r.stageStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stageStatus", r.stageStatus, "")
  }
	if r.applyTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applyTo", r.applyTo, "")
  }
	if r.membershipCodes != nil {
		t := *r.membershipCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "membershipCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetStayHistoryRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	includePurgeProfiles *bool
	markAsRecentlyAccessed *bool
	limit *[]int32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetStayHistoryRequest) Authorization(authorization string) ProfileAPIGetStayHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetStayHistoryRequest) XAppKey(xAppKey string) ProfileAPIGetStayHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetStayHistoryRequest) XHotelid(xHotelid string) ProfileAPIGetStayHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel Code used to filter hotel specific information regarding the profile.
func (r ProfileAPIGetStayHistoryRequest) HotelId(hotelId string) ProfileAPIGetStayHistoryRequest {
	r.hotelId = &hotelId
	return r
}

// Providing this flag includes purged profiles in the result.
func (r ProfileAPIGetStayHistoryRequest) IncludePurgeProfiles(includePurgeProfiles bool) ProfileAPIGetStayHistoryRequest {
	r.includePurgeProfiles = &includePurgeProfiles
	return r
}

// Providing this flag marks the profile as recently accessed.
func (r ProfileAPIGetStayHistoryRequest) MarkAsRecentlyAccessed(markAsRecentlyAccessed bool) ProfileAPIGetStayHistoryRequest {
	r.markAsRecentlyAccessed = &markAsRecentlyAccessed
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r ProfileAPIGetStayHistoryRequest) Limit(limit []int32) ProfileAPIGetStayHistoryRequest {
	r.limit = &limit
	return r
}

// Simple type for instructions that can be used in requests for partial operations to fetch past and future reservation.
func (r ProfileAPIGetStayHistoryRequest) FetchInstructions(fetchInstructions []string) ProfileAPIGetStayHistoryRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r ProfileAPIGetStayHistoryRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetStayHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetStayHistoryRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetStayHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetStayHistoryRequest) Execute() (*ProfileStayHistory, *http.Response, error) {
	return r.ApiService.GetStayHistoryExecute(r)
}

/*
GetStayHistory FetchStayHistory method provides stay history and future reservations of a profile based on the unique internal ID specified.

 <p><strong>OperationId:</strong>getStayHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIGetStayHistoryRequest
*/
func (a *ProfileAPIService) GetStayHistory(ctx context.Context, profileId string) ProfileAPIGetStayHistoryRequest {
	return ProfileAPIGetStayHistoryRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileStayHistory
func (a *ProfileAPIService) GetStayHistoryExecute(r ProfileAPIGetStayHistoryRequest) (*ProfileStayHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileStayHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetStayHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/stayHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.includePurgeProfiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePurgeProfiles", r.includePurgeProfiles, "")
  }
	if r.markAsRecentlyAccessed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRecentlyAccessed", r.markAsRecentlyAccessed, "")
  }
	if r.limit != nil {
		t := *r.limit
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "limit", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "limit", t, "multi")
		}
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetSuspendedAddressesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	name *string
	hotelId *string
	firstName *string
	profileType *string
	matchCode *string
	countryCode *string
	validateDate *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetSuspendedAddressesRequest) Authorization(authorization string) ProfileAPIGetSuspendedAddressesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetSuspendedAddressesRequest) XAppKey(xAppKey string) ProfileAPIGetSuspendedAddressesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetSuspendedAddressesRequest) XHotelid(xHotelid string) ProfileAPIGetSuspendedAddressesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Last Name of the Profile against which the Suspended Addresses are fetched.
func (r ProfileAPIGetSuspendedAddressesRequest) Name(name string) ProfileAPIGetSuspendedAddressesRequest {
	r.name = &name
	return r
}

// Hotel Code, It is used to filter hotel specific children to this specific hotel code.
func (r ProfileAPIGetSuspendedAddressesRequest) HotelId(hotelId string) ProfileAPIGetSuspendedAddressesRequest {
	r.hotelId = &hotelId
	return r
}

// First Name of the Profile against which the Suspended Addresses are fetched.
func (r ProfileAPIGetSuspendedAddressesRequest) FirstName(firstName string) ProfileAPIGetSuspendedAddressesRequest {
	r.firstName = &firstName
	return r
}

// ProfileT ype of the Profile against which the Suspended Addresses are fetched..
func (r ProfileAPIGetSuspendedAddressesRequest) ProfileType(profileType string) ProfileAPIGetSuspendedAddressesRequest {
	r.profileType = &profileType
	return r
}

// Match Code of the Address Validation Performed from the batch processing
func (r ProfileAPIGetSuspendedAddressesRequest) MatchCode(matchCode string) ProfileAPIGetSuspendedAddressesRequest {
	r.matchCode = &matchCode
	return r
}

// Code for a country or a nationality.
func (r ProfileAPIGetSuspendedAddressesRequest) CountryCode(countryCode string) ProfileAPIGetSuspendedAddressesRequest {
	r.countryCode = &countryCode
	return r
}

// Validate Date.
func (r ProfileAPIGetSuspendedAddressesRequest) ValidateDate(validateDate string) ProfileAPIGetSuspendedAddressesRequest {
	r.validateDate = &validateDate
	return r
}

// External system code.
func (r ProfileAPIGetSuspendedAddressesRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetSuspendedAddressesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetSuspendedAddressesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetSuspendedAddressesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetSuspendedAddressesRequest) Execute() (*SuspendedAddresses, *http.Response, error) {
	return r.ApiService.GetSuspendedAddressesExecute(r)
}

/*
GetSuspendedAddresses Fetch Suspended Profile Addresses

Fetch Suspended Profile Addresses <p><strong>OperationId:</strong>getSuspendedAddresses</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetSuspendedAddressesRequest
*/
func (a *ProfileAPIService) GetSuspendedAddresses(ctx context.Context) ProfileAPIGetSuspendedAddressesRequest {
	return ProfileAPIGetSuspendedAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuspendedAddresses
func (a *ProfileAPIService) GetSuspendedAddressesExecute(r ProfileAPIGetSuspendedAddressesRequest) (*SuspendedAddresses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuspendedAddresses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetSuspendedAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suspendedAddresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.matchCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchCode", r.matchCode, "")
  }
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
  }
	if r.validateDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateDate", r.validateDate, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIGetSuspendedProfileErrorSummaryRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) Authorization(authorization string) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) XAppKey(xAppKey string) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) XHotelid(xHotelid string) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) HotelIds(hotelIds []string) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) XExternalsystem(xExternalsystem string) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) AcceptLanguage(acceptLanguage string) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIGetSuspendedProfileErrorSummaryRequest) Execute() (*SuspendedProfileErrorSummaryInfo, *http.Response, error) {
	return r.ApiService.GetSuspendedProfileErrorSummaryExecute(r)
}

/*
GetSuspendedProfileErrorSummary Get suspended profile error summary details

Retrieve the suspended profile error summary details <p><strong>OperationId:</strong>getSuspendedProfileErrorSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIGetSuspendedProfileErrorSummaryRequest
*/
func (a *ProfileAPIService) GetSuspendedProfileErrorSummary(ctx context.Context) ProfileAPIGetSuspendedProfileErrorSummaryRequest {
	return ProfileAPIGetSuspendedProfileErrorSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuspendedProfileErrorSummaryInfo
func (a *ProfileAPIService) GetSuspendedProfileErrorSummaryExecute(r ProfileAPIGetSuspendedProfileErrorSummaryRequest) (*SuspendedProfileErrorSummaryInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuspendedProfileErrorSummaryInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetSuspendedProfileErrorSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suspendedProfileErrorSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIMergeProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	survivorProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileToBeMerged *MergeProfilesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIMergeProfilesRequest) Authorization(authorization string) ProfileAPIMergeProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIMergeProfilesRequest) XAppKey(xAppKey string) ProfileAPIMergeProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIMergeProfilesRequest) XHotelid(xHotelid string) ProfileAPIMergeProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for merging profiles.
func (r ProfileAPIMergeProfilesRequest) ProfileToBeMerged(profileToBeMerged MergeProfilesRequest) ProfileAPIMergeProfilesRequest {
	r.profileToBeMerged = &profileToBeMerged
	return r
}

// External system code.
func (r ProfileAPIMergeProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIMergeProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIMergeProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIMergeProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIMergeProfilesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.MergeProfilesExecute(r)
}

/*
MergeProfiles Merge two profiles by ID

When you need to merge 2 guest profiles into 1 profile, use this API. <p><strong>OperationId:</strong>mergeProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param survivorProfileId Original Profile ID to which profiles will be merged in OPERA.
 @return ProfileAPIMergeProfilesRequest
*/
func (a *ProfileAPIService) MergeProfiles(ctx context.Context, survivorProfileId string) ProfileAPIMergeProfilesRequest {
	return ProfileAPIMergeProfilesRequest{
		ApiService: a,
		ctx: ctx,
		survivorProfileId: survivorProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) MergeProfilesExecute(r ProfileAPIMergeProfilesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.MergeProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{survivorProfileId}/merges"
	localVarPath = strings.Replace(localVarPath, "{"+"survivorProfileId"+"}", url.PathEscape(parameterValueToString(r.survivorProfileId, "survivorProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.survivorProfileId) < 1 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have at least 1 elements")
	}
	if strlen(r.survivorProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("survivorProfileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileToBeMerged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostAccountForecastRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	forecastsInformation *ForecastsInformation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostAccountForecastRequest) Authorization(authorization string) ProfileAPIPostAccountForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostAccountForecastRequest) XAppKey(xAppKey string) ProfileAPIPostAccountForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostAccountForecastRequest) XHotelid(xHotelid string) ProfileAPIPostAccountForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating forecast(s) of an account profile.
func (r ProfileAPIPostAccountForecastRequest) ForecastsInformation(forecastsInformation ForecastsInformation) ProfileAPIPostAccountForecastRequest {
	r.forecastsInformation = &forecastsInformation
	return r
}

// External system code.
func (r ProfileAPIPostAccountForecastRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostAccountForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostAccountForecastRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostAccountForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostAccountForecastRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountForecastExecute(r)
}

/*
PostAccountForecast Create account forecast in a hotel

Use postAccountForecast to create a new account forecast for a hotel.  <p><strong>OperationId:</strong>postAccountForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @param profileId Unique OPERA internal account profile ID
 @return ProfileAPIPostAccountForecastRequest
*/
func (a *ProfileAPIService) PostAccountForecast(ctx context.Context, hotelId string, profileId string) ProfileAPIPostAccountForecastRequest {
	return ProfileAPIPostAccountForecastRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostAccountForecastExecute(r ProfileAPIPostAccountForecastRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostAccountForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/hotels/{hotelId}/forecasts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.forecastsInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostCompanyProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	company *Company
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostCompanyProfileRequest) Authorization(authorization string) ProfileAPIPostCompanyProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostCompanyProfileRequest) XAppKey(xAppKey string) ProfileAPIPostCompanyProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostCompanyProfileRequest) XHotelid(xHotelid string) ProfileAPIPostCompanyProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of company profile. This object contains profile details with unique identifiers of a profile. The standard optional Opera Context element is also included.
func (r ProfileAPIPostCompanyProfileRequest) Company(company Company) ProfileAPIPostCompanyProfileRequest {
	r.company = &company
	return r
}

// External system code.
func (r ProfileAPIPostCompanyProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostCompanyProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostCompanyProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostCompanyProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostCompanyProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCompanyProfileExecute(r)
}

/*
PostCompanyProfile This API facilitates creation of a company/agent/group/source profile in OPERA.

When a profile doesn't already exist for a guest, use this to create a new profile.  The response will provide the newly created profile's OPERA ID. There are many fields in postProfile defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postProfile. <p><strong>OperationId:</strong>postCompanyProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIPostCompanyProfileRequest
*/
func (a *ProfileAPIService) PostCompanyProfile(ctx context.Context) ProfileAPIPostCompanyProfileRequest {
	return ProfileAPIPostCompanyProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostCompanyProfileExecute(r ProfileAPIPostCompanyProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostCompanyProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.company
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostECertificateRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	eCertificateGeneration *ECertificateGeneration
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostECertificateRequest) Authorization(authorization string) ProfileAPIPostECertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostECertificateRequest) XAppKey(xAppKey string) ProfileAPIPostECertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostECertificateRequest) XHotelid(xHotelid string) ProfileAPIPostECertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to issue E-Certificate.
func (r ProfileAPIPostECertificateRequest) ECertificateGeneration(eCertificateGeneration ECertificateGeneration) ProfileAPIPostECertificateRequest {
	r.eCertificateGeneration = &eCertificateGeneration
	return r
}

// External system code.
func (r ProfileAPIPostECertificateRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostECertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostECertificateRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostECertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostECertificateRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostECertificateExecute(r)
}

/*
PostECertificate Create e-certificate

This API allows you to create a new eCertificates onto a profile in OPERA Cloud. <p><strong>OperationId:</strong>postECertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIPostECertificateRequest
*/
func (a *ProfileAPIService) PostECertificate(ctx context.Context) ProfileAPIPostECertificateRequest {
	return ProfileAPIPostECertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostECertificateExecute(r ProfileAPIPostECertificateRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostECertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecertificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCertificateGeneration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostGuestProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	guest *Guest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostGuestProfileRequest) Authorization(authorization string) ProfileAPIPostGuestProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostGuestProfileRequest) XAppKey(xAppKey string) ProfileAPIPostGuestProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostGuestProfileRequest) XHotelid(xHotelid string) ProfileAPIPostGuestProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of guest profile. This object contains profile details with unique identifiers of a profile. The standard optional Opera Context element is also included.
func (r ProfileAPIPostGuestProfileRequest) Guest(guest Guest) ProfileAPIPostGuestProfileRequest {
	r.guest = &guest
	return r
}

// External system code.
func (r ProfileAPIPostGuestProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostGuestProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostGuestProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostGuestProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostGuestProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostGuestProfileExecute(r)
}

/*
PostGuestProfile Create a guest, contact or employee profile in OPERA

When a profile doesn't already exist for a guest, use this to create a new profile.  The response will provide the newly created profile's OPERA ID. There are many fields in postProfile defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postProfile. <p><strong>OperationId:</strong>postGuestProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIPostGuestProfileRequest
*/
func (a *ProfileAPIService) PostGuestProfile(ctx context.Context) ProfileAPIPostGuestProfileRequest {
	return ProfileAPIPostGuestProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostGuestProfileExecute(r ProfileAPIPostGuestProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostGuestProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/guests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.guest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostMembershipRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	membership *Membership
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostMembershipRequest) Authorization(authorization string) ProfileAPIPostMembershipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostMembershipRequest) XAppKey(xAppKey string) ProfileAPIPostMembershipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostMembershipRequest) XHotelid(xHotelid string) ProfileAPIPostMembershipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for create membership. This object contains unique identifiers for each profile and list of membership details to be created. The standard optional Opera Context element is also included.
func (r ProfileAPIPostMembershipRequest) Membership(membership Membership) ProfileAPIPostMembershipRequest {
	r.membership = &membership
	return r
}

// External system code.
func (r ProfileAPIPostMembershipRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostMembershipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostMembershipRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostMembershipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostMembershipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipExecute(r)
}

/*
PostMembership Create membership on a profile

A guest might be a member of your hotel loyalty program and/or a member of multiple airline frequent flier programs. Use this API to add membership details onto a guests profile. <p><strong>OperationId:</strong>postMembership</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIPostMembershipRequest
*/
func (a *ProfileAPIService) PostMembership(ctx context.Context, profileId string) ProfileAPIPostMembershipRequest {
	return ProfileAPIPostMembershipRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostMembershipExecute(r ProfileAPIPostMembershipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/memberships"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membership
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostMembershipNumberRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	membershipType string
	authorization *string
	xAppKey *string
	xHotelid *string
	membershipNumber *MembershipNumber
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostMembershipNumberRequest) Authorization(authorization string) ProfileAPIPostMembershipNumberRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostMembershipNumberRequest) XAppKey(xAppKey string) ProfileAPIPostMembershipNumberRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostMembershipNumberRequest) XHotelid(xHotelid string) ProfileAPIPostMembershipNumberRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for generating membership number.
func (r ProfileAPIPostMembershipNumberRequest) MembershipNumber(membershipNumber MembershipNumber) ProfileAPIPostMembershipNumberRequest {
	r.membershipNumber = &membershipNumber
	return r
}

// External system code.
func (r ProfileAPIPostMembershipNumberRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostMembershipNumberRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostMembershipNumberRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostMembershipNumberRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostMembershipNumberRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostMembershipNumberExecute(r)
}

/*
PostMembershipNumber Generate membership number

This API will generate a new membership number. <p><strong>OperationId:</strong>postMembershipNumber</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipType
 @return ProfileAPIPostMembershipNumberRequest
*/
func (a *ProfileAPIService) PostMembershipNumber(ctx context.Context, membershipType string) ProfileAPIPostMembershipNumberRequest {
	return ProfileAPIPostMembershipNumberRequest{
		ApiService: a,
		ctx: ctx,
		membershipType: membershipType,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostMembershipNumberExecute(r ProfileAPIPostMembershipNumberRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostMembershipNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/memberships/{membershipType}/membershipNumbers"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipType"+"}", url.PathEscape(parameterValueToString(r.membershipType, "membershipType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.membershipType) < 1 {
		return localVarReturnValue, nil, reportError("membershipType must have at least 1 elements")
	}
	if strlen(r.membershipType) > 2000 {
		return localVarReturnValue, nil, reportError("membershipType must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.membershipNumber
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostPreferenceRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	preference *Preference
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostPreferenceRequest) Authorization(authorization string) ProfileAPIPostPreferenceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostPreferenceRequest) XAppKey(xAppKey string) ProfileAPIPostPreferenceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostPreferenceRequest) XHotelid(xHotelid string) ProfileAPIPostPreferenceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Create Preference. This object contains unique identifiers for each profile and list of preferences to be associated with the profile. The standard optional Opera Context element is also included.
func (r ProfileAPIPostPreferenceRequest) Preference(preference Preference) ProfileAPIPostPreferenceRequest {
	r.preference = &preference
	return r
}

// External system code.
func (r ProfileAPIPostPreferenceRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostPreferenceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostPreferenceRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostPreferenceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostPreferenceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostPreferenceExecute(r)
}

/*
PostPreference Add preferences to a profile

You can add new preferences to a profile to personalize or enhance your guest services.  You will need to know the profile ID, and the properties pre-configured preference codes. <p><strong>OperationId:</strong>postPreference</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIPostPreferenceRequest
*/
func (a *ProfileAPIService) PostPreference(ctx context.Context, profileId string) ProfileAPIPostPreferenceRequest {
	return ProfileAPIPostPreferenceRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostPreferenceExecute(r ProfileAPIPostPreferenceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.preference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	profile *PostProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostProfileRequest) Authorization(authorization string) ProfileAPIPostProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostProfileRequest) XAppKey(xAppKey string) ProfileAPIPostProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostProfileRequest) XHotelid(xHotelid string) ProfileAPIPostProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creation of profiles. This object contains profile details with unique identifiers for each profile. The standard optional Opera Context element is also included.
func (r ProfileAPIPostProfileRequest) Profile(profile PostProfileRequest) ProfileAPIPostProfileRequest {
	r.profile = &profile
	return r
}

// External system code.
func (r ProfileAPIPostProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostProfileRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileExecute(r)
}

/*
PostProfile Create a profile

When a profile doesn&apos;t already exist in OPERA, use this to create a new profile. The response will provide the newly created profile&apos;s OPERA ID in the Location header. There are many fields in postProfile defined by ListOfValues; ensure you have reviewed ListOfValues APIs in order successfully to use postProfile.<p><strong>OperationId:</strong>postProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIPostProfileRequest
*/
func (a *ProfileAPIService) PostProfile(ctx context.Context) ProfileAPIPostProfileRequest {
	return ProfileAPIPostProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostProfileExecute(r ProfileAPIPostProfileRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostProfileCommissionAccountRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileCommissionAccount *ProfileCommissionAccount
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostProfileCommissionAccountRequest) Authorization(authorization string) ProfileAPIPostProfileCommissionAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostProfileCommissionAccountRequest) XAppKey(xAppKey string) ProfileAPIPostProfileCommissionAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostProfileCommissionAccountRequest) XHotelid(xHotelid string) ProfileAPIPostProfileCommissionAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating profile commission detail.
func (r ProfileAPIPostProfileCommissionAccountRequest) ProfileCommissionAccount(profileCommissionAccount ProfileCommissionAccount) ProfileAPIPostProfileCommissionAccountRequest {
	r.profileCommissionAccount = &profileCommissionAccount
	return r
}

// External system code.
func (r ProfileAPIPostProfileCommissionAccountRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostProfileCommissionAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostProfileCommissionAccountRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostProfileCommissionAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostProfileCommissionAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileCommissionAccountExecute(r)
}

/*
PostProfileCommissionAccount Add a commission account on a profile

Add a commission account on a profile.  You can only add commission accounts onto a Travel Agent or Source Profile type in OPERA Cloud. <p><strong>OperationId:</strong>postProfileCommissionAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIPostProfileCommissionAccountRequest
*/
func (a *ProfileAPIService) PostProfileCommissionAccount(ctx context.Context, profileId string) ProfileAPIPostProfileCommissionAccountRequest {
	return ProfileAPIPostProfileCommissionAccountRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostProfileCommissionAccountExecute(r ProfileAPIPostProfileCommissionAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostProfileCommissionAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/commissionAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileCommissionAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostProfileOwnersRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileOwners *ProfileOwners
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostProfileOwnersRequest) Authorization(authorization string) ProfileAPIPostProfileOwnersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostProfileOwnersRequest) XAppKey(xAppKey string) ProfileAPIPostProfileOwnersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostProfileOwnersRequest) XHotelid(xHotelid string) ProfileAPIPostProfileOwnersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to assign profile owners.
func (r ProfileAPIPostProfileOwnersRequest) ProfileOwners(profileOwners ProfileOwners) ProfileAPIPostProfileOwnersRequest {
	r.profileOwners = &profileOwners
	return r
}

// External system code.
func (r ProfileAPIPostProfileOwnersRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostProfileOwnersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostProfileOwnersRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostProfileOwnersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostProfileOwnersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileOwnersExecute(r)
}

/*
PostProfileOwners Assign profile owners

Assign an Owner to a profile. <p><strong>OperationId:</strong>postProfileOwners</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIPostProfileOwnersRequest
*/
func (a *ProfileAPIService) PostProfileOwners(ctx context.Context, profileId string) ProfileAPIPostProfileOwnersRequest {
	return ProfileAPIPostProfileOwnersRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostProfileOwnersExecute(r ProfileAPIPostProfileOwnersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostProfileOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileOwners
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPostProfileRelationshipRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	targetProfileId string
	sourceProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileRelationship *PostProfileRelationshipRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPostProfileRelationshipRequest) Authorization(authorization string) ProfileAPIPostProfileRelationshipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPostProfileRelationshipRequest) XAppKey(xAppKey string) ProfileAPIPostProfileRelationshipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPostProfileRelationshipRequest) XHotelid(xHotelid string) ProfileAPIPostProfileRelationshipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating profile relationship.
func (r ProfileAPIPostProfileRelationshipRequest) ProfileRelationship(profileRelationship PostProfileRelationshipRequest) ProfileAPIPostProfileRelationshipRequest {
	r.profileRelationship = &profileRelationship
	return r
}

// External system code.
func (r ProfileAPIPostProfileRelationshipRequest) XExternalsystem(xExternalsystem string) ProfileAPIPostProfileRelationshipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPostProfileRelationshipRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPostProfileRelationshipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPostProfileRelationshipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostProfileRelationshipExecute(r)
}

/*
PostProfileRelationship CreateProfileRelationship method provides the ability to create profile relationship based on the request criteria of SourceProfileID,TargetProfileID and SourceRelationType specified.

 <p><strong>OperationId:</strong>postProfileRelationship</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetProfileId
 @param sourceProfileId
 @return ProfileAPIPostProfileRelationshipRequest
*/
func (a *ProfileAPIService) PostProfileRelationship(ctx context.Context, targetProfileId string, sourceProfileId string) ProfileAPIPostProfileRelationshipRequest {
	return ProfileAPIPostProfileRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		targetProfileId: targetProfileId,
		sourceProfileId: sourceProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PostProfileRelationshipExecute(r ProfileAPIPostProfileRelationshipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostProfileRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{sourceProfileId}/relationships/{targetProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetProfileId"+"}", url.PathEscape(parameterValueToString(r.targetProfileId, "targetProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceProfileId"+"}", url.PathEscape(parameterValueToString(r.sourceProfileId, "sourceProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetProfileId) < 1 {
		return localVarReturnValue, nil, reportError("targetProfileId must have at least 1 elements")
	}
	if strlen(r.targetProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("targetProfileId must have less than 2000 elements")
	}
	if strlen(r.sourceProfileId) < 1 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have at least 1 elements")
	}
	if strlen(r.sourceProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileRelationship
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPutAccountForecastRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	periodCode string
	hotelId string
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	forecastsInformation *ForecastsInformation
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPutAccountForecastRequest) Authorization(authorization string) ProfileAPIPutAccountForecastRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPutAccountForecastRequest) XAppKey(xAppKey string) ProfileAPIPutAccountForecastRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPutAccountForecastRequest) XHotelid(xHotelid string) ProfileAPIPutAccountForecastRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing forecast(s) of an account profile.
func (r ProfileAPIPutAccountForecastRequest) ForecastsInformation(forecastsInformation ForecastsInformation) ProfileAPIPutAccountForecastRequest {
	r.forecastsInformation = &forecastsInformation
	return r
}

// External system code.
func (r ProfileAPIPutAccountForecastRequest) XExternalsystem(xExternalsystem string) ProfileAPIPutAccountForecastRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPutAccountForecastRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPutAccountForecastRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPutAccountForecastRequest) Execute() (*ChangeAccountForecastsRS, *http.Response, error) {
	return r.ApiService.PutAccountForecastExecute(r)
}

/*
PutAccountForecast Update account forecast in a hotel by period code

Use this to update an existing account Forecast for a hotel.  You must know the period code for this API. <p><strong>OperationId:</strong>putAccountForecast</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param periodCode Period Code
 @param hotelId Unique ID of the hotel.
 @param profileId Unique Account Profile ID.
 @return ProfileAPIPutAccountForecastRequest
*/
func (a *ProfileAPIService) PutAccountForecast(ctx context.Context, periodCode string, hotelId string, profileId string) ProfileAPIPutAccountForecastRequest {
	return ProfileAPIPutAccountForecastRequest{
		ApiService: a,
		ctx: ctx,
		periodCode: periodCode,
		hotelId: hotelId,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ChangeAccountForecastsRS
func (a *ProfileAPIService) PutAccountForecastExecute(r ProfileAPIPutAccountForecastRequest) (*ChangeAccountForecastsRS, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChangeAccountForecastsRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutAccountForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/hotels/{hotelId}/forecasts/periodCodes/{periodCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"periodCode"+"}", url.PathEscape(parameterValueToString(r.periodCode, "periodCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.periodCode) < 1 {
		return localVarReturnValue, nil, reportError("periodCode must have at least 1 elements")
	}
	if strlen(r.periodCode) > 2000 {
		return localVarReturnValue, nil, reportError("periodCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.forecastsInformation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPutProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profile *PutProfileRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPutProfileRequest) Authorization(authorization string) ProfileAPIPutProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPutProfileRequest) XAppKey(xAppKey string) ProfileAPIPutProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPutProfileRequest) XHotelid(xHotelid string) ProfileAPIPutProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for change/modification of profile details. This object contains modified profile details with unique identifiers for each profile. The standard optional Opera Context element is also included.
func (r ProfileAPIPutProfileRequest) Profile(profile PutProfileRequest) ProfileAPIPutProfileRequest {
	r.profile = &profile
	return r
}

// External system code.
func (r ProfileAPIPutProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIPutProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPutProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPutProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPutProfileRequest) Execute() (*Profile, *http.Response, error) {
	return r.ApiService.PutProfileExecute(r)
}

/*
PutProfile Update a profile by ID

Use this to update a guests details on their profile.  You will need to know the OPERA Profile ID to use this API, and you will also need to know the List of Values for profile fields, such as AddressType, PhoneType, Title.  <p><strong>OperationId:</strong>putProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId OPERA internal profile ID which is used to uniquely identify the profile in OPERA. This ID is a primary identification of a profile in OPERA.
 @return ProfileAPIPutProfileRequest
*/
func (a *ProfileAPIService) PutProfile(ctx context.Context, profileId string) ProfileAPIPutProfileRequest {
	return ProfileAPIPutProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Profile
func (a *ProfileAPIService) PutProfileExecute(r ProfileAPIPutProfileRequest) (*Profile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Profile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIPutProfileRelationshipRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	targetProfileId string
	sourceProfileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileRelationshipToBeChanged *PutProfileRelationshipRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIPutProfileRelationshipRequest) Authorization(authorization string) ProfileAPIPutProfileRelationshipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIPutProfileRelationshipRequest) XAppKey(xAppKey string) ProfileAPIPutProfileRelationshipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIPutProfileRelationshipRequest) XHotelid(xHotelid string) ProfileAPIPutProfileRelationshipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing profile relationship.
func (r ProfileAPIPutProfileRelationshipRequest) ProfileRelationshipToBeChanged(profileRelationshipToBeChanged PutProfileRelationshipRequest) ProfileAPIPutProfileRelationshipRequest {
	r.profileRelationshipToBeChanged = &profileRelationshipToBeChanged
	return r
}

// External system code.
func (r ProfileAPIPutProfileRelationshipRequest) XExternalsystem(xExternalsystem string) ProfileAPIPutProfileRelationshipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIPutProfileRelationshipRequest) AcceptLanguage(acceptLanguage string) ProfileAPIPutProfileRelationshipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIPutProfileRelationshipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutProfileRelationshipExecute(r)
}

/*
PutProfileRelationship ChangeProfileRelationship method provides the ability to update(delete and add) profile relationship based on the request criteria of SourceProfileID , TargetProfileID, To Be ChangedProfileID and SourceProfileRelationType specified.

 <p><strong>OperationId:</strong>putProfileRelationship</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetProfileId
 @param sourceProfileId
 @return ProfileAPIPutProfileRelationshipRequest
*/
func (a *ProfileAPIService) PutProfileRelationship(ctx context.Context, targetProfileId string, sourceProfileId string) ProfileAPIPutProfileRelationshipRequest {
	return ProfileAPIPutProfileRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		targetProfileId: targetProfileId,
		sourceProfileId: sourceProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) PutProfileRelationshipExecute(r ProfileAPIPutProfileRelationshipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutProfileRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{sourceProfileId}/relationships/{targetProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetProfileId"+"}", url.PathEscape(parameterValueToString(r.targetProfileId, "targetProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceProfileId"+"}", url.PathEscape(parameterValueToString(r.sourceProfileId, "sourceProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetProfileId) < 1 {
		return localVarReturnValue, nil, reportError("targetProfileId must have at least 1 elements")
	}
	if strlen(r.targetProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("targetProfileId must have less than 2000 elements")
	}
	if strlen(r.sourceProfileId) < 1 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have at least 1 elements")
	}
	if strlen(r.sourceProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileRelationshipToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIRemoveProfileRelationshipRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	targetProfileId string
	sourceProfileId string
	sourceRelation *string
	targetRelation *string
	authorization *string
	xAppKey *string
	xHotelid *string
	primary *bool
	sourceRelationDescription *string
	targetRelationDescription *string
	xExternalsystem *string
	acceptLanguage *string
}

// Indicates the type of relationship the current profile(Source Profile) has with the related profile(Target Profile).
func (r ProfileAPIRemoveProfileRelationshipRequest) SourceRelation(sourceRelation string) ProfileAPIRemoveProfileRelationshipRequest {
	r.sourceRelation = &sourceRelation
	return r
}

// Indicates the type of relationship the related profile(Target Profile) has with the current profile(Source Profile).
func (r ProfileAPIRemoveProfileRelationshipRequest) TargetRelation(targetRelation string) ProfileAPIRemoveProfileRelationshipRequest {
	r.targetRelation = &targetRelation
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIRemoveProfileRelationshipRequest) Authorization(authorization string) ProfileAPIRemoveProfileRelationshipRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIRemoveProfileRelationshipRequest) XAppKey(xAppKey string) ProfileAPIRemoveProfileRelationshipRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIRemoveProfileRelationshipRequest) XHotelid(xHotelid string) ProfileAPIRemoveProfileRelationshipRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates if this relationship is the primary relationship.
func (r ProfileAPIRemoveProfileRelationshipRequest) Primary(primary bool) ProfileAPIRemoveProfileRelationshipRequest {
	r.primary = &primary
	return r
}

// Displays the description of relationship the current profile(Source Profile) has with the related profile(Target Profile).This needs to be passed if the attribute primary is sent as true.
func (r ProfileAPIRemoveProfileRelationshipRequest) SourceRelationDescription(sourceRelationDescription string) ProfileAPIRemoveProfileRelationshipRequest {
	r.sourceRelationDescription = &sourceRelationDescription
	return r
}

// Displays the description of relationship the related profile(Target Profile) has with the current profile(Source Profile).
func (r ProfileAPIRemoveProfileRelationshipRequest) TargetRelationDescription(targetRelationDescription string) ProfileAPIRemoveProfileRelationshipRequest {
	r.targetRelationDescription = &targetRelationDescription
	return r
}

// External system code.
func (r ProfileAPIRemoveProfileRelationshipRequest) XExternalsystem(xExternalsystem string) ProfileAPIRemoveProfileRelationshipRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIRemoveProfileRelationshipRequest) AcceptLanguage(acceptLanguage string) ProfileAPIRemoveProfileRelationshipRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIRemoveProfileRelationshipRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveProfileRelationshipExecute(r)
}

/*
RemoveProfileRelationship DeleteProfileRelationship method provides the ability to delete profile relationship based on the request criteria of SourceProfileID,TargetProfileID and SourceRelationType specified.

 <p><strong>OperationId:</strong>removeProfileRelationship</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetProfileId
 @param sourceProfileId
 @return ProfileAPIRemoveProfileRelationshipRequest
*/
func (a *ProfileAPIService) RemoveProfileRelationship(ctx context.Context, targetProfileId string, sourceProfileId string) ProfileAPIRemoveProfileRelationshipRequest {
	return ProfileAPIRemoveProfileRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		targetProfileId: targetProfileId,
		sourceProfileId: sourceProfileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) RemoveProfileRelationshipExecute(r ProfileAPIRemoveProfileRelationshipRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.RemoveProfileRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{sourceProfileId}/relationships/{targetProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetProfileId"+"}", url.PathEscape(parameterValueToString(r.targetProfileId, "targetProfileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceProfileId"+"}", url.PathEscape(parameterValueToString(r.sourceProfileId, "sourceProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.targetProfileId) < 1 {
		return localVarReturnValue, nil, reportError("targetProfileId must have at least 1 elements")
	}
	if strlen(r.targetProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("targetProfileId must have less than 2000 elements")
	}
	if strlen(r.sourceProfileId) < 1 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have at least 1 elements")
	}
	if strlen(r.sourceProfileId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceProfileId must have less than 2000 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sourceRelation", r.sourceRelation, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "targetRelation", r.targetRelation, "")
	if r.primary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primary", r.primary, "")
  }
	if r.sourceRelationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceRelationDescription", r.sourceRelationDescription, "")
  }
	if r.targetRelationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetRelationDescription", r.targetRelationDescription, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPISetProfileCommissionAccountRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileCommissionAccount *ProfileCommissionAccount
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPISetProfileCommissionAccountRequest) Authorization(authorization string) ProfileAPISetProfileCommissionAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPISetProfileCommissionAccountRequest) XAppKey(xAppKey string) ProfileAPISetProfileCommissionAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPISetProfileCommissionAccountRequest) XHotelid(xHotelid string) ProfileAPISetProfileCommissionAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for updating profile commission detail.
func (r ProfileAPISetProfileCommissionAccountRequest) ProfileCommissionAccount(profileCommissionAccount ProfileCommissionAccount) ProfileAPISetProfileCommissionAccountRequest {
	r.profileCommissionAccount = &profileCommissionAccount
	return r
}

// External system code.
func (r ProfileAPISetProfileCommissionAccountRequest) XExternalsystem(xExternalsystem string) ProfileAPISetProfileCommissionAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPISetProfileCommissionAccountRequest) AcceptLanguage(acceptLanguage string) ProfileAPISetProfileCommissionAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPISetProfileCommissionAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SetProfileCommissionAccountExecute(r)
}

/*
SetProfileCommissionAccount Set profile commission account

Apply a commission account to an existing profile. You can add commission accounts to Travel Agent profile types. <p><strong>OperationId:</strong>setProfileCommissionAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPISetProfileCommissionAccountRequest
*/
func (a *ProfileAPIService) SetProfileCommissionAccount(ctx context.Context, profileId string) ProfileAPISetProfileCommissionAccountRequest {
	return ProfileAPISetProfileCommissionAccountRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) SetProfileCommissionAccountExecute(r ProfileAPISetProfileCommissionAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.SetProfileCommissionAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/commissionAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileCommissionAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIStoreEmailRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	emailMessageType *StoreEmailRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIStoreEmailRequest) Authorization(authorization string) ProfileAPIStoreEmailRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIStoreEmailRequest) XAppKey(xAppKey string) ProfileAPIStoreEmailRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIStoreEmailRequest) XHotelid(xHotelid string) ProfileAPIStoreEmailRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for storing an email.
func (r ProfileAPIStoreEmailRequest) EmailMessageType(emailMessageType StoreEmailRequest) ProfileAPIStoreEmailRequest {
	r.emailMessageType = &emailMessageType
	return r
}

// External system code.
func (r ProfileAPIStoreEmailRequest) XExternalsystem(xExternalsystem string) ProfileAPIStoreEmailRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIStoreEmailRequest) AcceptLanguage(acceptLanguage string) ProfileAPIStoreEmailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIStoreEmailRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.StoreEmailExecute(r)
}

/*
StoreEmail Create an Email.

Use this API to create a new Email in OPERA.  You would need to know the Profile Id such as Contact or Account. <p><strong>OperationId:</strong>storeEmail</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Profile ID linked to an Email.
 @return ProfileAPIStoreEmailRequest
*/
func (a *ProfileAPIService) StoreEmail(ctx context.Context, profileId string) ProfileAPIStoreEmailRequest {
	return ProfileAPIStoreEmailRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) StoreEmailExecute(r ProfileAPIStoreEmailRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.StoreEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/emails"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.emailMessageType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPISynchronizeProfileSubscriptionsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	profileSubscriptionsToSynchronize *ProfileSubscriptionsToSynchronize
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPISynchronizeProfileSubscriptionsRequest) Authorization(authorization string) ProfileAPISynchronizeProfileSubscriptionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPISynchronizeProfileSubscriptionsRequest) XAppKey(xAppKey string) ProfileAPISynchronizeProfileSubscriptionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPISynchronizeProfileSubscriptionsRequest) XHotelid(xHotelid string) ProfileAPISynchronizeProfileSubscriptionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for re-subscribing profile subscriptions.
func (r ProfileAPISynchronizeProfileSubscriptionsRequest) ProfileSubscriptionsToSynchronize(profileSubscriptionsToSynchronize ProfileSubscriptionsToSynchronize) ProfileAPISynchronizeProfileSubscriptionsRequest {
	r.profileSubscriptionsToSynchronize = &profileSubscriptionsToSynchronize
	return r
}

// External system code.
func (r ProfileAPISynchronizeProfileSubscriptionsRequest) XExternalsystem(xExternalsystem string) ProfileAPISynchronizeProfileSubscriptionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPISynchronizeProfileSubscriptionsRequest) AcceptLanguage(acceptLanguage string) ProfileAPISynchronizeProfileSubscriptionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPISynchronizeProfileSubscriptionsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.SynchronizeProfileSubscriptionsExecute(r)
}

/*
SynchronizeProfileSubscriptions Synchronize profile subscriptions

Synchronize profile subscriptions <p><strong>OperationId:</strong>synchronizeProfileSubscriptions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPISynchronizeProfileSubscriptionsRequest
*/
func (a *ProfileAPIService) SynchronizeProfileSubscriptions(ctx context.Context) ProfileAPISynchronizeProfileSubscriptionsRequest {
	return ProfileAPISynchronizeProfileSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *ProfileAPIService) SynchronizeProfileSubscriptionsExecute(r ProfileAPISynchronizeProfileSubscriptionsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.SynchronizeProfileSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronizeProfileSubscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.profileSubscriptionsToSynchronize
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIValidateForgetProfilesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	forgetProfilesCriteria *ForgetProfilesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIValidateForgetProfilesRequest) Authorization(authorization string) ProfileAPIValidateForgetProfilesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIValidateForgetProfilesRequest) XAppKey(xAppKey string) ProfileAPIValidateForgetProfilesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIValidateForgetProfilesRequest) XHotelid(xHotelid string) ProfileAPIValidateForgetProfilesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to validate profiles for forgetting.
func (r ProfileAPIValidateForgetProfilesRequest) ForgetProfilesCriteria(forgetProfilesCriteria ForgetProfilesCriteria) ProfileAPIValidateForgetProfilesRequest {
	r.forgetProfilesCriteria = &forgetProfilesCriteria
	return r
}

// External system code.
func (r ProfileAPIValidateForgetProfilesRequest) XExternalsystem(xExternalsystem string) ProfileAPIValidateForgetProfilesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIValidateForgetProfilesRequest) AcceptLanguage(acceptLanguage string) ProfileAPIValidateForgetProfilesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIValidateForgetProfilesRequest) Execute() (*ValidatedForgetProfiles, *http.Response, error) {
	return r.ApiService.ValidateForgetProfilesExecute(r)
}

/*
ValidateForgetProfiles Validate forget profiles

Validate forget profiles. <p><strong>OperationId:</strong>validateForgetProfiles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProfileAPIValidateForgetProfilesRequest
*/
func (a *ProfileAPIService) ValidateForgetProfiles(ctx context.Context) ProfileAPIValidateForgetProfilesRequest {
	return ProfileAPIValidateForgetProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidatedForgetProfiles
func (a *ProfileAPIService) ValidateForgetProfilesExecute(r ProfileAPIValidateForgetProfilesRequest) (*ValidatedForgetProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidatedForgetProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ValidateForgetProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validateForgetProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.forgetProfilesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIValidateReservationsForProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	futurePastBookingsCriteria *FuturePastBookingsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIValidateReservationsForProfileRequest) Authorization(authorization string) ProfileAPIValidateReservationsForProfileRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIValidateReservationsForProfileRequest) XAppKey(xAppKey string) ProfileAPIValidateReservationsForProfileRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIValidateReservationsForProfileRequest) XHotelid(xHotelid string) ProfileAPIValidateReservationsForProfileRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for information regarding existence of profile in future and/or past business blocks and/or reservations.
func (r ProfileAPIValidateReservationsForProfileRequest) FuturePastBookingsCriteria(futurePastBookingsCriteria FuturePastBookingsCriteria) ProfileAPIValidateReservationsForProfileRequest {
	r.futurePastBookingsCriteria = &futurePastBookingsCriteria
	return r
}

// External system code.
func (r ProfileAPIValidateReservationsForProfileRequest) XExternalsystem(xExternalsystem string) ProfileAPIValidateReservationsForProfileRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIValidateReservationsForProfileRequest) AcceptLanguage(acceptLanguage string) ProfileAPIValidateReservationsForProfileRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIValidateReservationsForProfileRequest) Execute() (*FuturePastBookings, *http.Response, error) {
	return r.ApiService.ValidateReservationsForProfileExecute(r)
}

/*
ValidateReservationsForProfile Check future past bookings

Validate if a profile has future and past bookings on a specific profile. <p><strong>OperationId:</strong>validateReservationsForProfile</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId
 @return ProfileAPIValidateReservationsForProfileRequest
*/
func (a *ProfileAPIService) ValidateReservationsForProfile(ctx context.Context, profileId string) ProfileAPIValidateReservationsForProfileRequest {
	return ProfileAPIValidateReservationsForProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return FuturePastBookings
func (a *ProfileAPIService) ValidateReservationsForProfileExecute(r ProfileAPIValidateReservationsForProfileRequest) (*FuturePastBookings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FuturePastBookings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.ValidateReservationsForProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/reservations/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.futurePastBookingsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProfileAPIVerifyECertificateRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	certificateId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eCertificateToVerify *ECertificateToVerify
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ProfileAPIVerifyECertificateRequest) Authorization(authorization string) ProfileAPIVerifyECertificateRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ProfileAPIVerifyECertificateRequest) XAppKey(xAppKey string) ProfileAPIVerifyECertificateRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ProfileAPIVerifyECertificateRequest) XHotelid(xHotelid string) ProfileAPIVerifyECertificateRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object to Verify an E-Certificate Number.
func (r ProfileAPIVerifyECertificateRequest) ECertificateToVerify(eCertificateToVerify ECertificateToVerify) ProfileAPIVerifyECertificateRequest {
	r.eCertificateToVerify = &eCertificateToVerify
	return r
}

// External system code.
func (r ProfileAPIVerifyECertificateRequest) XExternalsystem(xExternalsystem string) ProfileAPIVerifyECertificateRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ProfileAPIVerifyECertificateRequest) AcceptLanguage(acceptLanguage string) ProfileAPIVerifyECertificateRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ProfileAPIVerifyECertificateRequest) Execute() (*VerifiedECertificate, *http.Response, error) {
	return r.ApiService.VerifyECertificateExecute(r)
}

/*
VerifyECertificate Verify E-Certificate Number

Use this API to verify an ng E-Certificate Number. <p><strong>OperationId:</strong>verifyECertificate</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certificateId
 @return ProfileAPIVerifyECertificateRequest
*/
func (a *ProfileAPIService) VerifyECertificate(ctx context.Context, certificateId string) ProfileAPIVerifyECertificateRequest {
	return ProfileAPIVerifyECertificateRequest{
		ApiService: a,
		ctx: ctx,
		certificateId: certificateId,
	}
}

// Execute executes the request
//  @return VerifiedECertificate
func (a *ProfileAPIService) VerifyECertificateExecute(r ProfileAPIVerifyECertificateRequest) (*VerifiedECertificate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifiedECertificate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.VerifyECertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecertificates/{certificateId}/action/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"certificateId"+"}", url.PathEscape(parameterValueToString(r.certificateId, "certificateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.certificateId) < 1 {
		return localVarReturnValue, nil, reportError("certificateId must have at least 1 elements")
	}
	if strlen(r.certificateId) > 2000 {
		return localVarReturnValue, nil, reportError("certificateId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eCertificateToVerify
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
