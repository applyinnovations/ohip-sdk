/*
OPERA Cloud Reservation Asynchronous API

APIs to cater for Reservation Asynchronous functionality in OPERA Cloud. This includes viewing reservation data along with its revenue. <p>This API follows an async pattern where</p><ul><li>You make an initial request, which returns a Location header</li><li>You poll HEAD on the Location header returned to obtain the status of the process</li><li>Once the process completes HEAD will return in the Location header the URL that must be called to obtain the results of the process</li><li>You call the URL to obtain the results of the process</li></ul><br /><br /> Compatible with OPERA Cloud release 24.4.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2024 Oracle and/or its affiliates.</p>

API version: 24.4
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rsvasync

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ReservationAsyncAPIService ReservationAsyncAPI service
type ReservationAsyncAPIService service

type ReservationAsyncAPIGetMassUpdateProcessSummaryRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	massUpdateId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) Authorization(authorization string) ReservationAsyncAPIGetMassUpdateProcessSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetMassUpdateProcessSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetMassUpdateProcessSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIGetMassUpdateProcessSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetMassUpdateProcessSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) Execute() (*MassUpdateSummaryType, *http.Response, error) {
	return r.ApiService.GetMassUpdateProcessSummaryExecute(r)
}

/*
GetMassUpdateProcessSummary Get results of a Mass Update process

This API returns a summary of the reservations included in the mass update process. You can get the value of massUpdateId from the process API response (under header location). <p><strong>OperationId:</strong>getMassUpdateProcessSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param massUpdateId Unique ID of mass update process
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIGetMassUpdateProcessSummaryRequest
*/
func (a *ReservationAsyncAPIService) GetMassUpdateProcessSummary(ctx context.Context, massUpdateId string, hotelId string) ReservationAsyncAPIGetMassUpdateProcessSummaryRequest {
	return ReservationAsyncAPIGetMassUpdateProcessSummaryRequest{
		ApiService: a,
		ctx: ctx,
		massUpdateId: massUpdateId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return MassUpdateSummaryType
func (a *ReservationAsyncAPIService) GetMassUpdateProcessSummaryExecute(r ReservationAsyncAPIGetMassUpdateProcessSummaryRequest) (*MassUpdateSummaryType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MassUpdateSummaryType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetMassUpdateProcessSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/massUpdate/{massUpdateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"massUpdateId"+"}", url.PathEscape(parameterValueToString(r.massUpdateId, "massUpdateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.massUpdateId) < 1 {
		return localVarReturnValue, nil, reportError("massUpdateId must have at least 1 elements")
	}
	if strlen(r.massUpdateId) > 2000 {
		return localVarReturnValue, nil, reportError("massUpdateId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationAsyncAPIGetReservationsDailySummaryRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	summaryId string
	extSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetReservationsDailySummaryRequest) Authorization(authorization string) ReservationAsyncAPIGetReservationsDailySummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetReservationsDailySummaryRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetReservationsDailySummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetReservationsDailySummaryRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetReservationsDailySummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r ReservationAsyncAPIGetReservationsDailySummaryRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetReservationsDailySummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetReservationsDailySummaryRequest) Execute() (*ReservationsDailySummaryDetails, *http.Response, error) {
	return r.ApiService.GetReservationsDailySummaryExecute(r)
}

/*
GetReservationsDailySummary Get results of Reservations Daily Summary

Use this API to retrieve a property&apos;s reservation daily summary within the dates given in the startReservationsDailySummaryProcess API request. You can get the value of the summaryId from the Location header returned by the getReservationsProcessStatus operation after the process is completed.  <p><strong>OperationId:</strong>getReservationsDailySummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param summaryId
 @param extSystemCode
 @param hotelId
 @return ReservationAsyncAPIGetReservationsDailySummaryRequest
*/
func (a *ReservationAsyncAPIService) GetReservationsDailySummary(ctx context.Context, summaryId string, extSystemCode string, hotelId string) ReservationAsyncAPIGetReservationsDailySummaryRequest {
	return ReservationAsyncAPIGetReservationsDailySummaryRequest{
		ApiService: a,
		ctx: ctx,
		summaryId: summaryId,
		extSystemCode: extSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ReservationsDailySummaryDetails
func (a *ReservationAsyncAPIService) GetReservationsDailySummaryExecute(r ReservationAsyncAPIGetReservationsDailySummaryRequest) (*ReservationsDailySummaryDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationsDailySummaryDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetReservationsDailySummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/reservations/dailySummary/{summaryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"summaryId"+"}", url.PathEscape(parameterValueToString(r.summaryId, "summaryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.summaryId) < 1 {
		return localVarReturnValue, nil, reportError("summaryId must have at least 1 elements")
	}
	if strlen(r.summaryId) > 2000 {
		return localVarReturnValue, nil, reportError("summaryId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return localVarReturnValue, nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return localVarReturnValue, nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationAsyncAPIGetReservationsProcessStatusRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	summaryId string
	extSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetReservationsProcessStatusRequest) Authorization(authorization string) ReservationAsyncAPIGetReservationsProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetReservationsProcessStatusRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetReservationsProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetReservationsProcessStatusRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetReservationsProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// Language code
func (r ReservationAsyncAPIGetReservationsProcessStatusRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetReservationsProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetReservationsProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetReservationsProcessStatusExecute(r)
}

/*
GetReservationsProcessStatus Check status of Reservation Daily Summary process

Use this to check whether the process to generate reservations daily summaries is complete. You can get value of summaryId from the Location header returned by the startReservationsDailySummaryProcess operation. <p><strong>OperationId:</strong>getReservationsProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param summaryId
 @param extSystemCode
 @param hotelId
 @return ReservationAsyncAPIGetReservationsProcessStatusRequest
*/
func (a *ReservationAsyncAPIService) GetReservationsProcessStatus(ctx context.Context, summaryId string, extSystemCode string, hotelId string) ReservationAsyncAPIGetReservationsProcessStatusRequest {
	return ReservationAsyncAPIGetReservationsProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		summaryId: summaryId,
		extSystemCode: extSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) GetReservationsProcessStatusExecute(r ReservationAsyncAPIGetReservationsProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetReservationsProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/reservations/dailySummary/{summaryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"summaryId"+"}", url.PathEscape(parameterValueToString(r.summaryId, "summaryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.summaryId) < 1 {
		return nil, reportError("summaryId must have at least 1 elements")
	}
	if strlen(r.summaryId) > 2000 {
		return nil, reportError("summaryId must have less than 2000 elements")
	}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	requestId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) Authorization(authorization string) ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) Execute() (*CreateRoomingListType, *http.Response, error) {
	return r.ApiService.GetRoomingListCreationProcessResultsExecute(r)
}

/*
GetRoomingListCreationProcessResults Get results of Rooming List Creation process

This API returns a summary of the status from rooming list creation process. You can get the value of requestId from the process API response (under header location). <p><strong>OperationId:</strong>getRoomingListCreationProcessResults</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId Unique ID for rooming list creation process
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest
*/
func (a *ReservationAsyncAPIService) GetRoomingListCreationProcessResults(ctx context.Context, requestId string, hotelId string) ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest {
	return ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CreateRoomingListType
func (a *ReservationAsyncAPIService) GetRoomingListCreationProcessResultsExecute(r ReservationAsyncAPIGetRoomingListCreationProcessResultsRequest) (*CreateRoomingListType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRoomingListType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetRoomingListCreationProcessResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roominglistcreation/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return localVarReturnValue, nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return localVarReturnValue, nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	requestId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) Authorization(authorization string) ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRoomingListCreationProcessStatusExecute(r)
}

/*
GetRoomingListCreationProcessStatus Check status of Rooming List creation process.

Use this to check whether the create rooming list process status is Processing, Invalid, Failed or Success. You can get the value of requestId from the process API response under header location. <p><strong>OperationId: </strong>getRoomingListCreationProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId Unique ID for rooming list creation process
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest
*/
func (a *ReservationAsyncAPIService) GetRoomingListCreationProcessStatus(ctx context.Context, requestId string, hotelId string) ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest {
	return ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) GetRoomingListCreationProcessStatusExecute(r ReservationAsyncAPIGetRoomingListCreationProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetRoomingListCreationProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roominglistcreation/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	requestId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) Authorization(authorization string) ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) Execute() (*ValidateRoomingListType, *http.Response, error) {
	return r.ApiService.GetRoomingListValidationProcessResultsExecute(r)
}

/*
GetRoomingListValidationProcessResults Get results of Rooming List validation process

This API returns a summary of the status from rooming list validation process. You can get the value of requestId from the process API response (under header location). <p><strong>OperationId:</strong>getRoomingListValidationProcessResults</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId Unique ID for rooming list validation process
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest
*/
func (a *ReservationAsyncAPIService) GetRoomingListValidationProcessResults(ctx context.Context, requestId string, hotelId string) ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest {
	return ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ValidateRoomingListType
func (a *ReservationAsyncAPIService) GetRoomingListValidationProcessResultsExecute(r ReservationAsyncAPIGetRoomingListValidationProcessResultsRequest) (*ValidateRoomingListType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateRoomingListType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetRoomingListValidationProcessResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roominglistvalidation/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return localVarReturnValue, nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return localVarReturnValue, nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	requestId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) Authorization(authorization string) ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) XAppKey(xAppKey string) ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) XHotelid(xHotelid string) ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRoomingListValidationProcessStatusExecute(r)
}

/*
GetRoomingListValidationProcessStatus Check status of Rooming List validation process.

Use this to check whether the validate rooming list process status is Processing, Invalid, Failed or Success. You can get the value of requestId from the process API response under header location. <p><strong>OperationId: </strong>getRoomingListValidationProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId Unique ID for rooming list validation process
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest
*/
func (a *ReservationAsyncAPIService) GetRoomingListValidationProcessStatus(ctx context.Context, requestId string, hotelId string) ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest {
	return ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) GetRoomingListValidationProcessStatusExecute(r ReservationAsyncAPIGetRoomingListValidationProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.GetRoomingListValidationProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roominglistvalidation/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.requestId) < 1 {
		return nil, reportError("requestId must have at least 1 elements")
	}
	if strlen(r.requestId) > 2000 {
		return nil, reportError("requestId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIHeadMassUpdateProcessStatusRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	massUpdateId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) Authorization(authorization string) ReservationAsyncAPIHeadMassUpdateProcessStatusRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) XAppKey(xAppKey string) ReservationAsyncAPIHeadMassUpdateProcessStatusRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) XHotelid(xHotelid string) ReservationAsyncAPIHeadMassUpdateProcessStatusRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIHeadMassUpdateProcessStatusRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIHeadMassUpdateProcessStatusRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadMassUpdateProcessStatusExecute(r)
}

/*
HeadMassUpdateProcessStatus Check status of Mass Update process.

Use this to check whether the mass update process has been completed. You can get the value of massUpdateId from the process API response (under header location). <p><strong>OperationId:</strong>headMassUpdateProcessStatus</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param massUpdateId Unique ID of mass update process
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIHeadMassUpdateProcessStatusRequest
*/
func (a *ReservationAsyncAPIService) HeadMassUpdateProcessStatus(ctx context.Context, massUpdateId string, hotelId string) ReservationAsyncAPIHeadMassUpdateProcessStatusRequest {
	return ReservationAsyncAPIHeadMassUpdateProcessStatusRequest{
		ApiService: a,
		ctx: ctx,
		massUpdateId: massUpdateId,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) HeadMassUpdateProcessStatusExecute(r ReservationAsyncAPIHeadMassUpdateProcessStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.HeadMassUpdateProcessStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/massUpdate/{massUpdateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"massUpdateId"+"}", url.PathEscape(parameterValueToString(r.massUpdateId, "massUpdateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.massUpdateId) < 1 {
		return nil, reportError("massUpdateId must have at least 1 elements")
	}
	if strlen(r.massUpdateId) > 2000 {
		return nil, reportError("massUpdateId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *HousekeepingMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of housekeeping options and schedule.
func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) Criteria(criteria HousekeepingMassUpdateCriteria) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartHousekeepingMassUpdateProcessExecute(r)
}

/*
StartHousekeepingMassUpdateProcess Updates reservation housekeeping options and/or schedules of a given list of reservations.

This API allows you to update reservation housekeeping options and/or schedules of a given list of reservations. A user is allowed to submit only one mass update reservations request per hotel at a time. <p><strong>OperationId:</strong>startHousekeepingMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartHousekeepingMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest {
	return ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartHousekeepingMassUpdateProcessExecute(r ReservationAsyncAPIStartHousekeepingMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartHousekeepingMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/housekeepingMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartNotesMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *NotesMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation notes.
func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) Criteria(criteria NotesMassUpdateCriteria) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartNotesMassUpdateProcessExecute(r)
}

/*
StartNotesMassUpdateProcess Updates reservation notes of a given list of reservations.

This API allows you to update reservation notes of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startNotesMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartNotesMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartNotesMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartNotesMassUpdateProcessRequest {
	return ReservationAsyncAPIStartNotesMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartNotesMassUpdateProcessExecute(r ReservationAsyncAPIStartNotesMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartNotesMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/notesMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *PaymentInstructionsMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation payment instructions.
func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) Criteria(criteria PaymentInstructionsMassUpdateCriteria) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartPaymentInstructionsMassUpdateProcessExecute(r)
}

/*
StartPaymentInstructionsMassUpdateProcess Updates reservation payment instructions of a given list of reservations.

This API allows you to update reservation payment instructions of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startPaymentInsructionsMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartPaymentInstructionsMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest {
	return ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartPaymentInstructionsMassUpdateProcessExecute(r ReservationAsyncAPIStartPaymentInstructionsMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartPaymentInstructionsMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/paymentInstructionsMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *PreferencesMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation preferences.
func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) Criteria(criteria PreferencesMassUpdateCriteria) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartPreferencesMassUpdateProcessExecute(r)
}

/*
StartPreferencesMassUpdateProcess Updates reservation preferences of a given list of reservations.

This API allows you to create reservation preferences of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startPreferencesMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartPreferencesMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest {
	return ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartPreferencesMassUpdateProcessExecute(r ReservationAsyncAPIStartPreferencesMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartPreferencesMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/preferencesMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *ReservationDetailsMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation details.
func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) Criteria(criteria ReservationDetailsMassUpdateCriteria) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartReservationDetailsMassUpdateProcessExecute(r)
}

/*
StartReservationDetailsMassUpdateProcess Updates reservation details of a given list of reservations.

This API allows you to update reservation details of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startReservationDetailsMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartReservationDetailsMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest {
	return ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartReservationDetailsMassUpdateProcessExecute(r ReservationAsyncAPIStartReservationDetailsMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartReservationDetailsMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/reservationDetailsMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartReservationsDailySummaryProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	extSystemCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *Criteria
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartReservationsDailySummaryProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartReservationsDailySummaryProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartReservationsDailySummaryProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for fetching future reservations asynchronously.
func (r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) Criteria(criteria Criteria) ReservationAsyncAPIStartReservationsDailySummaryProcessRequest {
	r.criteria = &criteria
	return r
}

// Language code
func (r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartReservationsDailySummaryProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartReservationsDailySummaryProcessExecute(r)
}

/*
StartReservationsDailySummaryProcess Fetch past, present and future Reservations Daily Summary

Use this API to get a reservation daily summary for a property within a given date range. Maximum limit of date range is 94 days, but the recommendation is to use a date range proportionate to the size of the hotel. Returns a header parameter Location that can be used in the getReservationsProcessStatus operation.  Use event driven APIs (see https://docs.oracle.com/cd/F29336_01/doc.201/f27480/c_business_events.htm#OHIPU-BusinessEvents-F0AC1F1C) to get real time reservation updates.  <p><strong>OperationId:</strong>startReservationsDailySummaryProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extSystemCode
 @param hotelId
 @return ReservationAsyncAPIStartReservationsDailySummaryProcessRequest
*/
func (a *ReservationAsyncAPIService) StartReservationsDailySummaryProcess(ctx context.Context, extSystemCode string, hotelId string) ReservationAsyncAPIStartReservationsDailySummaryProcessRequest {
	return ReservationAsyncAPIStartReservationsDailySummaryProcessRequest{
		ApiService: a,
		ctx: ctx,
		extSystemCode: extSystemCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartReservationsDailySummaryProcessExecute(r ReservationAsyncAPIStartReservationsDailySummaryProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartReservationsDailySummaryProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/externalSystems/{extSystemCode}/hotels/{hotelId}/reservations/dailySummary"
	localVarPath = strings.Replace(localVarPath, "{"+"extSystemCode"+"}", url.PathEscape(parameterValueToString(r.extSystemCode, "extSystemCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.extSystemCode) < 1 {
		return nil, reportError("extSystemCode must have at least 1 elements")
	}
	if strlen(r.extSystemCode) > 2000 {
		return nil, reportError("extSystemCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartRoomingListCreationProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomingList *RoomingList
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for create rooming list reservations.
func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) RoomingList(roomingList RoomingList) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	r.roomingList = &roomingList
	return r
}

// External system code.
func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartRoomingListCreationProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartRoomingListCreationProcessExecute(r)
}

/*
StartRoomingListCreationProcess Create Rooming List Reservations

Use this API to create Reservations Rooming List. <p><strong>OperationId:</strong>startRoomingListCreationProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @param blockId Block Id
 @return ReservationAsyncAPIStartRoomingListCreationProcessRequest
*/
func (a *ReservationAsyncAPIService) StartRoomingListCreationProcess(ctx context.Context, hotelId string, blockId string) ReservationAsyncAPIStartRoomingListCreationProcessRequest {
	return ReservationAsyncAPIStartRoomingListCreationProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		blockId: blockId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartRoomingListCreationProcessExecute(r ReservationAsyncAPIStartRoomingListCreationProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartRoomingListCreationProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/roominglistcreation"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomingList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartRoomingListValidationProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	blockId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomingList *RoomingList
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for validate rooming list reservations.
func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) RoomingList(roomingList RoomingList) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	r.roomingList = &roomingList
	return r
}

// External system code.
func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartRoomingListValidationProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartRoomingListValidationProcessExecute(r)
}

/*
StartRoomingListValidationProcess Validate Rooming List Reservations

Use this API to validate Reservations Rooming List. <p><strong>OperationId:</strong>startRoomingListValidationProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @param blockId Block Id
 @return ReservationAsyncAPIStartRoomingListValidationProcessRequest
*/
func (a *ReservationAsyncAPIService) StartRoomingListValidationProcess(ctx context.Context, hotelId string, blockId string) ReservationAsyncAPIStartRoomingListValidationProcessRequest {
	return ReservationAsyncAPIStartRoomingListValidationProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
		blockId: blockId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartRoomingListValidationProcessExecute(r ReservationAsyncAPIStartRoomingListValidationProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartRoomingListValidationProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/blocks/{blockId}/roominglistvalidation"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"blockId"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return nil, reportError("hotelId must have less than 2000 elements")
	}
	if strlen(r.blockId) < 1 {
		return nil, reportError("blockId must have at least 1 elements")
	}
	if strlen(r.blockId) > 2000 {
		return nil, reportError("blockId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomingList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *RoutingInstructionsMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation routing instructions.
func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) Criteria(criteria RoutingInstructionsMassUpdateCriteria) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartRoutingInstructionsMassUpdateProcessExecute(r)
}

/*
StartRoutingInstructionsMassUpdateProcess Updates reservation routing instructions of a given list of reservations.

This API allows you to update reservation routing instructions of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startRoutingInstructionsMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartRoutingInstructionsMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest {
	return ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartRoutingInstructionsMassUpdateProcessExecute(r ReservationAsyncAPIStartRoutingInstructionsMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartRoutingInstructionsMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/routingInstructionsMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartTracesMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *TracesMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation traces.
func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) Criteria(criteria TracesMassUpdateCriteria) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartTracesMassUpdateProcessExecute(r)
}

/*
StartTracesMassUpdateProcess Updates reservation traces of a given list of reservations.

This API allows you to update reservation traces of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startTracesMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartTracesMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartTracesMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartTracesMassUpdateProcessRequest {
	return ReservationAsyncAPIStartTracesMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartTracesMassUpdateProcessExecute(r ReservationAsyncAPIStartTracesMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartTracesMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/tracesMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest struct {
	ctx context.Context
	ApiService *ReservationAsyncAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	criteria *TransportationsMassUpdateCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) Authorization(authorization string) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) XAppKey(xAppKey string) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) XHotelid(xHotelid string) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for submitting mass update of reservation transportations.
func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) Criteria(criteria TransportationsMassUpdateCriteria) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	r.criteria = &criteria
	return r
}

// External system code.
func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) XExternalsystem(xExternalsystem string) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) AcceptLanguage(acceptLanguage string) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartTransportationsMassUpdateProcessExecute(r)
}

/*
StartTransportationsMassUpdateProcess Updates reservation transportations of a given list of reservations.

This API allows you to create reservation transportations of a given list of reservations. A user is allowed to submit only one mass update request per hotel at a time. <p><strong>OperationId:</strong>startTransportationsMassUpdateProcess</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of a Hotel
 @return ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest
*/
func (a *ReservationAsyncAPIService) StartTransportationsMassUpdateProcess(ctx context.Context, hotelId string) ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest {
	return ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
func (a *ReservationAsyncAPIService) StartTransportationsMassUpdateProcessExecute(r ReservationAsyncAPIStartTransportationsMassUpdateProcessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAsyncAPIService.StartTransportationsMassUpdateProcess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transportationsMassUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 20 {
		return nil, reportError("hotelId must have less than 20 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.criteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
