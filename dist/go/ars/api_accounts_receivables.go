/*
OPERA Cloud Accounts Receivables API

APIs to cater for Accounts Receivables functionality in OPERA Cloud. <br /><br The OPERA Cloud Accounts Receivable module enables you to manage debtors’ accounts, invoices, and remittance.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ars

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AccountsReceivablesApiService AccountsReceivablesApi service
type AccountsReceivablesApiService service

type AccountsReceivablesApiCopyARAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arAccountCopy *CopyARAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesApiCopyARAccountRequest) Authorization(authorization string) AccountsReceivablesApiCopyARAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r AccountsReceivablesApiCopyARAccountRequest) XAppKey(xAppKey string) AccountsReceivablesApiCopyARAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesApiCopyARAccountRequest) XHotelid(xHotelid string) AccountsReceivablesApiCopyARAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to copy AR Account
func (r AccountsReceivablesApiCopyARAccountRequest) ArAccountCopy(arAccountCopy CopyARAccountRequest) AccountsReceivablesApiCopyARAccountRequest {
	r.arAccountCopy = &arAccountCopy
	return r
}

// External system code.
func (r AccountsReceivablesApiCopyARAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesApiCopyARAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesApiCopyARAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesApiCopyARAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesApiCopyARAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyARAccountExecute(r)
}

/*
CopyARAccount Copy account receivable account 

Use this API to create account receivable to multiple hotels by copying from source hotel. <p><strong>OperationId:</strong>copyARAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesApiCopyARAccountRequest
*/
func (a *AccountsReceivablesApiService) CopyARAccount(ctx context.Context, accountId string, hotelId string) AccountsReceivablesApiCopyARAccountRequest {
	return AccountsReceivablesApiCopyARAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) CopyARAccountExecute(r AccountsReceivablesApiCopyARAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.CopyARAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/copyAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arAccountCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesApiGetARTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	accounts *string
	endDate *string
	startDate *string
	fromAmount *float32
	fromCurrencyCode *string
	toAmount *float32
	toCurrencyCode *string
	guestName *string
	invoices *[]float32
	folios *[]string
	fiscalBillNo *string
	accountName *string
	addresseName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property where the Accounts exist.
func (r AccountsReceivablesApiGetARTransactionsRequest) HotelIds(hotelIds []string) AccountsReceivablesApiGetARTransactionsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesApiGetARTransactionsRequest) Authorization(authorization string) AccountsReceivablesApiGetARTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r AccountsReceivablesApiGetARTransactionsRequest) XAppKey(xAppKey string) AccountsReceivablesApiGetARTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesApiGetARTransactionsRequest) XHotelid(xHotelid string) AccountsReceivablesApiGetARTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account number of this transaction.
func (r AccountsReceivablesApiGetARTransactionsRequest) Accounts(accounts string) AccountsReceivablesApiGetARTransactionsRequest {
	r.accounts = &accounts
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesApiGetARTransactionsRequest) EndDate(endDate string) AccountsReceivablesApiGetARTransactionsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesApiGetARTransactionsRequest) StartDate(startDate string) AccountsReceivablesApiGetARTransactionsRequest {
	r.startDate = &startDate
	return r
}

// A monetary amount.
func (r AccountsReceivablesApiGetARTransactionsRequest) FromAmount(fromAmount float32) AccountsReceivablesApiGetARTransactionsRequest {
	r.fromAmount = &fromAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesApiGetARTransactionsRequest) FromCurrencyCode(fromCurrencyCode string) AccountsReceivablesApiGetARTransactionsRequest {
	r.fromCurrencyCode = &fromCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesApiGetARTransactionsRequest) ToAmount(toAmount float32) AccountsReceivablesApiGetARTransactionsRequest {
	r.toAmount = &toAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesApiGetARTransactionsRequest) ToCurrencyCode(toCurrencyCode string) AccountsReceivablesApiGetARTransactionsRequest {
	r.toCurrencyCode = &toCurrencyCode
	return r
}

// Display Name for the guest.
func (r AccountsReceivablesApiGetARTransactionsRequest) GuestName(guestName string) AccountsReceivablesApiGetARTransactionsRequest {
	r.guestName = &guestName
	return r
}

// invoice Number .
func (r AccountsReceivablesApiGetARTransactionsRequest) Invoices(invoices []float32) AccountsReceivablesApiGetARTransactionsRequest {
	r.invoices = &invoices
	return r
}

// folio Number .
func (r AccountsReceivablesApiGetARTransactionsRequest) Folios(folios []string) AccountsReceivablesApiGetARTransactionsRequest {
	r.folios = &folios
	return r
}

// Fiscal bill number of this transaction.
func (r AccountsReceivablesApiGetARTransactionsRequest) FiscalBillNo(fiscalBillNo string) AccountsReceivablesApiGetARTransactionsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Account number of this transaction.
func (r AccountsReceivablesApiGetARTransactionsRequest) AccountName(accountName string) AccountsReceivablesApiGetARTransactionsRequest {
	r.accountName = &accountName
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r AccountsReceivablesApiGetARTransactionsRequest) AddresseName(addresseName string) AccountsReceivablesApiGetARTransactionsRequest {
	r.addresseName = &addresseName
	return r
}

// External system code.
func (r AccountsReceivablesApiGetARTransactionsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesApiGetARTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesApiGetARTransactionsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesApiGetARTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesApiGetARTransactionsRequest) Execute() (*ArTransactions, *http.Response, error) {
	return r.ApiService.GetARTransactionsExecute(r)
}

/*
GetARTransactions Get AR transactions.

Use this API to get list of transaction data for a given account receivable account number and list of hotels <p><strong>OperationId:</strong>getARTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesApiGetARTransactionsRequest
*/
func (a *AccountsReceivablesApiService) GetARTransactions(ctx context.Context) AccountsReceivablesApiGetARTransactionsRequest {
	return AccountsReceivablesApiGetARTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArTransactions
func (a *AccountsReceivablesApiService) GetARTransactionsExecute(r AccountsReceivablesApiGetARTransactionsRequest) (*ArTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetARTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/arTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.accounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", r.accounts, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.fromAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAmount", r.fromAmount, "")
	}
	if r.fromCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromCurrencyCode", r.fromCurrencyCode, "")
	}
	if r.toAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toAmount", r.toAmount, "")
	}
	if r.toCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toCurrencyCode", r.toCurrencyCode, "")
	}
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
	}
	if r.invoices != nil {
		t := *r.invoices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", t, "multi")
		}
	}
	if r.folios != nil {
		t := *r.folios
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folios", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folios", t, "multi")
		}
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.addresseName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseName", r.addresseName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesApiGetAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	balance *string
	batchStatement *bool
	limit *int32
	offset *int32
	hotelIds *[]string
	profileId *string
	profileIdContext *string
	profileType *string
	type_ *string
	accountNo *[]string
	accountName *string
	accountId *[]string
	accountIdContext *[]string
	accountType *[]string
	includeStatementHistoryIndicator *bool
	includeReminderHistoryIndicator *bool
	superSearch *string
	searchHotelIds *[]string
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesApiGetAccountsRequest) Authorization(authorization string) AccountsReceivablesApiGetAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r AccountsReceivablesApiGetAccountsRequest) XAppKey(xAppKey string) AccountsReceivablesApiGetAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesApiGetAccountsRequest) XHotelid(xHotelid string) AccountsReceivablesApiGetAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Search By Balance. Search will be done for &#39;All&#39;, &#39;Open Balance&#39; or &#39;Zero Balance&#39; Accounts.
func (r AccountsReceivablesApiGetAccountsRequest) Balance(balance string) AccountsReceivablesApiGetAccountsRequest {
	r.balance = &balance
	return r
}

// Search criteria for batch processing
func (r AccountsReceivablesApiGetAccountsRequest) BatchStatement(batchStatement bool) AccountsReceivablesApiGetAccountsRequest {
	r.batchStatement = &batchStatement
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AccountsReceivablesApiGetAccountsRequest) Limit(limit int32) AccountsReceivablesApiGetAccountsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r AccountsReceivablesApiGetAccountsRequest) Offset(offset int32) AccountsReceivablesApiGetAccountsRequest {
	r.offset = &offset
	return r
}

// Property where the Accounts exist.
func (r AccountsReceivablesApiGetAccountsRequest) HotelIds(hotelIds []string) AccountsReceivablesApiGetAccountsRequest {
	r.hotelIds = &hotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesApiGetAccountsRequest) ProfileId(profileId string) AccountsReceivablesApiGetAccountsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesApiGetAccountsRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesApiGetAccountsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesApiGetAccountsRequest) ProfileType(profileType string) AccountsReceivablesApiGetAccountsRequest {
	r.profileType = &profileType
	return r
}

// Search by Account Type.
func (r AccountsReceivablesApiGetAccountsRequest) Type_(type_ string) AccountsReceivablesApiGetAccountsRequest {
	r.type_ = &type_
	return r
}

// Account Number .
func (r AccountsReceivablesApiGetAccountsRequest) AccountNo(accountNo []string) AccountsReceivablesApiGetAccountsRequest {
	r.accountNo = &accountNo
	return r
}

// Wild Card Search by Account Name. Search will be done for any Accounts whose name starts with this value.
func (r AccountsReceivablesApiGetAccountsRequest) AccountName(accountName string) AccountsReceivablesApiGetAccountsRequest {
	r.accountName = &accountName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesApiGetAccountsRequest) AccountId(accountId []string) AccountsReceivablesApiGetAccountsRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesApiGetAccountsRequest) AccountIdContext(accountIdContext []string) AccountsReceivablesApiGetAccountsRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesApiGetAccountsRequest) AccountType(accountType []string) AccountsReceivablesApiGetAccountsRequest {
	r.accountType = &accountType
	return r
}

// Return statement history indicator in result. This flag included for performance reason to populate history flag only for Statements Mode.
func (r AccountsReceivablesApiGetAccountsRequest) IncludeStatementHistoryIndicator(includeStatementHistoryIndicator bool) AccountsReceivablesApiGetAccountsRequest {
	r.includeStatementHistoryIndicator = &includeStatementHistoryIndicator
	return r
}

// Return reminder history indicator in result. This flag included for performance reason to populate history flag only for Statements Mode.
func (r AccountsReceivablesApiGetAccountsRequest) IncludeReminderHistoryIndicator(includeReminderHistoryIndicator bool) AccountsReceivablesApiGetAccountsRequest {
	r.includeReminderHistoryIndicator = &includeReminderHistoryIndicator
	return r
}

// Free form text field for searching all reservation fields
func (r AccountsReceivablesApiGetAccountsRequest) SuperSearch(superSearch string) AccountsReceivablesApiGetAccountsRequest {
	r.superSearch = &superSearch
	return r
}

// Hotel code.
func (r AccountsReceivablesApiGetAccountsRequest) SearchHotelIds(searchHotelIds []string) AccountsReceivablesApiGetAccountsRequest {
	r.searchHotelIds = &searchHotelIds
	return r
}

func (r AccountsReceivablesApiGetAccountsRequest) AttributeName(attributeName []string) AccountsReceivablesApiGetAccountsRequest {
	r.attributeName = &attributeName
	return r
}

func (r AccountsReceivablesApiGetAccountsRequest) OrderType(orderType []string) AccountsReceivablesApiGetAccountsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r AccountsReceivablesApiGetAccountsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesApiGetAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesApiGetAccountsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesApiGetAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesApiGetAccountsRequest) Execute() (*AccountsInfo, *http.Response, error) {
	return r.ApiService.GetAccountsExecute(r)
}

/*
GetAccounts Get given profile's account receivable detail

Use this API to search for AR Accounts for a given OPERA Profile id. API returns contain a list of AR Accounts and their AR information. <p><strong>OperationId:</strong>getAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesApiGetAccountsRequest
*/
func (a *AccountsReceivablesApiService) GetAccounts(ctx context.Context) AccountsReceivablesApiGetAccountsRequest {
	return AccountsReceivablesApiGetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountsInfo
func (a *AccountsReceivablesApiService) GetAccountsExecute(r AccountsReceivablesApiGetAccountsRequest) (*AccountsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
	}
	if r.batchStatement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchStatement", r.batchStatement, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
	}
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
	}
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	if r.accountId != nil {
		t := *r.accountId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", t, "multi")
		}
	}
	if r.accountIdContext != nil {
		t := *r.accountIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", t, "multi")
		}
	}
	if r.accountType != nil {
		t := *r.accountType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", t, "multi")
		}
	}
	if r.includeStatementHistoryIndicator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStatementHistoryIndicator", r.includeStatementHistoryIndicator, "")
	}
	if r.includeReminderHistoryIndicator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReminderHistoryIndicator", r.includeReminderHistoryIndicator, "")
	}
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
	}
	if r.searchHotelIds != nil {
		t := *r.searchHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchHotelIds", t, "multi")
		}
	}
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
	}
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesApiGetInvoicesPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inclDetails *bool
	inclZeroBalance *bool
	limit *int32
	offset *int32
	hotelIds *[]string
	end *string
	start *string
	guestDisplayName *string
	remark *string
	reference *string
	invoiceNo *[]float32
	addresseeName *string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	printed *bool
	unBilled *bool
	folioNo *[]string
	fiscalBillNo *string
	statementNo *float32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Authorization(authorization string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if Invoice Details are required.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) InclDetails(inclDetails bool) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.inclDetails = &inclDetails
	return r
}

// Flag to indicate if Zero Balance Invoices are to be included.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) InclZeroBalance(inclZeroBalance bool) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.inclZeroBalance = &inclZeroBalance
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Limit(limit int32) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Offset(offset int32) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.offset = &offset
	return r
}

// Property where the Accounts exist.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) HotelIds(hotelIds []string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.hotelIds = &hotelIds
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) End(end string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Start(start string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.start = &start
	return r
}

// Display Name for the guest.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) GuestDisplayName(guestDisplayName string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.guestDisplayName = &guestDisplayName
	return r
}

// Filter for User-defined Invoice Supplement. The search is case-insensitive and supports % as wildcard character with right-side wildcard search by default. Examples: ABC or ABC% finds records that start with ABC, such as ABC, ABCDEF, and ABC123. %ABC or %ABC% finds records that contain ABC, such as ABC, ABC123, MYABC, and MYABC123.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Remark(remark string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.remark = &remark
	return r
}

// Filter for User-defined Invoice Reference. The search is case-insensitive and supports % as wildcard character with right-side wildcard search by default. Examples: ABC or ABC% finds records that start with ABC, such as ABC, ABCDEF, and ABC123. %ABC or %ABC% finds records that contain ABC, such as ABC, ABC123, MYABC, and MYABC123.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Reference(reference string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.reference = &reference
	return r
}

// invoice Number .
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) InvoiceNo(invoiceNo []float32) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) AddresseeName(addresseeName string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.addresseeName = &addresseeName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) ReservationId(reservationId string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) ReservationIdContext(reservationIdContext string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) ReservationType(reservationType string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.reservationType = &reservationType
	return r
}

// Flag to check Invoice Statement is Printed.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Printed(printed bool) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.printed = &printed
	return r
}

// Flag to check Invoice is billed
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) UnBilled(unBilled bool) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.unBilled = &unBilled
	return r
}

// folio Number .
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) FolioNo(folioNo []string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.folioNo = &folioNo
	return r
}

// Fiscal bill number of this transaction.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) FiscalBillNo(fiscalBillNo string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// The Statement number of this invoice.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) StatementNo(statementNo float32) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.statementNo = &statementNo
	return r
}

// Type of AR Invoice information to fetch the invoices or payments data.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) FetchInstructions(fetchInstructions []string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesApiGetInvoicesPaymentsRequest) Execute() (*InvoicesPayments, *http.Response, error) {
	return r.ApiService.GetInvoicesPaymentsExecute(r)
}

/*
GetInvoicesPayments Get payment detail for account's invoices

Use this API to get payment data for account receivable invoices. <p><strong>OperationId:</strong>getInvoicesPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return AccountsReceivablesApiGetInvoicesPaymentsRequest
*/
func (a *AccountsReceivablesApiService) GetInvoicesPayments(ctx context.Context, accountId string) AccountsReceivablesApiGetInvoicesPaymentsRequest {
	return AccountsReceivablesApiGetInvoicesPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return InvoicesPayments
func (a *AccountsReceivablesApiService) GetInvoicesPaymentsExecute(r AccountsReceivablesApiGetInvoicesPaymentsRequest) (*InvoicesPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicesPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.GetInvoicesPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicePayments/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}

	if r.inclDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclDetails", r.inclDetails, "")
	}
	if r.inclZeroBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZeroBalance", r.inclZeroBalance, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.guestDisplayName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestDisplayName", r.guestDisplayName, "")
	}
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
	}
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
	}
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
	}
	if r.addresseeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeName", r.addresseeName, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
	}
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
	}
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
	}
	if r.printed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printed", r.printed, "")
	}
	if r.unBilled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unBilled", r.unBilled, "")
	}
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
	}
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
	}
	if r.statementNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", r.statementNo, "")
	}
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesApiPostAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountCriteria *PostAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesApiPostAccountRequest) Authorization(authorization string) AccountsReceivablesApiPostAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r AccountsReceivablesApiPostAccountRequest) XAppKey(xAppKey string) AccountsReceivablesApiPostAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesApiPostAccountRequest) XHotelid(xHotelid string) AccountsReceivablesApiPostAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new AR Account
func (r AccountsReceivablesApiPostAccountRequest) AccountCriteria(accountCriteria PostAccountRequest) AccountsReceivablesApiPostAccountRequest {
	r.accountCriteria = &accountCriteria
	return r
}

// External system code.
func (r AccountsReceivablesApiPostAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesApiPostAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesApiPostAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesApiPostAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesApiPostAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountExecute(r)
}

/*
PostAccount Create an account receivable account

Use this API to create a new account receivable type account for given OPERA profile id. Prior creating account, need to use getProfile to find OPERA profile's id.  <p><strong>OperationId:</strong>postAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesApiPostAccountRequest
*/
func (a *AccountsReceivablesApiService) PostAccount(ctx context.Context, hotelId string) AccountsReceivablesApiPostAccountRequest {
	return AccountsReceivablesApiPostAccountRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PostAccountExecute(r AccountsReceivablesApiPostAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PostAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesApiPutAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesApiService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	account *PutAccountRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesApiPutAccountRequest) Authorization(authorization string) AccountsReceivablesApiPutAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r AccountsReceivablesApiPutAccountRequest) XAppKey(xAppKey string) AccountsReceivablesApiPutAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesApiPutAccountRequest) XHotelid(xHotelid string) AccountsReceivablesApiPutAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change and existing AR Account. The Account No, Credit Limit, Address, Email, Telephone information, Permanent Flag, Primary Account Flag, Contact Name are the details that can be changed on an existing account.
func (r AccountsReceivablesApiPutAccountRequest) Account(account PutAccountRequest) AccountsReceivablesApiPutAccountRequest {
	r.account = &account
	return r
}

// External system code.
func (r AccountsReceivablesApiPutAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesApiPutAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesApiPutAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesApiPutAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesApiPutAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountExecute(r)
}

/*
PutAccount Update a account receivable account

Use this API to update existing account using account id and further detail. Use get account to get account detail prior updating. <p><strong>OperationId:</strong>putAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesApiPutAccountRequest
*/
func (a *AccountsReceivablesApiService) PutAccount(ctx context.Context, accountId string, hotelId string) AccountsReceivablesApiPutAccountRequest {
	return AccountsReceivablesApiPutAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesApiService) PutAccountExecute(r AccountsReceivablesApiPutAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesApiService.PutAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.account
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
