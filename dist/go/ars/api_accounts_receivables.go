/*
OPERA Cloud Accounts Receivables API

APIs to cater for Accounts Receivables functionality in OPERA Cloud. <br /><br The OPERA Cloud Accounts Receivable module enables you to manage debtors' accounts, invoices, and remittance.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ars

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AccountsReceivablesAPIService AccountsReceivablesAPI service
type AccountsReceivablesAPIService service

type AccountsReceivablesAPICompressARInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arCompressInvoices *ArCompressInvoices
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPICompressARInvoicesRequest) Authorization(authorization string) AccountsReceivablesAPICompressARInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPICompressARInvoicesRequest) XAppKey(xAppKey string) AccountsReceivablesAPICompressARInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPICompressARInvoicesRequest) XHotelid(xHotelid string) AccountsReceivablesAPICompressARInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to compress two or more invoices for an Account
func (r AccountsReceivablesAPICompressARInvoicesRequest) ArCompressInvoices(arCompressInvoices ArCompressInvoices) AccountsReceivablesAPICompressARInvoicesRequest {
	r.arCompressInvoices = &arCompressInvoices
	return r
}

// External system code.
func (r AccountsReceivablesAPICompressARInvoicesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPICompressARInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPICompressARInvoicesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPICompressARInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPICompressARInvoicesRequest) Execute() (*CompressedARInvoices, *http.Response, error) {
	return r.ApiService.CompressARInvoicesExecute(r)
}

/*
CompressARInvoices Combines Account receivable invoices

Use this API to combine two or more invoices into one invoice <p><strong>OperationId:</strong>compressARInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPICompressARInvoicesRequest
*/
func (a *AccountsReceivablesAPIService) CompressARInvoices(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPICompressARInvoicesRequest {
	return AccountsReceivablesAPICompressARInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return CompressedARInvoices
func (a *AccountsReceivablesAPIService) CompressARInvoicesExecute(r AccountsReceivablesAPICompressARInvoicesRequest) (*CompressedARInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompressedARInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.CompressARInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/compressInvoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arCompressInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPICopyARAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arAccountCopy *ArAccountCopy
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPICopyARAccountRequest) Authorization(authorization string) AccountsReceivablesAPICopyARAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPICopyARAccountRequest) XAppKey(xAppKey string) AccountsReceivablesAPICopyARAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPICopyARAccountRequest) XHotelid(xHotelid string) AccountsReceivablesAPICopyARAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to copy AR Account
func (r AccountsReceivablesAPICopyARAccountRequest) ArAccountCopy(arAccountCopy ArAccountCopy) AccountsReceivablesAPICopyARAccountRequest {
	r.arAccountCopy = &arAccountCopy
	return r
}

// External system code.
func (r AccountsReceivablesAPICopyARAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPICopyARAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPICopyARAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPICopyARAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPICopyARAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyARAccountExecute(r)
}

/*
CopyARAccount Copy account receivable account 

Use this API to create account receivable to multiple hotels by copying from source hotel. <p><strong>OperationId:</strong>copyARAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPICopyARAccountRequest
*/
func (a *AccountsReceivablesAPIService) CopyARAccount(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPICopyARAccountRequest {
	return AccountsReceivablesAPICopyARAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) CopyARAccountExecute(r AccountsReceivablesAPICopyARAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.CopyARAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/copyAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arAccountCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIDeleteAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIDeleteAccountRequest) Authorization(authorization string) AccountsReceivablesAPIDeleteAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIDeleteAccountRequest) XAppKey(xAppKey string) AccountsReceivablesAPIDeleteAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIDeleteAccountRequest) XHotelid(xHotelid string) AccountsReceivablesAPIDeleteAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r AccountsReceivablesAPIDeleteAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIDeleteAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIDeleteAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIDeleteAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIDeleteAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Delete Account 

Use this API to delete account detail for given unique account id. Use get accounts to find account id. <p><strong>OperationId:</strong>deleteAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIDeleteAccountRequest
*/
func (a *AccountsReceivablesAPIService) DeleteAccount(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIDeleteAccountRequest {
	return AccountsReceivablesAPIDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) DeleteAccountExecute(r AccountsReceivablesAPIDeleteAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIDeleteAccountCommentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	id *string
	value *string
	hotel *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) Authorization(authorization string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) XAppKey(xAppKey string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) XHotelid(xHotelid string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) Id(id string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.id = &id
	return r
}

// Property Value
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) Value(value string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.value = &value
	return r
}

// If specified comment belongs to the Hotel, otherwise it is a global comment.
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) Hotel(hotel string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.hotel = &hotel
	return r
}

// External system code.
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIDeleteAccountCommentRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIDeleteAccountCommentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountCommentExecute(r)
}

/*
DeleteAccountComment Delete Account Comment

Use this API to delete notes from a given account id. Use get account with an instruction to get note id. <p><strong>OperationId:</strong>deleteAccountComment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIDeleteAccountCommentRequest
*/
func (a *AccountsReceivablesAPIService) DeleteAccountComment(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIDeleteAccountCommentRequest {
	return AccountsReceivablesAPIDeleteAccountCommentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) DeleteAccountCommentExecute(r AccountsReceivablesAPIDeleteAccountCommentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.DeleteAccountComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "")
  }
	if r.hotel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotel", r.hotel, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIDeleteAccountFixedChargeRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	fixedChargeId string
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) Authorization(authorization string) AccountsReceivablesAPIDeleteAccountFixedChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) XAppKey(xAppKey string) AccountsReceivablesAPIDeleteAccountFixedChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) XHotelid(xHotelid string) AccountsReceivablesAPIDeleteAccountFixedChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIDeleteAccountFixedChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIDeleteAccountFixedChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountFixedChargeExecute(r)
}

/*
DeleteAccountFixedCharge Delete fixed charges 

Use this API to delete fixed charges for a given account receivable id. Use getaccounts to find an account id. <p><strong>OperationId:</strong>deleteAccountFixedCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fixedChargeId ID of the fixed charge
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIDeleteAccountFixedChargeRequest
*/
func (a *AccountsReceivablesAPIService) DeleteAccountFixedCharge(ctx context.Context, fixedChargeId string, accountId string, hotelId string) AccountsReceivablesAPIDeleteAccountFixedChargeRequest {
	return AccountsReceivablesAPIDeleteAccountFixedChargeRequest{
		ApiService: a,
		ctx: ctx,
		fixedChargeId: fixedChargeId,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) DeleteAccountFixedChargeExecute(r AccountsReceivablesAPIDeleteAccountFixedChargeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.DeleteAccountFixedCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/fixedCharges/{fixedChargeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fixedChargeId"+"}", url.PathEscape(parameterValueToString(r.fixedChargeId, "fixedChargeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fixedChargeId) < 1 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have at least 1 elements")
	}
	if strlen(r.fixedChargeId) > 2000 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIDeleteAccountTraceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	traceID *string
	traceOn *string
	traceText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) Authorization(authorization string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) TraceID(traceID string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.traceID = &traceID
	return r
}

// Date of the trace.
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) TraceOn(traceOn string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.traceOn = &traceOn
	return r
}

// The information this trace contains.
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) TraceText(traceText string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.traceText = &traceText
	return r
}

// External system code.
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIDeleteAccountTraceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIDeleteAccountTraceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeleteAccountTraceExecute(r)
}

/*
DeleteAccountTrace This API facilitates deletion of account traces.

 <p><strong>OperationId:</strong>deleteAccountTrace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIDeleteAccountTraceRequest
*/
func (a *AccountsReceivablesAPIService) DeleteAccountTrace(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIDeleteAccountTraceRequest {
	return AccountsReceivablesAPIDeleteAccountTraceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) DeleteAccountTraceExecute(r AccountsReceivablesAPIDeleteAccountTraceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.DeleteAccountTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.traceID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "traceID", r.traceID, "")
  }
	if r.traceOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "traceOn", r.traceOn, "")
  }
	if r.traceText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "traceText", r.traceText, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	transactionId string
	invoiceId string
	hotelId string
	trxNo *[]float32
	accountId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierID *float32
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Unique Transaction Identifier of the Payment.
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) TrxNo(trxNo []float32) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.trxNo = &trxNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) AccountId(accountId string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.accountId = &accountId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) Authorization(authorization string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) CashierID(cashierID float32) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.cashierID = &cashierID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) InvoiceNo(invoiceNo float32) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeletePaymentsFromInvoiceExecute(r)
}

/*
DeletePaymentsFromInvoice Delete payments from invoice

Delete payments from invoice.<br><p><strong><mark>This API is deprecated. Please use removePaymentsFromInvoice instead</mark></strong></p> <p><strong>OperationId:</strong>deletePaymentsFromInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param invoiceId Unique ID of the invoice
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest

Deprecated
*/
func (a *AccountsReceivablesAPIService) DeletePaymentsFromInvoice(ctx context.Context, transactionId string, invoiceId string, hotelId string) AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest {
	return AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		invoiceId: invoiceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *AccountsReceivablesAPIService) DeletePaymentsFromInvoiceExecute(r AccountsReceivablesAPIDeletePaymentsFromInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.DeletePaymentsFromInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices/{invoiceId}/transactions/{transactionId}/paymentsFromInvoice"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.invoiceId) < 1 {
		return localVarReturnValue, nil, reportError("invoiceId must have at least 1 elements")
	}
	if strlen(r.invoiceId) > 2000 {
		return localVarReturnValue, nil, reportError("invoiceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.trxNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	if r.cashierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierID", r.cashierID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetARAgingCyclesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetARAgingCyclesRequest) Authorization(authorization string) AccountsReceivablesAPIGetARAgingCyclesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetARAgingCyclesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetARAgingCyclesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetARAgingCyclesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetARAgingCyclesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetARAgingCyclesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetARAgingCyclesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetARAgingCyclesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetARAgingCyclesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetARAgingCyclesRequest) Execute() (*ArAgingCycles, *http.Response, error) {
	return r.ApiService.GetARAgingCyclesExecute(r)
}

/*
GetARAgingCycles Get given AR account's aging detail

Use this API to get account receivable profile's aging summary including account name, summary, credit limit, total outstanding balance, etc. per aging bucket. <p><strong>OperationId:</strong>getARAgingCycles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetARAgingCyclesRequest
*/
func (a *AccountsReceivablesAPIService) GetARAgingCycles(ctx context.Context, hotelId string) AccountsReceivablesAPIGetARAgingCyclesRequest {
	return AccountsReceivablesAPIGetARAgingCyclesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArAgingCycles
func (a *AccountsReceivablesAPIService) GetARAgingCyclesExecute(r AccountsReceivablesAPIGetARAgingCyclesRequest) (*ArAgingCycles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArAgingCycles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetARAgingCycles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/agingCycles"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetARCreditCardPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	endDate *string
	startDate *string
	limit *int32
	offset *int32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) Authorization(authorization string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) EndDate(endDate string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) StartDate(startDate string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.startDate = &startDate
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) Limit(limit int32) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) Offset(offset int32) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.offset = &offset
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) Execute() (*ArCreditCardPayments, *http.Response, error) {
	return r.ApiService.GetARCreditCardPaymentsExecute(r)
}

/*
GetARCreditCardPayments Get account receivable folios which are paid using credit cards

Use this API to get lists of folios for guests who checked out using a credit card payment transaction code that has an account receivable associated with it. It also lists payments made prior to check out if the payment was made using a credit card transaction code that has a an account receivable associated with it. <p><strong>OperationId:</strong>getARCreditCardPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetARCreditCardPaymentsRequest
*/
func (a *AccountsReceivablesAPIService) GetARCreditCardPayments(ctx context.Context, transactionId string, hotelId string) AccountsReceivablesAPIGetARCreditCardPaymentsRequest {
	return AccountsReceivablesAPIGetARCreditCardPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArCreditCardPayments
func (a *AccountsReceivablesAPIService) GetARCreditCardPaymentsExecute(r AccountsReceivablesAPIGetARCreditCardPaymentsRequest) (*ArCreditCardPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArCreditCardPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetARCreditCardPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/creditcard/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetARFolioPrintersRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	balance *float32
	overrideCreditHoldCheck *bool
	cashierId *float32
	profileId *string
	accountNo *string
	accountName *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	folioWindowNo *[]int32
	chargeCashierId *[]float32
	chargeTransactionCode *[]string
	articleCode *[]string
	amount *float32
	currencyCode *string
	postingQuantity *[]int32
	postingReference *[]string
	postingRemark *[]string
	checkNumber *[]string
	arrangementCode *[]string
	applyRoutingInstructions *[]bool
	usePackageAllowance *[]bool
	autoPosting *[]bool
	financialTransactionId *[]string
	financialTransactionIdContext *[]string
	financialTransactionType *[]string
	reference *string
	remark *string
	folioType *string
	generateFiscalFolio *bool
	queueName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) Authorization(authorization string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r AccountsReceivablesAPIGetARFolioPrintersRequest) Balance(balance float32) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.balance = &balance
	return r
}

func (r AccountsReceivablesAPIGetARFolioPrintersRequest) OverrideCreditHoldCheck(overrideCreditHoldCheck bool) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.overrideCreditHoldCheck = &overrideCreditHoldCheck
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) CashierId(cashierId float32) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.cashierId = &cashierId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) ProfileId(profileId string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.profileId = &profileId
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) AccountName(accountName string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.accountName = &accountName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) GuestProfileId(guestProfileId string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) GuestProfileIdContext(guestProfileIdContext string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) GuestProfileType(guestProfileType string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.guestProfileType = &guestProfileType
	return r
}

func (r AccountsReceivablesAPIGetARFolioPrintersRequest) FolioWindowNo(folioWindowNo []int32) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.folioWindowNo = &folioWindowNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) ChargeCashierId(chargeCashierId []float32) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.chargeCashierId = &chargeCashierId
	return r
}

// Transaction Code to post.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) ChargeTransactionCode(chargeTransactionCode []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.chargeTransactionCode = &chargeTransactionCode
	return r
}

// Article ID.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) ArticleCode(articleCode []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.articleCode = &articleCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) Amount(amount float32) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) CurrencyCode(currencyCode string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.currencyCode = &currencyCode
	return r
}

// Quantity to post to the folio.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) PostingQuantity(postingQuantity []int32) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.postingQuantity = &postingQuantity
	return r
}

// User-defined posting reference.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) PostingReference(postingReference []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.postingReference = &postingReference
	return r
}

// User-defined posting remark.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) PostingRemark(postingRemark []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.postingRemark = &postingRemark
	return r
}

// Indicates the Cheque number.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) CheckNumber(checkNumber []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.checkNumber = &checkNumber
	return r
}

// Corrected arrangement code from the package associated to this transaction.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) ArrangementCode(arrangementCode []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.arrangementCode = &arrangementCode
	return r
}

// Apply room routing when making this posting.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) ApplyRoutingInstructions(applyRoutingInstructions []bool) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.applyRoutingInstructions = &applyRoutingInstructions
	return r
}

// Use the applicable package allowance when making this posting.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) UsePackageAllowance(usePackageAllowance []bool) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.usePackageAllowance = &usePackageAllowance
	return r
}

// True indicates the Transaction Code is allowed to be posted automatically.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) AutoPosting(autoPosting []bool) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.autoPosting = &autoPosting
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) FinancialTransactionId(financialTransactionId []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.financialTransactionId = &financialTransactionId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) FinancialTransactionIdContext(financialTransactionIdContext []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.financialTransactionIdContext = &financialTransactionIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) FinancialTransactionType(financialTransactionType []string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.financialTransactionType = &financialTransactionType
	return r
}

// User-defined invoice reference.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) Reference(reference string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.reference = &reference
	return r
}

// User-defined invoice remark.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) Remark(remark string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.remark = &remark
	return r
}

// Folio Type to be assigned to generated folio. This is a country requirement.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) FolioType(folioType string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.folioType = &folioType
	return r
}

// Fiscal folio flag to call fiscal folio web service after folio generation.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) GenerateFiscalFolio(generateFiscalFolio bool) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.generateFiscalFolio = &generateFiscalFolio
	return r
}

// Folio Queue name.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) QueueName(queueName string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.queueName = &queueName
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetARFolioPrintersRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetARFolioPrintersRequest) Execute() (*ArFolioPrinters, *http.Response, error) {
	return r.ApiService.GetARFolioPrintersExecute(r)
}

/*
GetARFolioPrinters Get list of account receivable folio printers

Use this API to find account receivable folio printers <p><strong>OperationId:</strong>getARFolioPrinters</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetARFolioPrintersRequest
*/
func (a *AccountsReceivablesAPIService) GetARFolioPrinters(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIGetARFolioPrintersRequest {
	return AccountsReceivablesAPIGetARFolioPrintersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArFolioPrinters
func (a *AccountsReceivablesAPIService) GetARFolioPrintersExecute(r AccountsReceivablesAPIGetARFolioPrintersRequest) (*ArFolioPrinters, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArFolioPrinters
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetARFolioPrinters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/folioPrinters"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
  }
	if r.overrideCreditHoldCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overrideCreditHoldCheck", r.overrideCreditHoldCheck, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
  }
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
  }
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
  }
	if r.folioWindowNo != nil {
		t := *r.folioWindowNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioWindowNo", t, "multi")
		}
  }
	if r.chargeCashierId != nil {
		t := *r.chargeCashierId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chargeCashierId", t, "multi")
		}
  }
	if r.chargeTransactionCode != nil {
		t := *r.chargeTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chargeTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chargeTransactionCode", t, "multi")
		}
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.postingQuantity != nil {
		t := *r.postingQuantity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingQuantity", t, "multi")
		}
  }
	if r.postingReference != nil {
		t := *r.postingReference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingReference", t, "multi")
		}
  }
	if r.postingRemark != nil {
		t := *r.postingRemark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingRemark", t, "multi")
		}
  }
	if r.checkNumber != nil {
		t := *r.checkNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumber", t, "multi")
		}
  }
	if r.arrangementCode != nil {
		t := *r.arrangementCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "arrangementCode", t, "multi")
		}
  }
	if r.applyRoutingInstructions != nil {
		t := *r.applyRoutingInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "applyRoutingInstructions", t, "multi")
		}
  }
	if r.usePackageAllowance != nil {
		t := *r.usePackageAllowance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "usePackageAllowance", t, "multi")
		}
  }
	if r.autoPosting != nil {
		t := *r.autoPosting
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "autoPosting", t, "multi")
		}
  }
	if r.financialTransactionId != nil {
		t := *r.financialTransactionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionId", t, "multi")
		}
  }
	if r.financialTransactionIdContext != nil {
		t := *r.financialTransactionIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionIdContext", t, "multi")
		}
  }
	if r.financialTransactionType != nil {
		t := *r.financialTransactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financialTransactionType", t, "multi")
		}
  }
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
  }
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
  }
	if r.folioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioType", r.folioType, "")
  }
	if r.generateFiscalFolio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateFiscalFolio", r.generateFiscalFolio, "")
  }
	if r.queueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueName", r.queueName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetARStatementsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	profileId *[]string
	profileIdContext *string
	profileType *string
	accountID *[]string
	accountNo *[]string
	accountName *[]string
	canBeModified *[]bool
	closeDate *[]string
	fiscalBillNo *[]string
	folioDate *[]string
	folioNo *[]float32
	folioStatus *[]string
	folioTypeName *[]string
	internalFolioWindowID *[]string
	invoiceNo *[]float32
	invoiceType *[]string
	postingDate *[]string
	revenueDate *[]string
	statementNo *[]int32
	status *[]string
	transferDate *[]string
	invoiceTransactionCode *[]string
	transactionDate *[]string
	transactionNo *[]float32
	invoiceHotelIds *[]string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	age *[]int32
	guestName *[]string
	originalAmount *float32
	originalAmountCurrencyCode *string
	amount *float32
	currencyCode *string
	paymentsAmount *float32
	paymentsCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	reference *[]string
	remark *[]string
	adjusted *[]bool
	parentInvoiceNo *[]float32
	compressed *[]bool
	compressedDate *[]string
	transferredOut *[]bool
	transferredIn *[]bool
	marketDescription *string
	marketHotelId *string
	marketCode *string
	marketGroup *string
	roomClassDescription *string
	roomClassHotelId *string
	roomClassCode *string
	sourceDescription *string
	sourceHotelId *string
	sourceCode *string
	sourceGroup *string
	cashierId *float32
	cashierName *string
	transactionHotelId *string
	printTrxReceipt *bool
	accountInvoiceTransactionCode *string
	transactionDescription *string
	transactionGroup *string
	transactionSubGroup *string
	universalProductCode *string
	routingInstructionsId *float32
	articleCode *[]string
	articleHotelIds *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	transactionCode *[]string
	articleAmount *float32
	articleCurrencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	invoicePaymentCardId *string
	invoicePaymentCardIdContext *string
	invoicePaymentCardIdType *string
	currentAuthorizedAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmount *float32
	approvalAmountCurrencyCode *string
	type_ *string
	addresseeProfileId *string
	addresseeProfileIdContext *string
	addresseeProfileType *string
	name *string
	city *string
	phone *string
	allowPartialTransferYn *[]bool
	printed *[]bool
	printedDate *[]string
	storedFolioId *string
	storedFolioIdContext *string
	storedFolioType *string
	storedFolioName *[]string
	storedDebitFolioId *string
	storedDebitFolioIdContext *string
	storedDebitFolioType *string
	storedDebitFolioName *[]string
	balanceForwardDate *string
	inclFolios *bool
	inclPrinted *bool
	inclZero *bool
	filterEndDate *string
	filterStartDate *string
	statementText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetARStatementsRequest) Authorization(authorization string) AccountsReceivablesAPIGetARStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetARStatementsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetARStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetARStatementsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetARStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) HotelId(hotelId []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) ProfileId(profileId []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) ProfileType(profileType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) AccountID(accountID []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.accountID = &accountID
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetARStatementsRequest) AccountNo(accountNo []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetARStatementsRequest) AccountName(accountName []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.accountName = &accountName
	return r
}

// Flag to indicate if postings or adjustments can be made to the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) CanBeModified(canBeModified []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.canBeModified = &canBeModified
	return r
}

// Close date of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) CloseDate(closeDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.closeDate = &closeDate
	return r
}

// The Fiscal Bill number of this posting
func (r AccountsReceivablesAPIGetARStatementsRequest) FiscalBillNo(fiscalBillNo []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r AccountsReceivablesAPIGetARStatementsRequest) FolioDate(folioDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r AccountsReceivablesAPIGetARStatementsRequest) FolioNo(folioNo []float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r AccountsReceivablesAPIGetARStatementsRequest) FolioStatus(folioStatus []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r AccountsReceivablesAPIGetARStatementsRequest) FolioTypeName(folioTypeName []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r AccountsReceivablesAPIGetARStatementsRequest) InternalFolioWindowID(internalFolioWindowID []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIGetARStatementsRequest) InvoiceNo(invoiceNo []float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) InvoiceType(invoiceType []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoiceType = &invoiceType
	return r
}

// Posting date of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) PostingDate(postingDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.postingDate = &postingDate
	return r
}

// Revenue date ID of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) RevenueDate(revenueDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.revenueDate = &revenueDate
	return r
}

// Statementno of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) StatementNo(statementNo []int32) AccountsReceivablesAPIGetARStatementsRequest {
	r.statementNo = &statementNo
	return r
}

// Status of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) Status(status []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.status = &status
	return r
}

// Transfer date of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransferDate(transferDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transferDate = &transferDate
	return r
}

// Transaction code of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) InvoiceTransactionCode(invoiceTransactionCode []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoiceTransactionCode = &invoiceTransactionCode
	return r
}

// Transaction Date of the invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionDate(transactionDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Unique Transaction Identifier of the Invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionNo(transactionNo []float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) InvoiceHotelIds(invoiceHotelIds []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoiceHotelIds = &invoiceHotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) ReservationId(reservationId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) ReservationIdContext(reservationIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) ReservationType(reservationType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.reservationType = &reservationType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) GuestProfileId(guestProfileId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) GuestProfileIdContext(guestProfileIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) GuestProfileType(guestProfileType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.guestProfileType = &guestProfileType
	return r
}

// The Aging age of the invoice
func (r AccountsReceivablesAPIGetARStatementsRequest) Age(age []int32) AccountsReceivablesAPIGetARStatementsRequest {
	r.age = &age
	return r
}

// Name of the Guest who consumed these transactions.
func (r AccountsReceivablesAPIGetARStatementsRequest) GuestName(guestName []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.guestName = &guestName
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) OriginalAmount(originalAmount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.originalAmount = &originalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) OriginalAmountCurrencyCode(originalAmountCurrencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.originalAmountCurrencyCode = &originalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) Amount(amount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) CurrencyCode(currencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) PaymentsAmount(paymentsAmount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.paymentsAmount = &paymentsAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) PaymentsCurrencyCode(paymentsCurrencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.paymentsCurrencyCode = &paymentsCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) BalanceAmount(balanceAmount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) BalanceCurrencyCode(balanceCurrencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// User-defined posting reference.
func (r AccountsReceivablesAPIGetARStatementsRequest) Reference(reference []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.reference = &reference
	return r
}

// User-defined posting remark.
func (r AccountsReceivablesAPIGetARStatementsRequest) Remark(remark []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.remark = &remark
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) Adjusted(adjusted []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.adjusted = &adjusted
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) ParentInvoiceNo(parentInvoiceNo []float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.parentInvoiceNo = &parentInvoiceNo
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) Compressed(compressed []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.compressed = &compressed
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) CompressedDate(compressedDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.compressedDate = &compressedDate
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) TransferredOut(transferredOut []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.transferredOut = &transferredOut
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) TransferredIn(transferredIn []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.transferredIn = &transferredIn
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) MarketDescription(marketDescription string) AccountsReceivablesAPIGetARStatementsRequest {
	r.marketDescription = &marketDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) MarketHotelId(marketHotelId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.marketHotelId = &marketHotelId
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) MarketCode(marketCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.marketCode = &marketCode
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) MarketGroup(marketGroup string) AccountsReceivablesAPIGetARStatementsRequest {
	r.marketGroup = &marketGroup
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) RoomClassDescription(roomClassDescription string) AccountsReceivablesAPIGetARStatementsRequest {
	r.roomClassDescription = &roomClassDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) RoomClassHotelId(roomClassHotelId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) RoomClassCode(roomClassCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) SourceDescription(sourceDescription string) AccountsReceivablesAPIGetARStatementsRequest {
	r.sourceDescription = &sourceDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) SourceHotelId(sourceHotelId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.sourceHotelId = &sourceHotelId
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) SourceCode(sourceCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.sourceCode = &sourceCode
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) SourceGroup(sourceGroup string) AccountsReceivablesAPIGetARStatementsRequest {
	r.sourceGroup = &sourceGroup
	return r
}

// Cashier Id of the Cashier.
func (r AccountsReceivablesAPIGetARStatementsRequest) CashierId(cashierId float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier Name.
func (r AccountsReceivablesAPIGetARStatementsRequest) CashierName(cashierName string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cashierName = &cashierName
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionHotelId(transactionHotelId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r AccountsReceivablesAPIGetARStatementsRequest) PrintTrxReceipt(printTrxReceipt bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r AccountsReceivablesAPIGetARStatementsRequest) AccountInvoiceTransactionCode(accountInvoiceTransactionCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.accountInvoiceTransactionCode = &accountInvoiceTransactionCode
	return r
}

// Transaction codes info.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionDescription(transactionDescription string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Category of the transaction code.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionGroup(transactionGroup string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionSubGroup(transactionSubGroup string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r AccountsReceivablesAPIGetARStatementsRequest) UniversalProductCode(universalProductCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r AccountsReceivablesAPIGetARStatementsRequest) RoutingInstructionsId(routingInstructionsId float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r AccountsReceivablesAPIGetARStatementsRequest) ArticleCode(articleCode []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.articleCode = &articleCode
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetARStatementsRequest) ArticleHotelIds(articleHotelIds []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.articleHotelIds = &articleHotelIds
	return r
}

// Indicates whether the article is inactive or not.
func (r AccountsReceivablesAPIGetARStatementsRequest) Inactive(inactive []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r AccountsReceivablesAPIGetARStatementsRequest) OrderSequence(orderSequence []float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r AccountsReceivablesAPIGetARStatementsRequest) ArticleDescription(articleDescription []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r AccountsReceivablesAPIGetARStatementsRequest) TransactionCode(transactionCode []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) ArticleAmount(articleAmount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.articleAmount = &articleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) ArticleCurrencyCode(articleCurrencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.articleCurrencyCode = &articleCurrencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r AccountsReceivablesAPIGetARStatementsRequest) AvailableForPostIt(availableForPostIt bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r AccountsReceivablesAPIGetARStatementsRequest) Color(color string) AccountsReceivablesAPIGetARStatementsRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r AccountsReceivablesAPIGetARStatementsRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Attach the credit card to profile.
func (r AccountsReceivablesAPIGetARStatementsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) CardHolderName(cardHolderName string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) CardNumber(cardNumber string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) CardNumberMasked(cardNumberMasked string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r AccountsReceivablesAPIGetARStatementsRequest) CardOrToken(cardOrToken string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r AccountsReceivablesAPIGetARStatementsRequest) CardType(cardType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r AccountsReceivablesAPIGetARStatementsRequest) ExpirationDate(expirationDate string) AccountsReceivablesAPIGetARStatementsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) ExpirationDateExpired(expirationDateExpired bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r AccountsReceivablesAPIGetARStatementsRequest) ExpirationDateMasked(expirationDateMasked string) AccountsReceivablesAPIGetARStatementsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) Processing(processing string) AccountsReceivablesAPIGetARStatementsRequest {
	r.processing = &processing
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) Swiped(swiped bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r AccountsReceivablesAPIGetARStatementsRequest) UserDefinedCardType(userDefinedCardType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) InvoicePaymentCardId(invoicePaymentCardId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoicePaymentCardId = &invoicePaymentCardId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) InvoicePaymentCardIdContext(invoicePaymentCardIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoicePaymentCardIdContext = &invoicePaymentCardIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) InvoicePaymentCardIdType(invoicePaymentCardIdType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.invoicePaymentCardIdType = &invoicePaymentCardIdType
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARStatementsRequest) ApprovalAmount(approvalAmount float32) AccountsReceivablesAPIGetARStatementsRequest {
	r.approvalAmount = &approvalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARStatementsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) AccountsReceivablesAPIGetARStatementsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Defines the type of Linked profiles for a block.
func (r AccountsReceivablesAPIGetARStatementsRequest) Type_(type_ string) AccountsReceivablesAPIGetARStatementsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) AddresseeProfileId(addresseeProfileId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.addresseeProfileId = &addresseeProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) AddresseeProfileIdContext(addresseeProfileIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.addresseeProfileIdContext = &addresseeProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) AddresseeProfileType(addresseeProfileType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.addresseeProfileType = &addresseeProfileType
	return r
}

// Name for the profile attached to the block.
func (r AccountsReceivablesAPIGetARStatementsRequest) Name(name string) AccountsReceivablesAPIGetARStatementsRequest {
	r.name = &name
	return r
}

// City for the profile attached to the block.
func (r AccountsReceivablesAPIGetARStatementsRequest) City(city string) AccountsReceivablesAPIGetARStatementsRequest {
	r.city = &city
	return r
}

// Phone for the profile attached to the block.
func (r AccountsReceivablesAPIGetARStatementsRequest) Phone(phone string) AccountsReceivablesAPIGetARStatementsRequest {
	r.phone = &phone
	return r
}

// Flag to check Partail Transfer Allowed.
func (r AccountsReceivablesAPIGetARStatementsRequest) AllowPartialTransferYn(allowPartialTransferYn []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.allowPartialTransferYn = &allowPartialTransferYn
	return r
}

// Flag to check Invoice Statement is Printed.
func (r AccountsReceivablesAPIGetARStatementsRequest) Printed(printed []bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.printed = &printed
	return r
}

// Invoice Statement Printed Date.
func (r AccountsReceivablesAPIGetARStatementsRequest) PrintedDate(printedDate []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.printedDate = &printedDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredFolioId(storedFolioId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedFolioId = &storedFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredFolioIdContext(storedFolioIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedFolioIdContext = &storedFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredFolioType(storedFolioType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedFolioType = &storedFolioType
	return r
}

// Name of the Stored Folio.
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredFolioName(storedFolioName []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedFolioName = &storedFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredDebitFolioId(storedDebitFolioId string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedDebitFolioId = &storedDebitFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredDebitFolioIdContext(storedDebitFolioIdContext string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedDebitFolioIdContext = &storedDebitFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredDebitFolioType(storedDebitFolioType string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedDebitFolioType = &storedDebitFolioType
	return r
}

// Name of the Stored Debit Folio.
func (r AccountsReceivablesAPIGetARStatementsRequest) StoredDebitFolioName(storedDebitFolioName []string) AccountsReceivablesAPIGetARStatementsRequest {
	r.storedDebitFolioName = &storedDebitFolioName
	return r
}

// The date specified in this field determines the balance forward date and balance forward total that is printed on the statement. (A balance forward shows the net amount for all invoices and payments (debits and credits) prior to the balance forward date as a single total, rather than itemizing them individually on the statement.)
func (r AccountsReceivablesAPIGetARStatementsRequest) BalanceForwardDate(balanceForwardDate string) AccountsReceivablesAPIGetARStatementsRequest {
	r.balanceForwardDate = &balanceForwardDate
	return r
}

// Flag to indicate if the associated Folios for the Invoices are to be included along with the the Statement.
func (r AccountsReceivablesAPIGetARStatementsRequest) InclFolios(inclFolios bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.inclFolios = &inclFolios
	return r
}

// Flag to indicate if Previousely Printed Invoices are to be included in the Statement. This is based on the Functionality for AR PRINTED INVOICES.
func (r AccountsReceivablesAPIGetARStatementsRequest) InclPrinted(inclPrinted bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.inclPrinted = &inclPrinted
	return r
}

// Flag to indicate if Zero Balances Invoices are to be included in the Statement.
func (r AccountsReceivablesAPIGetARStatementsRequest) InclZero(inclZero bool) AccountsReceivablesAPIGetARStatementsRequest {
	r.inclZero = &inclZero
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetARStatementsRequest) FilterEndDate(filterEndDate string) AccountsReceivablesAPIGetARStatementsRequest {
	r.filterEndDate = &filterEndDate
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetARStatementsRequest) FilterStartDate(filterStartDate string) AccountsReceivablesAPIGetARStatementsRequest {
	r.filterStartDate = &filterStartDate
	return r
}

// Text which will be printed on the Invoice.
func (r AccountsReceivablesAPIGetARStatementsRequest) StatementText(statementText string) AccountsReceivablesAPIGetARStatementsRequest {
	r.statementText = &statementText
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetARStatementsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetARStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetARStatementsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetARStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetARStatementsRequest) Execute() (*Statements, *http.Response, error) {
	return r.ApiService.GetARStatementsExecute(r)
}

/*
GetARStatements Get given profile's account receivable statements

Use this API to prepare statement for an AR account holders. It is typically prepared for billing purposes. <p><strong>OperationId:</strong>getARStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIGetARStatementsRequest
*/
func (a *AccountsReceivablesAPIService) GetARStatements(ctx context.Context) AccountsReceivablesAPIGetARStatementsRequest {
	return AccountsReceivablesAPIGetARStatementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Statements
func (a *AccountsReceivablesAPIService) GetARStatementsExecute(r AccountsReceivablesAPIGetARStatementsRequest) (*Statements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Statements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetARStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.profileId != nil {
		t := *r.profileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", t, "multi")
		}
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.accountID != nil {
		t := *r.accountID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountID", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountID", t, "multi")
		}
  }
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
  }
	if r.accountName != nil {
		t := *r.accountName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", t, "multi")
		}
  }
	if r.canBeModified != nil {
		t := *r.canBeModified
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", t, "multi")
		}
  }
	if r.closeDate != nil {
		t := *r.closeDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", t, "multi")
		}
  }
	if r.fiscalBillNo != nil {
		t := *r.fiscalBillNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", t, "multi")
		}
  }
	if r.folioDate != nil {
		t := *r.folioDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", t, "multi")
		}
  }
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
  }
	if r.folioStatus != nil {
		t := *r.folioStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", t, "multi")
		}
  }
	if r.folioTypeName != nil {
		t := *r.folioTypeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", t, "multi")
		}
  }
	if r.internalFolioWindowID != nil {
		t := *r.internalFolioWindowID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", t, "multi")
		}
  }
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
  }
	if r.invoiceType != nil {
		t := *r.invoiceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", t, "multi")
		}
  }
	if r.postingDate != nil {
		t := *r.postingDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", t, "multi")
		}
  }
	if r.revenueDate != nil {
		t := *r.revenueDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", t, "multi")
		}
  }
	if r.statementNo != nil {
		t := *r.statementNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", t, "multi")
		}
  }
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
  }
	if r.transferDate != nil {
		t := *r.transferDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", t, "multi")
		}
  }
	if r.invoiceTransactionCode != nil {
		t := *r.invoiceTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", t, "multi")
		}
  }
	if r.transactionDate != nil {
		t := *r.transactionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", t, "multi")
		}
  }
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
  }
	if r.invoiceHotelIds != nil {
		t := *r.invoiceHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", t, "multi")
		}
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
  }
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
  }
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
  }
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
  }
	if r.age != nil {
		t := *r.age
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "age", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "age", t, "multi")
		}
  }
	if r.guestName != nil {
		t := *r.guestName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", t, "multi")
		}
  }
	if r.originalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmount", r.originalAmount, "")
  }
	if r.originalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmountCurrencyCode", r.originalAmountCurrencyCode, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.paymentsAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsAmount", r.paymentsAmount, "")
  }
	if r.paymentsCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsCurrencyCode", r.paymentsCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.reference != nil {
		t := *r.reference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reference", t, "multi")
		}
  }
	if r.remark != nil {
		t := *r.remark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remark", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remark", t, "multi")
		}
  }
	if r.adjusted != nil {
		t := *r.adjusted
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", t, "multi")
		}
  }
	if r.parentInvoiceNo != nil {
		t := *r.parentInvoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", t, "multi")
		}
  }
	if r.compressed != nil {
		t := *r.compressed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", t, "multi")
		}
  }
	if r.compressedDate != nil {
		t := *r.compressedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", t, "multi")
		}
  }
	if r.transferredOut != nil {
		t := *r.transferredOut
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", t, "multi")
		}
  }
	if r.transferredIn != nil {
		t := *r.transferredIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", t, "multi")
		}
  }
	if r.marketDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketDescription", r.marketDescription, "")
  }
	if r.marketHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketHotelId", r.marketHotelId, "")
  }
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
  }
	if r.marketGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroup", r.marketGroup, "")
  }
	if r.roomClassDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassDescription", r.roomClassDescription, "")
  }
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
  }
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
  }
	if r.sourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceDescription", r.sourceDescription, "")
  }
	if r.sourceHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceHotelId", r.sourceHotelId, "")
  }
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
  }
	if r.sourceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceGroup", r.sourceGroup, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.cashierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierName", r.cashierName, "")
  }
	if r.transactionHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", r.transactionHotelId, "")
  }
	if r.printTrxReceipt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", r.printTrxReceipt, "")
  }
	if r.accountInvoiceTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountInvoiceTransactionCode", r.accountInvoiceTransactionCode, "")
  }
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
  }
	if r.transactionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", r.transactionGroup, "")
  }
	if r.transactionSubGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", r.transactionSubGroup, "")
  }
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
  }
	if r.routingInstructionsId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", r.routingInstructionsId, "")
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.articleHotelIds != nil {
		t := *r.articleHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.articleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleAmount", r.articleAmount, "")
  }
	if r.articleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleCurrencyCode", r.articleCurrencyCode, "")
  }
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
  }
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
  }
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.invoicePaymentCardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardId", r.invoicePaymentCardId, "")
  }
	if r.invoicePaymentCardIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdContext", r.invoicePaymentCardIdContext, "")
  }
	if r.invoicePaymentCardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdType", r.invoicePaymentCardIdType, "")
  }
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
  }
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
  }
	if r.approvalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmount", r.approvalAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.addresseeProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileId", r.addresseeProfileId, "")
  }
	if r.addresseeProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileIdContext", r.addresseeProfileIdContext, "")
  }
	if r.addresseeProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileType", r.addresseeProfileType, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
  }
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
  }
	if r.allowPartialTransferYn != nil {
		t := *r.allowPartialTransferYn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", t, "multi")
		}
  }
	if r.printed != nil {
		t := *r.printed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printed", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printed", t, "multi")
		}
  }
	if r.printedDate != nil {
		t := *r.printedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", t, "multi")
		}
  }
	if r.storedFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioId", r.storedFolioId, "")
  }
	if r.storedFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioIdContext", r.storedFolioIdContext, "")
  }
	if r.storedFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioType", r.storedFolioType, "")
  }
	if r.storedFolioName != nil {
		t := *r.storedFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", t, "multi")
		}
  }
	if r.storedDebitFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioId", r.storedDebitFolioId, "")
  }
	if r.storedDebitFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioIdContext", r.storedDebitFolioIdContext, "")
  }
	if r.storedDebitFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioType", r.storedDebitFolioType, "")
  }
	if r.storedDebitFolioName != nil {
		t := *r.storedDebitFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", t, "multi")
		}
  }
	if r.balanceForwardDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceForwardDate", r.balanceForwardDate, "")
  }
	if r.inclFolios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclFolios", r.inclFolios, "")
  }
	if r.inclPrinted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclPrinted", r.inclPrinted, "")
  }
	if r.inclZero != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZero", r.inclZero, "")
  }
	if r.filterEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndDate", r.filterEndDate, "")
  }
	if r.filterStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartDate", r.filterStartDate, "")
  }
	if r.statementText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementText", r.statementText, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetARTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelIds *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	accounts *string
	endDate *string
	startDate *string
	fromAmount *float32
	fromCurrencyCode *string
	toAmount *float32
	toCurrencyCode *string
	guestName *string
	invoices *[]float32
	folios *[]string
	fiscalBillNo *string
	accountName *string
	addresseName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Property where the Accounts exist.
func (r AccountsReceivablesAPIGetARTransactionsRequest) HotelIds(hotelIds []string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetARTransactionsRequest) Authorization(authorization string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetARTransactionsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetARTransactionsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account number of this transaction.
func (r AccountsReceivablesAPIGetARTransactionsRequest) Accounts(accounts string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.accounts = &accounts
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetARTransactionsRequest) EndDate(endDate string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetARTransactionsRequest) StartDate(startDate string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.startDate = &startDate
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARTransactionsRequest) FromAmount(fromAmount float32) AccountsReceivablesAPIGetARTransactionsRequest {
	r.fromAmount = &fromAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARTransactionsRequest) FromCurrencyCode(fromCurrencyCode string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.fromCurrencyCode = &fromCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetARTransactionsRequest) ToAmount(toAmount float32) AccountsReceivablesAPIGetARTransactionsRequest {
	r.toAmount = &toAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetARTransactionsRequest) ToCurrencyCode(toCurrencyCode string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.toCurrencyCode = &toCurrencyCode
	return r
}

// Display Name for the guest.
func (r AccountsReceivablesAPIGetARTransactionsRequest) GuestName(guestName string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.guestName = &guestName
	return r
}

// invoice Number .
func (r AccountsReceivablesAPIGetARTransactionsRequest) Invoices(invoices []float32) AccountsReceivablesAPIGetARTransactionsRequest {
	r.invoices = &invoices
	return r
}

// folio Number .
func (r AccountsReceivablesAPIGetARTransactionsRequest) Folios(folios []string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.folios = &folios
	return r
}

// Fiscal bill number of this transaction.
func (r AccountsReceivablesAPIGetARTransactionsRequest) FiscalBillNo(fiscalBillNo string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Account number of this transaction.
func (r AccountsReceivablesAPIGetARTransactionsRequest) AccountName(accountName string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.accountName = &accountName
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r AccountsReceivablesAPIGetARTransactionsRequest) AddresseName(addresseName string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.addresseName = &addresseName
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetARTransactionsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetARTransactionsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetARTransactionsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetARTransactionsRequest) Execute() (*ArTransactions, *http.Response, error) {
	return r.ApiService.GetARTransactionsExecute(r)
}

/*
GetARTransactions Get AR transactions.

Use this API to get list of transaction data for a given account receivable account number and list of hotels <p><strong>OperationId:</strong>getARTransactions</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIGetARTransactionsRequest
*/
func (a *AccountsReceivablesAPIService) GetARTransactions(ctx context.Context) AccountsReceivablesAPIGetARTransactionsRequest {
	return AccountsReceivablesAPIGetARTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArTransactions
func (a *AccountsReceivablesAPIService) GetARTransactionsExecute(r AccountsReceivablesAPIGetARTransactionsRequest) (*ArTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetARTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/arTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
	}
	if r.accounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", r.accounts, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.fromAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAmount", r.fromAmount, "")
  }
	if r.fromCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromCurrencyCode", r.fromCurrencyCode, "")
  }
	if r.toAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toAmount", r.toAmount, "")
  }
	if r.toCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toCurrencyCode", r.toCurrencyCode, "")
  }
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
  }
	if r.invoices != nil {
		t := *r.invoices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", t, "multi")
		}
  }
	if r.folios != nil {
		t := *r.folios
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folios", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folios", t, "multi")
		}
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	if r.addresseName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseName", r.addresseName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountNo *string
	profileId *string
	profileIdContext *string
	profileType *string
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetAccountRequest) Authorization(authorization string) AccountsReceivablesAPIGetAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetAccountRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetAccountRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account Number for the Account.
func (r AccountsReceivablesAPIGetAccountRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetAccountRequest {
	r.accountNo = &accountNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetAccountRequest) ProfileId(profileId string) AccountsReceivablesAPIGetAccountRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetAccountRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetAccountRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetAccountRequest) ProfileType(profileType string) AccountsReceivablesAPIGetAccountRequest {
	r.profileType = &profileType
	return r
}

// Instructions to fetch AR Account details.
func (r AccountsReceivablesAPIGetAccountRequest) FetchInstructions(fetchInstructions []string) AccountsReceivablesAPIGetAccountRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetAccountRequest) Execute() (*Account, *http.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Get account

Use this API to search for account receivable type account's  detail for given account id. <p><strong>OperationId:</strong>getAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetAccountRequest
*/
func (a *AccountsReceivablesAPIService) GetAccount(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIGetAccountRequest {
	return AccountsReceivablesAPIGetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Account
func (a *AccountsReceivablesAPIService) GetAccountExecute(r AccountsReceivablesAPIGetAccountRequest) (*Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	balance *string
	batchStatement *bool
	limit *int32
	offset *int32
	hotelIds *[]string
	profileId *string
	profileIdContext *string
	profileType *string
	type_ *string
	accountNo *[]string
	accountName *string
	accountId *[]string
	accountIdContext *[]string
	accountType *[]string
	includeStatementHistoryIndicator *bool
	includeReminderHistoryIndicator *bool
	superSearch *string
	searchHotelIds *[]string
	attributeName *[]string
	orderType *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetAccountsRequest) Authorization(authorization string) AccountsReceivablesAPIGetAccountsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetAccountsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetAccountsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetAccountsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetAccountsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Search By Balance. Search will be done for &#39;All&#39;, &#39;Open Balance&#39; or &#39;Zero Balance&#39; Accounts.
func (r AccountsReceivablesAPIGetAccountsRequest) Balance(balance string) AccountsReceivablesAPIGetAccountsRequest {
	r.balance = &balance
	return r
}

// Search criteria for batch processing
func (r AccountsReceivablesAPIGetAccountsRequest) BatchStatement(batchStatement bool) AccountsReceivablesAPIGetAccountsRequest {
	r.batchStatement = &batchStatement
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AccountsReceivablesAPIGetAccountsRequest) Limit(limit int32) AccountsReceivablesAPIGetAccountsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r AccountsReceivablesAPIGetAccountsRequest) Offset(offset int32) AccountsReceivablesAPIGetAccountsRequest {
	r.offset = &offset
	return r
}

// Property where the Accounts exist.
func (r AccountsReceivablesAPIGetAccountsRequest) HotelIds(hotelIds []string) AccountsReceivablesAPIGetAccountsRequest {
	r.hotelIds = &hotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetAccountsRequest) ProfileId(profileId string) AccountsReceivablesAPIGetAccountsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetAccountsRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetAccountsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetAccountsRequest) ProfileType(profileType string) AccountsReceivablesAPIGetAccountsRequest {
	r.profileType = &profileType
	return r
}

// Search by Account Type.
func (r AccountsReceivablesAPIGetAccountsRequest) Type_(type_ string) AccountsReceivablesAPIGetAccountsRequest {
	r.type_ = &type_
	return r
}

// Account Number .
func (r AccountsReceivablesAPIGetAccountsRequest) AccountNo(accountNo []string) AccountsReceivablesAPIGetAccountsRequest {
	r.accountNo = &accountNo
	return r
}

// Wild Card Search by Account Name. Search will be done for any Accounts whose name starts with this value.
func (r AccountsReceivablesAPIGetAccountsRequest) AccountName(accountName string) AccountsReceivablesAPIGetAccountsRequest {
	r.accountName = &accountName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetAccountsRequest) AccountId(accountId []string) AccountsReceivablesAPIGetAccountsRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetAccountsRequest) AccountIdContext(accountIdContext []string) AccountsReceivablesAPIGetAccountsRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetAccountsRequest) AccountType(accountType []string) AccountsReceivablesAPIGetAccountsRequest {
	r.accountType = &accountType
	return r
}

// Return statement history indicator in result. This flag included for performance reason to populate history flag only for Statements Mode.
func (r AccountsReceivablesAPIGetAccountsRequest) IncludeStatementHistoryIndicator(includeStatementHistoryIndicator bool) AccountsReceivablesAPIGetAccountsRequest {
	r.includeStatementHistoryIndicator = &includeStatementHistoryIndicator
	return r
}

// Return reminder history indicator in result. This flag included for performance reason to populate history flag only for Statements Mode.
func (r AccountsReceivablesAPIGetAccountsRequest) IncludeReminderHistoryIndicator(includeReminderHistoryIndicator bool) AccountsReceivablesAPIGetAccountsRequest {
	r.includeReminderHistoryIndicator = &includeReminderHistoryIndicator
	return r
}

// Free form text field for searching all reservation fields
func (r AccountsReceivablesAPIGetAccountsRequest) SuperSearch(superSearch string) AccountsReceivablesAPIGetAccountsRequest {
	r.superSearch = &superSearch
	return r
}

// Hotel code.
func (r AccountsReceivablesAPIGetAccountsRequest) SearchHotelIds(searchHotelIds []string) AccountsReceivablesAPIGetAccountsRequest {
	r.searchHotelIds = &searchHotelIds
	return r
}

func (r AccountsReceivablesAPIGetAccountsRequest) AttributeName(attributeName []string) AccountsReceivablesAPIGetAccountsRequest {
	r.attributeName = &attributeName
	return r
}

func (r AccountsReceivablesAPIGetAccountsRequest) OrderType(orderType []string) AccountsReceivablesAPIGetAccountsRequest {
	r.orderType = &orderType
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetAccountsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetAccountsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetAccountsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetAccountsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetAccountsRequest) Execute() (*AccountsInfo, *http.Response, error) {
	return r.ApiService.GetAccountsExecute(r)
}

/*
GetAccounts Get given profile's account receivable detail

Use this API to search for AR Accounts for a given OPERA Profile id. API returns contain a list of AR Accounts and their AR information. <p><strong>OperationId:</strong>getAccounts</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIGetAccountsRequest
*/
func (a *AccountsReceivablesAPIService) GetAccounts(ctx context.Context) AccountsReceivablesAPIGetAccountsRequest {
	return AccountsReceivablesAPIGetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountsInfo
func (a *AccountsReceivablesAPIService) GetAccountsExecute(r AccountsReceivablesAPIGetAccountsRequest) (*AccountsInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
  }
	if r.batchStatement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchStatement", r.batchStatement, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	if r.accountId != nil {
		t := *r.accountId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", t, "multi")
		}
  }
	if r.accountIdContext != nil {
		t := *r.accountIdContext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", t, "multi")
		}
  }
	if r.accountType != nil {
		t := *r.accountType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", t, "multi")
		}
  }
	if r.includeStatementHistoryIndicator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStatementHistoryIndicator", r.includeStatementHistoryIndicator, "")
  }
	if r.includeReminderHistoryIndicator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReminderHistoryIndicator", r.includeReminderHistoryIndicator, "")
  }
	if r.superSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "superSearch", r.superSearch, "")
  }
	if r.searchHotelIds != nil {
		t := *r.searchHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchHotelIds", t, "multi")
		}
  }
	if r.attributeName != nil {
		t := *r.attributeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", t, "multi")
		}
  }
	if r.orderType != nil {
		t := *r.orderType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderType", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	transactionId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) Authorization(authorization string) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) InvoiceNo(invoiceNo float32) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) Execute() (*InvoiceAppliedPayments, *http.Response, error) {
	return r.ApiService.GetAppliedInvoicePaymentsExecute(r)
}

/*
GetAppliedInvoicePayments Get account receivable invoice's payment history

Use this API to get applied payment details for AR invoices. <p><strong>OperationId:</strong>getAppliedInvoicePayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest
*/
func (a *AccountsReceivablesAPIService) GetAppliedInvoicePayments(ctx context.Context, accountId string, transactionId string, hotelId string) AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest {
	return AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoiceAppliedPayments
func (a *AccountsReceivablesAPIService) GetAppliedInvoicePaymentsExecute(r AccountsReceivablesAPIGetAppliedInvoicePaymentsRequest) (*InvoiceAppliedPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceAppliedPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetAppliedInvoicePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/accounts/{accountId}/invoiceAppliedPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	transactionId string
	invoiceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) Authorization(authorization string) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) InvoiceNo(invoiceNo float32) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) Execute() (*InvoiceAppliedPayments, *http.Response, error) {
	return r.ApiService.GetInvoiceAppliedPaymentsExecute(r)
}

/*
GetInvoiceAppliedPayments Get account receivable invoice's payment history

Use this API to get applied payment details for AR invoices.<br><p><strong><mark>This API is deprecated. Please use getAppliedInvoicePayments instead</mark></strong></p> <p><strong>OperationId:</strong>getInvoiceAppliedPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param transactionId Unique ID of the transaction
 @param invoiceId Unique ID of the invoice
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest

Deprecated
*/
func (a *AccountsReceivablesAPIService) GetInvoiceAppliedPayments(ctx context.Context, accountId string, transactionId string, invoiceId string, hotelId string) AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest {
	return AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		transactionId: transactionId,
		invoiceId: invoiceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoiceAppliedPayments
// Deprecated
func (a *AccountsReceivablesAPIService) GetInvoiceAppliedPaymentsExecute(r AccountsReceivablesAPIGetInvoiceAppliedPaymentsRequest) (*InvoiceAppliedPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceAppliedPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetInvoiceAppliedPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices/{invoiceId}/transactions/{transactionId}/accounts/{accountId}/invoiceAppliedPayments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.invoiceId) < 1 {
		return localVarReturnValue, nil, reportError("invoiceId must have at least 1 elements")
	}
	if strlen(r.invoiceId) > 2000 {
		return localVarReturnValue, nil, reportError("invoiceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetInvoicePaymentDetailRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	transactionId string
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileId *string
	profileIdContext *string
	profileType *string
	accountNo *string
	accountName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) Authorization(authorization string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) ProfileId(profileId string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) ProfileType(profileType string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.profileType = &profileType
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) AccountName(accountName string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.accountName = &accountName
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) Execute() (*InvoicePayment, *http.Response, error) {
	return r.ApiService.GetInvoicePaymentDetailExecute(r)
}

/*
GetInvoicePaymentDetail Get account receivable invoice and payment details

Use this API to get AR account's invoice and payment details including credit, debit, amount due date, etc. <p><strong>OperationId:</strong>getInvoicePaymentDetail</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetInvoicePaymentDetailRequest
*/
func (a *AccountsReceivablesAPIService) GetInvoicePaymentDetail(ctx context.Context, transactionId string, accountId string, hotelId string) AccountsReceivablesAPIGetInvoicePaymentDetailRequest {
	return AccountsReceivablesAPIGetInvoicePaymentDetailRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoicePayment
func (a *AccountsReceivablesAPIService) GetInvoicePaymentDetailExecute(r AccountsReceivablesAPIGetInvoicePaymentDetailRequest) (*InvoicePayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicePayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetInvoicePaymentDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/transactions/{transactionId}/invoicePaymentDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetInvoicePostingsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	canBeModified *bool
	closeDate *string
	fiscalBillNo *string
	folioDate *string
	folioNo *float32
	folioStatus *string
	folioTypeName *string
	internalFolioWindowID *string
	invoiceNo *float32
	invoiceType *string
	postingDate *string
	revenueDate *string
	statementNo *int32
	status *string
	transferDate *string
	postingTransactionCode *string
	transactionDate *string
	transactionNo *float32
	cashierId *float32
	hotelId *string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	age *int32
	guestName *string
	originalAmount *float32
	originalAmountCurrencyCode *string
	amount *float32
	currencyCode *string
	paymentsAmount *float32
	paymentsCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	reference *string
	remark *string
	adjusted *bool
	parentInvoiceNo *float32
	compressed *bool
	compressedDate *string
	transferredOut *bool
	transferredIn *bool
	marketDescription *string
	marketHotelId *string
	marketCode *string
	marketGroup *string
	roomClassDescription *string
	roomClassHotelId *string
	roomClassCode *string
	sourceDescription *string
	sourceHotelId *string
	sourceCode *string
	sourceGroup *string
	cashierInfoCashierId *float32
	cashierName *string
	transactionHotelId *string
	printTrxReceipt *bool
	invoicePostingsTransactionCode *string
	transactionDescription *string
	transactionGroup *string
	transactionSubGroup *string
	universalProductCode *string
	routingInstructionsId *float32
	articleCode *[]string
	articleHotelIds *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	transactionCode *[]string
	articleAmount *float32
	articleCurrencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	cardId *string
	paymentCardIdContext *string
	paymentCardIdType *string
	currentAuthorizedAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmount *float32
	approvalAmountCurrencyCode *string
	addresseeType *string
	addressProfileId *string
	addressProfileIdContext *string
	addressProfileIdType *string
	name *string
	city *string
	phone *string
	allowPartialTransferYn *bool
	printed *bool
	printedDate *string
	storedFolioId *string
	storedFolioIdContext *string
	storedFolioType *string
	storedFolioName *string
	storedDebitFolioId *string
	storedDebitFolioIdContext *string
	storedDebitFolioType *string
	storedDebitFolioName *string
	accountId *string
	accountIdContext *string
	accountType *string
	accountNo *string
	profileId *string
	profileIdContext *string
	profileIdType *string
	additionalFilterCashierId *float32
	additionalFilterTransactionCode *[]string
	additionalFilterTransactionSubGroupCode *[]string
	end *string
	start *string
	referenceWildCard *string
	supplementWildCard *string
	checkNumberWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Authorization(authorization string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if postings or adjustments can be made to the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CanBeModified(canBeModified bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.canBeModified = &canBeModified
	return r
}

// Close date of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CloseDate(closeDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.closeDate = &closeDate
	return r
}

// The Fiscal Bill number of this posting
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) FiscalBillNo(fiscalBillNo string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) FolioDate(folioDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) FolioNo(folioNo float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) FolioStatus(folioStatus string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) FolioTypeName(folioTypeName string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) InternalFolioWindowID(internalFolioWindowID string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) InvoiceNo(invoiceNo float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) InvoiceType(invoiceType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.invoiceType = &invoiceType
	return r
}

// Posting date of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PostingDate(postingDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.postingDate = &postingDate
	return r
}

// Revenue date ID of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) RevenueDate(revenueDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.revenueDate = &revenueDate
	return r
}

// Statementno of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StatementNo(statementNo int32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.statementNo = &statementNo
	return r
}

// Status of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Status(status string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.status = &status
	return r
}

// Transfer date of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransferDate(transferDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transferDate = &transferDate
	return r
}

// Transaction code of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PostingTransactionCode(postingTransactionCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.postingTransactionCode = &postingTransactionCode
	return r
}

// Transaction Date of the invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionDate(transactionDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Unique Transaction Identifier of the Invoice.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionNo(transactionNo float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionNo = &transactionNo
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CashierId(cashierId float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cashierId = &cashierId
	return r
}

// Property where the invoice exists.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) HotelId(hotelId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ReservationId(reservationId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ReservationIdContext(reservationIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ReservationType(reservationType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.reservationType = &reservationType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) GuestProfileId(guestProfileId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) GuestProfileIdContext(guestProfileIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) GuestProfileType(guestProfileType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.guestProfileType = &guestProfileType
	return r
}

// The Aging age of the invoice
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Age(age int32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.age = &age
	return r
}

// Name of the Guest who consumed these transactions.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) GuestName(guestName string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.guestName = &guestName
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) OriginalAmount(originalAmount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.originalAmount = &originalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) OriginalAmountCurrencyCode(originalAmountCurrencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.originalAmountCurrencyCode = &originalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Amount(amount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CurrencyCode(currencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PaymentsAmount(paymentsAmount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.paymentsAmount = &paymentsAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PaymentsCurrencyCode(paymentsCurrencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.paymentsCurrencyCode = &paymentsCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) BalanceAmount(balanceAmount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) BalanceCurrencyCode(balanceCurrencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// User-defined posting reference.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Reference(reference string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.reference = &reference
	return r
}

// User-defined posting remark.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Remark(remark string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.remark = &remark
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Adjusted(adjusted bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.adjusted = &adjusted
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ParentInvoiceNo(parentInvoiceNo float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.parentInvoiceNo = &parentInvoiceNo
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Compressed(compressed bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.compressed = &compressed
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CompressedDate(compressedDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.compressedDate = &compressedDate
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransferredOut(transferredOut bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transferredOut = &transferredOut
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransferredIn(transferredIn bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transferredIn = &transferredIn
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) MarketDescription(marketDescription string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.marketDescription = &marketDescription
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) MarketHotelId(marketHotelId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.marketHotelId = &marketHotelId
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) MarketCode(marketCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.marketCode = &marketCode
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) MarketGroup(marketGroup string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.marketGroup = &marketGroup
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) RoomClassDescription(roomClassDescription string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.roomClassDescription = &roomClassDescription
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) RoomClassHotelId(roomClassHotelId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) RoomClassCode(roomClassCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) SourceDescription(sourceDescription string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.sourceDescription = &sourceDescription
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) SourceHotelId(sourceHotelId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.sourceHotelId = &sourceHotelId
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) SourceCode(sourceCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.sourceCode = &sourceCode
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) SourceGroup(sourceGroup string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.sourceGroup = &sourceGroup
	return r
}

// Cashier Id of the Cashier.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CashierInfoCashierId(cashierInfoCashierId float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cashierInfoCashierId = &cashierInfoCashierId
	return r
}

// Cashier Name.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CashierName(cashierName string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cashierName = &cashierName
	return r
}

// Hotel context of the Transaction code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionHotelId(transactionHotelId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PrintTrxReceipt(printTrxReceipt bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) InvoicePostingsTransactionCode(invoicePostingsTransactionCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.invoicePostingsTransactionCode = &invoicePostingsTransactionCode
	return r
}

// Transaction codes info.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionDescription(transactionDescription string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Category of the transaction code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionGroup(transactionGroup string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionSubGroup(transactionSubGroup string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) UniversalProductCode(universalProductCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) RoutingInstructionsId(routingInstructionsId float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ArticleCode(articleCode []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.articleCode = &articleCode
	return r
}

// Hotel code to which the article belongs.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ArticleHotelIds(articleHotelIds []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.articleHotelIds = &articleHotelIds
	return r
}

// Indicates whether the article is inactive or not.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Inactive(inactive []bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) OrderSequence(orderSequence []float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ArticleDescription(articleDescription []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) TransactionCode(transactionCode []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ArticleAmount(articleAmount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.articleAmount = &articleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ArticleCurrencyCode(articleCurrencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.articleCurrencyCode = &articleCurrencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AvailableForPostIt(availableForPostIt bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Color(color string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Attach the credit card to profile.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardHolderName(cardHolderName string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardNumber(cardNumber string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardNumberMasked(cardNumberMasked string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardOrToken(cardOrToken string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardType(cardType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ExpirationDate(expirationDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ExpirationDateExpired(expirationDateExpired bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ExpirationDateMasked(expirationDateMasked string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Processing(processing string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.processing = &processing
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Swiped(swiped bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) UserDefinedCardType(userDefinedCardType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CardId(cardId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.cardId = &cardId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PaymentCardIdContext(paymentCardIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.paymentCardIdContext = &paymentCardIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PaymentCardIdType(paymentCardIdType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.paymentCardIdType = &paymentCardIdType
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ApprovalAmount(approvalAmount float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.approvalAmount = &approvalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Defines the type of Linked profiles for a block.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AddresseeType(addresseeType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.addresseeType = &addresseeType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AddressProfileId(addressProfileId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.addressProfileId = &addressProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AddressProfileIdContext(addressProfileIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.addressProfileIdContext = &addressProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AddressProfileIdType(addressProfileIdType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.addressProfileIdType = &addressProfileIdType
	return r
}

// Name for the profile attached to the block.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Name(name string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.name = &name
	return r
}

// City for the profile attached to the block.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) City(city string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.city = &city
	return r
}

// Phone for the profile attached to the block.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Phone(phone string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.phone = &phone
	return r
}

// Flag to check Partail Transfer Allowed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AllowPartialTransferYn(allowPartialTransferYn bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.allowPartialTransferYn = &allowPartialTransferYn
	return r
}

// Flag to check Invoice Statement is Printed.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Printed(printed bool) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.printed = &printed
	return r
}

// Invoice Statement Printed Date.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) PrintedDate(printedDate string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.printedDate = &printedDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredFolioId(storedFolioId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedFolioId = &storedFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredFolioIdContext(storedFolioIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedFolioIdContext = &storedFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredFolioType(storedFolioType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedFolioType = &storedFolioType
	return r
}

// Name of the Stored Folio.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredFolioName(storedFolioName string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedFolioName = &storedFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredDebitFolioId(storedDebitFolioId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedDebitFolioId = &storedDebitFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredDebitFolioIdContext(storedDebitFolioIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedDebitFolioIdContext = &storedDebitFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredDebitFolioType(storedDebitFolioType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedDebitFolioType = &storedDebitFolioType
	return r
}

// Name of the Stored Debit Folio.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) StoredDebitFolioName(storedDebitFolioName string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.storedDebitFolioName = &storedDebitFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AccountId(accountId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.accountId = &accountId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AccountIdContext(accountIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AccountType(accountType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.accountType = &accountType
	return r
}

// The Account Number for the Account.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.accountNo = &accountNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ProfileId(profileId string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ProfileIdType(profileIdType string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.profileIdType = &profileIdType
	return r
}

// Cashier Id of the Cashier.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AdditionalFilterCashierId(additionalFilterCashierId float32) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.additionalFilterCashierId = &additionalFilterCashierId
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AdditionalFilterTransactionCode(additionalFilterTransactionCode []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.additionalFilterTransactionCode = &additionalFilterTransactionCode
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AdditionalFilterTransactionSubGroupCode(additionalFilterTransactionSubGroupCode []string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.additionalFilterTransactionSubGroupCode = &additionalFilterTransactionSubGroupCode
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) End(end string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Start(start string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.start = &start
	return r
}

// Filters the results for reference.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) ReferenceWildCard(referenceWildCard string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.referenceWildCard = &referenceWildCard
	return r
}

// Filter the results for supplement.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) SupplementWildCard(supplementWildCard string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.supplementWildCard = &supplementWildCard
	return r
}

// Lookup string which will try to match an existing Cheque number&#39;s.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) CheckNumberWildCard(checkNumberWildCard string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.checkNumberWildCard = &checkNumberWildCard
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetInvoicePostingsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetInvoicePostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetInvoicePostingsRequest) Execute() (*InvoicePostings, *http.Response, error) {
	return r.ApiService.GetInvoicePostingsExecute(r)
}

/*
GetInvoicePostings Get account receivable invoice postings

Use this API to get account receivable postings. <p><strong>OperationId:</strong>getInvoicePostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIGetInvoicePostingsRequest
*/
func (a *AccountsReceivablesAPIService) GetInvoicePostings(ctx context.Context) AccountsReceivablesAPIGetInvoicePostingsRequest {
	return AccountsReceivablesAPIGetInvoicePostingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InvoicePostings
func (a *AccountsReceivablesAPIService) GetInvoicePostingsExecute(r AccountsReceivablesAPIGetInvoicePostingsRequest) (*InvoicePostings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicePostings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetInvoicePostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicePostings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.canBeModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", r.canBeModified, "")
  }
	if r.closeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", r.closeDate, "")
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.folioDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", r.folioDate, "")
  }
	if r.folioNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", r.folioNo, "")
  }
	if r.folioStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", r.folioStatus, "")
  }
	if r.folioTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", r.folioTypeName, "")
  }
	if r.internalFolioWindowID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", r.internalFolioWindowID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	if r.invoiceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", r.invoiceType, "")
  }
	if r.postingDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", r.postingDate, "")
  }
	if r.revenueDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", r.revenueDate, "")
  }
	if r.statementNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", r.statementNo, "")
  }
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
  }
	if r.transferDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", r.transferDate, "")
  }
	if r.postingTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingTransactionCode", r.postingTransactionCode, "")
  }
	if r.transactionDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", r.transactionDate, "")
  }
	if r.transactionNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", r.transactionNo, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
  }
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
  }
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
  }
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
  }
	if r.age != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age", r.age, "")
  }
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
  }
	if r.originalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmount", r.originalAmount, "")
  }
	if r.originalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmountCurrencyCode", r.originalAmountCurrencyCode, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.paymentsAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsAmount", r.paymentsAmount, "")
  }
	if r.paymentsCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsCurrencyCode", r.paymentsCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
  }
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
  }
	if r.adjusted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", r.adjusted, "")
  }
	if r.parentInvoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", r.parentInvoiceNo, "")
  }
	if r.compressed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", r.compressed, "")
  }
	if r.compressedDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", r.compressedDate, "")
  }
	if r.transferredOut != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", r.transferredOut, "")
  }
	if r.transferredIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", r.transferredIn, "")
  }
	if r.marketDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketDescription", r.marketDescription, "")
  }
	if r.marketHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketHotelId", r.marketHotelId, "")
  }
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
  }
	if r.marketGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroup", r.marketGroup, "")
  }
	if r.roomClassDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassDescription", r.roomClassDescription, "")
  }
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
  }
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
  }
	if r.sourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceDescription", r.sourceDescription, "")
  }
	if r.sourceHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceHotelId", r.sourceHotelId, "")
  }
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
  }
	if r.sourceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceGroup", r.sourceGroup, "")
  }
	if r.cashierInfoCashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierInfoCashierId", r.cashierInfoCashierId, "")
  }
	if r.cashierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierName", r.cashierName, "")
  }
	if r.transactionHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", r.transactionHotelId, "")
  }
	if r.printTrxReceipt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", r.printTrxReceipt, "")
  }
	if r.invoicePostingsTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePostingsTransactionCode", r.invoicePostingsTransactionCode, "")
  }
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
  }
	if r.transactionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", r.transactionGroup, "")
  }
	if r.transactionSubGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", r.transactionSubGroup, "")
  }
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
  }
	if r.routingInstructionsId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", r.routingInstructionsId, "")
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.articleHotelIds != nil {
		t := *r.articleHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.articleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleAmount", r.articleAmount, "")
  }
	if r.articleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleCurrencyCode", r.articleCurrencyCode, "")
  }
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
  }
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
  }
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.cardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardId", r.cardId, "")
  }
	if r.paymentCardIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "PaymentCardIdContext", r.paymentCardIdContext, "")
  }
	if r.paymentCardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentCardIdType", r.paymentCardIdType, "")
  }
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
  }
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
  }
	if r.approvalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmount", r.approvalAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.addresseeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeType", r.addresseeType, "")
  }
	if r.addressProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressProfileId", r.addressProfileId, "")
  }
	if r.addressProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressProfileIdContext", r.addressProfileIdContext, "")
  }
	if r.addressProfileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressProfileIdType", r.addressProfileIdType, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
  }
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
  }
	if r.allowPartialTransferYn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", r.allowPartialTransferYn, "")
  }
	if r.printed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printed", r.printed, "")
  }
	if r.printedDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", r.printedDate, "")
  }
	if r.storedFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioId", r.storedFolioId, "")
  }
	if r.storedFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioIdContext", r.storedFolioIdContext, "")
  }
	if r.storedFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioType", r.storedFolioType, "")
  }
	if r.storedFolioName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", r.storedFolioName, "")
  }
	if r.storedDebitFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioId", r.storedDebitFolioId, "")
  }
	if r.storedDebitFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioIdContext", r.storedDebitFolioIdContext, "")
  }
	if r.storedDebitFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioType", r.storedDebitFolioType, "")
  }
	if r.storedDebitFolioName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", r.storedDebitFolioName, "")
  }
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
  }
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
  }
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
  }
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdType", r.profileIdType, "")
  }
	if r.additionalFilterCashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterCashierId", r.additionalFilterCashierId, "")
  }
	if r.additionalFilterTransactionCode != nil {
		t := *r.additionalFilterTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionCode", t, "multi")
		}
  }
	if r.additionalFilterTransactionSubGroupCode != nil {
		t := *r.additionalFilterTransactionSubGroupCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionSubGroupCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "additionalFilterTransactionSubGroupCode", t, "multi")
		}
  }
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
  }
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
  }
	if r.referenceWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceWildCard", r.referenceWildCard, "")
  }
	if r.supplementWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supplementWildCard", r.supplementWildCard, "")
  }
	if r.checkNumberWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkNumberWildCard", r.checkNumberWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetInvoicesOnHoldRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	profileId *string
	profileIdContext *string
	profileType *string
	id *string
	accountIdContext *string
	accountType *string
	accountNo *string
	accountName *string
	endDate *string
	startDate *string
	folios *string
	invoices *float32
	fiscalBillNo *string
	guestName *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) Authorization(authorization string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.xHotelid = &xHotelid
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) ProfileId(profileId string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) ProfileType(profileType string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.profileType = &profileType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) Id(id string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.id = &id
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) AccountIdContext(accountIdContext string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) AccountType(accountType string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.accountType = &accountType
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) AccountName(accountName string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.accountName = &accountName
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) EndDate(endDate string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.endDate = &endDate
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) StartDate(startDate string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.startDate = &startDate
	return r
}

// Folio Number for the invoice.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) Folios(folios string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.folios = &folios
	return r
}

// Invoice number for the invoice.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) Invoices(invoices float32) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.invoices = &invoices
	return r
}

// Fiscal Bill number for the invoice.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) FiscalBillNo(fiscalBillNo string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Guest Name set for the invoice.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) GuestName(guestName string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.guestName = &guestName
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetInvoicesOnHoldRequest) Execute() (*InvoicesOnHold, *http.Response, error) {
	return r.ApiService.GetInvoicesOnHoldExecute(r)
}

/*
GetInvoicesOnHold Get list of hold invoices for account receivable

Use this API to get list of account receivable invoices which are put on hold. <p><strong>OperationId:</strong>getInvoicesOnHold</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetInvoicesOnHoldRequest
*/
func (a *AccountsReceivablesAPIService) GetInvoicesOnHold(ctx context.Context, hotelId string) AccountsReceivablesAPIGetInvoicesOnHoldRequest {
	return AccountsReceivablesAPIGetInvoicesOnHoldRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return InvoicesOnHold
func (a *AccountsReceivablesAPIService) GetInvoicesOnHoldExecute(r AccountsReceivablesAPIGetInvoicesOnHoldRequest) (*InvoicesOnHold, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicesOnHold
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetInvoicesOnHold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/invoicesOnHold"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
  }
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
  }
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
  }
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
  }
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
  }
	if r.folios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folios", r.folios, "")
  }
	if r.invoices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoices", r.invoices, "")
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.guestName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", r.guestName, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetInvoicesPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	inclDetails *bool
	inclZeroBalance *bool
	limit *int32
	offset *int32
	hotelIds *[]string
	end *string
	start *string
	guestDisplayName *string
	remark *string
	reference *string
	invoiceNo *[]float32
	addresseeName *string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	printed *bool
	unBilled *bool
	folioNo *[]string
	fiscalBillNo *string
	statementNo *float32
	fetchInstructions *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Authorization(authorization string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if Invoice Details are required.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) InclDetails(inclDetails bool) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.inclDetails = &inclDetails
	return r
}

// Flag to indicate if Zero Balance Invoices are to be included.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) InclZeroBalance(inclZeroBalance bool) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.inclZeroBalance = &inclZeroBalance
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Limit(limit int32) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Offset(offset int32) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.offset = &offset
	return r
}

// Property where the Accounts exist.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) HotelIds(hotelIds []string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.hotelIds = &hotelIds
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) End(end string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.end = &end
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Start(start string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.start = &start
	return r
}

// Display Name for the guest.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) GuestDisplayName(guestDisplayName string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.guestDisplayName = &guestDisplayName
	return r
}

// Filter for User-defined Invoice Supplement. The search is case-insensitive and supports % as wildcard character with right-side wildcard search by default. Examples: ABC or ABC% finds records that start with ABC, such as ABC, ABCDEF, and ABC123. %ABC or %ABC% finds records that contain ABC, such as ABC, ABC123, MYABC, and MYABC123.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Remark(remark string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.remark = &remark
	return r
}

// Filter for User-defined Invoice Reference. The search is case-insensitive and supports % as wildcard character with right-side wildcard search by default. Examples: ABC or ABC% finds records that start with ABC, such as ABC, ABCDEF, and ABC123. %ABC or %ABC% finds records that contain ABC, such as ABC, ABC123, MYABC, and MYABC123.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Reference(reference string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.reference = &reference
	return r
}

// invoice Number .
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) InvoiceNo(invoiceNo []float32) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// Addressee Name filter. Works with the Addressee Functionality.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) AddresseeName(addresseeName string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.addresseeName = &addresseeName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) ReservationId(reservationId string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) ReservationIdContext(reservationIdContext string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) ReservationType(reservationType string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.reservationType = &reservationType
	return r
}

// Flag to check Invoice Statement is Printed.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Printed(printed bool) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.printed = &printed
	return r
}

// Flag to check Invoice is billed
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) UnBilled(unBilled bool) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.unBilled = &unBilled
	return r
}

// folio Number .
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) FolioNo(folioNo []string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.folioNo = &folioNo
	return r
}

// Fiscal bill number of this transaction.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) FiscalBillNo(fiscalBillNo string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// The Statement number of this invoice.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) StatementNo(statementNo float32) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.statementNo = &statementNo
	return r
}

// Type of AR Invoice information to fetch the invoices or payments data.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) FetchInstructions(fetchInstructions []string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.fetchInstructions = &fetchInstructions
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetInvoicesPaymentsRequest) Execute() (*InvoicesPayments, *http.Response, error) {
	return r.ApiService.GetInvoicesPaymentsExecute(r)
}

/*
GetInvoicesPayments Get payment detail for account's invoices

Use this API to get payment data for account receivable invoices. <p><strong>OperationId:</strong>getInvoicesPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return AccountsReceivablesAPIGetInvoicesPaymentsRequest
*/
func (a *AccountsReceivablesAPIService) GetInvoicesPayments(ctx context.Context, accountId string) AccountsReceivablesAPIGetInvoicesPaymentsRequest {
	return AccountsReceivablesAPIGetInvoicesPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return InvoicesPayments
func (a *AccountsReceivablesAPIService) GetInvoicesPaymentsExecute(r AccountsReceivablesAPIGetInvoicesPaymentsRequest) (*InvoicesPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoicesPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetInvoicesPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicePayments/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}

	if r.inclDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclDetails", r.inclDetails, "")
  }
	if r.inclZeroBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZeroBalance", r.inclZeroBalance, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
  }
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
  }
	if r.guestDisplayName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestDisplayName", r.guestDisplayName, "")
  }
	if r.remark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remark", r.remark, "")
  }
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
  }
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
  }
	if r.addresseeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeName", r.addresseeName, "")
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
  }
	if r.printed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printed", r.printed, "")
  }
	if r.unBilled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unBilled", r.unBilled, "")
  }
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
  }
	if r.fiscalBillNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", r.fiscalBillNo, "")
  }
	if r.statementNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", r.statementNo, "")
  }
	if r.fetchInstructions != nil {
		t := *r.fetchInstructions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInstructions", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetProfileAgingRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	currency *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetProfileAgingRequest) Authorization(authorization string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetProfileAgingRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetProfileAgingRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency of the aging amounts.
func (r AccountsReceivablesAPIGetProfileAgingRequest) Currency(currency string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.currency = &currency
	return r
}

func (r AccountsReceivablesAPIGetProfileAgingRequest) HotelIds(hotelIds []string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetProfileAgingRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetProfileAgingRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetProfileAgingRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetProfileAgingRequest) Execute() (*ProfileAging, *http.Response, error) {
	return r.ApiService.GetProfileAgingExecute(r)
}

/*
GetProfileAging Get given profile's aging detail

Use this API to get profile's account receivable summary including fixed charges, account balance, statements, reminder history, etc. <p><strong>OperationId:</strong>getProfileAging</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @return AccountsReceivablesAPIGetProfileAgingRequest
*/
func (a *AccountsReceivablesAPIService) GetProfileAging(ctx context.Context, profileId string) AccountsReceivablesAPIGetProfileAgingRequest {
	return AccountsReceivablesAPIGetProfileAgingRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileAging
func (a *AccountsReceivablesAPIService) GetProfileAgingExecute(r AccountsReceivablesAPIGetProfileAgingRequest) (*ProfileAging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileAging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetProfileAging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/aging"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetProfileYearViewRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	profileId string
	authorization *string
	xAppKey *string
	xHotelid *string
	currency *string
	hotelIds *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetProfileYearViewRequest) Authorization(authorization string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetProfileYearViewRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetProfileYearViewRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.xHotelid = &xHotelid
	return r
}

// Currency of the Year View amounts.
func (r AccountsReceivablesAPIGetProfileYearViewRequest) Currency(currency string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.currency = &currency
	return r
}

func (r AccountsReceivablesAPIGetProfileYearViewRequest) HotelIds(hotelIds []string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.hotelIds = &hotelIds
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetProfileYearViewRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetProfileYearViewRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetProfileYearViewRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetProfileYearViewRequest) Execute() (*ProfileYearView, *http.Response, error) {
	return r.ApiService.GetProfileYearViewExecute(r)
}

/*
GetProfileYearView Get given profile's yearly account receivable detail

Use this API to get a month-by-month total of accrued debits, accrued credits, and a net total for the selected account data. <p><strong>OperationId:</strong>getProfileYearView</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId Unique ID of the profile
 @return AccountsReceivablesAPIGetProfileYearViewRequest
*/
func (a *AccountsReceivablesAPIService) GetProfileYearView(ctx context.Context, profileId string) AccountsReceivablesAPIGetProfileYearViewRequest {
	return AccountsReceivablesAPIGetProfileYearViewRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileYearView
func (a *AccountsReceivablesAPIService) GetProfileYearViewExecute(r AccountsReceivablesAPIGetProfileYearViewRequest) (*ProfileYearView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileYearView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetProfileYearView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profileId}/yearViews"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
  }
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetRemindersRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accounts *[]string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	profiles *[]string
	accountNo *[]string
	accountName *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetRemindersRequest) Accounts(accounts []string) AccountsReceivablesAPIGetRemindersRequest {
	r.accounts = &accounts
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetRemindersRequest) Authorization(authorization string) AccountsReceivablesAPIGetRemindersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetRemindersRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetRemindersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetRemindersRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetRemindersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetRemindersRequest) HotelIds(hotelIds []string) AccountsReceivablesAPIGetRemindersRequest {
	r.hotelIds = &hotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetRemindersRequest) Profiles(profiles []string) AccountsReceivablesAPIGetRemindersRequest {
	r.profiles = &profiles
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetRemindersRequest) AccountNo(accountNo []string) AccountsReceivablesAPIGetRemindersRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetRemindersRequest) AccountName(accountName []string) AccountsReceivablesAPIGetRemindersRequest {
	r.accountName = &accountName
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetRemindersRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetRemindersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetRemindersRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetRemindersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetRemindersRequest) Execute() (*Reminders, *http.Response, error) {
	return r.ApiService.GetRemindersExecute(r)
}

/*
GetReminders Get account receivable's reminder statements

Use this API to get AR account holders' reminder letter that includes detail of payment due, their current account balance, or for other purposes. <p><strong>OperationId:</strong>getReminders</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIGetRemindersRequest
*/
func (a *AccountsReceivablesAPIService) GetReminders(ctx context.Context) AccountsReceivablesAPIGetRemindersRequest {
	return AccountsReceivablesAPIGetRemindersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Reminders
func (a *AccountsReceivablesAPIService) GetRemindersExecute(r AccountsReceivablesAPIGetRemindersRequest) (*Reminders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reminders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetReminders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountReminders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	{
		t := *r.accounts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accounts", t, "multi")
		}
	}
	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.profiles != nil {
		t := *r.profiles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profiles", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profiles", t, "multi")
		}
  }
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
  }
	if r.accountName != nil {
		t := *r.accountName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetRemindersHistoryRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *string
	profileId *string
	accountIdContext *string
	accountType *string
	accountNo *string
	accountName *string
	dateSent *string
	reportFileNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) Authorization(authorization string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) HotelId(hotelId string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) ProfileId(profileId string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) AccountIdContext(accountIdContext string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.accountIdContext = &accountIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) AccountType(accountType string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.accountType = &accountType
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) AccountName(accountName string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.accountName = &accountName
	return r
}

// History Date filter.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) DateSent(dateSent string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.dateSent = &dateSent
	return r
}

// Report Name wild card.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) ReportFileNameWildCard(reportFileNameWildCard string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.reportFileNameWildCard = &reportFileNameWildCard
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetRemindersHistoryRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetRemindersHistoryRequest) Execute() (*RemindersHistory, *http.Response, error) {
	return r.ApiService.GetRemindersHistoryExecute(r)
}

/*
GetRemindersHistory Get history of reminder letters for a given account receivable

Use this API to get history of reminder letters prepared for AR account. <p><strong>OperationId:</strong>getRemindersHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return AccountsReceivablesAPIGetRemindersHistoryRequest
*/
func (a *AccountsReceivablesAPIService) GetRemindersHistory(ctx context.Context, accountId string) AccountsReceivablesAPIGetRemindersHistoryRequest {
	return AccountsReceivablesAPIGetRemindersHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return RemindersHistory
func (a *AccountsReceivablesAPIService) GetRemindersHistoryExecute(r AccountsReceivablesAPIGetRemindersHistoryRequest) (*RemindersHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemindersHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetRemindersHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/remindersHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.accountIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIdContext", r.accountIdContext, "")
  }
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "")
  }
	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	if r.dateSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateSent", r.dateSent, "")
  }
	if r.reportFileNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportFileNameWildCard", r.reportFileNameWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetStatementsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	profileId *string
	profileIdContext *string
	profileType *string
	accountNo *[]string
	accountName *[]string
	canBeModified *[]bool
	closeDate *[]string
	fiscalBillNo *[]string
	folioDate *[]string
	folioNo *[]float32
	folioStatus *[]string
	folioTypeName *[]string
	internalFolioWindowID *[]string
	invoiceNo *[]float32
	invoiceType *[]string
	postingDate *[]string
	revenueDate *[]string
	statementNo *[]int32
	status *[]string
	transferDate *[]string
	invoiceTransactionCode *[]string
	transactionDate *[]string
	transactionNo *[]float32
	invoiceHotelIds *[]string
	reservationId *string
	reservationIdContext *string
	reservationType *string
	guestProfileId *string
	guestProfileIdContext *string
	guestProfileType *string
	age *[]int32
	guestName *[]string
	originalAmount *float32
	originalAmountCurrencyCode *string
	amount *float32
	currencyCode *string
	paymentsAmount *float32
	paymentsCurrencyCode *string
	balanceAmount *float32
	balanceCurrencyCode *string
	reference *[]string
	remark *[]string
	adjusted *[]bool
	parentInvoiceNo *[]float32
	compressed *[]bool
	compressedDate *[]string
	transferredOut *[]bool
	transferredIn *[]bool
	marketDescription *string
	marketHotelId *string
	marketCode *string
	marketGroup *string
	roomClassDescription *string
	roomClassHotelId *string
	roomClassCode *string
	sourceDescription *string
	sourceHotelId *string
	sourceCode *string
	sourceGroup *string
	cashierId *float32
	cashierName *string
	transactionHotelId *string
	printTrxReceipt *bool
	accountInvoiceTransactionCode *string
	transactionDescription *string
	transactionGroup *string
	transactionSubGroup *string
	universalProductCode *string
	routingInstructionsId *float32
	articleCode *[]string
	articleHotelIds *[]string
	inactive *[]bool
	orderSequence *[]float32
	articleDescription *[]string
	transactionCode *[]string
	articleAmount *float32
	articleCurrencyCode *string
	availableForPostIt *bool
	color *string
	articleUniversalProductCode *[]string
	attachCreditCardToProfile *bool
	cardHolderName *string
	cardNumber *string
	cardNumberLast4Digits *string
	cardNumberMasked *string
	cardOrToken *string
	cardType *string
	expirationDate *string
	expirationDateExpired *bool
	expirationDateMasked *string
	processing *string
	swiped *bool
	userDefinedCardType *string
	invoicePaymentCardId *string
	invoicePaymentCardIdContext *string
	invoicePaymentCardIdType *string
	currentAuthorizedAmount *float32
	currentAuthorizedAmountCurrencyCode *string
	approvalAmount *float32
	approvalAmountCurrencyCode *string
	type_ *string
	addresseeProfileId *string
	addresseeProfileIdContext *string
	addresseeProfileType *string
	name *string
	city *string
	phone *string
	allowPartialTransferYn *[]bool
	printed *[]bool
	printedDate *[]string
	storedFolioId *string
	storedFolioIdContext *string
	storedFolioType *string
	storedFolioName *[]string
	storedDebitFolioId *string
	storedDebitFolioIdContext *string
	storedDebitFolioType *string
	storedDebitFolioName *[]string
	balanceForwardDate *string
	inclFolios *bool
	inclPrinted *bool
	inclZero *bool
	filterEndDate *string
	filterStartDate *string
	statementText *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetStatementsRequest) Authorization(authorization string) AccountsReceivablesAPIGetStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetStatementsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetStatementsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) HotelId(hotelId []string) AccountsReceivablesAPIGetStatementsRequest {
	r.hotelId = &hotelId
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) ProfileId(profileId string) AccountsReceivablesAPIGetStatementsRequest {
	r.profileId = &profileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) ProfileIdContext(profileIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.profileIdContext = &profileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) ProfileType(profileType string) AccountsReceivablesAPIGetStatementsRequest {
	r.profileType = &profileType
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetStatementsRequest) AccountNo(accountNo []string) AccountsReceivablesAPIGetStatementsRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetStatementsRequest) AccountName(accountName []string) AccountsReceivablesAPIGetStatementsRequest {
	r.accountName = &accountName
	return r
}

// Flag to indicate if postings or adjustments can be made to the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) CanBeModified(canBeModified []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.canBeModified = &canBeModified
	return r
}

// Close date of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) CloseDate(closeDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.closeDate = &closeDate
	return r
}

// The Fiscal Bill number of this posting
func (r AccountsReceivablesAPIGetStatementsRequest) FiscalBillNo(fiscalBillNo []string) AccountsReceivablesAPIGetStatementsRequest {
	r.fiscalBillNo = &fiscalBillNo
	return r
}

// Date of Folio Generation.
func (r AccountsReceivablesAPIGetStatementsRequest) FolioDate(folioDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.folioDate = &folioDate
	return r
}

// Folio Number.
func (r AccountsReceivablesAPIGetStatementsRequest) FolioNo(folioNo []float32) AccountsReceivablesAPIGetStatementsRequest {
	r.folioNo = &folioNo
	return r
}

// The Folio Status Example: DEPOSIT folio, VOID folio or the default OK folio status.
func (r AccountsReceivablesAPIGetStatementsRequest) FolioStatus(folioStatus []string) AccountsReceivablesAPIGetStatementsRequest {
	r.folioStatus = &folioStatus
	return r
}

// The name of the Folio Type used for the Folio Number sequence.
func (r AccountsReceivablesAPIGetStatementsRequest) FolioTypeName(folioTypeName []string) AccountsReceivablesAPIGetStatementsRequest {
	r.folioTypeName = &folioTypeName
	return r
}

// Internal window ID which is unique to the reservation. This ID can only be used for reference.
func (r AccountsReceivablesAPIGetStatementsRequest) InternalFolioWindowID(internalFolioWindowID []string) AccountsReceivablesAPIGetStatementsRequest {
	r.internalFolioWindowID = &internalFolioWindowID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIGetStatementsRequest) InvoiceNo(invoiceNo []float32) AccountsReceivablesAPIGetStatementsRequest {
	r.invoiceNo = &invoiceNo
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) InvoiceType(invoiceType []string) AccountsReceivablesAPIGetStatementsRequest {
	r.invoiceType = &invoiceType
	return r
}

// Posting date of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) PostingDate(postingDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.postingDate = &postingDate
	return r
}

// Revenue date ID of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) RevenueDate(revenueDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.revenueDate = &revenueDate
	return r
}

// Statementno of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) StatementNo(statementNo []int32) AccountsReceivablesAPIGetStatementsRequest {
	r.statementNo = &statementNo
	return r
}

// Status of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) Status(status []string) AccountsReceivablesAPIGetStatementsRequest {
	r.status = &status
	return r
}

// Transfer date of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) TransferDate(transferDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.transferDate = &transferDate
	return r
}

// Transaction code of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) InvoiceTransactionCode(invoiceTransactionCode []string) AccountsReceivablesAPIGetStatementsRequest {
	r.invoiceTransactionCode = &invoiceTransactionCode
	return r
}

// Transaction Date of the invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionDate(transactionDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionDate = &transactionDate
	return r
}

// Unique Transaction Identifier of the Invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionNo(transactionNo []float32) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionNo = &transactionNo
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) InvoiceHotelIds(invoiceHotelIds []string) AccountsReceivablesAPIGetStatementsRequest {
	r.invoiceHotelIds = &invoiceHotelIds
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) ReservationId(reservationId string) AccountsReceivablesAPIGetStatementsRequest {
	r.reservationId = &reservationId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) ReservationIdContext(reservationIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.reservationIdContext = &reservationIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) ReservationType(reservationType string) AccountsReceivablesAPIGetStatementsRequest {
	r.reservationType = &reservationType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) GuestProfileId(guestProfileId string) AccountsReceivablesAPIGetStatementsRequest {
	r.guestProfileId = &guestProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) GuestProfileIdContext(guestProfileIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.guestProfileIdContext = &guestProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) GuestProfileType(guestProfileType string) AccountsReceivablesAPIGetStatementsRequest {
	r.guestProfileType = &guestProfileType
	return r
}

// The Aging age of the invoice
func (r AccountsReceivablesAPIGetStatementsRequest) Age(age []int32) AccountsReceivablesAPIGetStatementsRequest {
	r.age = &age
	return r
}

// Name of the Guest who consumed these transactions.
func (r AccountsReceivablesAPIGetStatementsRequest) GuestName(guestName []string) AccountsReceivablesAPIGetStatementsRequest {
	r.guestName = &guestName
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) OriginalAmount(originalAmount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.originalAmount = &originalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) OriginalAmountCurrencyCode(originalAmountCurrencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.originalAmountCurrencyCode = &originalAmountCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) Amount(amount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.amount = &amount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) CurrencyCode(currencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.currencyCode = &currencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) PaymentsAmount(paymentsAmount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.paymentsAmount = &paymentsAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) PaymentsCurrencyCode(paymentsCurrencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.paymentsCurrencyCode = &paymentsCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) BalanceAmount(balanceAmount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.balanceAmount = &balanceAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) BalanceCurrencyCode(balanceCurrencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.balanceCurrencyCode = &balanceCurrencyCode
	return r
}

// User-defined posting reference.
func (r AccountsReceivablesAPIGetStatementsRequest) Reference(reference []string) AccountsReceivablesAPIGetStatementsRequest {
	r.reference = &reference
	return r
}

// User-defined posting remark.
func (r AccountsReceivablesAPIGetStatementsRequest) Remark(remark []string) AccountsReceivablesAPIGetStatementsRequest {
	r.remark = &remark
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) Adjusted(adjusted []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.adjusted = &adjusted
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) ParentInvoiceNo(parentInvoiceNo []float32) AccountsReceivablesAPIGetStatementsRequest {
	r.parentInvoiceNo = &parentInvoiceNo
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) Compressed(compressed []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.compressed = &compressed
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) CompressedDate(compressedDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.compressedDate = &compressedDate
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) TransferredOut(transferredOut []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.transferredOut = &transferredOut
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) TransferredIn(transferredIn []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.transferredIn = &transferredIn
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) MarketDescription(marketDescription string) AccountsReceivablesAPIGetStatementsRequest {
	r.marketDescription = &marketDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) MarketHotelId(marketHotelId string) AccountsReceivablesAPIGetStatementsRequest {
	r.marketHotelId = &marketHotelId
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) MarketCode(marketCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.marketCode = &marketCode
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) MarketGroup(marketGroup string) AccountsReceivablesAPIGetStatementsRequest {
	r.marketGroup = &marketGroup
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) RoomClassDescription(roomClassDescription string) AccountsReceivablesAPIGetStatementsRequest {
	r.roomClassDescription = &roomClassDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) RoomClassHotelId(roomClassHotelId string) AccountsReceivablesAPIGetStatementsRequest {
	r.roomClassHotelId = &roomClassHotelId
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) RoomClassCode(roomClassCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.roomClassCode = &roomClassCode
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) SourceDescription(sourceDescription string) AccountsReceivablesAPIGetStatementsRequest {
	r.sourceDescription = &sourceDescription
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) SourceHotelId(sourceHotelId string) AccountsReceivablesAPIGetStatementsRequest {
	r.sourceHotelId = &sourceHotelId
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) SourceCode(sourceCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.sourceCode = &sourceCode
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) SourceGroup(sourceGroup string) AccountsReceivablesAPIGetStatementsRequest {
	r.sourceGroup = &sourceGroup
	return r
}

// Cashier Id of the Cashier.
func (r AccountsReceivablesAPIGetStatementsRequest) CashierId(cashierId float32) AccountsReceivablesAPIGetStatementsRequest {
	r.cashierId = &cashierId
	return r
}

// Cashier Name.
func (r AccountsReceivablesAPIGetStatementsRequest) CashierName(cashierName string) AccountsReceivablesAPIGetStatementsRequest {
	r.cashierName = &cashierName
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionHotelId(transactionHotelId string) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionHotelId = &transactionHotelId
	return r
}

// Print receipt flag that tells whether the transaction receipt is to be printed or not. This is based on the transaction code.
func (r AccountsReceivablesAPIGetStatementsRequest) PrintTrxReceipt(printTrxReceipt bool) AccountsReceivablesAPIGetStatementsRequest {
	r.printTrxReceipt = &printTrxReceipt
	return r
}

// Unique identifier for the Transaction code.
func (r AccountsReceivablesAPIGetStatementsRequest) AccountInvoiceTransactionCode(accountInvoiceTransactionCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.accountInvoiceTransactionCode = &accountInvoiceTransactionCode
	return r
}

// Transaction codes info.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionDescription(transactionDescription string) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionDescription = &transactionDescription
	return r
}

// Category of the transaction code.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionGroup(transactionGroup string) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionGroup = &transactionGroup
	return r
}

// Sub category of the transaction code.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionSubGroup(transactionSubGroup string) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionSubGroup = &transactionSubGroup
	return r
}

// Unique Universal product code of the transaction code.
func (r AccountsReceivablesAPIGetStatementsRequest) UniversalProductCode(universalProductCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.universalProductCode = &universalProductCode
	return r
}

// This is the Routing Instruction Id attached with Reservation. It is only used for internal purpose. It should not be used by external vendor or consumer.
func (r AccountsReceivablesAPIGetStatementsRequest) RoutingInstructionsId(routingInstructionsId float32) AccountsReceivablesAPIGetStatementsRequest {
	r.routingInstructionsId = &routingInstructionsId
	return r
}

// Unique code of the article.
func (r AccountsReceivablesAPIGetStatementsRequest) ArticleCode(articleCode []string) AccountsReceivablesAPIGetStatementsRequest {
	r.articleCode = &articleCode
	return r
}

// Property where the AR Account exists. This is required.
func (r AccountsReceivablesAPIGetStatementsRequest) ArticleHotelIds(articleHotelIds []string) AccountsReceivablesAPIGetStatementsRequest {
	r.articleHotelIds = &articleHotelIds
	return r
}

// Indicates whether the article is inactive or not.
func (r AccountsReceivablesAPIGetStatementsRequest) Inactive(inactive []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.inactive = &inactive
	return r
}

// Display Order sequence.
func (r AccountsReceivablesAPIGetStatementsRequest) OrderSequence(orderSequence []float32) AccountsReceivablesAPIGetStatementsRequest {
	r.orderSequence = &orderSequence
	return r
}

// Description of the article.
func (r AccountsReceivablesAPIGetStatementsRequest) ArticleDescription(articleDescription []string) AccountsReceivablesAPIGetStatementsRequest {
	r.articleDescription = &articleDescription
	return r
}

// Transaction code to which the article belongs.
func (r AccountsReceivablesAPIGetStatementsRequest) TransactionCode(transactionCode []string) AccountsReceivablesAPIGetStatementsRequest {
	r.transactionCode = &transactionCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) ArticleAmount(articleAmount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.articleAmount = &articleAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) ArticleCurrencyCode(articleCurrencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.articleCurrencyCode = &articleCurrencyCode
	return r
}

// Indicates whether the article is available for post it.
func (r AccountsReceivablesAPIGetStatementsRequest) AvailableForPostIt(availableForPostIt bool) AccountsReceivablesAPIGetStatementsRequest {
	r.availableForPostIt = &availableForPostIt
	return r
}

// Color configuration type. This color configuration provides a visual category of entities.
func (r AccountsReceivablesAPIGetStatementsRequest) Color(color string) AccountsReceivablesAPIGetStatementsRequest {
	r.color = &color
	return r
}

// Unique Universal product code of the article.
func (r AccountsReceivablesAPIGetStatementsRequest) ArticleUniversalProductCode(articleUniversalProductCode []string) AccountsReceivablesAPIGetStatementsRequest {
	r.articleUniversalProductCode = &articleUniversalProductCode
	return r
}

// Attach the credit card to profile.
func (r AccountsReceivablesAPIGetStatementsRequest) AttachCreditCardToProfile(attachCreditCardToProfile bool) AccountsReceivablesAPIGetStatementsRequest {
	r.attachCreditCardToProfile = &attachCreditCardToProfile
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) CardHolderName(cardHolderName string) AccountsReceivablesAPIGetStatementsRequest {
	r.cardHolderName = &cardHolderName
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) CardNumber(cardNumber string) AccountsReceivablesAPIGetStatementsRequest {
	r.cardNumber = &cardNumber
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) CardNumberLast4Digits(cardNumberLast4Digits string) AccountsReceivablesAPIGetStatementsRequest {
	r.cardNumberLast4Digits = &cardNumberLast4Digits
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) CardNumberMasked(cardNumberMasked string) AccountsReceivablesAPIGetStatementsRequest {
	r.cardNumberMasked = &cardNumberMasked
	return r
}

// Simple type for indicating if credit card number is tokenized.
func (r AccountsReceivablesAPIGetStatementsRequest) CardOrToken(cardOrToken string) AccountsReceivablesAPIGetStatementsRequest {
	r.cardOrToken = &cardOrToken
	return r
}

// This is required for Credit Card Payment Methods. This indicates the type of Credit Card associated with this payment method.
func (r AccountsReceivablesAPIGetStatementsRequest) CardType(cardType string) AccountsReceivablesAPIGetStatementsRequest {
	r.cardType = &cardType
	return r
}

// Expiration date of the credit card
func (r AccountsReceivablesAPIGetStatementsRequest) ExpirationDate(expirationDate string) AccountsReceivablesAPIGetStatementsRequest {
	r.expirationDate = &expirationDate
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) ExpirationDateExpired(expirationDateExpired bool) AccountsReceivablesAPIGetStatementsRequest {
	r.expirationDateExpired = &expirationDateExpired
	return r
}

// Masked Expiration date of the credit card
func (r AccountsReceivablesAPIGetStatementsRequest) ExpirationDateMasked(expirationDateMasked string) AccountsReceivablesAPIGetStatementsRequest {
	r.expirationDateMasked = &expirationDateMasked
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) Processing(processing string) AccountsReceivablesAPIGetStatementsRequest {
	r.processing = &processing
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) Swiped(swiped bool) AccountsReceivablesAPIGetStatementsRequest {
	r.swiped = &swiped
	return r
}

// Indicates the user defined credit card type if credit card type from a defined list is not provided
func (r AccountsReceivablesAPIGetStatementsRequest) UserDefinedCardType(userDefinedCardType string) AccountsReceivablesAPIGetStatementsRequest {
	r.userDefinedCardType = &userDefinedCardType
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) InvoicePaymentCardId(invoicePaymentCardId string) AccountsReceivablesAPIGetStatementsRequest {
	r.invoicePaymentCardId = &invoicePaymentCardId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) InvoicePaymentCardIdContext(invoicePaymentCardIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.invoicePaymentCardIdContext = &invoicePaymentCardIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) InvoicePaymentCardIdType(invoicePaymentCardIdType string) AccountsReceivablesAPIGetStatementsRequest {
	r.invoicePaymentCardIdType = &invoicePaymentCardIdType
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) CurrentAuthorizedAmount(currentAuthorizedAmount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.currentAuthorizedAmount = &currentAuthorizedAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) CurrentAuthorizedAmountCurrencyCode(currentAuthorizedAmountCurrencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.currentAuthorizedAmountCurrencyCode = &currentAuthorizedAmountCurrencyCode
	return r
}

// A monetary amount.
func (r AccountsReceivablesAPIGetStatementsRequest) ApprovalAmount(approvalAmount float32) AccountsReceivablesAPIGetStatementsRequest {
	r.approvalAmount = &approvalAmount
	return r
}

// Provides a currency code to reflect the currency in which an amount may be expressed.
func (r AccountsReceivablesAPIGetStatementsRequest) ApprovalAmountCurrencyCode(approvalAmountCurrencyCode string) AccountsReceivablesAPIGetStatementsRequest {
	r.approvalAmountCurrencyCode = &approvalAmountCurrencyCode
	return r
}

// Defines the type of Linked profiles for a block.
func (r AccountsReceivablesAPIGetStatementsRequest) Type_(type_ string) AccountsReceivablesAPIGetStatementsRequest {
	r.type_ = &type_
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) AddresseeProfileId(addresseeProfileId string) AccountsReceivablesAPIGetStatementsRequest {
	r.addresseeProfileId = &addresseeProfileId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) AddresseeProfileIdContext(addresseeProfileIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.addresseeProfileIdContext = &addresseeProfileIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) AddresseeProfileType(addresseeProfileType string) AccountsReceivablesAPIGetStatementsRequest {
	r.addresseeProfileType = &addresseeProfileType
	return r
}

// Name for the profile attached to the block.
func (r AccountsReceivablesAPIGetStatementsRequest) Name(name string) AccountsReceivablesAPIGetStatementsRequest {
	r.name = &name
	return r
}

// City for the profile attached to the block.
func (r AccountsReceivablesAPIGetStatementsRequest) City(city string) AccountsReceivablesAPIGetStatementsRequest {
	r.city = &city
	return r
}

// Phone for the profile attached to the block.
func (r AccountsReceivablesAPIGetStatementsRequest) Phone(phone string) AccountsReceivablesAPIGetStatementsRequest {
	r.phone = &phone
	return r
}

// Flag to check Partail Transfer Allowed.
func (r AccountsReceivablesAPIGetStatementsRequest) AllowPartialTransferYn(allowPartialTransferYn []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.allowPartialTransferYn = &allowPartialTransferYn
	return r
}

// Flag to check Invoice Statement is Printed.
func (r AccountsReceivablesAPIGetStatementsRequest) Printed(printed []bool) AccountsReceivablesAPIGetStatementsRequest {
	r.printed = &printed
	return r
}

// Invoice Statement Printed Date.
func (r AccountsReceivablesAPIGetStatementsRequest) PrintedDate(printedDate []string) AccountsReceivablesAPIGetStatementsRequest {
	r.printedDate = &printedDate
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) StoredFolioId(storedFolioId string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedFolioId = &storedFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) StoredFolioIdContext(storedFolioIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedFolioIdContext = &storedFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) StoredFolioType(storedFolioType string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedFolioType = &storedFolioType
	return r
}

// Name of the Stored Folio.
func (r AccountsReceivablesAPIGetStatementsRequest) StoredFolioName(storedFolioName []string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedFolioName = &storedFolioName
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIGetStatementsRequest) StoredDebitFolioId(storedDebitFolioId string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedDebitFolioId = &storedDebitFolioId
	return r
}

// Used to identify the source of the identifier (e.g., IATA, ABTA).
func (r AccountsReceivablesAPIGetStatementsRequest) StoredDebitFolioIdContext(storedDebitFolioIdContext string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedDebitFolioIdContext = &storedDebitFolioIdContext
	return r
}

// A reference to the type of object defined by the UniqueID element.
func (r AccountsReceivablesAPIGetStatementsRequest) StoredDebitFolioType(storedDebitFolioType string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedDebitFolioType = &storedDebitFolioType
	return r
}

// Name of the Stored Debit Folio.
func (r AccountsReceivablesAPIGetStatementsRequest) StoredDebitFolioName(storedDebitFolioName []string) AccountsReceivablesAPIGetStatementsRequest {
	r.storedDebitFolioName = &storedDebitFolioName
	return r
}

// The date specified in this field determines the balance forward date and balance forward total that is printed on the statement. (A balance forward shows the net amount for all invoices and payments (debits and credits) prior to the balance forward date as a single total, rather than itemizing them individually on the statement.)
func (r AccountsReceivablesAPIGetStatementsRequest) BalanceForwardDate(balanceForwardDate string) AccountsReceivablesAPIGetStatementsRequest {
	r.balanceForwardDate = &balanceForwardDate
	return r
}

// Flag to indicate if the associated Folios for the Invoices are to be included along with the the Statement.
func (r AccountsReceivablesAPIGetStatementsRequest) InclFolios(inclFolios bool) AccountsReceivablesAPIGetStatementsRequest {
	r.inclFolios = &inclFolios
	return r
}

// Flag to indicate if Previousely Printed Invoices are to be included in the Statement. This is based on the Functionality for AR PRINTED INVOICES.
func (r AccountsReceivablesAPIGetStatementsRequest) InclPrinted(inclPrinted bool) AccountsReceivablesAPIGetStatementsRequest {
	r.inclPrinted = &inclPrinted
	return r
}

// Flag to indicate if Zero Balances Invoices are to be included in the Statement.
func (r AccountsReceivablesAPIGetStatementsRequest) InclZero(inclZero bool) AccountsReceivablesAPIGetStatementsRequest {
	r.inclZero = &inclZero
	return r
}

// The ending value of the date range.
func (r AccountsReceivablesAPIGetStatementsRequest) FilterEndDate(filterEndDate string) AccountsReceivablesAPIGetStatementsRequest {
	r.filterEndDate = &filterEndDate
	return r
}

// The starting value of the date range.
func (r AccountsReceivablesAPIGetStatementsRequest) FilterStartDate(filterStartDate string) AccountsReceivablesAPIGetStatementsRequest {
	r.filterStartDate = &filterStartDate
	return r
}

// Text which will be printed on the Invoice.
func (r AccountsReceivablesAPIGetStatementsRequest) StatementText(statementText string) AccountsReceivablesAPIGetStatementsRequest {
	r.statementText = &statementText
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetStatementsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetStatementsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetStatementsRequest) Execute() (*Statements, *http.Response, error) {
	return r.ApiService.GetStatementsExecute(r)
}

/*
GetStatements Get given profile's account receivable statements

Use this API to prepare statement for an AR account holders. It is typically prepared for billing purposes.<br><p><strong><mark>This API is deprecated. Please use getARStatements instead</mark></strong></p> <p><strong>OperationId:</strong>getStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @return AccountsReceivablesAPIGetStatementsRequest

Deprecated
*/
func (a *AccountsReceivablesAPIService) GetStatements(ctx context.Context, accountId string) AccountsReceivablesAPIGetStatementsRequest {
	return AccountsReceivablesAPIGetStatementsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return Statements
// Deprecated
func (a *AccountsReceivablesAPIService) GetStatementsExecute(r AccountsReceivablesAPIGetStatementsRequest) (*Statements, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Statements
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileId", r.profileId, "")
  }
	if r.profileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileIdContext", r.profileIdContext, "")
  }
	if r.profileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profileType", r.profileType, "")
  }
	if r.accountNo != nil {
		t := *r.accountNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", t, "multi")
		}
  }
	if r.accountName != nil {
		t := *r.accountName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", t, "multi")
		}
  }
	if r.canBeModified != nil {
		t := *r.canBeModified
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "canBeModified", t, "multi")
		}
  }
	if r.closeDate != nil {
		t := *r.closeDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "closeDate", t, "multi")
		}
  }
	if r.fiscalBillNo != nil {
		t := *r.fiscalBillNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fiscalBillNo", t, "multi")
		}
  }
	if r.folioDate != nil {
		t := *r.folioDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioDate", t, "multi")
		}
  }
	if r.folioNo != nil {
		t := *r.folioNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioNo", t, "multi")
		}
  }
	if r.folioStatus != nil {
		t := *r.folioStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioStatus", t, "multi")
		}
  }
	if r.folioTypeName != nil {
		t := *r.folioTypeName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "folioTypeName", t, "multi")
		}
  }
	if r.internalFolioWindowID != nil {
		t := *r.internalFolioWindowID
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "internalFolioWindowID", t, "multi")
		}
  }
	if r.invoiceNo != nil {
		t := *r.invoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", t, "multi")
		}
  }
	if r.invoiceType != nil {
		t := *r.invoiceType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceType", t, "multi")
		}
  }
	if r.postingDate != nil {
		t := *r.postingDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "postingDate", t, "multi")
		}
  }
	if r.revenueDate != nil {
		t := *r.revenueDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "revenueDate", t, "multi")
		}
  }
	if r.statementNo != nil {
		t := *r.statementNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statementNo", t, "multi")
		}
  }
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
  }
	if r.transferDate != nil {
		t := *r.transferDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferDate", t, "multi")
		}
  }
	if r.invoiceTransactionCode != nil {
		t := *r.invoiceTransactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceTransactionCode", t, "multi")
		}
  }
	if r.transactionDate != nil {
		t := *r.transactionDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDate", t, "multi")
		}
  }
	if r.transactionNo != nil {
		t := *r.transactionNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionNo", t, "multi")
		}
  }
	if r.invoiceHotelIds != nil {
		t := *r.invoiceHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceHotelIds", t, "multi")
		}
  }
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "")
  }
	if r.reservationIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationIdContext", r.reservationIdContext, "")
  }
	if r.reservationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationType", r.reservationType, "")
  }
	if r.guestProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileId", r.guestProfileId, "")
  }
	if r.guestProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileIdContext", r.guestProfileIdContext, "")
  }
	if r.guestProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guestProfileType", r.guestProfileType, "")
  }
	if r.age != nil {
		t := *r.age
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "age", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "age", t, "multi")
		}
  }
	if r.guestName != nil {
		t := *r.guestName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guestName", t, "multi")
		}
  }
	if r.originalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmount", r.originalAmount, "")
  }
	if r.originalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originalAmountCurrencyCode", r.originalAmountCurrencyCode, "")
  }
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
  }
	if r.currencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyCode", r.currencyCode, "")
  }
	if r.paymentsAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsAmount", r.paymentsAmount, "")
  }
	if r.paymentsCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsCurrencyCode", r.paymentsCurrencyCode, "")
  }
	if r.balanceAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAmount", r.balanceAmount, "")
  }
	if r.balanceCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceCurrencyCode", r.balanceCurrencyCode, "")
  }
	if r.reference != nil {
		t := *r.reference
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reference", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reference", t, "multi")
		}
  }
	if r.remark != nil {
		t := *r.remark
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remark", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remark", t, "multi")
		}
  }
	if r.adjusted != nil {
		t := *r.adjusted
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "adjusted", t, "multi")
		}
  }
	if r.parentInvoiceNo != nil {
		t := *r.parentInvoiceNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parentInvoiceNo", t, "multi")
		}
  }
	if r.compressed != nil {
		t := *r.compressed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", t, "multi")
		}
  }
	if r.compressedDate != nil {
		t := *r.compressedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "compressedDate", t, "multi")
		}
  }
	if r.transferredOut != nil {
		t := *r.transferredOut
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredOut", t, "multi")
		}
  }
	if r.transferredIn != nil {
		t := *r.transferredIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transferredIn", t, "multi")
		}
  }
	if r.marketDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketDescription", r.marketDescription, "")
  }
	if r.marketHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketHotelId", r.marketHotelId, "")
  }
	if r.marketCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketCode", r.marketCode, "")
  }
	if r.marketGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marketGroup", r.marketGroup, "")
  }
	if r.roomClassDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassDescription", r.roomClassDescription, "")
  }
	if r.roomClassHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassHotelId", r.roomClassHotelId, "")
  }
	if r.roomClassCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCode", r.roomClassCode, "")
  }
	if r.sourceDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceDescription", r.sourceDescription, "")
  }
	if r.sourceHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceHotelId", r.sourceHotelId, "")
  }
	if r.sourceCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceCode", r.sourceCode, "")
  }
	if r.sourceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceGroup", r.sourceGroup, "")
  }
	if r.cashierId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierId", r.cashierId, "")
  }
	if r.cashierName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierName", r.cashierName, "")
  }
	if r.transactionHotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionHotelId", r.transactionHotelId, "")
  }
	if r.printTrxReceipt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "printTrxReceipt", r.printTrxReceipt, "")
  }
	if r.accountInvoiceTransactionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountInvoiceTransactionCode", r.accountInvoiceTransactionCode, "")
  }
	if r.transactionDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDescription", r.transactionDescription, "")
  }
	if r.transactionGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionGroup", r.transactionGroup, "")
  }
	if r.transactionSubGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionSubGroup", r.transactionSubGroup, "")
  }
	if r.universalProductCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalProductCode", r.universalProductCode, "")
  }
	if r.routingInstructionsId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingInstructionsId", r.routingInstructionsId, "")
  }
	if r.articleCode != nil {
		t := *r.articleCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleCode", t, "multi")
		}
  }
	if r.articleHotelIds != nil {
		t := *r.articleHotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleHotelIds", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.orderSequence != nil {
		t := *r.orderSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderSequence", t, "multi")
		}
  }
	if r.articleDescription != nil {
		t := *r.articleDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleDescription", t, "multi")
		}
  }
	if r.transactionCode != nil {
		t := *r.transactionCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionCode", t, "multi")
		}
  }
	if r.articleAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleAmount", r.articleAmount, "")
  }
	if r.articleCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "articleCurrencyCode", r.articleCurrencyCode, "")
  }
	if r.availableForPostIt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableForPostIt", r.availableForPostIt, "")
  }
	if r.color != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "color", r.color, "")
  }
	if r.articleUniversalProductCode != nil {
		t := *r.articleUniversalProductCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "articleUniversalProductCode", t, "multi")
		}
  }
	if r.attachCreditCardToProfile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachCreditCardToProfile", r.attachCreditCardToProfile, "")
  }
	if r.cardHolderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardHolderName", r.cardHolderName, "")
  }
	if r.cardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumber", r.cardNumber, "")
  }
	if r.cardNumberLast4Digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberLast4Digits", r.cardNumberLast4Digits, "")
  }
	if r.cardNumberMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardNumberMasked", r.cardNumberMasked, "")
  }
	if r.cardOrToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardOrToken", r.cardOrToken, "")
  }
	if r.cardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cardType", r.cardType, "")
  }
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "")
  }
	if r.expirationDateExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateExpired", r.expirationDateExpired, "")
  }
	if r.expirationDateMasked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDateMasked", r.expirationDateMasked, "")
  }
	if r.processing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "processing", r.processing, "")
  }
	if r.swiped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "swiped", r.swiped, "")
  }
	if r.userDefinedCardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userDefinedCardType", r.userDefinedCardType, "")
  }
	if r.invoicePaymentCardId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardId", r.invoicePaymentCardId, "")
  }
	if r.invoicePaymentCardIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdContext", r.invoicePaymentCardIdContext, "")
  }
	if r.invoicePaymentCardIdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoicePaymentCardIdType", r.invoicePaymentCardIdType, "")
  }
	if r.currentAuthorizedAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmount", r.currentAuthorizedAmount, "")
  }
	if r.currentAuthorizedAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentAuthorizedAmountCurrencyCode", r.currentAuthorizedAmountCurrencyCode, "")
  }
	if r.approvalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmount", r.approvalAmount, "")
  }
	if r.approvalAmountCurrencyCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalAmountCurrencyCode", r.approvalAmountCurrencyCode, "")
  }
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
  }
	if r.addresseeProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileId", r.addresseeProfileId, "")
  }
	if r.addresseeProfileIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileIdContext", r.addresseeProfileIdContext, "")
  }
	if r.addresseeProfileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addresseeProfileType", r.addresseeProfileType, "")
  }
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
  }
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
  }
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
  }
	if r.allowPartialTransferYn != nil {
		t := *r.allowPartialTransferYn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowPartialTransferYn", t, "multi")
		}
  }
	if r.printed != nil {
		t := *r.printed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printed", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printed", t, "multi")
		}
  }
	if r.printedDate != nil {
		t := *r.printedDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "printedDate", t, "multi")
		}
  }
	if r.storedFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioId", r.storedFolioId, "")
  }
	if r.storedFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioIdContext", r.storedFolioIdContext, "")
  }
	if r.storedFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioType", r.storedFolioType, "")
  }
	if r.storedFolioName != nil {
		t := *r.storedFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedFolioName", t, "multi")
		}
  }
	if r.storedDebitFolioId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioId", r.storedDebitFolioId, "")
  }
	if r.storedDebitFolioIdContext != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioIdContext", r.storedDebitFolioIdContext, "")
  }
	if r.storedDebitFolioType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioType", r.storedDebitFolioType, "")
  }
	if r.storedDebitFolioName != nil {
		t := *r.storedDebitFolioName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "storedDebitFolioName", t, "multi")
		}
  }
	if r.balanceForwardDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceForwardDate", r.balanceForwardDate, "")
  }
	if r.inclFolios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclFolios", r.inclFolios, "")
  }
	if r.inclPrinted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclPrinted", r.inclPrinted, "")
  }
	if r.inclZero != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclZero", r.inclZero, "")
  }
	if r.filterEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndDate", r.filterEndDate, "")
  }
	if r.filterStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartDate", r.filterStartDate, "")
  }
	if r.statementText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statementText", r.statementText, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIGetStatementsHistoryRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountNo *string
	accountName *string
	dateSent *string
	reportFileNameWildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) Authorization(authorization string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) XAppKey(xAppKey string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) XHotelid(xHotelid string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Account Number for the AR Account.
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) AccountNo(accountNo string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.accountNo = &accountNo
	return r
}

// Account Name for the AR Account.
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) AccountName(accountName string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.accountName = &accountName
	return r
}

// History Date filter.
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) DateSent(dateSent string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.dateSent = &dateSent
	return r
}

// Report Name wild card.
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) ReportFileNameWildCard(reportFileNameWildCard string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.reportFileNameWildCard = &reportFileNameWildCard
	return r
}

// External system code.
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIGetStatementsHistoryRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIGetStatementsHistoryRequest) Execute() (*StatementHistory, *http.Response, error) {
	return r.ApiService.GetStatementsHistoryExecute(r)
}

/*
GetStatementsHistory Get given profile's account receivable statements history

Use this API to find the history of statements prepared for AR accounts. <p><strong>OperationId:</strong>getStatementsHistory</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIGetStatementsHistoryRequest
*/
func (a *AccountsReceivablesAPIService) GetStatementsHistory(ctx context.Context, accountId string, profileId string, hotelId string) AccountsReceivablesAPIGetStatementsHistoryRequest {
	return AccountsReceivablesAPIGetStatementsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return StatementHistory
func (a *AccountsReceivablesAPIService) GetStatementsHistoryExecute(r AccountsReceivablesAPIGetStatementsHistoryRequest) (*StatementHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.GetStatementsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/statementsHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.accountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNo", r.accountNo, "")
  }
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "")
  }
	if r.dateSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateSent", r.dateSent, "")
  }
	if r.reportFileNameWildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportFileNameWildCard", r.reportFileNameWildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostARChargesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arChargesPostingCriteria *ArChargesPostingCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostARChargesRequest) Authorization(authorization string) AccountsReceivablesAPIPostARChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostARChargesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostARChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostARChargesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostARChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post charges to an existing invoice, when the functionality is available. If the invoice should not be modified or if the folio should not be modified,based on other functionalities, then the charges cannot be posted to the invoice.
func (r AccountsReceivablesAPIPostARChargesRequest) ArChargesPostingCriteria(arChargesPostingCriteria ArChargesPostingCriteria) AccountsReceivablesAPIPostARChargesRequest {
	r.arChargesPostingCriteria = &arChargesPostingCriteria
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostARChargesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostARChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostARChargesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostARChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostARChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostARChargesExecute(r)
}

/*
PostARCharges Add charges to account receivable

Use this API to post charges to account receivable account.<br><p><strong><mark>This API is deprecated. Please use postChargesToAR instead</mark></strong></p> <p><strong>OperationId:</strong>postARCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostARChargesRequest

Deprecated
*/
func (a *AccountsReceivablesAPIService) PostARCharges(ctx context.Context, accountId string, profileId string, hotelId string) AccountsReceivablesAPIPostARChargesRequest {
	return AccountsReceivablesAPIPostARChargesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *AccountsReceivablesAPIService) PostARChargesExecute(r AccountsReceivablesAPIPostARChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostARCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arChargesPostingCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostAROldBalancesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	arOldBalances *ArOldBalances
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostAROldBalancesRequest) Authorization(authorization string) AccountsReceivablesAPIPostAROldBalancesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostAROldBalancesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostAROldBalancesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostAROldBalancesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostAROldBalancesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Post AR Old Balances
func (r AccountsReceivablesAPIPostAROldBalancesRequest) ArOldBalances(arOldBalances ArOldBalances) AccountsReceivablesAPIPostAROldBalancesRequest {
	r.arOldBalances = &arOldBalances
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostAROldBalancesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostAROldBalancesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostAROldBalancesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostAROldBalancesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostAROldBalancesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAROldBalancesExecute(r)
}

/*
PostAROldBalances Add old balances from external accounting systems

Use this API to add old balances from external accounting systems into OPERA Accounts Receivable. <p><strong>OperationId:</strong>postAROldBalances</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIPostAROldBalancesRequest
*/
func (a *AccountsReceivablesAPIService) PostAROldBalances(ctx context.Context) AccountsReceivablesAPIPostAROldBalancesRequest {
	return AccountsReceivablesAPIPostAROldBalancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostAROldBalancesExecute(r AccountsReceivablesAPIPostAROldBalancesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostAROldBalances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oldBalances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arOldBalances
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostARPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arPaymentsToBeCreated *ArPaymentsToBeCreated
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostARPaymentsRequest) Authorization(authorization string) AccountsReceivablesAPIPostARPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostARPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostARPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostARPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostARPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post a payment to an AR Account and apply the payment to Invoices..
func (r AccountsReceivablesAPIPostARPaymentsRequest) ArPaymentsToBeCreated(arPaymentsToBeCreated ArPaymentsToBeCreated) AccountsReceivablesAPIPostARPaymentsRequest {
	r.arPaymentsToBeCreated = &arPaymentsToBeCreated
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostARPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostARPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostARPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostARPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostARPaymentsRequest) Execute() (*ArPayments, *http.Response, error) {
	return r.ApiService.PostARPaymentsExecute(r)
}

/*
PostARPayments Add payment to an account receivable account for a list of reservations

Use this API to make payment to AR accounts for a list of reservations. <p><strong>OperationId:</strong>postARPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostARPaymentsRequest
*/
func (a *AccountsReceivablesAPIService) PostARPayments(ctx context.Context, accountId string, profileId string, hotelId string) AccountsReceivablesAPIPostARPaymentsRequest {
	return AccountsReceivablesAPIPostARPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArPayments
func (a *AccountsReceivablesAPIService) PostARPaymentsExecute(r AccountsReceivablesAPIPostARPaymentsRequest) (*ArPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostARPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/payments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arPaymentsToBeCreated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountCriteria *AccountCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostAccountRequest) Authorization(authorization string) AccountsReceivablesAPIPostAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostAccountRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostAccountRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new AR Account
func (r AccountsReceivablesAPIPostAccountRequest) AccountCriteria(accountCriteria AccountCriteria) AccountsReceivablesAPIPostAccountRequest {
	r.accountCriteria = &accountCriteria
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountExecute(r)
}

/*
PostAccount Create an account receivable account

Use this API to create a new account receivable type account for given OPERA profile id. Prior creating account, need to use getProfile to find OPERA profile's id.  <p><strong>OperationId:</strong>postAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostAccountRequest
*/
func (a *AccountsReceivablesAPIService) PostAccount(ctx context.Context, hotelId string) AccountsReceivablesAPIPostAccountRequest {
	return AccountsReceivablesAPIPostAccountRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostAccountExecute(r AccountsReceivablesAPIPostAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostAccountCommentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountComment *AccountComment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostAccountCommentRequest) Authorization(authorization string) AccountsReceivablesAPIPostAccountCommentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostAccountCommentRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostAccountCommentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostAccountCommentRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostAccountCommentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Comment for an Account.
func (r AccountsReceivablesAPIPostAccountCommentRequest) AccountComment(accountComment AccountComment) AccountsReceivablesAPIPostAccountCommentRequest {
	r.accountComment = &accountComment
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostAccountCommentRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostAccountCommentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostAccountCommentRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostAccountCommentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostAccountCommentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountCommentExecute(r)
}

/*
PostAccountComment Create Account Comment

Use this API to add a note for a given account id. Use get accounts to find account id. <p><strong>OperationId:</strong>postAccountComment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostAccountCommentRequest
*/
func (a *AccountsReceivablesAPIService) PostAccountComment(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostAccountCommentRequest {
	return AccountsReceivablesAPIPostAccountCommentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostAccountCommentExecute(r AccountsReceivablesAPIPostAccountCommentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostAccountComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostAccountFixedChargeRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountFixedCharge *AccountFixedCharge
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) Authorization(authorization string) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Fixed Charge for an Account.
func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) AccountFixedCharge(accountFixedCharge AccountFixedCharge) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	r.accountFixedCharge = &accountFixedCharge
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostAccountFixedChargeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountFixedChargeExecute(r)
}

/*
PostAccountFixedCharge Create fixed charges 

Use this API to create fixed charges for a given account id of account receivable. Use get accounts to find an account id. <p><strong>OperationId:</strong>postAccountFixedCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostAccountFixedChargeRequest
*/
func (a *AccountsReceivablesAPIService) PostAccountFixedCharge(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostAccountFixedChargeRequest {
	return AccountsReceivablesAPIPostAccountFixedChargeRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostAccountFixedChargeExecute(r AccountsReceivablesAPIPostAccountFixedChargeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostAccountFixedCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/fixedCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountFixedCharge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostAccountTraceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountTrace *AccountTrace
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostAccountTraceRequest) Authorization(authorization string) AccountsReceivablesAPIPostAccountTraceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostAccountTraceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostAccountTraceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostAccountTraceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostAccountTraceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a Trace for an Account.
func (r AccountsReceivablesAPIPostAccountTraceRequest) AccountTrace(accountTrace AccountTrace) AccountsReceivablesAPIPostAccountTraceRequest {
	r.accountTrace = &accountTrace
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostAccountTraceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostAccountTraceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostAccountTraceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostAccountTraceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostAccountTraceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostAccountTraceExecute(r)
}

/*
PostAccountTrace Add a trace to an account receivable account

Use this API to add a trace for a given account id. Use getaccounts to find account id. <p><strong>OperationId:</strong>postAccountTrace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostAccountTraceRequest
*/
func (a *AccountsReceivablesAPIService) PostAccountTrace(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostAccountTraceRequest {
	return AccountsReceivablesAPIPostAccountTraceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostAccountTraceExecute(r AccountsReceivablesAPIPostAccountTraceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostAccountTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountTrace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostBatchChargesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	batchChargesToPost *BatchChargesToPost
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostBatchChargesRequest) Authorization(authorization string) AccountsReceivablesAPIPostBatchChargesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostBatchChargesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostBatchChargesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostBatchChargesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostBatchChargesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for posting a charge in a batch to list of accounts.
func (r AccountsReceivablesAPIPostBatchChargesRequest) BatchChargesToPost(batchChargesToPost BatchChargesToPost) AccountsReceivablesAPIPostBatchChargesRequest {
	r.batchChargesToPost = &batchChargesToPost
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostBatchChargesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostBatchChargesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostBatchChargesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostBatchChargesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostBatchChargesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostBatchChargesExecute(r)
}

/*
PostBatchCharges Create process to charge on multiple account receivables

Use this API to create a batch process for simultaneously post a one-time charge to multiple account receivable accounts. <p><strong>OperationId:</strong>postBatchCharges</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostBatchChargesRequest
*/
func (a *AccountsReceivablesAPIService) PostBatchCharges(ctx context.Context, hotelId string) AccountsReceivablesAPIPostBatchChargesRequest {
	return AccountsReceivablesAPIPostBatchChargesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostBatchChargesExecute(r AccountsReceivablesAPIPostBatchChargesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostBatchCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/batchCharges"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.batchChargesToPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostChargesToARRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arChargesPostingCriteria *ArChargesPostingCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostChargesToARRequest) Authorization(authorization string) AccountsReceivablesAPIPostChargesToARRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostChargesToARRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostChargesToARRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostChargesToARRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostChargesToARRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to post charges to an existing invoice, when the functionality is available. If the invoice should not be modified or if the folio should not be modified,based on other functionalities, then the charges cannot be posted to the invoice.
func (r AccountsReceivablesAPIPostChargesToARRequest) ArChargesPostingCriteria(arChargesPostingCriteria ArChargesPostingCriteria) AccountsReceivablesAPIPostChargesToARRequest {
	r.arChargesPostingCriteria = &arChargesPostingCriteria
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostChargesToARRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostChargesToARRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostChargesToARRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostChargesToARRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostChargesToARRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostChargesToARExecute(r)
}

/*
PostChargesToAR Add charges to account receivable

Use this API to post charges to account receivable account. <p><strong>OperationId:</strong>postChargesToAR</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostChargesToARRequest
*/
func (a *AccountsReceivablesAPIService) PostChargesToAR(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostChargesToARRequest {
	return AccountsReceivablesAPIPostChargesToARRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostChargesToARExecute(r AccountsReceivablesAPIPostChargesToARRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostChargesToAR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/charges"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arChargesPostingCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostCreditToInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	creditToInvoices *CreditToInvoices
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) Authorization(authorization string) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) CreditToInvoices(creditToInvoices CreditToInvoices) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	r.creditToInvoices = &creditToInvoices
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostCreditToInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCreditToInvoicesExecute(r)
}

/*
PostCreditToInvoices Add credits to AR invoices

Use this API to add credits to account receivable invoices. <p><strong>OperationId:</strong>postCreditToInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostCreditToInvoicesRequest
*/
func (a *AccountsReceivablesAPIService) PostCreditToInvoices(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostCreditToInvoicesRequest {
	return AccountsReceivablesAPIPostCreditToInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostCreditToInvoicesExecute(r AccountsReceivablesAPIPostCreditToInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostCreditToInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/applyCreditToInvoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.creditToInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arInvoice *ArInvoice
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostInvoiceRequest) Authorization(authorization string) AccountsReceivablesAPIPostInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostInvoiceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostInvoiceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to create a new Invoice for an Account.
func (r AccountsReceivablesAPIPostInvoiceRequest) ArInvoice(arInvoice ArInvoice) AccountsReceivablesAPIPostInvoiceRequest {
	r.arInvoice = &arInvoice
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostInvoiceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostInvoiceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostInvoiceRequest) Execute() (*ArInvoiceDetails, *http.Response, error) {
	return r.ApiService.PostInvoiceExecute(r)
}

/*
PostInvoice Create account receivable invoices

Use this API to create a new invoice for an AR account. <p><strong>OperationId:</strong>postInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostInvoiceRequest
*/
func (a *AccountsReceivablesAPIService) PostInvoice(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostInvoiceRequest {
	return AccountsReceivablesAPIPostInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return ArInvoiceDetails
func (a *AccountsReceivablesAPIService) PostInvoiceExecute(r AccountsReceivablesAPIPostInvoiceRequest) (*ArInvoiceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArInvoiceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/invoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arInvoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostRemindersRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	reminders *Reminders
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostRemindersRequest) Authorization(authorization string) AccountsReceivablesAPIPostRemindersRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostRemindersRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostRemindersRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostRemindersRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostRemindersRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to update the reminder information on an Account. After the letter has been generated and sent, the account and the invoices will be updated with the Reminder Cycle information. This is done so that the next cycle of Reminder Letters c can be generated correctly.
func (r AccountsReceivablesAPIPostRemindersRequest) Reminders(reminders Reminders) AccountsReceivablesAPIPostRemindersRequest {
	r.reminders = &reminders
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostRemindersRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostRemindersRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostRemindersRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostRemindersRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostRemindersRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRemindersExecute(r)
}

/*
PostReminders Generate reminders

Use this API to generate a reminder statement which includes payment due,  current account balance, and etc. of account receivable account holder. <p><strong>OperationId:</strong>postReminders</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIPostRemindersRequest
*/
func (a *AccountsReceivablesAPIService) PostReminders(ctx context.Context) AccountsReceivablesAPIPostRemindersRequest {
	return AccountsReceivablesAPIPostRemindersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostRemindersExecute(r AccountsReceivablesAPIPostRemindersRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostReminders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accountReminders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reminders
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostReversePaymentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	transactionId string
	accountId string
	profileId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	reversePayment *ReversePayment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostReversePaymentRequest) Authorization(authorization string) AccountsReceivablesAPIPostReversePaymentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostReversePaymentRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostReversePaymentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostReversePaymentRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostReversePaymentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for reverse AR payment
func (r AccountsReceivablesAPIPostReversePaymentRequest) ReversePayment(reversePayment ReversePayment) AccountsReceivablesAPIPostReversePaymentRequest {
	r.reversePayment = &reversePayment
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostReversePaymentRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostReversePaymentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostReversePaymentRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostReversePaymentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostReversePaymentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostReversePaymentExecute(r)
}

/*
PostReversePayment Reverse Payment

Use this API to reverse payment that occurred accidently or via user error. <p><strong>OperationId:</strong>postReversePayment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param accountId Unique ID of the account
 @param profileId Unique ID of the profile
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostReversePaymentRequest
*/
func (a *AccountsReceivablesAPIService) PostReversePayment(ctx context.Context, transactionId string, accountId string, profileId string, hotelId string) AccountsReceivablesAPIPostReversePaymentRequest {
	return AccountsReceivablesAPIPostReversePaymentRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		accountId: accountId,
		profileId: profileId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostReversePaymentExecute(r AccountsReceivablesAPIPostReversePaymentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostReversePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/profiles/{profileId}/accounts/{accountId}/transactions/{transactionId}/reversePayment"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.profileId) < 1 {
		return localVarReturnValue, nil, reportError("profileId must have at least 1 elements")
	}
	if strlen(r.profileId) > 2000 {
		return localVarReturnValue, nil, reportError("profileId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.reversePayment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPostStatementsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	statementsToBeGenerated *StatementsToBeGenerated
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPostStatementsRequest) Authorization(authorization string) AccountsReceivablesAPIPostStatementsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPostStatementsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPostStatementsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPostStatementsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPostStatementsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Operation to generate AR Statements. This will validate and check if there exists any invoices to be included in the Statement based on the criteria used. If Statement Numbering is used, this will return a statement number to use in report as well as report sequence id to identify statement&#39;s invoices.
func (r AccountsReceivablesAPIPostStatementsRequest) StatementsToBeGenerated(statementsToBeGenerated StatementsToBeGenerated) AccountsReceivablesAPIPostStatementsRequest {
	r.statementsToBeGenerated = &statementsToBeGenerated
	return r
}

// External system code.
func (r AccountsReceivablesAPIPostStatementsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPostStatementsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPostStatementsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPostStatementsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPostStatementsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostStatementsExecute(r)
}

/*
PostStatements Generate a statement for a given account receivable

Use this API to generate statement for a given account receivable id. It includes the account balance as of the current business date, an aging summary that shows how long outstanding balances have been "on the books" for each aging level set up for given property. <p><strong>OperationId:</strong>postStatements</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPostStatementsRequest
*/
func (a *AccountsReceivablesAPIService) PostStatements(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPostStatementsRequest {
	return AccountsReceivablesAPIPostStatementsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PostStatementsExecute(r AccountsReceivablesAPIPostStatementsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PostStatements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.statementsToBeGenerated
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutARInvoicesAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	arInvoicesAccount *ArInvoicesAccount
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) Authorization(authorization string) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change AR invoice(s) account in AR.
func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) ArInvoicesAccount(arInvoicesAccount ArInvoicesAccount) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	r.arInvoicesAccount = &arInvoicesAccount
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutARInvoicesAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutARInvoicesAccountExecute(r)
}

/*
PutARInvoicesAccount Change Account receivable invoice for an AR account

Use this API to update existing AR invoice for a given profile and/or a reservation. <p><strong>OperationId:</strong>putARInvoicesAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIPutARInvoicesAccountRequest
*/
func (a *AccountsReceivablesAPIService) PutARInvoicesAccount(ctx context.Context) AccountsReceivablesAPIPutARInvoicesAccountRequest {
	return AccountsReceivablesAPIPutARInvoicesAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutARInvoicesAccountExecute(r AccountsReceivablesAPIPutARInvoicesAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutARInvoicesAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoicesAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arInvoicesAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutAccountRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	account *Account
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutAccountRequest) Authorization(authorization string) AccountsReceivablesAPIPutAccountRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutAccountRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutAccountRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutAccountRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutAccountRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to change and existing AR Account. The Account No, Credit Limit, Address, Email, Telephone information, Permanent Flag, Primary Account Flag, Contact Name are the details that can be changed on an existing account.
func (r AccountsReceivablesAPIPutAccountRequest) Account(account Account) AccountsReceivablesAPIPutAccountRequest {
	r.account = &account
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutAccountRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutAccountRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutAccountRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutAccountRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutAccountRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountExecute(r)
}

/*
PutAccount Update a account receivable account

Use this API to update existing account using account id and further detail. Use get account to get account detail prior updating. <p><strong>OperationId:</strong>putAccount</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPutAccountRequest
*/
func (a *AccountsReceivablesAPIService) PutAccount(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPutAccountRequest {
	return AccountsReceivablesAPIPutAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutAccountExecute(r AccountsReceivablesAPIPutAccountRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.account
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutAccountCommentRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountComment *AccountComment
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutAccountCommentRequest) Authorization(authorization string) AccountsReceivablesAPIPutAccountCommentRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutAccountCommentRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutAccountCommentRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutAccountCommentRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutAccountCommentRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Change the Comment on an Account.
func (r AccountsReceivablesAPIPutAccountCommentRequest) AccountComment(accountComment AccountComment) AccountsReceivablesAPIPutAccountCommentRequest {
	r.accountComment = &accountComment
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutAccountCommentRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutAccountCommentRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutAccountCommentRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutAccountCommentRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutAccountCommentRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountCommentExecute(r)
}

/*
PutAccountComment Change Account Comment

Use this API to update existing account note. Use get account to find noteid <p><strong>OperationId:</strong>putAccountComment</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPutAccountCommentRequest
*/
func (a *AccountsReceivablesAPIService) PutAccountComment(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPutAccountCommentRequest {
	return AccountsReceivablesAPIPutAccountCommentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutAccountCommentExecute(r AccountsReceivablesAPIPutAccountCommentRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutAccountComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutAccountFixedChargeRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	fixedChargeId string
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountFixedCharge *AccountFixedCharge
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) Authorization(authorization string) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Change the Fixed Charge on an Account.
func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) AccountFixedCharge(accountFixedCharge AccountFixedCharge) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	r.accountFixedCharge = &accountFixedCharge
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutAccountFixedChargeRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountFixedChargeExecute(r)
}

/*
PutAccountFixedCharge Update fixed charge detail 

Use this API to update existing fixed charges for a given account receivable. <p><strong>OperationId:</strong>putAccountFixedCharge</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fixedChargeId ID of the fixed charge
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPutAccountFixedChargeRequest
*/
func (a *AccountsReceivablesAPIService) PutAccountFixedCharge(ctx context.Context, fixedChargeId string, accountId string, hotelId string) AccountsReceivablesAPIPutAccountFixedChargeRequest {
	return AccountsReceivablesAPIPutAccountFixedChargeRequest{
		ApiService: a,
		ctx: ctx,
		fixedChargeId: fixedChargeId,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutAccountFixedChargeExecute(r AccountsReceivablesAPIPutAccountFixedChargeRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutAccountFixedCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/fixedCharges/{fixedChargeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fixedChargeId"+"}", url.PathEscape(parameterValueToString(r.fixedChargeId, "fixedChargeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.fixedChargeId) < 1 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have at least 1 elements")
	}
	if strlen(r.fixedChargeId) > 2000 {
		return localVarReturnValue, nil, reportError("fixedChargeId must have less than 2000 elements")
	}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountFixedCharge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutAccountTraceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accountTrace *AccountTrace
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutAccountTraceRequest) Authorization(authorization string) AccountsReceivablesAPIPutAccountTraceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutAccountTraceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutAccountTraceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutAccountTraceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutAccountTraceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to Change the Trace on an Account.
func (r AccountsReceivablesAPIPutAccountTraceRequest) AccountTrace(accountTrace AccountTrace) AccountsReceivablesAPIPutAccountTraceRequest {
	r.accountTrace = &accountTrace
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutAccountTraceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutAccountTraceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutAccountTraceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutAccountTraceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutAccountTraceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutAccountTraceExecute(r)
}

/*
PutAccountTrace This API facilitates modification of account traces.

 <p><strong>OperationId:</strong>putAccountTrace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPutAccountTraceRequest
*/
func (a *AccountsReceivablesAPIService) PutAccountTrace(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIPutAccountTraceRequest {
	return AccountsReceivablesAPIPutAccountTraceRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutAccountTraceExecute(r AccountsReceivablesAPIPutAccountTraceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutAccountTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.accountTrace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	invoiceId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoice *Invoice
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutInvoiceRequest) Authorization(authorization string) AccountsReceivablesAPIPutInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutInvoiceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutInvoiceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Response to the request to change invoice
func (r AccountsReceivablesAPIPutInvoiceRequest) Invoice(invoice Invoice) AccountsReceivablesAPIPutInvoiceRequest {
	r.invoice = &invoice
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutInvoiceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutInvoiceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInvoiceExecute(r)
}

/*
PutInvoice Update invoice detail.

Use this API to update or transfer invoice detail such as amount, transaction code, etc.<br><p><strong><mark>This API is deprecated. Please use putInvoiceDetails instead</mark></strong></p> <p><strong>OperationId:</strong>putInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId Unique ID of the invoice
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPutInvoiceRequest

Deprecated
*/
func (a *AccountsReceivablesAPIService) PutInvoice(ctx context.Context, invoiceId string, hotelId string) AccountsReceivablesAPIPutInvoiceRequest {
	return AccountsReceivablesAPIPutInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
// Deprecated
func (a *AccountsReceivablesAPIService) PutInvoiceExecute(r AccountsReceivablesAPIPutInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.invoiceId) < 1 {
		return localVarReturnValue, nil, reportError("invoiceId must have at least 1 elements")
	}
	if strlen(r.invoiceId) > 2000 {
		return localVarReturnValue, nil, reportError("invoiceId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutInvoiceDetailsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoice *Invoice
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) Authorization(authorization string) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Response to the request to change invoice
func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) Invoice(invoice Invoice) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	r.invoice = &invoice
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutInvoiceDetailsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInvoiceDetailsExecute(r)
}

/*
PutInvoiceDetails Update invoice detail.

Use this API to update or transfer invoice detail such as amount, transaction code, etc. <p><strong>OperationId:</strong>putInvoiceDetails</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIPutInvoiceDetailsRequest
*/
func (a *AccountsReceivablesAPIService) PutInvoiceDetails(ctx context.Context, hotelId string) AccountsReceivablesAPIPutInvoiceDetailsRequest {
	return AccountsReceivablesAPIPutInvoiceDetailsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutInvoiceDetailsExecute(r AccountsReceivablesAPIPutInvoiceDetailsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutInvoiceDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/invoices"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIPutInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	invoices *Invoices
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIPutInvoicesRequest) Authorization(authorization string) AccountsReceivablesAPIPutInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIPutInvoicesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIPutInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIPutInvoicesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIPutInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to close invoice(s)
func (r AccountsReceivablesAPIPutInvoicesRequest) Invoices(invoices Invoices) AccountsReceivablesAPIPutInvoicesRequest {
	r.invoices = &invoices
	return r
}

// External system code.
func (r AccountsReceivablesAPIPutInvoicesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIPutInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIPutInvoicesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIPutInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIPutInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PutInvoicesExecute(r)
}

/*
PutInvoices Close account receivable invoices

Use this API to close ("freeze") one or more selected invoices at any point after they have been created. When an invoice has been closed, no new postings to the invoice can be made, transaction reference or supplemental information can be edited, or adjustments to transaction codes can be made. However, payments can be posted to an invoice after it has been closed. <p><strong>OperationId:</strong>putInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIPutInvoicesRequest
*/
func (a *AccountsReceivablesAPIService) PutInvoices(ctx context.Context) AccountsReceivablesAPIPutInvoicesRequest {
	return AccountsReceivablesAPIPutInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) PutInvoicesExecute(r AccountsReceivablesAPIPutInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.PutInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	transactionId string
	hotelId string
	trxNo *[]float32
	accountId *string
	authorization *string
	xAppKey *string
	xHotelid *string
	cashierID *float32
	invoiceNo *float32
	xExternalsystem *string
	acceptLanguage *string
}

// Unique Transaction Identifier of the Payment.
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) TrxNo(trxNo []float32) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.trxNo = &trxNo
	return r
}

// A unique identifying value assigned by the creating system. The ID attribute may be used to reference a primary-key value within a database or in a particular implementation.
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) AccountId(accountId string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.accountId = &accountId
	return r
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) Authorization(authorization string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) XAppKey(xAppKey string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) XHotelid(xHotelid string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.xHotelid = &xHotelid
	return r
}

// The Cashier ID of the Cashier who is currently processing the transaction(s).
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) CashierID(cashierID float32) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.cashierID = &cashierID
	return r
}

// Invoice No after the folio is generated. Same invoice number may be referred in multiple folios
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) InvoiceNo(invoiceNo float32) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.invoiceNo = &invoiceNo
	return r
}

// External system code.
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemovePaymentsFromInvoiceExecute(r)
}

/*
RemovePaymentsFromInvoice Delete payments from invoice

Delete payments from invoice. <p><strong>OperationId:</strong>removePaymentsFromInvoice</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Unique ID of the transaction
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest
*/
func (a *AccountsReceivablesAPIService) RemovePaymentsFromInvoice(ctx context.Context, transactionId string, hotelId string) AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest {
	return AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) RemovePaymentsFromInvoiceExecute(r AccountsReceivablesAPIRemovePaymentsFromInvoiceRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.RemovePaymentsFromInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/transactions/{transactionId}/paymentsFromInvoice"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.transactionId) < 1 {
		return localVarReturnValue, nil, reportError("transactionId must have at least 1 elements")
	}
	if strlen(r.transactionId) > 2000 {
		return localVarReturnValue, nil, reportError("transactionId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	{
		t := *r.trxNo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "trxNo", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	if r.cashierID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cashierID", r.cashierID, "")
  }
	if r.invoiceNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoiceNo", r.invoiceNo, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIReopenInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	invoices *Invoices
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIReopenInvoicesRequest) Authorization(authorization string) AccountsReceivablesAPIReopenInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIReopenInvoicesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIReopenInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIReopenInvoicesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIReopenInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to re-open closed invoice(s)
func (r AccountsReceivablesAPIReopenInvoicesRequest) Invoices(invoices Invoices) AccountsReceivablesAPIReopenInvoicesRequest {
	r.invoices = &invoices
	return r
}

// External system code.
func (r AccountsReceivablesAPIReopenInvoicesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIReopenInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIReopenInvoicesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIReopenInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIReopenInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ReopenInvoicesExecute(r)
}

/*
ReopenInvoices Reopen account receivable closed invoice

Use this API to unfreeze or reopen invoice for account receivable. <p><strong>OperationId:</strong>reopenInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPIReopenInvoicesRequest
*/
func (a *AccountsReceivablesAPIService) ReopenInvoices(ctx context.Context) AccountsReceivablesAPIReopenInvoicesRequest {
	return AccountsReceivablesAPIReopenInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) ReopenInvoicesExecute(r AccountsReceivablesAPIReopenInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.ReopenInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reopenInvoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPITransferARCreditCardPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	arCreditCardPaymentsToTransfer *ArCreditCardPaymentsToTransfer
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) Authorization(authorization string) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to transfer AR Credit Card payments.
func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) ArCreditCardPaymentsToTransfer(arCreditCardPaymentsToTransfer ArCreditCardPaymentsToTransfer) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	r.arCreditCardPaymentsToTransfer = &arCreditCardPaymentsToTransfer
	return r
}

// External system code.
func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferARCreditCardPaymentsExecute(r)
}

/*
TransferARCreditCardPayments Move credit card payment to account receivable

Use this API to transfer credit card payment transactions to Accounts Receivable. <p><strong>OperationId:</strong>transferARCreditCardPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPITransferARCreditCardPaymentsRequest
*/
func (a *AccountsReceivablesAPIService) TransferARCreditCardPayments(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPITransferARCreditCardPaymentsRequest {
	return AccountsReceivablesAPITransferARCreditCardPaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) TransferARCreditCardPaymentsExecute(r AccountsReceivablesAPITransferARCreditCardPaymentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.TransferARCreditCardPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/arCreditCard/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.arCreditCardPaymentsToTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPITransferDirectBillsToArRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	transferDirectBillsToAr *TransferDirectBillsToAr
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPITransferDirectBillsToArRequest) Authorization(authorization string) AccountsReceivablesAPITransferDirectBillsToArRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPITransferDirectBillsToArRequest) XAppKey(xAppKey string) AccountsReceivablesAPITransferDirectBillsToArRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPITransferDirectBillsToArRequest) XHotelid(xHotelid string) AccountsReceivablesAPITransferDirectBillsToArRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for Transfer Directs bill to AR.
func (r AccountsReceivablesAPITransferDirectBillsToArRequest) TransferDirectBillsToAr(transferDirectBillsToAr TransferDirectBillsToAr) AccountsReceivablesAPITransferDirectBillsToArRequest {
	r.transferDirectBillsToAr = &transferDirectBillsToAr
	return r
}

// External system code.
func (r AccountsReceivablesAPITransferDirectBillsToArRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPITransferDirectBillsToArRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPITransferDirectBillsToArRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPITransferDirectBillsToArRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPITransferDirectBillsToArRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferDirectBillsToArExecute(r)
}

/*
TransferDirectBillsToAr Move direct bills to account receivable

Use this API to transfer direct bills to account receivable account <p><strong>OperationId:</strong>transferDirectBillsToAr</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPITransferDirectBillsToArRequest
*/
func (a *AccountsReceivablesAPIService) TransferDirectBillsToAr(ctx context.Context, hotelId string) AccountsReceivablesAPITransferDirectBillsToArRequest {
	return AccountsReceivablesAPITransferDirectBillsToArRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) TransferDirectBillsToArExecute(r AccountsReceivablesAPITransferDirectBillsToArRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.TransferDirectBillsToAr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/directBillsToAR"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transferDirectBillsToAr
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPITransferInvoicesAndPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	invoicesAndPaymentsToTransfer *InvoicesAndPaymentsToTransfer
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) Authorization(authorization string) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) XAppKey(xAppKey string) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) XHotelid(xHotelid string) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transferring invoice(s) in AR.
func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) InvoicesAndPaymentsToTransfer(invoicesAndPaymentsToTransfer InvoicesAndPaymentsToTransfer) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	r.invoicesAndPaymentsToTransfer = &invoicesAndPaymentsToTransfer
	return r
}

// External system code.
func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferInvoicesAndPaymentsExecute(r)
}

/*
TransferInvoicesAndPayments Move an invoice or a payment to another AR account

Use this API to move all or a portion of an invoice or a payment from one AR account to another AR account <p><strong>OperationId:</strong>transferInvoicesAndPayments</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPITransferInvoicesAndPaymentsRequest
*/
func (a *AccountsReceivablesAPIService) TransferInvoicesAndPayments(ctx context.Context) AccountsReceivablesAPITransferInvoicesAndPaymentsRequest {
	return AccountsReceivablesAPITransferInvoicesAndPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) TransferInvoicesAndPaymentsExecute(r AccountsReceivablesAPITransferInvoicesAndPaymentsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.TransferInvoicesAndPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferInvoicesAndPayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoicesAndPaymentsToTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPITransferPostingsRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	transferPostings *TransferPostings
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPITransferPostingsRequest) Authorization(authorization string) AccountsReceivablesAPITransferPostingsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPITransferPostingsRequest) XAppKey(xAppKey string) AccountsReceivablesAPITransferPostingsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPITransferPostingsRequest) XHotelid(xHotelid string) AccountsReceivablesAPITransferPostingsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request for transferring invoice posting(s)in AR.
func (r AccountsReceivablesAPITransferPostingsRequest) TransferPostings(transferPostings TransferPostings) AccountsReceivablesAPITransferPostingsRequest {
	r.transferPostings = &transferPostings
	return r
}

// External system code.
func (r AccountsReceivablesAPITransferPostingsRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPITransferPostingsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPITransferPostingsRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPITransferPostingsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPITransferPostingsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.TransferPostingsExecute(r)
}

/*
TransferPostings Transfer postings

Use this API to transfer postings from one account receivable invoice to another account receivable invoice. <p><strong>OperationId:</strong>transferPostings</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountsReceivablesAPITransferPostingsRequest
*/
func (a *AccountsReceivablesAPIService) TransferPostings(ctx context.Context) AccountsReceivablesAPITransferPostingsRequest {
	return AccountsReceivablesAPITransferPostingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) TransferPostingsExecute(r AccountsReceivablesAPITransferPostingsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.TransferPostings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferPostings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.transferPostings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIUncompressARInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	accountId string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	invoice *Invoice
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIUncompressARInvoicesRequest) Authorization(authorization string) AccountsReceivablesAPIUncompressARInvoicesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIUncompressARInvoicesRequest) XAppKey(xAppKey string) AccountsReceivablesAPIUncompressARInvoicesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIUncompressARInvoicesRequest) XHotelid(xHotelid string) AccountsReceivablesAPIUncompressARInvoicesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to uncompress a compressed(Parent) Invoice
func (r AccountsReceivablesAPIUncompressARInvoicesRequest) Invoice(invoice Invoice) AccountsReceivablesAPIUncompressARInvoicesRequest {
	r.invoice = &invoice
	return r
}

// External system code.
func (r AccountsReceivablesAPIUncompressARInvoicesRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIUncompressARInvoicesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIUncompressARInvoicesRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIUncompressARInvoicesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIUncompressARInvoicesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UncompressARInvoicesExecute(r)
}

/*
UncompressARInvoices Reverse the compressing invoice process

Use this API to reverse compressing account receivable invoices and break single combined invoice into individual invoices. <p><strong>OperationId:</strong>uncompressARInvoices</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Unique ID of the account
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIUncompressARInvoicesRequest
*/
func (a *AccountsReceivablesAPIService) UncompressARInvoices(ctx context.Context, accountId string, hotelId string) AccountsReceivablesAPIUncompressARInvoicesRequest {
	return AccountsReceivablesAPIUncompressARInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) UncompressARInvoicesExecute(r AccountsReceivablesAPIUncompressARInvoicesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.UncompressARInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/accounts/{accountId}/uncompressInvoices"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountId) < 1 {
		return localVarReturnValue, nil, reportError("accountId must have at least 1 elements")
	}
	if strlen(r.accountId) > 2000 {
		return localVarReturnValue, nil, reportError("accountId must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.invoice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest struct {
	ctx context.Context
	ApiService *AccountsReceivablesAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	unlinkInvoiceFromStatement *UnlinkInvoiceFromStatement
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) Authorization(authorization string) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) XAppKey(xAppKey string) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) XHotelid(xHotelid string) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request to unlink invoice from statement
func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) UnlinkInvoiceFromStatement(unlinkInvoiceFromStatement UnlinkInvoiceFromStatement) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	r.unlinkInvoiceFromStatement = &unlinkInvoiceFromStatement
	return r
}

// External system code.
func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) XExternalsystem(xExternalsystem string) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) AcceptLanguage(acceptLanguage string) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.UnlinkInvoiceFromStatementExecute(r)
}

/*
UnlinkInvoiceFromStatement Unlink invoices from a statement

Use this API to remove the invoice from the statement before that invoice can be included in a different statement. <p><strong>OperationId:</strong>unlinkInvoiceFromStatement</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of the hotel
 @return AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest
*/
func (a *AccountsReceivablesAPIService) UnlinkInvoiceFromStatement(ctx context.Context, hotelId string) AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest {
	return AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *AccountsReceivablesAPIService) UnlinkInvoiceFromStatementExecute(r AccountsReceivablesAPIUnlinkInvoiceFromStatementRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsReceivablesAPIService.UnlinkInvoiceFromStatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/unlink/invoiceFromStatement"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.unlinkInvoiceFromStatement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
