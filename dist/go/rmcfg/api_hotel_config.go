/*
OPERA Cloud Room Configuration API

APIs to cater for room configuration, such as configuring room types, room Classes, creating new room features, or updating housekeeping room maintenance reasons.<br /><br /> Compatible with OPERA Cloud release 22.3.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 22.3
Contact: hospitality_apis_ww_grp@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigApiService HotelConfigApi service
type HotelConfigApiService service

type HotelConfigApiGetRoomTypeInfoRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	roomTypeCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomTypeInfoRequest) Authorization(authorization string) HotelConfigApiGetRoomTypeInfoRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomTypeInfoRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomTypeInfoRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomTypeInfoRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomTypeInfoRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigApiGetRoomTypeInfoRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomTypeInfoRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomTypeInfoRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomTypeInfoRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomTypeInfoRequest) Execute() (*RoomTypeInfoDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypeInfoExecute(r)
}

/*
GetRoomTypeInfo Get Room Type Information

Use this API to get Room Type details of a Property. The search criteria can include a list of Room Types and the  Property (hotelID). <p><strong>OperationId:</strong>getRoomTypeInfo</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomTypeCode Unique Code of room type.
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetRoomTypeInfoRequest
*/
func (a *HotelConfigApiService) GetRoomTypeInfo(ctx context.Context, roomTypeCode string, hotelId string) HotelConfigApiGetRoomTypeInfoRequest {
	return HotelConfigApiGetRoomTypeInfoRequest{
		ApiService: a,
		ctx: ctx,
		roomTypeCode: roomTypeCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomTypeInfoDetails
func (a *HotelConfigApiService) GetRoomTypeInfoExecute(r HotelConfigApiGetRoomTypeInfoRequest) (*RoomTypeInfoDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypeInfoDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomTypeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomType/{roomTypeCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomTypeCode"+"}", url.PathEscape(parameterValueToString(r.roomTypeCode, "roomTypeCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomTypeCode) < 1 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have at least 1 elements")
	}
	if strlen(r.roomTypeCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomTypeCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomTypeTemplatesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	physical *bool
	pseudo *bool
	summaryInfo *bool
	roomTypeCodes *[]string
	roomClassCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomTypeTemplatesRequest) Authorization(authorization string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomTypeTemplatesRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomTypeTemplatesRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Include inactive Room type in search result?
func (r HotelConfigApiGetRoomTypeTemplatesRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Is it a physical sleep room type.
func (r HotelConfigApiGetRoomTypeTemplatesRequest) Physical(physical bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomTypeTemplatesRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.pseudo = &pseudo
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) SummaryInfo(summaryInfo bool) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

// External system code.
func (r HotelConfigApiGetRoomTypeTemplatesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomTypeTemplatesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomTypeTemplatesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomTypeTemplatesRequest) Execute() (*RoomTypeTemplatesDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypeTemplatesExecute(r)
}

/*
GetRoomTypeTemplates Get Room Type Templates

This API accepts the room type template request search criteria and gets the Room Type templates. <p><strong>OperationId:</strong>getRoomTypeTemplates</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetRoomTypeTemplatesRequest
*/
func (a *HotelConfigApiService) GetRoomTypeTemplates(ctx context.Context) HotelConfigApiGetRoomTypeTemplatesRequest {
	return HotelConfigApiGetRoomTypeTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoomTypeTemplatesDetails
func (a *HotelConfigApiService) GetRoomTypeTemplatesExecute(r HotelConfigApiGetRoomTypeTemplatesRequest) (*RoomTypeTemplatesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypeTemplatesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomTypeTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	accessible *bool
	includeInactive *bool
	limit *int32
	offset *int32
	physical *bool
	pseudo *bool
	summaryInfo *bool
	roomTypeCodes *[]string
	roomClassCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomTypesRequest) Authorization(authorization string) HotelConfigApiGetRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomTypesRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomTypesRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if accessible room type should be fetched.
func (r HotelConfigApiGetRoomTypesRequest) Accessible(accessible bool) HotelConfigApiGetRoomTypesRequest {
	r.accessible = &accessible
	return r
}

// Flag to indicate if inactive room types should be included.
func (r HotelConfigApiGetRoomTypesRequest) IncludeInactive(includeInactive bool) HotelConfigApiGetRoomTypesRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetRoomTypesRequest) Limit(limit int32) HotelConfigApiGetRoomTypesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetRoomTypesRequest) Offset(offset int32) HotelConfigApiGetRoomTypesRequest {
	r.offset = &offset
	return r
}

// Is it a physical sleep room type.
func (r HotelConfigApiGetRoomTypesRequest) Physical(physical bool) HotelConfigApiGetRoomTypesRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomTypesRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomTypesRequest {
	r.pseudo = &pseudo
	return r
}

// Flag to indicate if summary or detailed information should be fetched.
func (r HotelConfigApiGetRoomTypesRequest) SummaryInfo(summaryInfo bool) HotelConfigApiGetRoomTypesRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r HotelConfigApiGetRoomTypesRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomTypesRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r HotelConfigApiGetRoomTypesRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomTypesRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

// External system code.
func (r HotelConfigApiGetRoomTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomTypesRequest) Execute() (*RoomTypesDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypesExecute(r)
}

/*
GetRoomTypes Get hotel room types

Use this API to return room types for a specific property based on search criteria such as roomClassCodes, roomTypeCodes, physical, pseudo, etc.<p><strong>OperationId:</strong>getRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetRoomTypesRequest
*/
func (a *HotelConfigApiService) GetRoomTypes(ctx context.Context, hotelId string) HotelConfigApiGetRoomTypesRequest {
	return HotelConfigApiGetRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomTypesDetails
func (a *HotelConfigApiService) GetRoomTypesExecute(r HotelConfigApiGetRoomTypesRequest) (*RoomTypesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.accessible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessible", r.accessible, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	physical *bool
	pseudo *bool
	roomClassCodes *[]string
	roomTypeCodes *[]string
	room *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomsRequest) Authorization(authorization string) HotelConfigApiGetRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomsRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomsRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetRoomsRequest) Limit(limit int32) HotelConfigApiGetRoomsRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetRoomsRequest) Offset(offset int32) HotelConfigApiGetRoomsRequest {
	r.offset = &offset
	return r
}

// Is it a physical room type.
func (r HotelConfigApiGetRoomsRequest) Physical(physical bool) HotelConfigApiGetRoomsRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomsRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomsRequest {
	r.pseudo = &pseudo
	return r
}

func (r HotelConfigApiGetRoomsRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomsRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r HotelConfigApiGetRoomsRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomsRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

// Room to be searched.
func (r HotelConfigApiGetRoomsRequest) Room(room string) HotelConfigApiGetRoomsRequest {
	r.room = &room
	return r
}

// External system code.
func (r HotelConfigApiGetRoomsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomsRequest) Execute() (*RoomsDetails, *http.Response, error) {
	return r.ApiService.GetRoomsExecute(r)
}

/*
GetRooms Get hotel rooms

Use this API to return rooms for a specific property based on search criteria such as roomClassCodes, roomTypeCodes, room, etc.<p><strong>OperationId:</strong>getRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiGetRoomsRequest
*/
func (a *HotelConfigApiService) GetRooms(ctx context.Context, hotelId string) HotelConfigApiGetRoomsRequest {
	return HotelConfigApiGetRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomsDetails
func (a *HotelConfigApiService) GetRoomsExecute(r HotelConfigApiGetRoomsRequest) (*RoomsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.room != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "room", r.room, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiGetRoomsSummaryRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	offset *int32
	physical *bool
	pseudo *bool
	hotelId *string
	roomClassCodes *[]string
	roomTypeCodes *[]string
	roomCodes *[]string
	wildCard *string
	building *string
	ratingsCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiGetRoomsSummaryRequest) Authorization(authorization string) HotelConfigApiGetRoomsSummaryRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiGetRoomsSummaryRequest) XAppKey(xAppKey string) HotelConfigApiGetRoomsSummaryRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiGetRoomsSummaryRequest) XHotelid(xHotelid string) HotelConfigApiGetRoomsSummaryRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigApiGetRoomsSummaryRequest) Limit(limit int32) HotelConfigApiGetRoomsSummaryRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigApiGetRoomsSummaryRequest) Offset(offset int32) HotelConfigApiGetRoomsSummaryRequest {
	r.offset = &offset
	return r
}

// Is it a physical room type.
func (r HotelConfigApiGetRoomsSummaryRequest) Physical(physical bool) HotelConfigApiGetRoomsSummaryRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigApiGetRoomsSummaryRequest) Pseudo(pseudo bool) HotelConfigApiGetRoomsSummaryRequest {
	r.pseudo = &pseudo
	return r
}

// Hotel code of room to be searched.
func (r HotelConfigApiGetRoomsSummaryRequest) HotelId(hotelId string) HotelConfigApiGetRoomsSummaryRequest {
	r.hotelId = &hotelId
	return r
}

func (r HotelConfigApiGetRoomsSummaryRequest) RoomClassCodes(roomClassCodes []string) HotelConfigApiGetRoomsSummaryRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r HotelConfigApiGetRoomsSummaryRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigApiGetRoomsSummaryRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

// Codes to be searched.
func (r HotelConfigApiGetRoomsSummaryRequest) RoomCodes(roomCodes []string) HotelConfigApiGetRoomsSummaryRequest {
	r.roomCodes = &roomCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigApiGetRoomsSummaryRequest) WildCard(wildCard string) HotelConfigApiGetRoomsSummaryRequest {
	r.wildCard = &wildCard
	return r
}

// Building associated with room to be searched.
func (r HotelConfigApiGetRoomsSummaryRequest) Building(building string) HotelConfigApiGetRoomsSummaryRequest {
	r.building = &building
	return r
}

func (r HotelConfigApiGetRoomsSummaryRequest) RatingsCodes(ratingsCodes []string) HotelConfigApiGetRoomsSummaryRequest {
	r.ratingsCodes = &ratingsCodes
	return r
}

// External system code.
func (r HotelConfigApiGetRoomsSummaryRequest) XExternalsystem(xExternalsystem string) HotelConfigApiGetRoomsSummaryRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiGetRoomsSummaryRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiGetRoomsSummaryRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiGetRoomsSummaryRequest) Execute() (*RoomsSummaryDetails, *http.Response, error) {
	return r.ApiService.GetRoomsSummaryExecute(r)
}

/*
GetRoomsSummary Get room summary

Use this API to return room summary information based on search criteria such as hotelId, roomClassCodes, roomTypeCodes, roomCodes, wildCard, etc.<p><strong>OperationId:</strong>getRoomsSummary</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigApiGetRoomsSummaryRequest
*/
func (a *HotelConfigApiService) GetRoomsSummary(ctx context.Context) HotelConfigApiGetRoomsSummaryRequest {
	return HotelConfigApiGetRoomsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoomsSummaryDetails
func (a *HotelConfigApiService) GetRoomsSummaryExecute(r HotelConfigApiGetRoomsSummaryRequest) (*RoomsSummaryDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomsSummaryDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.GetRoomsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/roomsSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
	}
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
	}
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
	}
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
	}
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
	}
	if r.roomCodes != nil {
		t := *r.roomCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomCodes", t, "multi")
		}
	}
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
	}
	if r.building != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "building", r.building, "")
	}
	if r.ratingsCodes != nil {
		t := *r.ratingsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ratingsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ratingsCodes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostResortRoomConditionRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	resortRoomConditionCriteria *PostResortRoomConditionRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostResortRoomConditionRequest) Authorization(authorization string) HotelConfigApiPostResortRoomConditionRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostResortRoomConditionRequest) XAppKey(xAppKey string) HotelConfigApiPostResortRoomConditionRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostResortRoomConditionRequest) XHotelid(xHotelid string) HotelConfigApiPostResortRoomConditionRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Create Room Condition.
func (r HotelConfigApiPostResortRoomConditionRequest) ResortRoomConditionCriteria(resortRoomConditionCriteria PostResortRoomConditionRequest) HotelConfigApiPostResortRoomConditionRequest {
	r.resortRoomConditionCriteria = &resortRoomConditionCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostResortRoomConditionRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostResortRoomConditionRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostResortRoomConditionRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostResortRoomConditionRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostResortRoomConditionRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostResortRoomConditionExecute(r)
}

/*
PostResortRoomCondition Create room condition configuration 

Use this API to create room condition configuration . <p><strong>OperationId:</strong>postResortRoomCondition</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostResortRoomConditionRequest
*/
func (a *HotelConfigApiService) PostResortRoomCondition(ctx context.Context, hotelId string) HotelConfigApiPostResortRoomConditionRequest {
	return HotelConfigApiPostResortRoomConditionRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostResortRoomConditionExecute(r HotelConfigApiPostResortRoomConditionRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostResortRoomCondition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomConditions"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.resortRoomConditionCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostRoomTypesRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypesCriteria *PostRoomTypesRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostRoomTypesRequest) Authorization(authorization string) HotelConfigApiPostRoomTypesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostRoomTypesRequest) XAppKey(xAppKey string) HotelConfigApiPostRoomTypesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostRoomTypesRequest) XHotelid(xHotelid string) HotelConfigApiPostRoomTypesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for Creating a new Room Type.
func (r HotelConfigApiPostRoomTypesRequest) RoomTypesCriteria(roomTypesCriteria PostRoomTypesRequest) HotelConfigApiPostRoomTypesRequest {
	r.roomTypesCriteria = &roomTypesCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostRoomTypesRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostRoomTypesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostRoomTypesRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostRoomTypesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostRoomTypesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomTypesExecute(r)
}

/*
PostRoomTypes Create a new room type

Use this API to create new room types for a property. A list of new room types can be passed as part of the request to Use this API to create multiple rooms in one request. <p><strong>OperationId:</strong>postRoomTypes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostRoomTypesRequest
*/
func (a *HotelConfigApiService) PostRoomTypes(ctx context.Context, hotelId string) HotelConfigApiPostRoomTypesRequest {
	return HotelConfigApiPostRoomTypesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostRoomTypesExecute(r HotelConfigApiPostRoomTypesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostRoomTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigApiPostRoomsRequest struct {
	ctx context.Context
	ApiService *HotelConfigApiService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomCriteria *PostRoomsRequest
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigApiPostRoomsRequest) Authorization(authorization string) HotelConfigApiPostRoomsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner’s Application Key
func (r HotelConfigApiPostRoomsRequest) XAppKey(xAppKey string) HotelConfigApiPostRoomsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigApiPostRoomsRequest) XHotelid(xHotelid string) HotelConfigApiPostRoomsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating a new room.
func (r HotelConfigApiPostRoomsRequest) RoomCriteria(roomCriteria PostRoomsRequest) HotelConfigApiPostRoomsRequest {
	r.roomCriteria = &roomCriteria
	return r
}

// External system code.
func (r HotelConfigApiPostRoomsRequest) XExternalsystem(xExternalsystem string) HotelConfigApiPostRoomsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigApiPostRoomsRequest) AcceptLanguage(acceptLanguage string) HotelConfigApiPostRoomsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigApiPostRoomsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomsExecute(r)
}

/*
PostRooms Post a new room

Use this API to create a new room for a specific property.<p><strong>OperationId:</strong>postRooms</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigApiPostRoomsRequest
*/
func (a *HotelConfigApiService) PostRooms(ctx context.Context, hotelId string) HotelConfigApiPostRoomsRequest {
	return HotelConfigApiPostRoomsRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigApiService) PostRoomsExecute(r HotelConfigApiPostRoomsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigApiService.PostRooms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
