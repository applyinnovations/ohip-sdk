/*
OPERA Cloud Event Configuration API

This API caters for Event Configuration in OPERA Cloud. <br /><There are operations to post, update, fetch and delete codes such as item inventory, function spaces, menu items and many more.<br /><br /> Compatible with OPERA Cloud release 23.2.<br /><br /><p> This document and all content within is available under the Universal Permissive License v 1.0 (https://oss.oracle.com/licenses/upl). Copyright (c) 2020, 2023 Oracle and/or its affiliates.</p>

API version: 23.2
Contact: hospitality-integrations_ww@oracle.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package evmcfg

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HotelConfigAPIService HotelConfigAPI service
type HotelConfigAPIService service

type HotelConfigAPIChangeCateringRentalCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	cateringRentalId string
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringRentalCodesToBeChanged *CateringRentalCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeCateringRentalCodesRequest) Authorization(authorization string) HotelConfigAPIChangeCateringRentalCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeCateringRentalCodesRequest) XAppKey(xAppKey string) HotelConfigAPIChangeCateringRentalCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeCateringRentalCodesRequest) XHotelid(xHotelid string) HotelConfigAPIChangeCateringRentalCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds modified Catering Rental Codes.
func (r HotelConfigAPIChangeCateringRentalCodesRequest) CateringRentalCodesToBeChanged(cateringRentalCodesToBeChanged CateringRentalCodesToBeChanged) HotelConfigAPIChangeCateringRentalCodesRequest {
	r.cateringRentalCodesToBeChanged = &cateringRentalCodesToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeCateringRentalCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeCateringRentalCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeCateringRentalCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeCateringRentalCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeCateringRentalCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeCateringRentalCodesExecute(r)
}

/*
ChangeCateringRentalCodes Change Catering s Rental Codes

Use this API to update Catering s Rental Codes. <p><strong>OperationId:</strong>changeCateringRentalCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringRentalId Unique CateringRentalCode for functionSpace.
 @return HotelConfigAPIChangeCateringRentalCodesRequest
*/
func (a *HotelConfigAPIService) ChangeCateringRentalCodes(ctx context.Context, cateringRentalId string) HotelConfigAPIChangeCateringRentalCodesRequest {
	return HotelConfigAPIChangeCateringRentalCodesRequest{
		ApiService: a,
		ctx: ctx,
		cateringRentalId: cateringRentalId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeCateringRentalCodesExecute(r HotelConfigAPIChangeCateringRentalCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeCateringRentalCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionSpaceRentalCodes/{cateringRentalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringRentalId"+"}", url.PathEscape(parameterValueToString(r.cateringRentalId, "cateringRentalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringRentalId) < 1 {
		return localVarReturnValue, nil, reportError("cateringRentalId must have at least 1 elements")
	}
	if strlen(r.cateringRentalId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringRentalId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringRentalCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventCodesToBeChanged *EventCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeEventCodesRequest) Authorization(authorization string) HotelConfigAPIChangeEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIChangeEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIChangeEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying Event Codes for a hotel.
func (r HotelConfigAPIChangeEventCodesRequest) EventCodesToBeChanged(eventCodesToBeChanged EventCodesToBeChanged) HotelConfigAPIChangeEventCodesRequest {
	r.eventCodesToBeChanged = &eventCodesToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeEventCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeEventCodesExecute(r)
}

/*
ChangeEventCodes Change Hotel Event Codes

Use this API to update Hotel Event Codes. <p><strong>OperationId:</strong>changeEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIChangeEventCodesRequest
*/
func (a *HotelConfigAPIService) ChangeEventCodes(ctx context.Context, hotelId string) HotelConfigAPIChangeEventCodesRequest {
	return HotelConfigAPIChangeEventCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeEventCodesExecute(r HotelConfigAPIChangeEventCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeFunctionSpaceLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionspaceLocationCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpaceLocationsToBeChanged *FunctionSpaceLocationsToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) Authorization(authorization string) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying function space location(s) for resort.
func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) FunctionSpaceLocationsToBeChanged(functionSpaceLocationsToBeChanged FunctionSpaceLocationsToBeChanged) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	r.functionSpaceLocationsToBeChanged = &functionSpaceLocationsToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeFunctionSpaceLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFunctionSpaceLocationsExecute(r)
}

/*
ChangeFunctionSpaceLocations Change function space locations

Use this API to update function space locations. <p><strong>OperationId:</strong>changeFunctionSpaceLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionspaceLocationCode Unique Code of function space locations.
 @return HotelConfigAPIChangeFunctionSpaceLocationsRequest
*/
func (a *HotelConfigAPIService) ChangeFunctionSpaceLocations(ctx context.Context, functionspaceLocationCode string) HotelConfigAPIChangeFunctionSpaceLocationsRequest {
	return HotelConfigAPIChangeFunctionSpaceLocationsRequest{
		ApiService: a,
		ctx: ctx,
		functionspaceLocationCode: functionspaceLocationCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeFunctionSpaceLocationsExecute(r HotelConfigAPIChangeFunctionSpaceLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeFunctionSpaceLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceLocations/{functionspaceLocationCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionspaceLocationCode"+"}", url.PathEscape(parameterValueToString(r.functionspaceLocationCode, "functionspaceLocationCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionspaceLocationCode) < 1 {
		return localVarReturnValue, nil, reportError("functionspaceLocationCode must have at least 1 elements")
	}
	if strlen(r.functionspaceLocationCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionspaceLocationCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.functionSpaceLocationsToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeFunctionSpaceSetupStylesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionSpaceSetupStyleId string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpaceSetupStylesToBeChanged *FunctionSpaceSetupStylesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) Authorization(authorization string) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) XAppKey(xAppKey string) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) XHotelid(xHotelid string) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying function space setup style(s)
func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) FunctionSpaceSetupStylesToBeChanged(functionSpaceSetupStylesToBeChanged FunctionSpaceSetupStylesToBeChanged) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	r.functionSpaceSetupStylesToBeChanged = &functionSpaceSetupStylesToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFunctionSpaceSetupStylesExecute(r)
}

/*
ChangeFunctionSpaceSetupStyles Change function space setup styles

Use this API to update function space setup styles. <p><strong>OperationId:</strong>changeFunctionSpaceSetupStyles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionSpaceSetupStyleId Unique ID of function space setup styles.
 @return HotelConfigAPIChangeFunctionSpaceSetupStylesRequest
*/
func (a *HotelConfigAPIService) ChangeFunctionSpaceSetupStyles(ctx context.Context, functionSpaceSetupStyleId string) HotelConfigAPIChangeFunctionSpaceSetupStylesRequest {
	return HotelConfigAPIChangeFunctionSpaceSetupStylesRequest{
		ApiService: a,
		ctx: ctx,
		functionSpaceSetupStyleId: functionSpaceSetupStyleId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeFunctionSpaceSetupStylesExecute(r HotelConfigAPIChangeFunctionSpaceSetupStylesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeFunctionSpaceSetupStyles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceSetupStyles/{functionSpaceSetupStyleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionSpaceSetupStyleId"+"}", url.PathEscape(parameterValueToString(r.functionSpaceSetupStyleId, "functionSpaceSetupStyleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionSpaceSetupStyleId) < 1 {
		return localVarReturnValue, nil, reportError("functionSpaceSetupStyleId must have at least 1 elements")
	}
	if strlen(r.functionSpaceSetupStyleId) > 2000 {
		return localVarReturnValue, nil, reportError("functionSpaceSetupStyleId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.functionSpaceSetupStylesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeFunctionSpacesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionSpaceCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpacesToBeChanged *FunctionSpacesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeFunctionSpacesRequest) Authorization(authorization string) HotelConfigAPIChangeFunctionSpacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeFunctionSpacesRequest) XAppKey(xAppKey string) HotelConfigAPIChangeFunctionSpacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeFunctionSpacesRequest) XHotelid(xHotelid string) HotelConfigAPIChangeFunctionSpacesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing function spaces.
func (r HotelConfigAPIChangeFunctionSpacesRequest) FunctionSpacesToBeChanged(functionSpacesToBeChanged FunctionSpacesToBeChanged) HotelConfigAPIChangeFunctionSpacesRequest {
	r.functionSpacesToBeChanged = &functionSpacesToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeFunctionSpacesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeFunctionSpacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeFunctionSpacesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeFunctionSpacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeFunctionSpacesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeFunctionSpacesExecute(r)
}

/*
ChangeFunctionSpaces Change Function Spaces

Use this API to update Function Spaces. <p><strong>OperationId:</strong>changeFunctionSpaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionSpaceCode Unique Code of functionSpace.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIChangeFunctionSpacesRequest
*/
func (a *HotelConfigAPIService) ChangeFunctionSpaces(ctx context.Context, functionSpaceCode string, hotelId string) HotelConfigAPIChangeFunctionSpacesRequest {
	return HotelConfigAPIChangeFunctionSpacesRequest{
		ApiService: a,
		ctx: ctx,
		functionSpaceCode: functionSpaceCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeFunctionSpacesExecute(r HotelConfigAPIChangeFunctionSpacesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeFunctionSpaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionSpaces/{functionSpaceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionSpaceCode"+"}", url.PathEscape(parameterValueToString(r.functionSpaceCode, "functionSpaceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionSpaceCode) < 1 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have at least 1 elements")
	}
	if strlen(r.functionSpaceCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.functionSpacesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	roomPoolCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypePoolToBeChanged *RoomTypePoolToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeRoomTypePoolRequest) Authorization(authorization string) HotelConfigAPIChangeRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeRoomTypePoolRequest) XAppKey(xAppKey string) HotelConfigAPIChangeRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeRoomTypePoolRequest) XHotelid(xHotelid string) HotelConfigAPIChangeRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for changing existing room pool.
func (r HotelConfigAPIChangeRoomTypePoolRequest) RoomTypePoolToBeChanged(roomTypePoolToBeChanged RoomTypePoolToBeChanged) HotelConfigAPIChangeRoomTypePoolRequest {
	r.roomTypePoolToBeChanged = &roomTypePoolToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeRoomTypePoolRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeRoomTypePoolRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeRoomTypePoolExecute(r)
}

/*
ChangeRoomTypePool Change Room Type Pool 

Use this API to update Room Type Pool and Associated Room Types. <p><strong>OperationId:</strong>changeRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomPoolCode Unique Code of room type pool.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIChangeRoomTypePoolRequest
*/
func (a *HotelConfigAPIService) ChangeRoomTypePool(ctx context.Context, roomPoolCode string, hotelId string) HotelConfigAPIChangeRoomTypePoolRequest {
	return HotelConfigAPIChangeRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		roomPoolCode: roomPoolCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeRoomTypePoolExecute(r HotelConfigAPIChangeRoomTypePoolRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools/{roomPoolCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomPoolCode"+"}", url.PathEscape(parameterValueToString(r.roomPoolCode, "roomPoolCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomPoolCode) < 1 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have at least 1 elements")
	}
	if strlen(r.roomPoolCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypePoolToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIChangeTemplateEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateEventCodesToBeChanged *TemplateEventCodesToBeChanged
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIChangeTemplateEventCodesRequest) Authorization(authorization string) HotelConfigAPIChangeTemplateEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIChangeTemplateEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIChangeTemplateEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIChangeTemplateEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIChangeTemplateEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for modifying template Event Codes.
func (r HotelConfigAPIChangeTemplateEventCodesRequest) TemplateEventCodesToBeChanged(templateEventCodesToBeChanged TemplateEventCodesToBeChanged) HotelConfigAPIChangeTemplateEventCodesRequest {
	r.templateEventCodesToBeChanged = &templateEventCodesToBeChanged
	return r
}

// External system code.
func (r HotelConfigAPIChangeTemplateEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIChangeTemplateEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIChangeTemplateEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIChangeTemplateEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIChangeTemplateEventCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.ChangeTemplateEventCodesExecute(r)
}

/*
ChangeTemplateEventCodes Change Template Event Codes

Use this API to update Template Event Codes. <p><strong>OperationId:</strong>changeTemplateEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIChangeTemplateEventCodesRequest
*/
func (a *HotelConfigAPIService) ChangeTemplateEventCodes(ctx context.Context) HotelConfigAPIChangeTemplateEventCodesRequest {
	return HotelConfigAPIChangeTemplateEventCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) ChangeTemplateEventCodesExecute(r HotelConfigAPIChangeTemplateEventCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.ChangeTemplateEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateEventCodesToBeChanged
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPICopyFunctionSpaceLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyFunctionSpaceLocations *CopyFunctionSpaceLocations
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) Authorization(authorization string) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) XAppKey(xAppKey string) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) XHotelid(xHotelid string) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// List of function space location(s) to be copied.
func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) CopyFunctionSpaceLocations(copyFunctionSpaceLocations CopyFunctionSpaceLocations) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	r.copyFunctionSpaceLocations = &copyFunctionSpaceLocations
	return r
}

// External system code.
func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPICopyFunctionSpaceLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyFunctionSpaceLocationsExecute(r)
}

/*
CopyFunctionSpaceLocations Copy function space locations

Use this API to copy function space locations. <p><strong>OperationId:</strong>copyFunctionSpaceLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return HotelConfigAPICopyFunctionSpaceLocationsRequest
*/
func (a *HotelConfigAPIService) CopyFunctionSpaceLocations(ctx context.Context, sourceHotelId string) HotelConfigAPICopyFunctionSpaceLocationsRequest {
	return HotelConfigAPICopyFunctionSpaceLocationsRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) CopyFunctionSpaceLocationsExecute(r HotelConfigAPICopyFunctionSpaceLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.CopyFunctionSpaceLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/functionspaceLocations/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyFunctionSpaceLocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPICopyFunctionSpacesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	sourceHotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	copyFunctionSpaces *CopyFunctionSpaces
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPICopyFunctionSpacesRequest) Authorization(authorization string) HotelConfigAPICopyFunctionSpacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPICopyFunctionSpacesRequest) XAppKey(xAppKey string) HotelConfigAPICopyFunctionSpacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPICopyFunctionSpacesRequest) XHotelid(xHotelid string) HotelConfigAPICopyFunctionSpacesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating multiple function spaces based on an existing function space. New function space may have different name, display name on function dairy, order of display and combo elements. The rest of the details will be copied from the source function space.
func (r HotelConfigAPICopyFunctionSpacesRequest) CopyFunctionSpaces(copyFunctionSpaces CopyFunctionSpaces) HotelConfigAPICopyFunctionSpacesRequest {
	r.copyFunctionSpaces = &copyFunctionSpaces
	return r
}

// External system code.
func (r HotelConfigAPICopyFunctionSpacesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPICopyFunctionSpacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPICopyFunctionSpacesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPICopyFunctionSpacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPICopyFunctionSpacesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.CopyFunctionSpacesExecute(r)
}

/*
CopyFunctionSpaces Copy Function Spaces

 Use this API to copy Function Space. <p><strong>OperationId:</strong>copyFunctionSpaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceHotelId Unique ID of source hotel.
 @return HotelConfigAPICopyFunctionSpacesRequest
*/
func (a *HotelConfigAPIService) CopyFunctionSpaces(ctx context.Context, sourceHotelId string) HotelConfigAPICopyFunctionSpacesRequest {
	return HotelConfigAPICopyFunctionSpacesRequest{
		ApiService: a,
		ctx: ctx,
		sourceHotelId: sourceHotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) CopyFunctionSpacesExecute(r HotelConfigAPICopyFunctionSpacesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.CopyFunctionSpaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{sourceHotelId}/functionSpaces/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceHotelId"+"}", url.PathEscape(parameterValueToString(r.sourceHotelId, "sourceHotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sourceHotelId) < 1 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have at least 1 elements")
	}
	if strlen(r.sourceHotelId) > 2000 {
		return localVarReturnValue, nil, reportError("sourceHotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.copyFunctionSpaces
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetCateringRentalCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetCateringRentalCodesRequest) Authorization(authorization string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetCateringRentalCodesRequest) XAppKey(xAppKey string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetCateringRentalCodesRequest) XHotelid(xHotelid string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r HotelConfigAPIGetCateringRentalCodesRequest) FetchInactive(fetchInactive bool) HotelConfigAPIGetCateringRentalCodesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetCateringRentalCodesRequest) Codes(codes []string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetCateringRentalCodesRequest) WildCard(wildCard string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r HotelConfigAPIGetCateringRentalCodesRequest) Description(description string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.description = &description
	return r
}

// External system code.
func (r HotelConfigAPIGetCateringRentalCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetCateringRentalCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetCateringRentalCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetCateringRentalCodesRequest) Execute() (*CateringRentalCodesDetails, *http.Response, error) {
	return r.ApiService.GetCateringRentalCodesExecute(r)
}

/*
GetCateringRentalCodes Get Catering s Rental Codes

Use this API to get Catering s Rental Codes. <p><strong>OperationId:</strong>getCateringRentalCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIGetCateringRentalCodesRequest
*/
func (a *HotelConfigAPIService) GetCateringRentalCodes(ctx context.Context) HotelConfigAPIGetCateringRentalCodesRequest {
	return HotelConfigAPIGetCateringRentalCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CateringRentalCodesDetails
func (a *HotelConfigAPIService) GetCateringRentalCodesExecute(r HotelConfigAPIGetCateringRentalCodesRequest) (*CateringRentalCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CateringRentalCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetCateringRentalCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionSpaceRentalCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	eventsCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetEventCodesRequest) Authorization(authorization string) HotelConfigAPIGetEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIGetEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIGetEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel code.
func (r HotelConfigAPIGetEventCodesRequest) HotelIds(hotelIds []string) HotelConfigAPIGetEventCodesRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetEventCodesRequest) EventsCodes(eventsCodes []string) HotelConfigAPIGetEventCodesRequest {
	r.eventsCodes = &eventsCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetEventCodesRequest) WildCard(wildCard string) HotelConfigAPIGetEventCodesRequest {
	r.wildCard = &wildCard
	return r
}

// If true, this flag will set the criteria to return only Inactive records.
func (r HotelConfigAPIGetEventCodesRequest) IncludeInactive(includeInactive bool) HotelConfigAPIGetEventCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r HotelConfigAPIGetEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetEventCodesRequest) Execute() (*EventCodesDetails, *http.Response, error) {
	return r.ApiService.GetEventCodesExecute(r)
}

/*
GetEventCodes Get Hotel Event Codes

Use this API to get Hotel Event Codes. <p><strong>OperationId:</strong>getEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetEventCodesRequest
*/
func (a *HotelConfigAPIService) GetEventCodes(ctx context.Context, hotelId string) HotelConfigAPIGetEventCodesRequest {
	return HotelConfigAPIGetEventCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return EventCodesDetails
func (a *HotelConfigAPIService) GetEventCodesExecute(r HotelConfigAPIGetEventCodesRequest) (*EventCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.eventsCodes != nil {
		t := *r.eventsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventsCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetFunctionSpaceRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionSpaceCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	physical *bool
	pseudo *bool
	hotelId *string
	roomClassCodes *[]string
	roomTypeCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetFunctionSpaceRequest) Authorization(authorization string) HotelConfigAPIGetFunctionSpaceRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetFunctionSpaceRequest) XAppKey(xAppKey string) HotelConfigAPIGetFunctionSpaceRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetFunctionSpaceRequest) XHotelid(xHotelid string) HotelConfigAPIGetFunctionSpaceRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigAPIGetFunctionSpaceRequest) Limit(limit int32) HotelConfigAPIGetFunctionSpaceRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigAPIGetFunctionSpaceRequest) PageNumber(pageNumber int32) HotelConfigAPIGetFunctionSpaceRequest {
	r.pageNumber = &pageNumber
	return r
}

// Is it a physical room type.
func (r HotelConfigAPIGetFunctionSpaceRequest) Physical(physical bool) HotelConfigAPIGetFunctionSpaceRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigAPIGetFunctionSpaceRequest) Pseudo(pseudo bool) HotelConfigAPIGetFunctionSpaceRequest {
	r.pseudo = &pseudo
	return r
}

// Hotel code of room to be searched.
func (r HotelConfigAPIGetFunctionSpaceRequest) HotelId(hotelId string) HotelConfigAPIGetFunctionSpaceRequest {
	r.hotelId = &hotelId
	return r
}

func (r HotelConfigAPIGetFunctionSpaceRequest) RoomClassCodes(roomClassCodes []string) HotelConfigAPIGetFunctionSpaceRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r HotelConfigAPIGetFunctionSpaceRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigAPIGetFunctionSpaceRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

// External system code.
func (r HotelConfigAPIGetFunctionSpaceRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetFunctionSpaceRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetFunctionSpaceRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetFunctionSpaceRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetFunctionSpaceRequest) Execute() (*FunctionSpaceDetails, *http.Response, error) {
	return r.ApiService.GetFunctionSpaceExecute(r)
}

/*
GetFunctionSpace Get Function space 

Retrieve detailed information on function spaces, for example Meeting Room. <p><strong>OperationId:</strong>getFunctionSpace</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionSpaceCode Unique code of  function Space .
 @return HotelConfigAPIGetFunctionSpaceRequest
*/
func (a *HotelConfigAPIService) GetFunctionSpace(ctx context.Context, functionSpaceCode string) HotelConfigAPIGetFunctionSpaceRequest {
	return HotelConfigAPIGetFunctionSpaceRequest{
		ApiService: a,
		ctx: ctx,
		functionSpaceCode: functionSpaceCode,
	}
}

// Execute executes the request
//  @return FunctionSpaceDetails
func (a *HotelConfigAPIService) GetFunctionSpaceExecute(r HotelConfigAPIGetFunctionSpaceRequest) (*FunctionSpaceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpaceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetFunctionSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaces/{functionSpaceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionSpaceCode"+"}", url.PathEscape(parameterValueToString(r.functionSpaceCode, "functionSpaceCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionSpaceCode) < 1 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have at least 1 elements")
	}
	if strlen(r.functionSpaceCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
  }
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
  }
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
  }
	if r.hotelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", r.hotelId, "")
  }
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
  }
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetFunctionSpaceConfigRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionSpaceCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetFunctionSpaceConfigRequest) Authorization(authorization string) HotelConfigAPIGetFunctionSpaceConfigRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetFunctionSpaceConfigRequest) XAppKey(xAppKey string) HotelConfigAPIGetFunctionSpaceConfigRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetFunctionSpaceConfigRequest) XHotelid(xHotelid string) HotelConfigAPIGetFunctionSpaceConfigRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIGetFunctionSpaceConfigRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetFunctionSpaceConfigRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetFunctionSpaceConfigRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetFunctionSpaceConfigRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetFunctionSpaceConfigRequest) Execute() (*FunctionSpaceConfigDetails, *http.Response, error) {
	return r.ApiService.GetFunctionSpaceConfigExecute(r)
}

/*
GetFunctionSpaceConfig Get Function Space Configuration

 Use this  get Function Space detailed information. <p><strong>OperationId:</strong>getFunctionSpaceConfig</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionSpaceCode Unique Code of function space.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetFunctionSpaceConfigRequest
*/
func (a *HotelConfigAPIService) GetFunctionSpaceConfig(ctx context.Context, functionSpaceCode string, hotelId string) HotelConfigAPIGetFunctionSpaceConfigRequest {
	return HotelConfigAPIGetFunctionSpaceConfigRequest{
		ApiService: a,
		ctx: ctx,
		functionSpaceCode: functionSpaceCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FunctionSpaceConfigDetails
func (a *HotelConfigAPIService) GetFunctionSpaceConfigExecute(r HotelConfigAPIGetFunctionSpaceConfigRequest) (*FunctionSpaceConfigDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpaceConfigDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetFunctionSpaceConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionSpaces/{functionSpaceCode}/configurations"
	localVarPath = strings.Replace(localVarPath, "{"+"functionSpaceCode"+"}", url.PathEscape(parameterValueToString(r.functionSpaceCode, "functionSpaceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionSpaceCode) < 1 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have at least 1 elements")
	}
	if strlen(r.functionSpaceCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetFunctionSpaceLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelIds *[]string
	codes *[]string
	wildCard *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) Authorization(authorization string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) HotelIds(hotelIds []string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.hotelIds = &hotelIds
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) Codes(codes []string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) WildCard(wildCard string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.wildCard = &wildCard
	return r
}

// External system code.
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetFunctionSpaceLocationsRequest) Execute() (*FunctionSpaceLocationsDetails, *http.Response, error) {
	return r.ApiService.GetFunctionSpaceLocationsExecute(r)
}

/*
GetFunctionSpaceLocations Get Function space locations

Use this API to get detail information of function space locations. <p><strong>OperationId:</strong>getFunctionSpaceLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIGetFunctionSpaceLocationsRequest
*/
func (a *HotelConfigAPIService) GetFunctionSpaceLocations(ctx context.Context) HotelConfigAPIGetFunctionSpaceLocationsRequest {
	return HotelConfigAPIGetFunctionSpaceLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FunctionSpaceLocationsDetails
func (a *HotelConfigAPIService) GetFunctionSpaceLocationsExecute(r HotelConfigAPIGetFunctionSpaceLocationsRequest) (*FunctionSpaceLocationsDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpaceLocationsDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetFunctionSpaceLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceLocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hotelIds != nil {
		t := *r.hotelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelIds", t, "multi")
		}
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetFunctionSpaceSetupStylesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	fetchInactive *bool
	codes *[]string
	wildCard *string
	description *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) Authorization(authorization string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) XAppKey(xAppKey string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) XHotelid(xHotelid string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Determines wether to fetch inactive records or not.
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) FetchInactive(fetchInactive bool) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.fetchInactive = &fetchInactive
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) Codes(codes []string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.codes = &codes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) WildCard(wildCard string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.wildCard = &wildCard
	return r
}

// Description of the code.
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) Description(description string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.description = &description
	return r
}

// External system code.
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) Execute() (*FunctionSpaceSetupStylesDetails, *http.Response, error) {
	return r.ApiService.GetFunctionSpaceSetupStylesExecute(r)
}

/*
GetFunctionSpaceSetupStyles Get Function space setup styles

Use this API to get Function space setup styles. <p><strong>OperationId:</strong>getFunctionSpaceSetupStyles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIGetFunctionSpaceSetupStylesRequest
*/
func (a *HotelConfigAPIService) GetFunctionSpaceSetupStyles(ctx context.Context) HotelConfigAPIGetFunctionSpaceSetupStylesRequest {
	return HotelConfigAPIGetFunctionSpaceSetupStylesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FunctionSpaceSetupStylesDetails
func (a *HotelConfigAPIService) GetFunctionSpaceSetupStylesExecute(r HotelConfigAPIGetFunctionSpaceSetupStylesRequest) (*FunctionSpaceSetupStylesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpaceSetupStylesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetFunctionSpaceSetupStyles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceSetupStyles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchInactive", r.fetchInactive, "")
  }
	if r.codes != nil {
		t := *r.codes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "codes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "codes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetFunctionSpacesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	limit *int32
	pageNumber *int32
	sortingBy *string
	roomCodes *[]string
	roomType *string
	spaceType *string
	functionSpaceWildcard *string
	webBookable *bool
	floorCodes *[]string
	locationCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetFunctionSpacesRequest) Authorization(authorization string) HotelConfigAPIGetFunctionSpacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetFunctionSpacesRequest) XAppKey(xAppKey string) HotelConfigAPIGetFunctionSpacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetFunctionSpacesRequest) XHotelid(xHotelid string) HotelConfigAPIGetFunctionSpacesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigAPIGetFunctionSpacesRequest) Limit(limit int32) HotelConfigAPIGetFunctionSpacesRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigAPIGetFunctionSpacesRequest) PageNumber(pageNumber int32) HotelConfigAPIGetFunctionSpacesRequest {
	r.pageNumber = &pageNumber
	return r
}

// A collection of supported sorting for Event Calendar Function Space.
func (r HotelConfigAPIGetFunctionSpacesRequest) SortingBy(sortingBy string) HotelConfigAPIGetFunctionSpacesRequest {
	r.sortingBy = &sortingBy
	return r
}

func (r HotelConfigAPIGetFunctionSpacesRequest) RoomCodes(roomCodes []string) HotelConfigAPIGetFunctionSpacesRequest {
	r.roomCodes = &roomCodes
	return r
}

// Room Type where function space belongs to
func (r HotelConfigAPIGetFunctionSpacesRequest) RoomType(roomType string) HotelConfigAPIGetFunctionSpacesRequest {
	r.roomType = &roomType
	return r
}

// Space Type where function space belongs to
func (r HotelConfigAPIGetFunctionSpacesRequest) SpaceType(spaceType string) HotelConfigAPIGetFunctionSpacesRequest {
	r.spaceType = &spaceType
	return r
}

// Wild search on Room Code and Function Name.
func (r HotelConfigAPIGetFunctionSpacesRequest) FunctionSpaceWildcard(functionSpaceWildcard string) HotelConfigAPIGetFunctionSpacesRequest {
	r.functionSpaceWildcard = &functionSpaceWildcard
	return r
}

// If true, will set the criteria to return Function Spaces configured as web bookable only.
func (r HotelConfigAPIGetFunctionSpacesRequest) WebBookable(webBookable bool) HotelConfigAPIGetFunctionSpacesRequest {
	r.webBookable = &webBookable
	return r
}

func (r HotelConfigAPIGetFunctionSpacesRequest) FloorCodes(floorCodes []string) HotelConfigAPIGetFunctionSpacesRequest {
	r.floorCodes = &floorCodes
	return r
}

func (r HotelConfigAPIGetFunctionSpacesRequest) LocationCodes(locationCodes []string) HotelConfigAPIGetFunctionSpacesRequest {
	r.locationCodes = &locationCodes
	return r
}

// External system code.
func (r HotelConfigAPIGetFunctionSpacesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetFunctionSpacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetFunctionSpacesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetFunctionSpacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetFunctionSpacesRequest) Execute() (*FunctionSpacesDetails, *http.Response, error) {
	return r.ApiService.GetFunctionSpacesExecute(r)
}

/*
GetFunctionSpaces Get Function Spaces

This API fetches the configured function spaces of a specific property with possible search criteria of function space code, and space type. The result returns the function spaces that fit the search criteria with details about space name, short name, attributes such as shareable, combo, web bookable, and more. <p><strong>OperationId:</strong>getFunctionSpaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetFunctionSpacesRequest
*/
func (a *HotelConfigAPIService) GetFunctionSpaces(ctx context.Context, hotelId string) HotelConfigAPIGetFunctionSpacesRequest {
	return HotelConfigAPIGetFunctionSpacesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return FunctionSpacesDetails
func (a *HotelConfigAPIService) GetFunctionSpacesExecute(r HotelConfigAPIGetFunctionSpacesRequest) (*FunctionSpacesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FunctionSpacesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetFunctionSpaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionSpaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
  }
	if r.sortingBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortingBy", r.sortingBy, "")
  }
	if r.roomCodes != nil {
		t := *r.roomCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomCodes", t, "multi")
		}
  }
	if r.roomType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", r.roomType, "")
  }
	if r.spaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spaceType", r.spaceType, "")
  }
	if r.functionSpaceWildcard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "functionSpaceWildcard", r.functionSpaceWildcard, "")
  }
	if r.webBookable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webBookable", r.webBookable, "")
  }
	if r.floorCodes != nil {
		t := *r.floorCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "floorCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "floorCodes", t, "multi")
		}
  }
	if r.locationCodes != nil {
		t := *r.locationCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locationCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locationCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	includeInactive *bool
	limit *int32
	pageNumber *int32
	physical *bool
	pseudo *bool
	summaryInfo *bool
	roomTypeCodes *[]string
	roomClassCodes *[]string
	roomTypePoolCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetRoomTypePoolRequest) Authorization(authorization string) HotelConfigAPIGetRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetRoomTypePoolRequest) XAppKey(xAppKey string) HotelConfigAPIGetRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetRoomTypePoolRequest) XHotelid(xHotelid string) HotelConfigAPIGetRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// Flag to indicate if inactive room types should be included.
func (r HotelConfigAPIGetRoomTypePoolRequest) IncludeInactive(includeInactive bool) HotelConfigAPIGetRoomTypePoolRequest {
	r.includeInactive = &includeInactive
	return r
}

// Indicates maximum number of records a Web Service should return.
func (r HotelConfigAPIGetRoomTypePoolRequest) Limit(limit int32) HotelConfigAPIGetRoomTypePoolRequest {
	r.limit = &limit
	return r
}

// Index or initial index of the set(page) being requested. If the index goes out of the bounds of the total set count then no data will be returned.
func (r HotelConfigAPIGetRoomTypePoolRequest) PageNumber(pageNumber int32) HotelConfigAPIGetRoomTypePoolRequest {
	r.pageNumber = &pageNumber
	return r
}

// Is it a physical sleep room type.
func (r HotelConfigAPIGetRoomTypePoolRequest) Physical(physical bool) HotelConfigAPIGetRoomTypePoolRequest {
	r.physical = &physical
	return r
}

// Is it a pseudo room type.
func (r HotelConfigAPIGetRoomTypePoolRequest) Pseudo(pseudo bool) HotelConfigAPIGetRoomTypePoolRequest {
	r.pseudo = &pseudo
	return r
}

// Flag to indicate if summary or detailed information should be fetched.
func (r HotelConfigAPIGetRoomTypePoolRequest) SummaryInfo(summaryInfo bool) HotelConfigAPIGetRoomTypePoolRequest {
	r.summaryInfo = &summaryInfo
	return r
}

func (r HotelConfigAPIGetRoomTypePoolRequest) RoomTypeCodes(roomTypeCodes []string) HotelConfigAPIGetRoomTypePoolRequest {
	r.roomTypeCodes = &roomTypeCodes
	return r
}

func (r HotelConfigAPIGetRoomTypePoolRequest) RoomClassCodes(roomClassCodes []string) HotelConfigAPIGetRoomTypePoolRequest {
	r.roomClassCodes = &roomClassCodes
	return r
}

func (r HotelConfigAPIGetRoomTypePoolRequest) RoomTypePoolCodes(roomTypePoolCodes []string) HotelConfigAPIGetRoomTypePoolRequest {
	r.roomTypePoolCodes = &roomTypePoolCodes
	return r
}

// External system code.
func (r HotelConfigAPIGetRoomTypePoolRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetRoomTypePoolRequest) Execute() (*RoomTypePoolDetails, *http.Response, error) {
	return r.ApiService.GetRoomTypePoolExecute(r)
}

/*
GetRoomTypePool Fetch Room Type Pool

This API allows you to Use this API to get Room Type Pool and the associated Room Types. <p><strong>OperationId:</strong>getRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIGetRoomTypePoolRequest
*/
func (a *HotelConfigAPIService) GetRoomTypePool(ctx context.Context, hotelId string) HotelConfigAPIGetRoomTypePoolRequest {
	return HotelConfigAPIGetRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return RoomTypePoolDetails
func (a *HotelConfigAPIService) GetRoomTypePoolExecute(r HotelConfigAPIGetRoomTypePoolRequest) (*RoomTypePoolDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoomTypePoolDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
  }
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
  }
	if r.physical != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physical", r.physical, "")
  }
	if r.pseudo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", r.pseudo, "")
  }
	if r.summaryInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryInfo", r.summaryInfo, "")
  }
	if r.roomTypeCodes != nil {
		t := *r.roomTypeCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypeCodes", t, "multi")
		}
  }
	if r.roomClassCodes != nil {
		t := *r.roomClassCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClassCodes", t, "multi")
		}
  }
	if r.roomTypePoolCodes != nil {
		t := *r.roomTypePoolCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypePoolCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomTypePoolCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIGetTemplateEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	eventsCodes *[]string
	wildCard *string
	includeInactive *bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIGetTemplateEventCodesRequest) Authorization(authorization string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIGetTemplateEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIGetTemplateEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Codes to be searched.
func (r HotelConfigAPIGetTemplateEventCodesRequest) EventsCodes(eventsCodes []string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.eventsCodes = &eventsCodes
	return r
}

// Wildcard search on the code.
func (r HotelConfigAPIGetTemplateEventCodesRequest) WildCard(wildCard string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.wildCard = &wildCard
	return r
}

// If true, this flag will set the criteria to return only Inactive records.
func (r HotelConfigAPIGetTemplateEventCodesRequest) IncludeInactive(includeInactive bool) HotelConfigAPIGetTemplateEventCodesRequest {
	r.includeInactive = &includeInactive
	return r
}

// External system code.
func (r HotelConfigAPIGetTemplateEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIGetTemplateEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIGetTemplateEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIGetTemplateEventCodesRequest) Execute() (*TemplateEventCodesDetails, *http.Response, error) {
	return r.ApiService.GetTemplateEventCodesExecute(r)
}

/*
GetTemplateEventCodes Get Template Event Codes

Use this API to get Template Event Codes. <p><strong>OperationId:</strong>getTemplateEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIGetTemplateEventCodesRequest
*/
func (a *HotelConfigAPIService) GetTemplateEventCodes(ctx context.Context) HotelConfigAPIGetTemplateEventCodesRequest {
	return HotelConfigAPIGetTemplateEventCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplateEventCodesDetails
func (a *HotelConfigAPIService) GetTemplateEventCodesExecute(r HotelConfigAPIGetTemplateEventCodesRequest) (*TemplateEventCodesDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplateEventCodesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.GetTemplateEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventsCodes != nil {
		t := *r.eventsCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventsCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventsCodes", t, "multi")
		}
  }
	if r.wildCard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wildCard", r.wildCard, "")
  }
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostCateringRentalCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	cateringRentalCodesCriteria *CateringRentalCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostCateringRentalCodesRequest) Authorization(authorization string) HotelConfigAPIPostCateringRentalCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostCateringRentalCodesRequest) XAppKey(xAppKey string) HotelConfigAPIPostCateringRentalCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostCateringRentalCodesRequest) XHotelid(xHotelid string) HotelConfigAPIPostCateringRentalCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object which holds new Catering Rental Code Details.
func (r HotelConfigAPIPostCateringRentalCodesRequest) CateringRentalCodesCriteria(cateringRentalCodesCriteria CateringRentalCodesCriteria) HotelConfigAPIPostCateringRentalCodesRequest {
	r.cateringRentalCodesCriteria = &cateringRentalCodesCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostCateringRentalCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostCateringRentalCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostCateringRentalCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostCateringRentalCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostCateringRentalCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostCateringRentalCodesExecute(r)
}

/*
PostCateringRentalCodes Create Catering s Rental Codes

Use this API to create Catering s Rental Codes. <p><strong>OperationId:</strong>postCateringRentalCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIPostCateringRentalCodesRequest
*/
func (a *HotelConfigAPIService) PostCateringRentalCodes(ctx context.Context) HotelConfigAPIPostCateringRentalCodesRequest {
	return HotelConfigAPIPostCateringRentalCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostCateringRentalCodesExecute(r HotelConfigAPIPostCateringRentalCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostCateringRentalCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionSpaceRentalCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.cateringRentalCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventCodesCriteria *EventCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostEventCodesRequest) Authorization(authorization string) HotelConfigAPIPostEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIPostEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIPostEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new Event Codes for a hotel.
func (r HotelConfigAPIPostEventCodesRequest) EventCodesCriteria(eventCodesCriteria EventCodesCriteria) HotelConfigAPIPostEventCodesRequest {
	r.eventCodesCriteria = &eventCodesCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostEventCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostEventCodesExecute(r)
}

/*
PostEventCodes Create Hotel Event Codes

Use this API to create Hotel Event Codes. <p><strong>OperationId:</strong>postEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIPostEventCodesRequest
*/
func (a *HotelConfigAPIService) PostEventCodes(ctx context.Context, hotelId string) HotelConfigAPIPostEventCodesRequest {
	return HotelConfigAPIPostEventCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostEventCodesExecute(r HotelConfigAPIPostEventCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.eventCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostFunctionSpaceLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionspaceLocationCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpaceLocationsCriteria *FunctionSpaceLocationsCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) Authorization(authorization string) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for adding function space location configurations to resort.
func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) FunctionSpaceLocationsCriteria(functionSpaceLocationsCriteria FunctionSpaceLocationsCriteria) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	r.functionSpaceLocationsCriteria = &functionSpaceLocationsCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostFunctionSpaceLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFunctionSpaceLocationsExecute(r)
}

/*
PostFunctionSpaceLocations Create function space locations

Use this API to create function space locations. <p><strong>OperationId:</strong>postFunctionSpaceLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionspaceLocationCode Unique Code of function space locations.
 @return HotelConfigAPIPostFunctionSpaceLocationsRequest
*/
func (a *HotelConfigAPIService) PostFunctionSpaceLocations(ctx context.Context, functionspaceLocationCode string) HotelConfigAPIPostFunctionSpaceLocationsRequest {
	return HotelConfigAPIPostFunctionSpaceLocationsRequest{
		ApiService: a,
		ctx: ctx,
		functionspaceLocationCode: functionspaceLocationCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostFunctionSpaceLocationsExecute(r HotelConfigAPIPostFunctionSpaceLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostFunctionSpaceLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceLocations/{functionspaceLocationCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionspaceLocationCode"+"}", url.PathEscape(parameterValueToString(r.functionspaceLocationCode, "functionspaceLocationCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionspaceLocationCode) < 1 {
		return localVarReturnValue, nil, reportError("functionspaceLocationCode must have at least 1 elements")
	}
	if strlen(r.functionspaceLocationCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionspaceLocationCode must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.functionSpaceLocationsCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostFunctionSpaceSetupStylesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpaceSetupStylesCriteria *FunctionSpaceSetupStylesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) Authorization(authorization string) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) XAppKey(xAppKey string) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) XHotelid(xHotelid string) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for adding function space setup styles.
func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) FunctionSpaceSetupStylesCriteria(functionSpaceSetupStylesCriteria FunctionSpaceSetupStylesCriteria) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	r.functionSpaceSetupStylesCriteria = &functionSpaceSetupStylesCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFunctionSpaceSetupStylesExecute(r)
}

/*
PostFunctionSpaceSetupStyles Create function space setup styles

Use this API to create function space setup styles. <p><strong>OperationId:</strong>postFunctionSpaceSetupStyles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIPostFunctionSpaceSetupStylesRequest
*/
func (a *HotelConfigAPIService) PostFunctionSpaceSetupStyles(ctx context.Context) HotelConfigAPIPostFunctionSpaceSetupStylesRequest {
	return HotelConfigAPIPostFunctionSpaceSetupStylesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostFunctionSpaceSetupStylesExecute(r HotelConfigAPIPostFunctionSpaceSetupStylesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostFunctionSpaceSetupStyles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceSetupStyles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.functionSpaceSetupStylesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostFunctionSpacesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	functionSpacesCriteria *FunctionSpacesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostFunctionSpacesRequest) Authorization(authorization string) HotelConfigAPIPostFunctionSpacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostFunctionSpacesRequest) XAppKey(xAppKey string) HotelConfigAPIPostFunctionSpacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostFunctionSpacesRequest) XHotelid(xHotelid string) HotelConfigAPIPostFunctionSpacesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating function spaces.
func (r HotelConfigAPIPostFunctionSpacesRequest) FunctionSpacesCriteria(functionSpacesCriteria FunctionSpacesCriteria) HotelConfigAPIPostFunctionSpacesRequest {
	r.functionSpacesCriteria = &functionSpacesCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostFunctionSpacesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostFunctionSpacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostFunctionSpacesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostFunctionSpacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostFunctionSpacesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostFunctionSpacesExecute(r)
}

/*
PostFunctionSpaces Create Function Spaces

This API allows the creation of function spaces. Criteria that need to be supplied in the request body include function space code, description, space type, and min / max attendees. Optional details such as short name, shareable, combo, web bookable, and dimensions can also be included. <p><strong>OperationId:</strong>postFunctionSpaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIPostFunctionSpacesRequest
*/
func (a *HotelConfigAPIService) PostFunctionSpaces(ctx context.Context, hotelId string) HotelConfigAPIPostFunctionSpacesRequest {
	return HotelConfigAPIPostFunctionSpacesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostFunctionSpacesExecute(r HotelConfigAPIPostFunctionSpacesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostFunctionSpaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionSpaces"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.functionSpacesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	roomTypePoolCriteria *RoomTypePoolCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostRoomTypePoolRequest) Authorization(authorization string) HotelConfigAPIPostRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostRoomTypePoolRequest) XAppKey(xAppKey string) HotelConfigAPIPostRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostRoomTypePoolRequest) XHotelid(xHotelid string) HotelConfigAPIPostRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new room pool.
func (r HotelConfigAPIPostRoomTypePoolRequest) RoomTypePoolCriteria(roomTypePoolCriteria RoomTypePoolCriteria) HotelConfigAPIPostRoomTypePoolRequest {
	r.roomTypePoolCriteria = &roomTypePoolCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostRoomTypePoolRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostRoomTypePoolRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostRoomTypePoolExecute(r)
}

/*
PostRoomTypePool Create Room Type Pools

This API allows you to Use this API to create Room Type Pools. <p><strong>OperationId:</strong>postRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIPostRoomTypePoolRequest
*/
func (a *HotelConfigAPIService) PostRoomTypePool(ctx context.Context, hotelId string) HotelConfigAPIPostRoomTypePoolRequest {
	return HotelConfigAPIPostRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostRoomTypePoolExecute(r HotelConfigAPIPostRoomTypePoolRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.roomTypePoolCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIPostTemplateEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateEventCodesCriteria *TemplateEventCodesCriteria
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIPostTemplateEventCodesRequest) Authorization(authorization string) HotelConfigAPIPostTemplateEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIPostTemplateEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIPostTemplateEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIPostTemplateEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIPostTemplateEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Request object for creating new template Event Codes.
func (r HotelConfigAPIPostTemplateEventCodesRequest) TemplateEventCodesCriteria(templateEventCodesCriteria TemplateEventCodesCriteria) HotelConfigAPIPostTemplateEventCodesRequest {
	r.templateEventCodesCriteria = &templateEventCodesCriteria
	return r
}

// External system code.
func (r HotelConfigAPIPostTemplateEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIPostTemplateEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIPostTemplateEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIPostTemplateEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIPostTemplateEventCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.PostTemplateEventCodesExecute(r)
}

/*
PostTemplateEventCodes Create Template Event Codes

Use this API to create Template Event Codes. <p><strong>OperationId:</strong>postTemplateEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIPostTemplateEventCodesRequest
*/
func (a *HotelConfigAPIService) PostTemplateEventCodes(ctx context.Context) HotelConfigAPIPostTemplateEventCodesRequest {
	return HotelConfigAPIPostTemplateEventCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) PostTemplateEventCodesExecute(r HotelConfigAPIPostTemplateEventCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.PostTemplateEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.templateEventCodesCriteria
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveCateringRentalCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	cateringRentalId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveCateringRentalCodesRequest) Authorization(authorization string) HotelConfigAPIRemoveCateringRentalCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveCateringRentalCodesRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveCateringRentalCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveCateringRentalCodesRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveCateringRentalCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIRemoveCateringRentalCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveCateringRentalCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveCateringRentalCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveCateringRentalCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveCateringRentalCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveCateringRentalCodesExecute(r)
}

/*
RemoveCateringRentalCodes Delete Catering s Rental Codes

Use this API to delete Catering s Rental Codes. <p><strong>OperationId:</strong>removeCateringRentalCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cateringRentalId Unique CateringRentalCode for functionSpace.
 @return HotelConfigAPIRemoveCateringRentalCodesRequest
*/
func (a *HotelConfigAPIService) RemoveCateringRentalCodes(ctx context.Context, cateringRentalId string) HotelConfigAPIRemoveCateringRentalCodesRequest {
	return HotelConfigAPIRemoveCateringRentalCodesRequest{
		ApiService: a,
		ctx: ctx,
		cateringRentalId: cateringRentalId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveCateringRentalCodesExecute(r HotelConfigAPIRemoveCateringRentalCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveCateringRentalCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionSpaceRentalCodes/{cateringRentalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cateringRentalId"+"}", url.PathEscape(parameterValueToString(r.cateringRentalId, "cateringRentalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.cateringRentalId) < 1 {
		return localVarReturnValue, nil, reportError("cateringRentalId must have at least 1 elements")
	}
	if strlen(r.cateringRentalId) > 2000 {
		return localVarReturnValue, nil, reportError("cateringRentalId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	eventCode *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveEventCodesRequest) Authorization(authorization string) HotelConfigAPIRemoveEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

// Configuration code.
func (r HotelConfigAPIRemoveEventCodesRequest) EventCode(eventCode []string) HotelConfigAPIRemoveEventCodesRequest {
	r.eventCode = &eventCode
	return r
}

// External system code.
func (r HotelConfigAPIRemoveEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveEventCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveEventCodesExecute(r)
}

/*
RemoveEventCodes Delete Hotel Event Codes

Use this API to delete Hotel Event Codes. <p><strong>OperationId:</strong>removeEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIRemoveEventCodesRequest
*/
func (a *HotelConfigAPIService) RemoveEventCodes(ctx context.Context, hotelId string) HotelConfigAPIRemoveEventCodesRequest {
	return HotelConfigAPIRemoveEventCodesRequest{
		ApiService: a,
		ctx: ctx,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveEventCodesExecute(r HotelConfigAPIRemoveEventCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/eventCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.eventCode != nil {
		t := *r.eventCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eventCode", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eventCode", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveFunctionSpaceLocationsRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionspaceLocationCode string
	authorization *string
	xAppKey *string
	xHotelid *string
	hotelId *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) Authorization(authorization string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	r.xHotelid = &xHotelid
	return r
}

// Hotel where the code is configured.
func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) HotelId(hotelId []string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	r.hotelId = &hotelId
	return r
}

// External system code.
func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFunctionSpaceLocationsExecute(r)
}

/*
RemoveFunctionSpaceLocations Delete function space locations

Use this API to delete function space locations. <p><strong>OperationId:</strong>removeFunctionSpaceLocations</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionspaceLocationCode Unique Code of function space locations.
 @return HotelConfigAPIRemoveFunctionSpaceLocationsRequest
*/
func (a *HotelConfigAPIService) RemoveFunctionSpaceLocations(ctx context.Context, functionspaceLocationCode string) HotelConfigAPIRemoveFunctionSpaceLocationsRequest {
	return HotelConfigAPIRemoveFunctionSpaceLocationsRequest{
		ApiService: a,
		ctx: ctx,
		functionspaceLocationCode: functionspaceLocationCode,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveFunctionSpaceLocationsExecute(r HotelConfigAPIRemoveFunctionSpaceLocationsRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveFunctionSpaceLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceLocations/{functionspaceLocationCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionspaceLocationCode"+"}", url.PathEscape(parameterValueToString(r.functionspaceLocationCode, "functionspaceLocationCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionspaceLocationCode) < 1 {
		return localVarReturnValue, nil, reportError("functionspaceLocationCode must have at least 1 elements")
	}
	if strlen(r.functionspaceLocationCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionspaceLocationCode must have less than 2000 elements")
	}

	if r.hotelId != nil {
		t := *r.hotelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hotelId", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionSpaceSetupStyleId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) Authorization(authorization string) HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFunctionSpaceSetupStylesExecute(r)
}

/*
RemoveFunctionSpaceSetupStyles Delete function space setup styles

Use this API to delete function space setup styles. <p><strong>OperationId:</strong>removeFunctionSpaceSetupStyles</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionSpaceSetupStyleId Unique ID of function space setup styles.
 @return HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest
*/
func (a *HotelConfigAPIService) RemoveFunctionSpaceSetupStyles(ctx context.Context, functionSpaceSetupStyleId string) HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest {
	return HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest{
		ApiService: a,
		ctx: ctx,
		functionSpaceSetupStyleId: functionSpaceSetupStyleId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveFunctionSpaceSetupStylesExecute(r HotelConfigAPIRemoveFunctionSpaceSetupStylesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveFunctionSpaceSetupStyles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/functionspaceSetupStyles/{functionSpaceSetupStyleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionSpaceSetupStyleId"+"}", url.PathEscape(parameterValueToString(r.functionSpaceSetupStyleId, "functionSpaceSetupStyleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionSpaceSetupStyleId) < 1 {
		return localVarReturnValue, nil, reportError("functionSpaceSetupStyleId must have at least 1 elements")
	}
	if strlen(r.functionSpaceSetupStyleId) > 2000 {
		return localVarReturnValue, nil, reportError("functionSpaceSetupStyleId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveFunctionSpacesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	functionSpaceCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveFunctionSpacesRequest) Authorization(authorization string) HotelConfigAPIRemoveFunctionSpacesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveFunctionSpacesRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveFunctionSpacesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveFunctionSpacesRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveFunctionSpacesRequest {
	r.xHotelid = &xHotelid
	return r
}

// External system code.
func (r HotelConfigAPIRemoveFunctionSpacesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveFunctionSpacesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveFunctionSpacesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveFunctionSpacesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveFunctionSpacesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveFunctionSpacesExecute(r)
}

/*
RemoveFunctionSpaces Delete Function Spaces

Use this API to delete Function Spaces. <p><strong>OperationId:</strong>removeFunctionSpaces</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param functionSpaceCode Unique Code of functionSpace.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIRemoveFunctionSpacesRequest
*/
func (a *HotelConfigAPIService) RemoveFunctionSpaces(ctx context.Context, functionSpaceCode string, hotelId string) HotelConfigAPIRemoveFunctionSpacesRequest {
	return HotelConfigAPIRemoveFunctionSpacesRequest{
		ApiService: a,
		ctx: ctx,
		functionSpaceCode: functionSpaceCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveFunctionSpacesExecute(r HotelConfigAPIRemoveFunctionSpacesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveFunctionSpaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/functionSpaces/{functionSpaceCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"functionSpaceCode"+"}", url.PathEscape(parameterValueToString(r.functionSpaceCode, "functionSpaceCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.functionSpaceCode) < 1 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have at least 1 elements")
	}
	if strlen(r.functionSpaceCode) > 2000 {
		return localVarReturnValue, nil, reportError("functionSpaceCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveRoomTypePoolRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	roomPoolCode string
	hotelId string
	authorization *string
	xAppKey *string
	xHotelid *string
	description *[]string
	defaultText *string
	lang *[]string
	sequence *[]int32
	inactive *[]bool
	numberOfRooms *[]int32
	roomType *[]string
	roomClass *[]string
	shortDescription *[]string
	activeDate *[]string
	pseudo *[]bool
	accessible *[]bool
	sendToInterface *[]bool
	sellSequence *[]float32
	suite *[]bool
	meetingRoom *[]bool
	restricted *[]bool
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Authorization(authorization string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveRoomTypePoolRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveRoomTypePoolRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.xHotelid = &xHotelid
	return r
}

// The description of room pool type.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Description(description []string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.description = &description
	return r
}

// Default text with Character length from 0 to 1000.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) DefaultText(defaultText string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.defaultText = &defaultText
	return r
}

// Language code for the translation.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Lang(lang []string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.lang = &lang
	return r
}

// Sequence for representing room type pool record.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Sequence(sequence []int32) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.sequence = &sequence
	return r
}

// Indicates the room type is inactive or not.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Inactive(inactive []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.inactive = &inactive
	return r
}

// Number of rooms for this room type.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) NumberOfRooms(numberOfRooms []int32) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.numberOfRooms = &numberOfRooms
	return r
}

func (r HotelConfigAPIRemoveRoomTypePoolRequest) RoomType(roomType []string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.roomType = &roomType
	return r
}

// Room class for the room type code.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) RoomClass(roomClass []string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.roomClass = &roomClass
	return r
}

// Short Description of room type.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) ShortDescription(shortDescription []string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.shortDescription = &shortDescription
	return r
}

// Active date of the room type.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) ActiveDate(activeDate []string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.activeDate = &activeDate
	return r
}

// Indicates if room type is pseudo.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Pseudo(pseudo []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.pseudo = &pseudo
	return r
}

// Indicates if room type is accessible.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Accessible(accessible []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.accessible = &accessible
	return r
}

// Indicates if room type is sent to interface.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) SendToInterface(sendToInterface []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.sendToInterface = &sendToInterface
	return r
}

// Indicates room types sell sequence.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) SellSequence(sellSequence []float32) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.sellSequence = &sellSequence
	return r
}

// Indicates room type is a suite.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Suite(suite []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.suite = &suite
	return r
}

// Indicates room type is meeting room. This Can be Meeting room flag cannot be unmarked at the property level. Can only be marked for non pseudo room types.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) MeetingRoom(meetingRoom []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.meetingRoom = &meetingRoom
	return r
}

// Indicates that the room pool cannot be used to allocate inventory to this room type. Inventory must be allocated directly to the room type itself.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) Restricted(restricted []bool) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.restricted = &restricted
	return r
}

// External system code.
func (r HotelConfigAPIRemoveRoomTypePoolRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveRoomTypePoolRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveRoomTypePoolRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveRoomTypePoolRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveRoomTypePoolExecute(r)
}

/*
RemoveRoomTypePool Delete  Room Type Pool and Mappings

Use this API to delete  Room Type Pool and Mappings. <p><strong>OperationId:</strong>removeRoomTypePool</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roomPoolCode Unique Code of room type pool.
 @param hotelId Unique ID of hotel.
 @return HotelConfigAPIRemoveRoomTypePoolRequest
*/
func (a *HotelConfigAPIService) RemoveRoomTypePool(ctx context.Context, roomPoolCode string, hotelId string) HotelConfigAPIRemoveRoomTypePoolRequest {
	return HotelConfigAPIRemoveRoomTypePoolRequest{
		ApiService: a,
		ctx: ctx,
		roomPoolCode: roomPoolCode,
		hotelId: hotelId,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveRoomTypePoolExecute(r HotelConfigAPIRemoveRoomTypePoolRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveRoomTypePool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hotels/{hotelId}/roomPools/{roomPoolCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"roomPoolCode"+"}", url.PathEscape(parameterValueToString(r.roomPoolCode, "roomPoolCode")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hotelId"+"}", url.PathEscape(parameterValueToString(r.hotelId, "hotelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.roomPoolCode) < 1 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have at least 1 elements")
	}
	if strlen(r.roomPoolCode) > 2000 {
		return localVarReturnValue, nil, reportError("roomPoolCode must have less than 2000 elements")
	}
	if strlen(r.hotelId) < 1 {
		return localVarReturnValue, nil, reportError("hotelId must have at least 1 elements")
	}
	if strlen(r.hotelId) > 2000 {
		return localVarReturnValue, nil, reportError("hotelId must have less than 2000 elements")
	}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
  }
	if r.defaultText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultText", r.defaultText, "")
  }
	if r.lang != nil {
		t := *r.lang
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "lang", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "lang", t, "multi")
		}
  }
	if r.sequence != nil {
		t := *r.sequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sequence", t, "multi")
		}
  }
	if r.inactive != nil {
		t := *r.inactive
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inactive", t, "multi")
		}
  }
	if r.numberOfRooms != nil {
		t := *r.numberOfRooms
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfRooms", t, "multi")
		}
  }
	if r.roomType != nil {
		t := *r.roomType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomType", t, "multi")
		}
  }
	if r.roomClass != nil {
		t := *r.roomClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roomClass", t, "multi")
		}
  }
	if r.shortDescription != nil {
		t := *r.shortDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shortDescription", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shortDescription", t, "multi")
		}
  }
	if r.activeDate != nil {
		t := *r.activeDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "activeDate", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "activeDate", t, "multi")
		}
  }
	if r.pseudo != nil {
		t := *r.pseudo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pseudo", t, "multi")
		}
  }
	if r.accessible != nil {
		t := *r.accessible
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accessible", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accessible", t, "multi")
		}
  }
	if r.sendToInterface != nil {
		t := *r.sendToInterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sendToInterface", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sendToInterface", t, "multi")
		}
  }
	if r.sellSequence != nil {
		t := *r.sellSequence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sellSequence", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sellSequence", t, "multi")
		}
  }
	if r.suite != nil {
		t := *r.suite
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "suite", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "suite", t, "multi")
		}
  }
	if r.meetingRoom != nil {
		t := *r.meetingRoom
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "meetingRoom", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "meetingRoom", t, "multi")
		}
  }
	if r.restricted != nil {
		t := *r.restricted
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "restricted", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "restricted", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type HotelConfigAPIRemoveTemplateEventCodesRequest struct {
	ctx context.Context
	ApiService *HotelConfigAPIService
	authorization *string
	xAppKey *string
	xHotelid *string
	templateEventCodes *[]string
	xExternalsystem *string
	acceptLanguage *string
}

// Bearer token that needs to be passed which is generated post user authentication
func (r HotelConfigAPIRemoveTemplateEventCodesRequest) Authorization(authorization string) HotelConfigAPIRemoveTemplateEventCodesRequest {
	r.authorization = &authorization
	return r
}

// Client or Partner&#39;s Application Key
func (r HotelConfigAPIRemoveTemplateEventCodesRequest) XAppKey(xAppKey string) HotelConfigAPIRemoveTemplateEventCodesRequest {
	r.xAppKey = &xAppKey
	return r
}

// Mandatory parameter to identify the hotel code where the end user is logged in
func (r HotelConfigAPIRemoveTemplateEventCodesRequest) XHotelid(xHotelid string) HotelConfigAPIRemoveTemplateEventCodesRequest {
	r.xHotelid = &xHotelid
	return r
}

func (r HotelConfigAPIRemoveTemplateEventCodesRequest) TemplateEventCodes(templateEventCodes []string) HotelConfigAPIRemoveTemplateEventCodesRequest {
	r.templateEventCodes = &templateEventCodes
	return r
}

// External system code.
func (r HotelConfigAPIRemoveTemplateEventCodesRequest) XExternalsystem(xExternalsystem string) HotelConfigAPIRemoveTemplateEventCodesRequest {
	r.xExternalsystem = &xExternalsystem
	return r
}

// Language code
func (r HotelConfigAPIRemoveTemplateEventCodesRequest) AcceptLanguage(acceptLanguage string) HotelConfigAPIRemoveTemplateEventCodesRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r HotelConfigAPIRemoveTemplateEventCodesRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.RemoveTemplateEventCodesExecute(r)
}

/*
RemoveTemplateEventCodes Delete Template Event Codes

Use this API to delete Template Event Codes. <p><strong>OperationId:</strong>removeTemplateEventCodes</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return HotelConfigAPIRemoveTemplateEventCodesRequest
*/
func (a *HotelConfigAPIService) RemoveTemplateEventCodes(ctx context.Context) HotelConfigAPIRemoveTemplateEventCodesRequest {
	return HotelConfigAPIRemoveTemplateEventCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Status
func (a *HotelConfigAPIService) RemoveTemplateEventCodesExecute(r HotelConfigAPIRemoveTemplateEventCodesRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HotelConfigAPIService.RemoveTemplateEventCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventCodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.templateEventCodes != nil {
		t := *r.templateEventCodes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "templateEventCodes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "templateEventCodes", t, "multi")
		}
  }
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "")
	}
	if r.xAppKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-app-key", r.xAppKey, "")
	}
	if r.xHotelid != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-hotelid", r.xHotelid, "")
	}
	if r.xExternalsystem != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-externalsystem", r.xExternalsystem, "")
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ExceptionDetailType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
